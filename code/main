# 1 "/home/richard/Documents/ucsp-solar/code/main.cpp"
# 1 "/usr/bin//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/home/richard/Documents/ucsp-solar/code/main.cpp"
# 1 "/usr/local/include/ibex/ibex.h" 1 3

# 1 "/usr/local/include/ibex/ibex_Affine2.h" 1 3
# 15 "/usr/local/include/ibex/ibex_Affine2.h" 3
# 1 "/usr/local/include/ibex/ibex_Interval.h" 1 3
# 16 "/usr/local/include/ibex/ibex_Interval.h" 3
# 1 "/usr/local/include/ibex/ibex_Exception.h" 1 3
# 15 "/usr/local/include/ibex/ibex_Exception.h" 3
# 1 "/usr/include/c++/7/iostream" 1 3
# 36 "/usr/include/c++/7/iostream" 3
       
# 37 "/usr/include/c++/7/iostream" 3

# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 1 3
# 229 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 3

# 229 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 251 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 533 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/os_defines.h" 1 3
# 39 "/usr/include/x86_64-linux-gnu/c++/7/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 424 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 427 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 428 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 429 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 425 "/usr/include/features.h" 2 3 4
# 448 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 449 "/usr/include/features.h" 2 3 4
# 40 "/usr/include/x86_64-linux-gnu/c++/7/bits/os_defines.h" 2 3
# 534 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 2 3


# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/cpu_defines.h" 1 3
# 537 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 2 3
# 39 "/usr/include/c++/7/iostream" 2 3
# 1 "/usr/include/c++/7/ostream" 1 3
# 36 "/usr/include/c++/7/ostream" 3
       
# 37 "/usr/include/c++/7/ostream" 3

# 1 "/usr/include/c++/7/ios" 1 3
# 36 "/usr/include/c++/7/ios" 3
       
# 37 "/usr/include/c++/7/ios" 3

# 1 "/usr/include/c++/7/iosfwd" 1 3
# 36 "/usr/include/c++/7/iosfwd" 3
       
# 37 "/usr/include/c++/7/iosfwd" 3


# 1 "/usr/include/c++/7/bits/stringfwd.h" 1 3
# 37 "/usr/include/c++/7/bits/stringfwd.h" 3
       
# 38 "/usr/include/c++/7/bits/stringfwd.h" 3


# 1 "/usr/include/c++/7/bits/memoryfwd.h" 1 3
# 46 "/usr/include/c++/7/bits/memoryfwd.h" 3
       
# 47 "/usr/include/c++/7/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/7/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
# 41 "/usr/include/c++/7/bits/stringfwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{








  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;


  template<> struct char_traits<wchar_t>;




  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;


  typedef basic_string<char> string;



  typedef basic_string<wchar_t> wstring;





  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;


}




}
# 40 "/usr/include/c++/7/iosfwd" 2 3
# 1 "/usr/include/c++/7/bits/postypes.h" 1 3
# 38 "/usr/include/c++/7/bits/postypes.h" 3
       
# 39 "/usr/include/c++/7/bits/postypes.h" 3

# 1 "/usr/include/c++/7/cwchar" 1 3
# 39 "/usr/include/c++/7/cwchar" 3
       
# 40 "/usr/include/c++/7/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 27 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 75 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
# 87 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef __float128 _Float128;
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 207 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 244 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 261 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 278 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 31 "/usr/include/wchar.h" 2 3 4




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 216 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 36 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 39 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 41 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 3 4
typedef unsigned int wint_t;
# 42 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 2 3 4

typedef __mbstate_t mbstate_t;
# 43 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 44 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 47 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 50 "/usr/include/wchar.h" 2 3 4
# 79 "/usr/include/wchar.h" 3 4
extern "C" {



struct tm;



extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();



extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, locale_t __loc) throw ();




extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();







extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));




extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
# 181 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));




extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
         const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));




extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 240 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
         size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();




extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();





extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();
# 337 "/usr/include/wchar.h" 3 4
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();





extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();





extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();



extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 396 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();



extern _Float64 wcstof64 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();



extern _Float128 wcstof128 (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();



extern _Float32x wcstof32x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();



extern _Float64x wcstof64x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 428 "/usr/include/wchar.h" 3 4
extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();




__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();





__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();






extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 511 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();



extern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();



extern _Float128 wcstof128_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();



extern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();



extern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 551 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();
# 567 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();





extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;
# 673 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 727 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 782 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 808 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 818 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);






extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();
# 857 "/usr/include/wchar.h" 3 4
}
# 45 "/usr/include/c++/7/cwchar" 2 3
# 62 "/usr/include/c++/7/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "/usr/include/c++/7/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
# 232 "/usr/include/c++/7/cwchar" 3

}







namespace __gnu_cxx
{





  using ::wcstold;
# 257 "/usr/include/c++/7/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 277 "/usr/include/c++/7/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "/usr/include/c++/7/bits/postypes.h" 2 3
# 68 "/usr/include/c++/7/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 88 "/usr/include/c++/7/bits/postypes.h" 3
  typedef long streamoff;
# 98 "/usr/include/c++/7/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 111 "/usr/include/c++/7/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/usr/include/c++/7/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "/usr/include/c++/7/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/7/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 39 "/usr/include/c++/7/ios" 2 3
# 1 "/usr/include/c++/7/exception" 1 3
# 33 "/usr/include/c++/7/exception" 3
       
# 34 "/usr/include/c++/7/exception" 3

#pragma GCC visibility push(default)


# 1 "/usr/include/c++/7/bits/exception.h" 1 3
# 34 "/usr/include/c++/7/bits/exception.h" 3
       
# 35 "/usr/include/c++/7/bits/exception.h" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 60 "/usr/include/c++/7/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char*
    what() const noexcept;
  };

}

}

#pragma GCC visibility pop
# 39 "/usr/include/c++/7/exception" 2 3

extern "C++" {

namespace std
{


  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 101 "/usr/include/c++/7/exception" 3
  bool uncaught_exception() noexcept __attribute__ ((__pure__));




  int uncaught_exceptions() noexcept __attribute__ ((__pure__));



}

namespace __gnu_cxx
{

# 132 "/usr/include/c++/7/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "/usr/include/c++/7/bits/exception_ptr.h" 1 3
# 34 "/usr/include/c++/7/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)


# 1 "/usr/include/c++/7/bits/exception_defines.h" 1 3
# 38 "/usr/include/c++/7/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/7/bits/cxxabi_init_exception.h" 1 3
# 34 "/usr/include/c++/7/bits/cxxabi_init_exception.h" 3
       
# 35 "/usr/include/c++/7/bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 149 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 426 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 437 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 39 "/usr/include/c++/7/bits/cxxabi_init_exception.h" 2 3
# 50 "/usr/include/c++/7/bits/cxxabi_init_exception.h" 3
namespace std
{
  class type_info;
}

namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;

  extern "C"
    {

      void*
      __cxa_allocate_exception(size_t) noexcept;

      void
      __cxa_free_exception(void*) noexcept;


      __cxa_refcounted_exception*
      __cxa_init_primary_exception(void *object, std::type_info *tinfo,
                void ( *dest) (void *)) noexcept;

    }
}



#pragma GCC visibility pop
# 39 "/usr/include/c++/7/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/7/typeinfo" 1 3
# 32 "/usr/include/c++/7/typeinfo" 3
       
# 33 "/usr/include/c++/7/typeinfo" 3



# 1 "/usr/include/c++/7/bits/hash_bytes.h" 1 3
# 33 "/usr/include/c++/7/bits/hash_bytes.h" 3
       
# 34 "/usr/include/c++/7/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "/usr/include/c++/7/typeinfo" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/usr/include/c++/7/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "/usr/include/c++/7/typeinfo" 3
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 136 "/usr/include/c++/7/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 40 "/usr/include/c++/7/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/7/new" 1 3
# 37 "/usr/include/c++/7/new" 3
       
# 38 "/usr/include/c++/7/new" 3


# 1 "/usr/include/c++/7/exception" 1 3
# 41 "/usr/include/c++/7/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { };



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };






  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 120 "/usr/include/c++/7/new" 3
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
# 168 "/usr/include/c++/7/new" 3
inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}
# 216 "/usr/include/c++/7/new" 3
#pragma GCC visibility pop
# 41 "/usr/include/c++/7/bits/exception_ptr.h" 2 3

extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;

  template<typename _Ex>
  exception_ptr make_exception_ptr(_Ex) noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);
      template<typename _Ex>
      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 117 "/usr/include/c++/7/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 144 "/usr/include/c++/7/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

    template<typename _Ex>
      inline void
      __dest_thunk(void* __x)
      { static_cast<_Ex*>(__x)->~_Ex(); }

  }


  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {

      void* __e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
      (void) __cxxabiv1::__cxa_init_primary_exception(
   __e, const_cast<std::type_info*>(&typeid(__ex)),
   __exception_ptr::__dest_thunk<_Ex>);
      try
 {
          ::new (__e) _Ex(__ex);
          return exception_ptr(__e);
 }
      catch(...)
 {
   __cxxabiv1::__cxa_free_exception(__e);
   return current_exception();
 }
# 208 "/usr/include/c++/7/bits/exception_ptr.h" 3
    }





  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept __attribute__ ((__deprecated__));

  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept
    { return std::make_exception_ptr<_Ex>(__ex); }


}

}

#pragma GCC visibility pop
# 143 "/usr/include/c++/7/exception" 2 3
# 1 "/usr/include/c++/7/bits/nested_exception.h" 1 3
# 33 "/usr/include/c++/7/bits/nested_exception.h" 3
#pragma GCC visibility push(default)






# 1 "/usr/include/c++/7/bits/move.h" 1 3
# 34 "/usr/include/c++/7/bits/move.h" 3
# 1 "/usr/include/c++/7/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/7/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/7/bits/concept_check.h" 3
# 35 "/usr/include/c++/7/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }


}


# 1 "/usr/include/c++/7/type_traits" 1 3
# 32 "/usr/include/c++/7/type_traits" 3
       
# 33 "/usr/include/c++/7/type_traits" 3
# 42 "/usr/include/c++/7/type_traits" 3
namespace std
{
  typedef short unsigned int uint_least16_t;
  typedef unsigned int uint_least32_t;
}





namespace std __attribute__ ((__visibility__ ("default")))
{

# 68 "/usr/include/c++/7/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }




      constexpr value_type operator()() const noexcept { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 103 "/usr/include/c++/7/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public __bool_constant<!bool(_Pp::value)>
    { };
# 192 "/usr/include/c++/7/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
# 324 "/usr/include/c++/7/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };


  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };



  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile && >
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args...) >
    : public true_type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args......) >
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };
# 936 "/usr/include/c++/7/type_traits" 3
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;

  template<typename _Tp, typename... _Args>
    struct is_constructible;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>,
       __not_<is_constructible<__dst_t, _From>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public __is_direct_constructible_new<_Tp, _Arg>::type
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public __is_constructible_impl<_Tp, _Args...>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    {
      template<typename _Tp1, typename _Up1,
        typename = decltype(declval<_Tp1>() = declval<_Up1>())>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __is_assignable_helper<_Tp, _Up>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __and_<is_constructible<_Tp, _Args...>, integral_constant<bool,
   __is_trivially_constructible(_Tp, _Args...)>>
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
      : public __do_is_implicitly_default_constructible_impl
  {
    typedef decltype(__test(declval<_Tp>())) type;
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
      : public __is_implicitly_default_constructible_impl<_Tp>::type
  { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
      : public __and_<is_default_constructible<_Tp>,
                      __is_implicitly_default_constructible_safe<_Tp>>
  { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp, _Up)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __and_<is_copy_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __and_<is_move_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>
    { };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __make_unsigned<wchar_t> : __make_unsigned<int>
    { };



  template<>
    struct __make_unsigned<__int128>
    { typedef unsigned __int128 __type; };
# 1771 "/usr/include/c++/7/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);
      typedef conditional<__b3, unsigned long, unsigned long long> __cond3;
      typedef typename __cond3::type __cond3_type;
      typedef conditional<__b2, unsigned int, __cond3_type> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

      typedef typename conditional<__b0, __smallest, __cond1_type>::type
 __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };
# 1860 "/usr/include/c++/7/type_traits" 3
  template<>
    struct __make_signed<char16_t> : __make_signed<uint_least16_t>
    { };
  template<>
    struct __make_signed<char32_t> : __make_signed<uint_least32_t>
    { };



  template<>
    struct __make_signed<unsigned __int128>
    { typedef __int128 __type; };
# 1890 "/usr/include/c++/7/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2036 "/usr/include/c++/7/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2075 "/usr/include/c++/7/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = typename decay<_Tp>::type>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;



  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<typename...> using __void_t = void;




  template<typename...> using void_t = void;



  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2553 "/usr/include/c++/7/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename remove_cv<
      typename remove_reference<_Tp>::type>::type>::type
    { };

  template<typename _Tp>
    inline
    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    inline
    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };






  template<typename _Tp>
    struct is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };


  template<typename _Tp>
    struct is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };



  template<typename _Tp>
    constexpr bool is_swappable_v =
      is_swappable<_Tp>::value;


  template<typename _Tp>
    constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;


  namespace __swappable_with_details {
    using std::swap;

    struct __do_is_swappable_with_impl
    {
      template<typename _Tp, typename _Up, typename
               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
               typename
               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
        static true_type __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_with_impl
    {
      template<typename _Tp, typename _Up>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
          &&
          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))
        > __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp, typename _Up>
    struct __is_swappable_with_impl
    : public __swappable_with_details::__do_is_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_swappable_with
    : public __is_swappable_with_impl<_Tp, _Up>::type
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    { };



  template<typename _Tp, typename _Up>
    constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;


  template<typename _Tp, typename _Up>
    constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;






  template<typename _Result, typename _Ret, typename = void>
    struct __is_invocable_impl : false_type { };

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>>
    : __or_<is_void<_Ret>, is_convertible<typename _Result::type, _Ret>>::type
    { };

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

  struct __nonesuch {
    __nonesuch() = delete;
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
# 3108 "/usr/include/c++/7/type_traits" 3

}
# 55 "/usr/include/c++/7/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/include/c++/7/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 115 "/usr/include/c++/7/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 135 "/usr/include/c++/7/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }



}
# 166 "/usr/include/c++/7/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 181 "/usr/include/c++/7/bits/move.h" 3
  template<typename _Tp>
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)




    {

     

      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)




    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 41 "/usr/include/c++/7/bits/nested_exception.h" 2 3

extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };




  template<typename _Tp>
    inline void
    __throw_with_nested_impl(_Tp&& __t, true_type)
    {
      using _Up = typename remove_reference<_Tp>::type;
      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
    }

  template<typename _Tp>
    inline void
    __throw_with_nested_impl(_Tp&& __t, false_type)
    { throw std::forward<_Tp>(__t); }



  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      using _Up = typename decay<_Tp>::type;
      using _CopyConstructible
 = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
      static_assert(_CopyConstructible::value,
   "throw_with_nested argument must be CopyConstructible");
      using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,
       __not_<is_base_of<nested_exception, _Up>>>;
      std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});
    }


  template<typename _Tp>
    using __rethrow_if_nested_cond = typename enable_if<
      __and_<is_polymorphic<_Tp>,
      __or_<__not_<is_base_of<nested_exception, _Tp>>,
     is_convertible<_Tp*, nested_exception*>>>::value
    >::type;


  template<typename _Ex>
    inline __rethrow_if_nested_cond<_Ex>
    __rethrow_if_nested_impl(const _Ex* __ptr)
    {
      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))
 __ne_ptr->rethrow_nested();
    }


  inline void
  __rethrow_if_nested_impl(const void*)
  { }


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }


}

}



#pragma GCC visibility pop
# 144 "/usr/include/c++/7/exception" 2 3
# 40 "/usr/include/c++/7/ios" 2 3
# 1 "/usr/include/c++/7/bits/char_traits.h" 1 3
# 37 "/usr/include/c++/7/bits/char_traits.h" 3
       
# 38 "/usr/include/c++/7/bits/char_traits.h" 3

# 1 "/usr/include/c++/7/bits/stl_algobase.h" 1 3
# 60 "/usr/include/c++/7/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/7/bits/functexcept.h" 1 3
# 42 "/usr/include/c++/7/bits/functexcept.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "/usr/include/c++/7/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/7/bits/cpp_type_traits.h" 1 3
# 35 "/usr/include/c++/7/bits/cpp_type_traits.h" 3
       
# 36 "/usr/include/c++/7/bits/cpp_type_traits.h" 3
# 67 "/usr/include/c++/7/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 261 "/usr/include/c++/7/bits/cpp_type_traits.h" 3
template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
# 278 "/usr/include/c++/7/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 62 "/usr/include/c++/7/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/7/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/7/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/7/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 63 "/usr/include/c++/7/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/7/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/7/ext/numeric_traits.h" 3
       
# 33 "/usr/include/c++/7/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/include/c++/7/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "/usr/include/c++/7/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "/usr/include/c++/7/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/7/bits/stl_pair.h" 1 3
# 65 "/usr/include/c++/7/bits/stl_pair.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 76 "/usr/include/c++/7/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _CopyMovePair()
      {
 using __do_converts = __and_<is_convertible<const _U1&, _T1>,
      is_convertible<_U2&&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, _U2&&>,
        __converts
        >::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _MoveCopyPair()
      {
 using __do_converts = __and_<is_convertible<_U1&&, _T1>,
      is_convertible<const _U2&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, const _U2&&>,
        __converts
        >::value;
      }
  };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
  };




  struct __nonesuch_no_braces : std::__nonesuch {
    explicit __nonesuch_no_braces(const __nonesuch&) = delete;
  };


  template<typename _U1, typename _U2> class __pair_base
  {

    template<typename _T1, typename _T2> friend struct pair;
    __pair_base() = default;
    ~__pair_base() = default;
    __pair_base(const __pair_base&) = default;
    __pair_base& operator=(const __pair_base&) = delete;

  };







  template<typename _T1, typename _T2>
    struct pair
    : private __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }
# 252 "/usr/include/c++/7/bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;

      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 280 "/usr/include/c++/7/bits/stl_pair.h" 3
      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<true, _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<false, _U1, _T2>(),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<true, _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<false, _T1, _U2>(),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(typename conditional<
  __and_<is_copy_assignable<_T1>,
         is_copy_assignable<_T2>>::value,
  const pair&, const __nonesuch_no_braces&>::type __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(typename conditional<
  __and_<is_move_assignable<_T1>,
         is_move_assignable<_T2>>::value,
  pair&&, __nonesuch_no_braces&&>::type __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
        is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
    is_assignable<_T2&, const _U2&>>::value,
    pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
    is_assignable<_T2&, _U2&&>>::value,
    pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
                      __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };






  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<typename _T1, typename _T2>
    inline


    typename enable_if<__and_<__is_swappable<_T1>,
                              __is_swappable<_T2>>::value>::type



    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename _T1, typename _T2>
    typename enable_if<!__and_<__is_swappable<_T1>,
          __is_swappable<_T2>>::value>::type
    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
# 521 "/usr/include/c++/7/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 540 "/usr/include/c++/7/bits/stl_pair.h" 3

}
# 65 "/usr/include/c++/7/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/7/bits/stl_iterator_base_types.h" 1 3
# 62 "/usr/include/c++/7/bits/stl_iterator_base_types.h" 3
       
# 63 "/usr/include/c++/7/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 89 "/usr/include/c++/7/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "/usr/include/c++/7/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 143 "/usr/include/c++/7/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 177 "/usr/include/c++/7/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }
# 231 "/usr/include/c++/7/bits/stl_iterator_base_types.h" 3
  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
  iterator_traits<_InIter>::iterator_category,
          input_iterator_tag>::value>::type;



}
# 66 "/usr/include/c++/7/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/7/bits/stl_iterator_base_funcs.h" 1 3
# 62 "/usr/include/c++/7/bits/stl_iterator_base_funcs.h" 3
       
# 63 "/usr/include/c++/7/bits/stl_iterator_base_funcs.h" 3


# 1 "/usr/include/c++/7/debug/assertions.h" 1 3
# 66 "/usr/include/c++/7/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;




  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline constexpr
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
# 135 "/usr/include/c++/7/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline constexpr void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline constexpr void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 195 "/usr/include/c++/7/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _ForwardIterator>
    inline _ForwardIterator
    next(_ForwardIterator __x, typename
  iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "/usr/include/c++/7/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/7/bits/stl_iterator.h" 1 3
# 66 "/usr/include/c++/7/bits/stl_iterator.h" 3
# 1 "/usr/include/c++/7/bits/ptr_traits.h" 1 3
# 37 "/usr/include/c++/7/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  class __undefined;


  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_Template<_Tp, _Types...>>
    { using type = _Tp; };

  template<typename _Tp>
    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;





  template<typename _Ptr>
    struct pointer_traits
    {
    private:
      template<typename _Tp>
 using __element_type = typename _Tp::element_type;

      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up, typename = void>
 struct __rebind : __replace_first_arg<_Tp, _Up> { };

      template<typename _Tp, typename _Up>
 struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>
 { using type = typename _Tp::template rebind<_Up>; };

    public:

      using pointer = _Ptr;


      using element_type
 = __detected_or_t<__get_first_arg_t<_Ptr>, __element_type, _Ptr>;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind = typename __rebind<_Ptr, _Up>::type;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }

      static_assert(!is_same<element_type, __undefined>::value,
   "pointer type defines element_type or is like SomePointer<T, Args>");
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;


}
# 67 "/usr/include/c++/7/bits/stl_iterator.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 100 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;
# 126 "/usr/include/c++/7/bits/stl_iterator.h" 3
     
      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




     
      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>

        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 168 "/usr/include/c++/7/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }
# 182 "/usr/include/c++/7/bits/stl_iterator.h" 3
      pointer
      operator->() const
      { return std::__addressof(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 300 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }
# 390 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }







  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }




  template<typename _Iterator>
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 454 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 489 "/usr/include/c++/7/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 531 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 546 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 580 "/usr/include/c++/7/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 622 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 641 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 692 "/usr/include/c++/7/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 736 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 760 "/usr/include/c++/7/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


      reference
      operator*() const noexcept
      { return *_M_current; }

      pointer
      operator->() const noexcept
      { return _M_current; }

      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 860 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    { return __it.base(); }


}



namespace std __attribute__ ((__visibility__ ("default")))
{

# 1012 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;
      typedef typename __traits_type::reference __base_ref;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;

     
      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>

 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return static_cast<reference>(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }



  template<typename _Iterator>
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }


}
# 68 "/usr/include/c++/7/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/7/debug/debug.h" 1 3
# 48 "/usr/include/c++/7/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 70 "/usr/include/c++/7/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/7/bits/predefined_ops.h" 1 3
# 33 "/usr/include/c++/7/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "/usr/include/c++/7/bits/stl_algobase.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 118 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 148 "/usr/include/c++/7/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 164 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 192 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 216 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 240 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 262 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    inline _Iterator
    __niter_base(_Iterator __it)
    { return __it; }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 444 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 477 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 620 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 656 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
# 722 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 782 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, (void)++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   if (const size_t __len = (__last1 - __first1))
     return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
   return true;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 return std::__lexicographical_compare_impl(__first1, __last1,
         __first2, __last2,
     __gnu_cxx::__ops::__iter_less_iter());
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = __builtin_memcmp(__first1, __first2, __len))
       return __result < 0;
   return __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 982 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




# 1039 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1071 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1104 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1153 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_IIter1>::iterator_category;
      using _Cat2 = typename iterator_traits<_IIter2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1201 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1237 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1280 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1313 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1360 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1395 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



}
# 40 "/usr/include/c++/7/bits/char_traits.h" 2 3

# 1 "/usr/include/c++/7/cwchar" 1 3
# 39 "/usr/include/c++/7/cwchar" 3
       
# 40 "/usr/include/c++/7/cwchar" 3
# 42 "/usr/include/c++/7/bits/char_traits.h" 2 3





namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 61 "/usr/include/c++/7/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 86 "/usr/include/c++/7/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static constexpr void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static constexpr std::size_t
      length(const char_type* __s);

      static constexpr const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    constexpr int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    constexpr std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    constexpr const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

# 268 "/usr/include/c++/7/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {






 if (__n == 0)
   return 0;
 return __builtin_memcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      {




 return __builtin_strlen(__s);
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {






 if (__n == 0)
   return 0;
 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {






 if (__n == 0)
   return 0;
 else
   return wmemcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      {





   return wcslen(__s);
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {






 if (__n == 0)
   return 0;
 else
   return wmemchr(__s, __a, __n);
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemmove(__s1, __s2, __n);
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemcpy(__s1, __s2, __n);
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}




# 1 "/usr/include/c++/7/cstdint" 1 3
# 32 "/usr/include/c++/7/cstdint" 3
       
# 33 "/usr/include/c++/7/cstdint" 3
# 41 "/usr/include/c++/7/cstdint" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 130 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 131 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 68 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 81 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 97 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 111 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 2 3 4
# 42 "/usr/include/c++/7/cstdint" 2 3




namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 502 "/usr/include/c++/7/bits/char_traits.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 41 "/usr/include/c++/7/ios" 2 3
# 1 "/usr/include/c++/7/bits/localefwd.h" 1 3
# 37 "/usr/include/c++/7/bits/localefwd.h" 3
       
# 38 "/usr/include/c++/7/bits/localefwd.h" 3


# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++locale.h" 1 3
# 39 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++locale.h" 3
       
# 40 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++locale.h" 3

# 1 "/usr/include/c++/7/clocale" 1 3
# 39 "/usr/include/c++/7/clocale" 3
       
# 40 "/usr/include/c++/7/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) throw ();
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) throw ();



extern void freelocale (locale_t __dataset) throw ();






extern locale_t uselocale (locale_t __dataset) throw ();







}
# 43 "/usr/include/c++/7/clocale" 2 3
# 51 "/usr/include/c++/7/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 41 "/usr/include/c++/7/bits/localefwd.h" 2 3

# 1 "/usr/include/c++/7/cctype" 1 3
# 39 "/usr/include/c++/7/cctype" 3
       
# 40 "/usr/include/c++/7/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4
extern "C" {
# 39 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 62 "/usr/include/endian.h" 2 3 4
# 40 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();




extern int isblank (int) throw ();




extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) throw ();
extern int isalpha_l (int, locale_t) throw ();
extern int iscntrl_l (int, locale_t) throw ();
extern int isdigit_l (int, locale_t) throw ();
extern int islower_l (int, locale_t) throw ();
extern int isgraph_l (int, locale_t) throw ();
extern int isprint_l (int, locale_t) throw ();
extern int ispunct_l (int, locale_t) throw ();
extern int isspace_l (int, locale_t) throw ();
extern int isupper_l (int, locale_t) throw ();
extern int isxdigit_l (int, locale_t) throw ();

extern int isblank_l (int, locale_t) throw ();



extern int __tolower_l (int __c, locale_t __l) throw ();
extern int tolower_l (int __c, locale_t __l) throw ();


extern int __toupper_l (int __c, locale_t __l) throw ();
extern int toupper_l (int __c, locale_t __l) throw ();
# 327 "/usr/include/ctype.h" 3 4
}
# 43 "/usr/include/c++/7/cctype" 2 3
# 62 "/usr/include/c++/7/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "/usr/include/c++/7/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "/usr/include/c++/7/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  class messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}
# 42 "/usr/include/c++/7/ios" 2 3
# 1 "/usr/include/c++/7/bits/ios_base.h" 1 3
# 37 "/usr/include/c++/7/bits/ios_base.h" 3
       
# 38 "/usr/include/c++/7/bits/ios_base.h" 3

# 1 "/usr/include/c++/7/ext/atomicity.h" 1 3
# 32 "/usr/include/c++/7/ext/atomicity.h" 3
       
# 33 "/usr/include/c++/7/ext/atomicity.h" 3


# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr.h" 1 3
# 30 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 1 3
# 35 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 23 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 32 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4







struct timespec
{
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};
# 33 "/usr/include/sched.h" 2 3 4





typedef __pid_t pid_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 75 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
struct sched_param
{
  int sched_priority;
};

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();


}
# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 115 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
     throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 45 "/usr/include/sched.h" 2 3 4






extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 121 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 24 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 23 "/usr/include/x86_64-linux-gnu/bits/timex.h" 2 3 4



struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 34 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 38 "/usr/include/time.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 47 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 48 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4
extern "C" {



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) throw ();





extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();




extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
# 196 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 211 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 280 "/usr/include/time.h" 3 4
extern int getdate_err;
# 289 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 303 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 25 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 99 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
};
# 78 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 118 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
struct __pthread_mutex_s
{
  int __lock ;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;
 




  short __spins; short __elision;
  __pthread_list_t __list;
# 145 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
 
};




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 27 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4




enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 115 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 156 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 191 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 229 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 495 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 507 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 541 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 743 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 807 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 889 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1001 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1045 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1112 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1146 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
# 1160 "/usr/include/pthread.h" 3 4
}
# 36 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 2 3
# 47 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 101 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init")));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 236 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create")));
# 246 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
# 658 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 807 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 849 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 149 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "/usr/include/c++/7/ext/atomicity.h" 2 3
# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/atomic_word.h" 1 3
# 32 "/usr/include/x86_64-linux-gnu/c++/7/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/usr/include/c++/7/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "/usr/include/c++/7/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 40 "/usr/include/c++/7/bits/ios_base.h" 2 3

# 1 "/usr/include/c++/7/bits/locale_classes.h" 1 3
# 37 "/usr/include/c++/7/bits/locale_classes.h" 3
       
# 38 "/usr/include/c++/7/bits/locale_classes.h" 3


# 1 "/usr/include/c++/7/string" 1 3
# 36 "/usr/include/c++/7/string" 3
       
# 37 "/usr/include/c++/7/string" 3




# 1 "/usr/include/c++/7/bits/allocator.h" 1 3
# 46 "/usr/include/c++/7/bits/allocator.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++allocator.h" 1 3
# 33 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++allocator.h" 3
# 1 "/usr/include/c++/7/ext/new_allocator.h" 1 3
# 40 "/usr/include/c++/7/ext/new_allocator.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
# 57 "/usr/include/c++/7/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
 struct rebind
 { typedef new_allocator<_Tp1> other; };




      typedef std::true_type propagate_on_container_move_assignment;


      new_allocator() noexcept { }

      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
 new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = static_cast<const void*>(0))
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();
# 111 "/usr/include/c++/7/ext/new_allocator.h" 3
 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      {







 ::operator delete(__p);
      }

      size_type
      max_size() const noexcept
      { return size_t(-1) / sizeof(_Tp); }


      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p) { __p->~_Up(); }
# 151 "/usr/include/c++/7/ext/new_allocator.h" 3
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 34 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++allocator.h" 2 3


namespace std
{
# 47 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "/usr/include/c++/7/bits/allocator.h" 2 3
# 57 "/usr/include/c++/7/bits/allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{








  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;

      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p) { __p->~_Up(); }

    };
# 107 "/usr/include/c++/7/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;


      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __allocator_base<_Tp>(__a) { }

      template<typename _Tp1>
 allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return false; }






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };



}
# 42 "/usr/include/c++/7/string" 2 3


# 1 "/usr/include/c++/7/bits/ostream_insert.h" 1 3
# 33 "/usr/include/c++/7/bits/ostream_insert.h" 3
       
# 34 "/usr/include/c++/7/bits/ostream_insert.h" 3


# 1 "/usr/include/c++/7/bits/cxxabi_forced.h" 1 3
# 34 "/usr/include/c++/7/bits/cxxabi_forced.h" 3
       
# 35 "/usr/include/c++/7/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/usr/include/c++/7/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "/usr/include/c++/7/string" 2 3



# 1 "/usr/include/c++/7/bits/stl_function.h" 1 3
# 63 "/usr/include/c++/7/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 104 "/usr/include/c++/7/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 144 "/usr/include/c++/7/bits/stl_function.h" 3
  struct __is_transparent;

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;



  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };





  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct negate<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(-std::forward<_Tp>(__t)))
 -> decltype(-std::forward<_Tp>(__t))
 { return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 330 "/usr/include/c++/7/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;



  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };



  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };
# 512 "/usr/include/c++/7/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;



  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };



  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(!std::forward<_Tp>(__t)))
 -> decltype(!std::forward<_Tp>(__t))
 { return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };




  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };


  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(~std::forward<_Tp>(__t)))
 -> decltype(~std::forward<_Tp>(__t))
 { return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 740 "/usr/include/c++/7/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    constexpr
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    constexpr
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 817 "/usr/include/c++/7/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 937 "/usr/include/c++/7/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "/usr/include/c++/7/backward/binders.h" 1 3
# 60 "/usr/include/c++/7/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std __attribute__ ((__visibility__ ("default")))
{

# 107 "/usr/include/c++/7/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1128 "/usr/include/c++/7/bits/stl_function.h" 2 3
# 49 "/usr/include/c++/7/string" 2 3


# 1 "/usr/include/c++/7/bits/range_access.h" 1 3
# 33 "/usr/include/c++/7/bits/range_access.h" 3
       
# 34 "/usr/include/c++/7/bits/range_access.h" 3


# 1 "/usr/include/c++/7/initializer_list" 1 3
# 33 "/usr/include/c++/7/initializer_list" 3
       
# 34 "/usr/include/c++/7/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 37 "/usr/include/c++/7/bits/range_access.h" 2 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&);
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&);
  template<typename _Tp> _Tp* end(valarray<_Tp>&);
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&);






  template<typename _Container>
    inline constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<typename _Container>
    inline constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<typename _Container>
    inline auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Container>
    inline auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<typename _Container>
    inline auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<typename _Container>
    inline auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }
# 323 "/usr/include/c++/7/bits/range_access.h" 3

}
# 52 "/usr/include/c++/7/string" 2 3
# 1 "/usr/include/c++/7/bits/basic_string.h" 1 3
# 37 "/usr/include/c++/7/bits/basic_string.h" 3
       
# 38 "/usr/include/c++/7/bits/basic_string.h" 3


# 1 "/usr/include/c++/7/ext/alloc_traits.h" 1 3
# 32 "/usr/include/c++/7/ext/alloc_traits.h" 3
       
# 33 "/usr/include/c++/7/ext/alloc_traits.h" 3



# 1 "/usr/include/c++/7/bits/alloc_traits.h" 1 3
# 41 "/usr/include/c++/7/bits/alloc_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __allocator_traits_base
  {
    template<typename _Tp, typename _Up, typename = void>
      struct __rebind : __replace_first_arg<_Tp, _Up> { };

    template<typename _Tp, typename _Up>
      struct __rebind<_Tp, _Up,
        __void_t<typename _Tp::template rebind<_Up>::other>>
      { using type = typename _Tp::template rebind<_Up>::other; };

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind
      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;





  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;

    private:

      template<template<typename> class _Func, typename _Tp, typename = void>
 struct _Ptr
 {
   using type = typename pointer_traits<pointer>::template rebind<_Tp>;
 };

      template<template<typename> class _Func, typename _Tp>
 struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
 {
   using type = _Func<_Alloc>;
 };


      template<typename _A2, typename _PtrT, typename = void>
 struct _Diff
 { using type = typename pointer_traits<_PtrT>::difference_type; };

      template<typename _A2, typename _PtrT>
 struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
 { using type = typename _A2::difference_type; };


      template<typename _A2, typename _DiffT, typename = void>
 struct _Size : make_unsigned<_DiffT> { };

      template<typename _A2, typename _DiffT>
 struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
 { using type = typename _A2::size_type; };

    public:






      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;







      using void_pointer = typename _Ptr<__v_pointer, void>::type;







      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;







      using difference_type = typename _Diff<_Alloc, pointer>::type;







      using size_type = typename _Size<_Alloc, difference_type>::type;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 static auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }

      template<typename _Alloc2, typename _Tp>
 static auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 { __p->~_Tp(); }

      template<typename _Alloc2>
 static auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 299 "/usr/include/c++/7/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 314 "/usr/include/c++/7/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 326 "/usr/include/c++/7/bits/alloc_traits.h" 3
      static void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 341 "/usr/include/c++/7/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 354 "/usr/include/c++/7/bits/alloc_traits.h" 3
      template<typename _Tp>
 static void destroy(_Alloc& __a, _Tp* __p)
 { _S_destroy(__a, __p, 0); }
# 366 "/usr/include/c++/7/bits/alloc_traits.h" 3
      static size_type max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 377 "/usr/include/c++/7/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };


  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;

      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 434 "/usr/include/c++/7/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 448 "/usr/include/c++/7/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      { return __a.allocate(__n, __hint); }
# 460 "/usr/include/c++/7/bits/alloc_traits.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 472 "/usr/include/c++/7/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a, _Up* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }
# 484 "/usr/include/c++/7/bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type& __a, _Up* __p)
 { __a.destroy(__p); }






      static size_type
      max_size(const allocator_type& __a) noexcept
      { return __a.max_size(); }






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy(__one, __two, __pocca());
    }

  template<typename _Alloc>
    inline _Alloc __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move(__one, __two, __pocma());
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;
      __do_alloc_on_swap(__one, __two, __pocs());
    }

  template<typename _Alloc>
    class __is_copy_insertable_impl
    {
      typedef allocator_traits<_Alloc> _Traits;

      template<typename _Up, typename
        = decltype(_Traits::construct(std::declval<_Alloc&>(),
          std::declval<_Up*>(),
          std::declval<const _Up&>()))>
 static true_type
 _M_select(int);

      template<typename _Up>
 static false_type
 _M_select(...);

    public:
      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
    };


  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_copy_insertable_impl<_Alloc>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };


}
# 37 "/usr/include/c++/7/ext/alloc_traits.h" 2 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{






template<typename _Alloc>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      {
 _Base_type::construct(__a, std::addressof(*__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      { _Base_type::destroy(__a, std::addressof(*__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 158 "/usr/include/c++/7/ext/alloc_traits.h" 3
  };


}
# 41 "/usr/include/c++/7/bits/basic_string.h" 2 3
# 52 "/usr/include/c++/7/bits/basic_string.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



namespace __cxx11 {
# 76 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    private:




      typedef const_iterator __const_iterator;
# 139 "/usr/include/c++/7/bits/basic_string.h" 3
      struct _Alloc_hider : allocator_type
      {




 _Alloc_hider(pointer __dat, const _Alloc& __a)
 : allocator_type(__a), _M_p(__dat) { }

 _Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
 : allocator_type(std::move(__a)), _M_p(__dat) { }


 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }


      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }



      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
    std::__false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
 }



      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
 { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_construct_aux(__beg, __end, _Integral());
        }


      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:
# 298 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)")
                                         ,
       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, (void)++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_assign(const basic_string&);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:







      basic_string()
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }




      explicit
      basic_string(const _Alloc& __a) noexcept
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }





      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(),
      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
# 450 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, npos));
      }







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 481 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 499 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }






      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }







      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
# 531 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_local_data());
 __str._M_set_length(0);
      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      noexcept(_Alloc_traits::_S_always_equal())
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
     _M_length(__str.length());
     __str._M_set_length(0);
   }
 else if (_Alloc_traits::_S_always_equal()
     || __str.get_allocator() == __a)
   {
     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     __str._M_data(__str._M_local_buf);
     __str._M_set_length(0);
   }
 else
   _M_construct(__str.begin(), __str.end());
      }
# 599 "/usr/include/c++/7/bits/basic_string.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a)
 { _M_construct(__beg, __end); }
# 646 "/usr/include/c++/7/bits/basic_string.h" 3
      ~basic_string()
      { _M_dispose(); }





      basic_string&
      operator=(const basic_string& __str)
      {

 if (_Alloc_traits::_S_propagate_on_copy_assign())
   {
     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
  && _M_get_allocator() != __str._M_get_allocator())
       {


  if (__str.size() <= _S_local_capacity)
    {
      _M_destroy(_M_allocated_capacity);
      _M_data(_M_local_data());
      _M_set_length(0);
    }
  else
    {
      const auto __len = __str.size();
      auto __alloc = __str._M_get_allocator();

      auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
      _M_destroy(_M_allocated_capacity);
      _M_data(__ptr);
      _M_capacity(__len);
      _M_set_length(__len);
    }
       }
     std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
   }

 return this->assign(__str);
      }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 703 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 721 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {
 if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
     && !_Alloc_traits::_S_always_equal()
     && _M_get_allocator() != __str._M_get_allocator())
   {

     _M_destroy(_M_allocated_capacity);
     _M_data(_M_local_data());
     _M_set_length(0);
   }

 std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

 if (__str._M_is_local())
   {

     if (__str.size())
       this->_S_copy(_M_data(), __str._M_data(), __str.size());
     _M_set_length(__str.size());
   }
 else if (_Alloc_traits::_S_propagate_on_move_assign()
     || _Alloc_traits::_S_always_equal()
     || _M_get_allocator() == __str._M_get_allocator())
   {

     pointer __data = nullptr;
     size_type __capacity;
     if (!_M_is_local())
       {
  if (_Alloc_traits::_S_always_equal())
    {

      __data = _M_data();
      __capacity = _M_allocated_capacity;
    }
  else
    _M_destroy(_M_allocated_capacity);
       }

     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     if (__data)
       {
  __str._M_data(__data);
  __str._M_capacity(__capacity);
       }
     else
       __str._M_data(__str._M_local_buf);
   }
 else
   assign(__str);
 __str.clear();
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }
# 815 "/usr/include/c++/7/bits/basic_string.h" 3
      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_string_length; }



      size_type
      length() const noexcept
      { return _M_string_length; }


      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
# 944 "/usr/include/c++/7/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 957 "/usr/include/c++/7/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit() noexcept
      {

 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }

      }






      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
# 1006 "/usr/include/c++/7/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_set_length(0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 1035 "/usr/include/c++/7/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const noexcept
      {
 ;
 return _M_data()[__pos];
      }
# 1052 "/usr/include/c++/7/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {


 ;

 ;
 return _M_data()[__pos];
      }
# 1073 "/usr/include/c++/7/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }
# 1094 "/usr/include/c++/7/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }






      reference
      front() noexcept
      {
 ;
 return operator[](0);
      }





      const_reference
      front() const noexcept
      {
 ;
 return operator[](0);
      }





      reference
      back() noexcept
      {
 ;
 return operator[](this->size() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return operator[](this->size() - 1);
      }
# 1157 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1210 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }
# 1227 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_append(__str._M_data()
    + __str._M_check(__pos, "basic_string::append"),
    __str._M_limit(__pos, __n)); }







      basic_string&
      append(const _CharT* __s, size_type __n)
      {
 ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      basic_string&
      append(const _CharT* __s)
      {
 ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
# 1269 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1293 "/usr/include/c++/7/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }
# 1338 "/usr/include/c++/7/bits/basic_string.h" 3
      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      basic_string&
      assign(const basic_string& __str)
      {
 this->_M_assign(__str);
 return *this;
      }
# 1369 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {


 return *this = std::move(__str);
      }
# 1392 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
# 1408 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
# 1424 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
# 1441 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1454 "/usr/include/c++/7/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1522 "/usr/include/c++/7/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
# 1564 "/usr/include/c++/7/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
   ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
# 1600 "/usr/include/c++/7/bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
 ;
 this->insert(__p - begin(), __l.begin(), __l.size());
      }
# 1620 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
# 1643 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n = npos)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
# 1666 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
# 1685 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
# 1709 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1727 "/usr/include/c++/7/bits/basic_string.h" 3
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
# 1787 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_check(__pos, "basic_string::erase");
 if (__n == npos)
   this->_M_set_length(__pos);
 else if (__n != 0)
   this->_M_erase(__pos, _M_limit(__pos, __n));
 return *this;
      }
# 1806 "/usr/include/c++/7/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
# 1825 "/usr/include/c++/7/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 if (__last == end())
   this->_M_set_length(__pos);
 else
   this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      void
      pop_back() noexcept
      {
 ;
 _M_erase(size() - 1, 1);
      }
# 1869 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1891 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1916 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
 ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
# 1941 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1965 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1983 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 2003 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
# 2025 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 2046 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
# 2071 "/usr/include/c++/7/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                        ;
   ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
# 2103 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 2162 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }
# 2221 "/usr/include/c++/7/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
# 2259 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 2269 "/usr/include/c++/7/bits/basic_string.h" 3
      void
      swap(basic_string& __s) noexcept;
# 2279 "/usr/include/c++/7/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }
# 2291 "/usr/include/c++/7/bits/basic_string.h" 3
      const _CharT*
      data() const noexcept
      { return _M_data(); }
# 2310 "/usr/include/c++/7/bits/basic_string.h" 3
      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
# 2326 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2340 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 2372 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const noexcept
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 2389 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 2402 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 2436 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2450 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 2467 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 2481 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 2516 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2530 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2550 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2565 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2600 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2614 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2634 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2648 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2683 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const noexcept;
# 2697 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2715 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
      noexcept;
# 2730 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2765 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const noexcept;
# 2779 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2797 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
      noexcept;
# 2813 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2832 "/usr/include/c++/7/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2925 "/usr/include/c++/7/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2951 "/usr/include/c++/7/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos) const;
# 2969 "/usr/include/c++/7/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const noexcept;
# 2993 "/usr/include/c++/7/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 3020 "/usr/include/c++/7/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;


      template<typename, typename, typename> friend class basic_stringbuf;
    };
}
# 5886 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 6007 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs) noexcept
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 6054 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 6092 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 6130 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 6168 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 6206 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 6244 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }
# 6264 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 6282 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 6305 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 6322 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}



# 1 "/usr/include/c++/7/ext/string_conversions.h" 1 3
# 32 "/usr/include/c++/7/ext/string_conversions.h" 3
       
# 33 "/usr/include/c++/7/ext/string_conversions.h" 3
# 41 "/usr/include/c++/7/ext/string_conversions.h" 3
# 1 "/usr/include/c++/7/cstdlib" 1 3
# 39 "/usr/include/c++/7/cstdlib" 3
       
# 40 "/usr/include/c++/7/cstdlib" 3
# 75 "/usr/include/c++/7/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 32 "/usr/include/stdlib.h" 2 3 4

extern "C" {





# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 58 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;



extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 274 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;
# 104 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 135 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 146 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 178 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 197 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 198 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 41 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sysmacros.h" 1 3 4
# 42 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 2 3 4
# 71 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
extern "C" {

extern unsigned int gnu_dev_major (__dev_t __dev) throw () __attribute__ ((__const__));
extern unsigned int gnu_dev_minor (__dev_t __dev) throw () __attribute__ ((__const__));
extern __dev_t gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw () __attribute__ ((__const__));
# 85 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
}
# 206 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4






typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 246 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
# 257 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
}
# 395 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();



extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));



extern void free (void *__ptr) throw ();


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 567 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 607 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));





extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 672 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 685 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 695 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 707 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 728 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 739 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 749 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 759 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 771 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 781 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 797 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;
# 869 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();







extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 954 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 1016 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1017 "/usr/include/stdlib.h" 2 3 4
# 1026 "/usr/include/stdlib.h" 3 4
}
# 76 "/usr/include/c++/7/cstdlib" 2 3

# 1 "/usr/include/c++/7/bits/std_abs.h" 1 3
# 33 "/usr/include/c++/7/bits/std_abs.h" 3
       
# 34 "/usr/include/c++/7/bits/std_abs.h" 3
# 46 "/usr/include/c++/7/bits/std_abs.h" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }







  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }



  inline constexpr __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 100 "/usr/include/c++/7/bits/std_abs.h" 3
  inline constexpr
  __float128
  abs(__float128 __x)
  { return __x < 0 ? -__x : __x; }



}
}
# 78 "/usr/include/c++/7/cstdlib" 2 3
# 121 "/usr/include/c++/7/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;



  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "/usr/include/c++/7/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "/usr/include/c++/7/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 42 "/usr/include/c++/7/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/7/cwchar" 1 3
# 39 "/usr/include/c++/7/cwchar" 3
       
# 40 "/usr/include/c++/7/cwchar" 3
# 43 "/usr/include/c++/7/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/7/cstdio" 1 3
# 39 "/usr/include/c++/7/cstdio" 3
       
# 40 "/usr/include/c++/7/cstdio" 3


# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4

extern "C" {



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/libio.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 2 3 4






typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 36 "/usr/include/x86_64-linux-gnu/bits/libio.h" 2 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 1 3 4
# 54 "/usr/include/x86_64-linux-gnu/bits/libio.h" 2 3 4
# 149 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;




typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 337 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 433 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 462 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 524 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
}
# 42 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 78 "/usr/include/stdio.h" 3 4
typedef _G_fpos_t fpos_t;




typedef _G_fpos64_t fpos64_t;
# 131 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 132 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;






extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();







extern FILE *tmpfile (void) ;
# 169 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;




extern char *tmpnam_r (char *__s) throw () ;
# 190 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 213 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 223 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 232 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 256 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
# 420 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 477 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
# 495 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 506 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 517 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 587 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 662 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 750 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;



extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 868 "/usr/include/stdio.h" 3 4
}
# 43 "/usr/include/c++/7/cstdio" 2 3
# 96 "/usr/include/c++/7/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;




  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 157 "/usr/include/c++/7/cstdio" 3
namespace __gnu_cxx
{
# 175 "/usr/include/c++/7/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 44 "/usr/include/c++/7/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/7/cerrno" 1 3
# 39 "/usr/include/c++/7/cerrno" 3
       
# 40 "/usr/include/c++/7/cerrno" 3


# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4





extern "C" {


extern int *__errno_location (void) throw () __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;





typedef int error_t;




}
# 43 "/usr/include/c++/7/cerrno" 2 3
# 45 "/usr/include/c++/7/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;

      struct _Save_errno {
 _Save_errno() : _M_errno((*__errno_location ())) { (*__errno_location ()) = 0; }
 ~_Save_errno() { if ((*__errno_location ()) == 0) (*__errno_location ()) = _M_errno; }
 int _M_errno;
      } const __save_errno;

      struct _Range_chk {
   static bool
   _S_chk(_TRet, std::false_type) { return false; }

   static bool
   _S_chk(_TRet __val, std::true_type)
   {
     return __val < _TRet(__numeric_traits<int>::__min)
       || __val > _TRet(__numeric_traits<int>::__max);
   }
      };

      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
   || _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>{}))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 6362 "/usr/include/c++/7/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }






  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }



  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}

}





# 1 "/usr/include/c++/7/bits/functional_hash.h" 1 3
# 33 "/usr/include/c++/7/bits/functional_hash.h" 3
       
# 34 "/usr/include/c++/7/bits/functional_hash.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/7/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type;
      typedef _Arg argument_type;
    };


  template<typename _Tp>
    struct hash;

  template<typename _Tp, typename = void>
    struct __poison_hash
    {
      static constexpr bool __enable_hash_call = false;
    private:

      __poison_hash(__poison_hash&&);
      ~__poison_hash();
    };

  template<typename _Tp>
    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>
    {
      static constexpr bool __enable_hash_call = true;
    };


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 124 "/usr/include/c++/7/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<__int128> : public __hash_base<size_t, __int128> { size_t operator()(__int128 __val) const noexcept { return static_cast<size_t>(__val); } };
  template<> struct hash<__int128 unsigned> : public __hash_base<size_t, __int128 unsigned> { size_t operator()(__int128 unsigned __val) const noexcept { return static_cast<size_t>(__val); } };
# 187 "/usr/include/c++/7/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };







  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 6588 "/usr/include/c++/7/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };








  inline namespace literals
  {
  inline namespace string_literals
  {


    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char>
    operator""s(const char* __str, size_t __len)
    { return basic_string<char>{__str, __len}; }


    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<wchar_t>
    operator""s(const wchar_t* __str, size_t __len)
    { return basic_string<wchar_t>{__str, __len}; }



    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char16_t>
    operator""s(const char16_t* __str, size_t __len)
    { return basic_string<char16_t>{__str, __len}; }

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char32_t>
    operator""s(const char32_t* __str, size_t __len)
    { return basic_string<char32_t>{__str, __len}; }



  }
  }



}
# 53 "/usr/include/c++/7/string" 2 3
# 1 "/usr/include/c++/7/bits/basic_string.tcc" 1 3
# 42 "/usr/include/c++/7/bits/basic_string.tcc" 3
       
# 43 "/usr/include/c++/7/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == &__s)
 return;

      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      _S_local_capacity + 1);
       }
     else if (__s.length())
       {
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      _S_local_capacity + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         _S_local_capacity + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    _S_local_capacity + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 while (__beg != __end && __len < __capacity)
   {
     _M_data()[__len++] = *__beg;
     ++__beg;
   }

 try
   {
     while (__beg != __end)
       {
  if (__len == __capacity)
    {

      __capacity = __len + 1;
      pointer __another = _M_create(__capacity, __len);
      this->_S_copy(__another, _M_data(), __len);
      _M_dispose();
      _M_data(__another);
      _M_capacity(__capacity);
    }
  _M_data()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {

 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   std::__throw_logic_error(("basic_string::" "_M_construct null not valid")
                                         );

 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }


 try
   { this->_S_copy_chars(_M_data(), __beg, __end); }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {

      if (__res < length())
 __res = length();

      const size_type __capacity = capacity();
      if (__res != __capacity)
 {
   if (__res > __capacity
       || __res > size_type(_S_local_capacity))
     {
       pointer __tmp = _M_create(__res, __capacity);
       this->_S_copy(__tmp, _M_data(), length() + 1);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__res);
     }
   else if (!_M_is_local())
     {
       this->_S_copy(_M_local_data(), _M_data(), length() + 1);
       _M_destroy(__capacity);
       _M_data(_M_local_data());
     }
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;
   if (_M_disjunct(__s))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     {

       if (__len2 && __len2 <= __len1)
  this->_S_move(__p, __s, __len2);
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2 > __len1)
  {
    if (__s + __len2 <= __p + __len1)
      this->_S_move(__p, __s, __len2);
    else if (__s >= __p + __len1)
      this->_S_copy(__p, __s + __len2 - __len1, __len2);
    else
      {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2,
        __len2 - __nleft);
      }
  }
     }
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
# 1155 "/usr/include/c++/7/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;
      if (__pos >= __size)
 return npos;

      const _CharT __elem0 = __s[0];
      const _CharT* const __data = data();
      const _CharT* __first = __data + __pos;
      const _CharT* const __last = __data + __size;
      size_type __len = __size - __pos;

      while (__len >= __n)
 {

   __first = traits_type::find(__first, __len - __n + 1, __elem0);
   if (!__first)
     return npos;



   if (traits_type::compare(__first, __s, __n) == 0)
     return __first - __data;
   __len = __last - ++__first;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const noexcept
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
# 1607 "/usr/include/c++/7/bits/basic_string.tcc" 3
  extern template class basic_string<char>;







  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);



  extern template class basic_string<wchar_t>;





  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 54 "/usr/include/c++/7/string" 2 3
# 41 "/usr/include/c++/7/bits/locale_classes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 62 "/usr/include/c++/7/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "/usr/include/c++/7/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "/usr/include/c++/7/bits/locale_classes.h" 3
    locale() throw();
# 126 "/usr/include/c++/7/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "/usr/include/c++/7/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "/usr/include/c++/7/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 162 "/usr/include/c++/7/bits/locale_classes.h" 3
    explicit
    locale(const std::string& __s) : locale(__s.c_str()) { }
# 177 "/usr/include/c++/7/bits/locale_classes.h" 3
    locale(const locale& __base, const std::string& __s, category __cat)
    : locale(__base, __s.c_str(), __cat) { }
# 192 "/usr/include/c++/7/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 205 "/usr/include/c++/7/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 219 "/usr/include/c++/7/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 234 "/usr/include/c++/7/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    __attribute ((__abi_tag__ ("cxx11")))
    string
    name() const;
# 254 "/usr/include/c++/7/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 282 "/usr/include/c++/7/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 298 "/usr/include/c++/7/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 333 "/usr/include/c++/7/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);


    static const id* const _S_twinned_facets[];

  };
# 371 "/usr/include/c++/7/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 402 "/usr/include/c++/7/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
# 438 "/usr/include/c++/7/bits/locale_classes.h" 3
    facet(const facet&) = delete;

    facet&
    operator=(const facet&) = delete;


  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    const facet* _M_sso_shim(const id*) const;
    const facet* _M_cow_shim(const id*) const;

  protected:
    class __shim;
  };
# 483 "/usr/include/c++/7/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    template<typename _Facet>
      void
      _M_init_facet_unchecked(_Facet* __facet)
      {
 __facet->_M_add_reference();
 _M_facets[_Facet::id._M_id()] = __facet;
      }

    void
    _M_install_cache(const facet*, size_t);

    void _M_init_extra(facet**);
    void _M_init_extra(void*, void*, const char*, const char*);
  };
# 641 "/usr/include/c++/7/bits/locale_classes.h" 3
  template<typename _CharT>
    class __cxx11:: collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 668 "/usr/include/c++/7/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 682 "/usr/include/c++/7/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 699 "/usr/include/c++/7/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 718 "/usr/include/c++/7/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 732 "/usr/include/c++/7/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 761 "/usr/include/c++/7/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 775 "/usr/include/c++/7/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 788 "/usr/include/c++/7/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class __cxx11:: collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }


      explicit
      collate_byname(const string& __s, size_t __refs = 0)
      : collate_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~collate_byname() { }
    };


}

# 1 "/usr/include/c++/7/bits/locale_classes.tcc" 1 3
# 37 "/usr/include/c++/7/bits/locale_classes.tcc" 3
       
# 38 "/usr/include/c++/7/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "/usr/include/c++/7/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "/usr/include/c++/7/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 852 "/usr/include/c++/7/bits/locale_classes.h" 2 3
# 42 "/usr/include/c++/7/bits/ios_base.h" 2 3




# 1 "/usr/include/c++/7/system_error" 1 3
# 32 "/usr/include/c++/7/system_error" 3
       
# 33 "/usr/include/c++/7/system_error" 3






# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/error_constants.h" 1 3
# 34 "/usr/include/x86_64-linux-gnu/c++/7/bits/error_constants.h" 3
# 1 "/usr/include/c++/7/cerrno" 1 3
# 39 "/usr/include/c++/7/cerrno" 3
       
# 40 "/usr/include/c++/7/cerrno" 3
# 35 "/usr/include/x86_64-linux-gnu/c++/7/bits/error_constants.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  enum class errc
    {
      address_family_not_supported = 97,
      address_in_use = 98,
      address_not_available = 99,
      already_connected = 106,
      argument_list_too_long = 7,
      argument_out_of_domain = 33,
      bad_address = 14,
      bad_file_descriptor = 9,


      bad_message = 74,


      broken_pipe = 32,
      connection_aborted = 103,
      connection_already_in_progress = 114,
      connection_refused = 111,
      connection_reset = 104,
      cross_device_link = 18,
      destination_address_required = 89,
      device_or_resource_busy = 16,
      directory_not_empty = 39,
      executable_format_error = 8,
      file_exists = 17,
      file_too_large = 27,
      filename_too_long = 36,
      function_not_supported = 38,
      host_unreachable = 113,


      identifier_removed = 43,


      illegal_byte_sequence = 84,
      inappropriate_io_control_operation = 25,
      interrupted = 4,
      invalid_argument = 22,
      invalid_seek = 29,
      io_error = 5,
      is_a_directory = 21,
      message_size = 90,
      network_down = 100,
      network_reset = 102,
      network_unreachable = 101,
      no_buffer_space = 105,
      no_child_process = 10,


      no_link = 67,


      no_lock_available = 37,


      no_message_available = 61,


      no_message = 42,
      no_protocol_option = 92,
      no_space_on_device = 28,


      no_stream_resources = 63,


      no_such_device_or_address = 6,
      no_such_device = 19,
      no_such_file_or_directory = 2,
      no_such_process = 3,
      not_a_directory = 20,
      not_a_socket = 88,


      not_a_stream = 60,


      not_connected = 107,
      not_enough_memory = 12,


      not_supported = 95,



      operation_canceled = 125,


      operation_in_progress = 115,
      operation_not_permitted = 1,
      operation_not_supported = 95,
      operation_would_block = 11,


      owner_dead = 130,


      permission_denied = 13,


      protocol_error = 71,


      protocol_not_supported = 93,
      read_only_file_system = 30,
      resource_deadlock_would_occur = 35,
      resource_unavailable_try_again = 11,
      result_out_of_range = 34,


      state_not_recoverable = 131,



      stream_timeout = 62,



      text_file_busy = 26,


      timed_out = 110,
      too_many_files_open_in_system = 23,
      too_many_files_open = 24,
      too_many_links = 31,
      too_many_symbolic_link_levels = 40,


      value_too_large = 75,


      wrong_protocol_type = 91
    };


}
# 40 "/usr/include/c++/7/system_error" 2 3

# 1 "/usr/include/c++/7/stdexcept" 1 3
# 36 "/usr/include/c++/7/stdexcept" 3
       
# 37 "/usr/include/c++/7/stdexcept" 3




namespace std __attribute__ ((__visibility__ ("default")))
{





  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) noexcept;
    __cow_string& operator=(const __cow_string&) noexcept;
    ~__cow_string();

    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;

  };

  typedef basic_string<char> __sso_string;
# 113 "/usr/include/c++/7/stdexcept" 3
  class logic_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    logic_error(const string& __arg) ;


    explicit
    logic_error(const char*) ;



    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;


    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;





  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg) ;

    explicit domain_error(const char*) ;

    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg) ;

    explicit invalid_argument(const char*) ;

    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg) ;

    explicit length_error(const char*) ;

    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg) ;

    explicit out_of_range(const char*) ;

    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg) ;


    explicit
    runtime_error(const char*) ;



    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;


    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;





  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg) ;

    explicit range_error(const char*) ;

    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg) ;

    explicit overflow_error(const char*) ;

    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg) ;

    explicit underflow_error(const char*) ;

    virtual ~underflow_error() noexcept;
  };




}
# 42 "/usr/include/c++/7/system_error" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  class error_code;
  class error_condition;
  class system_error;


  template<typename _Tp>
    struct is_error_code_enum : public false_type { };


  template<typename _Tp>
    struct is_error_condition_enum : public false_type { };

  template<>
    struct is_error_condition_enum<errc>
    : public true_type { };
# 71 "/usr/include/c++/7/system_error" 3
  inline namespace _V2 {


  class error_category
  {
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category();

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char*
    name() const noexcept = 0;






  private:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual __cow_string
    _M_message(int) const;

  public:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual string
    message(int) const = 0;
# 110 "/usr/include/c++/7/system_error" 3
  public:
    virtual error_condition
    default_error_condition(int __i) const noexcept;

    virtual bool
    equivalent(int __i, const error_condition& __cond) const noexcept;

    virtual bool
    equivalent(const error_code& __code, int __i) const noexcept;

    bool
    operator<(const error_category& __other) const noexcept
    { return less<const error_category*>()(this, &__other); }

    bool
    operator==(const error_category& __other) const noexcept
    { return this == &__other; }

    bool
    operator!=(const error_category& __other) const noexcept
    { return this != &__other; }
  };


  __attribute__ ((__const__)) const error_category& system_category() noexcept;
  __attribute__ ((__const__)) const error_category& generic_category() noexcept;

  }

  error_code make_error_code(errc) noexcept;

  template<typename _Tp>
    struct hash;



  struct error_code
  {
    error_code() noexcept
    : _M_value(0), _M_cat(&system_category()) { }

    error_code(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorCodeEnum, typename = typename
      enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type>
      error_code(_ErrorCodeEnum __e) noexcept
      { *this = make_error_code(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void
    clear() noexcept
    { assign(0, system_category()); }


    template<typename _ErrorCodeEnum>
      typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,
    error_code&>::type
      operator=(_ErrorCodeEnum __e) noexcept
      { return *this = make_error_code(__e); }

    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    error_condition
    default_error_condition() const noexcept;

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    friend class hash<error_code>;

    int _M_value;
    const error_category* _M_cat;
  };


  inline error_code
  make_error_code(errc __e) noexcept
  { return error_code(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_code& __lhs, const error_code& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
    { return (__os << __e.category().name() << ':' << __e.value()); }

  error_condition make_error_condition(errc) noexcept;



  struct error_condition
  {
    error_condition() noexcept
    : _M_value(0), _M_cat(&generic_category()) { }

    error_condition(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorConditionEnum, typename = typename
  enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type>
      error_condition(_ErrorConditionEnum __e) noexcept
      { *this = make_error_condition(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }


    template<typename _ErrorConditionEnum>
      typename enable_if<is_error_condition_enum
    <_ErrorConditionEnum>::value, error_condition&>::type
      operator=(_ErrorConditionEnum __e) noexcept
      { return *this = make_error_condition(__e); }

    void
    clear() noexcept
    { assign(0, generic_category()); }


    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };


  inline error_condition
  make_error_condition(errc __e) noexcept
  { return error_condition(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_condition& __lhs,
     const error_condition& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }


  inline bool
  operator==(const error_code& __lhs, const error_code& __rhs) noexcept
  { return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value()); }

  inline bool
  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
  {
    return (__lhs.category().equivalent(__lhs.value(), __rhs)
     || __rhs.category().equivalent(__lhs, __rhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
  {
    return (__rhs.category().equivalent(__rhs.value(), __lhs)
     || __lhs.category().equivalent(__rhs, __lhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  {
    return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value());
  }

  inline bool
  operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }







  class system_error : public std::runtime_error
  {
  private:
    error_code _M_code;

  public:
    system_error(error_code __ec = error_code())
    : runtime_error(__ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const string& __what)
    : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const char* __what)
    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }

    system_error(int __v, const error_category& __ecat, const char* __what)
    : system_error(error_code(__v, __ecat), __what) { }

    system_error(int __v, const error_category& __ecat)
    : runtime_error(error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    system_error(int __v, const error_category& __ecat, const string& __what)
    : runtime_error(__what + ": " + error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    virtual ~system_error() noexcept;

    const error_code&
    code() const noexcept { return _M_code; }
  };


}



namespace std __attribute__ ((__visibility__ ("default")))
{





  template<>
    struct hash<error_code>
    : public __hash_base<size_t, error_code>
    {
      size_t
      operator()(const error_code& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e._M_value);
 return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp);
      }
    };
# 414 "/usr/include/c++/7/system_error" 3

}
# 47 "/usr/include/c++/7/bits/ios_base.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16,
      _S_ios_fmtflags_max = 0x7fffffff,
      _S_ios_fmtflags_min = ~0x7fffffff
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16,
      _S_ios_openmode_max = 0x7fffffff,
      _S_ios_openmode_min = ~0x7fffffff
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16,
      _S_ios_iostate_max = 0x7fffffff,
      _S_ios_iostate_min = ~0x7fffffff
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };



  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type { };

  const error_category& iostream_category() noexcept;

  inline error_code
  make_error_code(io_errc __e) noexcept
  { return error_code(static_cast<int>(__e), iostream_category()); }

  inline error_condition
  make_error_condition(io_errc __e) noexcept
  { return error_condition(static_cast<int>(__e), iostream_category()); }
# 228 "/usr/include/c++/7/bits/ios_base.h" 3
  class ios_base
  {
# 246 "/usr/include/c++/7/bits/ios_base.h" 3
  public:
# 255 "/usr/include/c++/7/bits/ios_base.h" 3
    class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error
    {
    public:
      explicit
      failure(const string& __str);


      explicit
      failure(const string&, const error_code&);

      explicit
      failure(const char*, const error_code& = io_errc::stream);


      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();
    };
# 323 "/usr/include/c++/7/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 398 "/usr/include/c++/7/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 429 "/usr/include/c++/7/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 461 "/usr/include/c++/7/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 487 "/usr/include/c++/7/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 504 "/usr/include/c++/7/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 516 "/usr/include/c++/7/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 629 "/usr/include/c++/7/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 645 "/usr/include/c++/7/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 662 "/usr/include/c++/7/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 688 "/usr/include/c++/7/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 739 "/usr/include/c++/7/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 751 "/usr/include/c++/7/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 762 "/usr/include/c++/7/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 773 "/usr/include/c++/7/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 792 "/usr/include/c++/7/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 808 "/usr/include/c++/7/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 829 "/usr/include/c++/7/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 846 "/usr/include/c++/7/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();
# 860 "/usr/include/c++/7/bits/ios_base.h" 3
  public:
    ios_base(const ios_base&) = delete;

    ios_base&
    operator=(const ios_base&) = delete;

  protected:
    void
    _M_move(ios_base&) noexcept;

    void
    _M_swap(ios_base& __rhs) noexcept;

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }






  inline ios_base&
  hexfloat(ios_base& __base)
  {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  defaultfloat(ios_base& __base)
  {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }



}
# 43 "/usr/include/c++/7/ios" 2 3
# 1 "/usr/include/c++/7/streambuf" 1 3
# 36 "/usr/include/c++/7/streambuf" 3
       
# 37 "/usr/include/c++/7/streambuf" 3
# 45 "/usr/include/c++/7/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 119 "/usr/include/c++/7/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 208 "/usr/include/c++/7/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 225 "/usr/include/c++/7/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 238 "/usr/include/c++/7/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 250 "/usr/include/c++/7/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 262 "/usr/include/c++/7/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 283 "/usr/include/c++/7/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 297 "/usr/include/c++/7/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 315 "/usr/include/c++/7/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 337 "/usr/include/c++/7/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 356 "/usr/include/c++/7/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 371 "/usr/include/c++/7/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 396 "/usr/include/c++/7/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 423 "/usr/include/c++/7/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 449 "/usr/include/c++/7/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 463 "/usr/include/c++/7/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 481 "/usr/include/c++/7/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 497 "/usr/include/c++/7/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 508 "/usr/include/c++/7/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 528 "/usr/include/c++/7/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 544 "/usr/include/c++/7/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 554 "/usr/include/c++/7/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 575 "/usr/include/c++/7/streambuf" 3
      virtual void
      imbue(const locale& __loc)
      { }
# 590 "/usr/include/c++/7/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 601 "/usr/include/c++/7/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 613 "/usr/include/c++/7/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 626 "/usr/include/c++/7/streambuf" 3
      virtual int
      sync() { return 0; }
# 648 "/usr/include/c++/7/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 664 "/usr/include/c++/7/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 686 "/usr/include/c++/7/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 699 "/usr/include/c++/7/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 723 "/usr/include/c++/7/streambuf" 3
      virtual int_type
      pbackfail(int_type __c = traits_type::eof())
      { return traits_type::eof(); }
# 741 "/usr/include/c++/7/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 767 "/usr/include/c++/7/streambuf" 3
      virtual int_type
      overflow(int_type __c = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 782 "/usr/include/c++/7/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }




    protected:

      basic_streambuf(const basic_streambuf&);

      basic_streambuf&
      operator=(const basic_streambuf&);


      void
      swap(basic_streambuf& __sb)
      {
 std::swap(_M_in_beg, __sb._M_in_beg);
 std::swap(_M_in_cur, __sb._M_in_cur);
 std::swap(_M_in_end, __sb._M_in_end);
 std::swap(_M_out_beg, __sb._M_out_beg);
 std::swap(_M_out_cur, __sb._M_out_cur);
 std::swap(_M_out_end, __sb._M_out_end);
 std::swap(_M_buf_locale, __sb._M_buf_locale);
      }

    };


  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>::
    basic_streambuf(const basic_streambuf&) = default;

  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>&
    std::basic_streambuf<_CharT, _Traits>::
    operator=(const basic_streambuf&) = default;



  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);



}

# 1 "/usr/include/c++/7/bits/streambuf.tcc" 1 3
# 37 "/usr/include/c++/7/bits/streambuf.tcc" 3
       
# 38 "/usr/include/c++/7/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 851 "/usr/include/c++/7/streambuf" 2 3
# 44 "/usr/include/c++/7/ios" 2 3
# 1 "/usr/include/c++/7/bits/basic_ios.h" 1 3
# 33 "/usr/include/c++/7/bits/basic_ios.h" 3
       
# 34 "/usr/include/c++/7/bits/basic_ios.h" 3



# 1 "/usr/include/c++/7/bits/locale_facets.h" 1 3
# 37 "/usr/include/c++/7/bits/locale_facets.h" 3
       
# 38 "/usr/include/c++/7/bits/locale_facets.h" 3

# 1 "/usr/include/c++/7/cwctype" 1 3
# 39 "/usr/include/c++/7/cwctype" 3
       
# 40 "/usr/include/c++/7/cwctype" 3
# 50 "/usr/include/c++/7/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 38 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
typedef unsigned long int wctype_t;
# 56 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {







extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 155 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
extern wctype_t wctype (const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();






extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();

}
# 39 "/usr/include/wctype.h" 2 3 4





extern "C" {



typedef const __int32_t *wctrans_t;



extern wctrans_t wctrans (const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();







extern int iswalnum_l (wint_t __wc, locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, locale_t __locale) throw ();



extern wctype_t wctype_l (const char *__property, locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, locale_t __locale)
     throw ();






extern wint_t towlower_l (wint_t __wc, locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, locale_t __locale) throw ();



extern wctrans_t wctrans_l (const char *__property, locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      locale_t __locale) throw ();



}
# 51 "/usr/include/c++/7/cwctype" 2 3
# 80 "/usr/include/c++/7/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "/usr/include/c++/7/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/7/cctype" 1 3
# 39 "/usr/include/c++/7/cctype" 3
       
# 40 "/usr/include/c++/7/cctype" 3
# 41 "/usr/include/c++/7/bits/locale_facets.h" 2 3
# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/ctype_base.h" 1 3
# 36 "/usr/include/x86_64-linux-gnu/c++/7/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;

    static const mask blank = _ISblank;

  };


}
# 42 "/usr/include/c++/7/bits/locale_facets.h" 2 3






# 1 "/usr/include/c++/7/bits/streambuf_iterator.h" 1 3
# 33 "/usr/include/c++/7/bits/streambuf_iterator.h" 3
       
# 34 "/usr/include/c++/7/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/7/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT*,


        _CharT>



    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }




}
# 49 "/usr/include/c++/7/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/include/c++/7/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 149 "/usr/include/c++/7/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 168 "/usr/include/c++/7/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 185 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 201 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 217 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 231 "/usr/include/c++/7/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 246 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 260 "/usr/include/c++/7/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 275 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 292 "/usr/include/c++/7/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 311 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 330 "/usr/include/c++/7/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 352 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 377 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 396 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 415 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 434 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 452 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 469 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 485 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 502 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 521 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 542 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 563 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 588 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 611 "/usr/include/c++/7/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 680 "/usr/include/c++/7/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 717 "/usr/include/c++/7/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 730 "/usr/include/c++/7/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 743 "/usr/include/c++/7/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 758 "/usr/include/c++/7/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 772 "/usr/include/c++/7/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 786 "/usr/include/c++/7/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 801 "/usr/include/c++/7/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 818 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 834 "/usr/include/c++/7/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 851 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 871 "/usr/include/c++/7/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 898 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 929 "/usr/include/c++/7/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 962 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1011 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1028 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1044 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1061 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1081 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1104 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1130 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault __attribute__((__unused__))) const
      { return __c; }
# 1156 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault __attribute__((__unused__)), char* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1181 "/usr/include/c++/7/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1214 "/usr/include/c++/7/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1225 "/usr/include/c++/7/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1249 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1268 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1286 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1304 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1321 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1338 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1354 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1371 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1391 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1413 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1436 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1462 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0)
      : ctype_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };



}


# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/ctype_inline.h" 1 3
# 37 "/usr/include/x86_64-linux-gnu/c++/7/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
# 1535 "/usr/include/c++/7/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }

namespace __cxx11 {
# 1665 "/usr/include/c++/7/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1703 "/usr/include/c++/7/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1717 "/usr/include/c++/7/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1731 "/usr/include/c++/7/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1744 "/usr/include/c++/7/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1775 "/usr/include/c++/7/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1788 "/usr/include/c++/7/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1801 "/usr/include/c++/7/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1818 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1830 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1843 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1856 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1869 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      numpunct_byname(const string& __s, size_t __refs = 0)
      : numpunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~numpunct_byname() { }
    };

}


# 1947 "/usr/include/c++/7/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1968 "/usr/include/c++/7/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1994 "/usr/include/c++/7/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2031 "/usr/include/c++/7/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2091 "/usr/include/c++/7/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2134 "/usr/include/c++/7/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      __attribute ((__abi_tag__ ("cxx11")))
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 __attribute ((__abi_tag__ ("cxx11")))
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2207 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2270 "/usr/include/c++/7/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2288 "/usr/include/c++/7/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2309 "/usr/include/c++/7/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2327 "/usr/include/c++/7/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2369 "/usr/include/c++/7/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2432 "/usr/include/c++/7/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2457 "/usr/include/c++/7/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2505 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }



  template<typename _CharT>
    inline bool
    isblank(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }



  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

# 1 "/usr/include/c++/7/bits/locale_facets.tcc" 1 3
# 33 "/usr/include/c++/7/bits/locale_facets.tcc" 3
       
# 34 "/usr/include/c++/7/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   const string& __g = __np.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __tn = __np.truename();
   _M_truename_size = __tn.size();
   __truename = new _CharT[_M_truename_size];
   __tn.copy(__truename, _M_truename_size);

   const basic_string<_CharT>& __fn = __np.falsename();
   _M_falsename_size = __fn.size();
   __falsename = new _CharT[_M_falsename_size];
   __fn.copy(__falsename, _M_falsename_size);

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);

   _M_grouping = __grouping;
   _M_truename = __truename;
   _M_falsename = __falsename;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 139 "/usr/include/c++/7/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    __attribute ((__abi_tag__ ("cxx11")))
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      __attribute ((__abi_tag__ ("cxx11")))
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 735 "/usr/include/c++/7/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 971 "/usr/include/c++/7/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);



 const bool __use_prec =
   (__io.flags() & ios_base::floatfield) != ios_base::floatfield;



 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 if (__use_prec)
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __prec, __v);
 else
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     if (__use_prec)
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __prec, __v);
     else
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __v);
   }
# 1044 "/usr/include/c++/7/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1169 "/usr/include/c++/7/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


# 1206 "/usr/include/c++/7/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class __cxx11:: numpunct<char>;
  extern template class __cxx11:: numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class __cxx11:: numpunct<wchar_t>;
  extern template class __cxx11:: numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2652 "/usr/include/c++/7/bits/locale_facets.h" 2 3
# 38 "/usr/include/c++/7/bits/basic_ios.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 66 "/usr/include/c++/7/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:
# 117 "/usr/include/c++/7/bits/basic_ios.h" 3
      explicit operator bool() const
      { return !this->fail(); }





      bool
      operator!() const
      { return this->fail(); }
# 136 "/usr/include/c++/7/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 147 "/usr/include/c++/7/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 200 "/usr/include/c++/7/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 221 "/usr/include/c++/7/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 256 "/usr/include/c++/7/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 294 "/usr/include/c++/7/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 306 "/usr/include/c++/7/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 346 "/usr/include/c++/7/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 360 "/usr/include/c++/7/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 389 "/usr/include/c++/7/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 409 "/usr/include/c++/7/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 429 "/usr/include/c++/7/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 448 "/usr/include/c++/7/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);


      basic_ios(const basic_ios&) = delete;
      basic_ios& operator=(const basic_ios&) = delete;

      void
      move(basic_ios& __rhs)
      {
 ios_base::_M_move(__rhs);
 _M_cache_locale(_M_ios_locale);
 this->tie(__rhs.tie(nullptr));
 _M_fill = __rhs._M_fill;
 _M_fill_init = __rhs._M_fill_init;
 _M_streambuf = nullptr;
      }

      void
      move(basic_ios&& __rhs)
      { this->move(__rhs); }

      void
      swap(basic_ios& __rhs) noexcept
      {
 ios_base::_M_swap(__rhs);
 _M_cache_locale(_M_ios_locale);
 __rhs._M_cache_locale(__rhs._M_ios_locale);
 std::swap(_M_tie, __rhs._M_tie);
 std::swap(_M_fill, __rhs._M_fill);
 std::swap(_M_fill_init, __rhs._M_fill_init);
      }

      void
      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
      { _M_streambuf = __sb; }


      void
      _M_cache_locale(const locale& __loc);
    };


}

# 1 "/usr/include/c++/7/bits/basic_ios.tcc" 1 3
# 33 "/usr/include/c++/7/bits/basic_ios.tcc" 3
       
# 34 "/usr/include/c++/7/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "/usr/include/c++/7/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = std::__addressof(use_facet<__ctype_type>(__loc));
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = std::__addressof(use_facet<__num_put_type>(__loc));
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = std::__addressof(use_facet<__num_get_type>(__loc));
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 517 "/usr/include/c++/7/bits/basic_ios.h" 2 3
# 45 "/usr/include/c++/7/ios" 2 3
# 39 "/usr/include/c++/7/ostream" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/7/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "/usr/include/c++/7/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 269 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 302 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 334 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 347 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      flush();
# 357 "/usr/include/c++/7/ostream" 3
      pos_type
      tellp();
# 368 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 380 "/usr/include/c++/7/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }



      basic_ostream(basic_iostream<_CharT, _Traits>&) { }

      basic_ostream(const basic_ostream&) = delete;

      basic_ostream(basic_ostream&& __rhs)
      : __ios_type()
      { __ios_type::move(__rhs); }



      basic_ostream& operator=(const basic_ostream&) = delete;

      basic_ostream&
      operator=(basic_ostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_ostream& __rhs)
      { __ios_type::swap(__rhs); }


      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 425 "/usr/include/c++/7/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 444 "/usr/include/c++/7/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 454 "/usr/include/c++/7/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 473 "/usr/include/c++/7/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 495 "/usr/include/c++/7/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 537 "/usr/include/c++/7/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 588 "/usr/include/c++/7/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 600 "/usr/include/c++/7/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }


  template<typename _Ch, typename _Up>
    basic_ostream<_Ch, _Up>&
    __is_convertible_to_basic_ostream_test(basic_ostream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_ostream_impl
    {
      using __ostream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_ostream_impl =
    decltype(__is_convertible_to_basic_ostream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_ostream_impl<_Tp>>>
    {
      using __ostream_type =
 __do_is_convertible_to_basic_ostream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream
    : __is_convertible_to_basic_ostream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_ostream_impl<_Tp>::__ostream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Ostream, typename _Tp, typename = void>
    struct __is_insertable : false_type {};

  template<typename _Ostream, typename _Tp>
    struct __is_insertable<_Ostream, _Tp,
      __void_t<decltype(declval<_Ostream&>()
          << declval<const _Tp&>())>>
        : true_type {};

  template<typename _Ostream>
    using __rvalue_ostream_type =
      typename __is_convertible_to_basic_ostream<
 _Ostream>::__ostream_type;
# 674 "/usr/include/c++/7/ostream" 3
  template<typename _Ostream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Ostream>>,
         __is_convertible_to_basic_ostream<_Ostream>,
         __is_insertable<
    __rvalue_ostream_type<_Ostream>,
    const _Tp&>>::value,
         __rvalue_ostream_type<_Ostream>>::type
    operator<<(_Ostream&& __os, const _Tp& __x)
    {
      __rvalue_ostream_type<_Ostream> __ret_os = __os;
      __ret_os << __x;
      return __ret_os;
    }



}

# 1 "/usr/include/c++/7/bits/ostream.tcc" 1 3
# 37 "/usr/include/c++/7/bits/ostream.tcc" 3
       
# 38 "/usr/include/c++/7/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 694 "/usr/include/c++/7/ostream" 2 3
# 40 "/usr/include/c++/7/iostream" 2 3
# 1 "/usr/include/c++/7/istream" 1 3
# 36 "/usr/include/c++/7/istream" 3
       
# 37 "/usr/include/c++/7/istream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/7/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "/usr/include/c++/7/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "/usr/include/c++/7/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "/usr/include/c++/7/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "/usr/include/c++/7/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "/usr/include/c++/7/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "/usr/include/c++/7/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "/usr/include/c++/7/istream" 3
      int_type
      get();
# 315 "/usr/include/c++/7/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "/usr/include/c++/7/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "/usr/include/c++/7/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "/usr/include/c++/7/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "/usr/include/c++/7/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "/usr/include/c++/7/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "/usr/include/c++/7/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "/usr/include/c++/7/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "/usr/include/c++/7/istream" 3
      int_type
      peek();
# 485 "/usr/include/c++/7/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "/usr/include/c++/7/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "/usr/include/c++/7/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "/usr/include/c++/7/istream" 3
      __istream_type&
      unget();
# 555 "/usr/include/c++/7/istream" 3
      int
      sync();
# 570 "/usr/include/c++/7/istream" 3
      pos_type
      tellg();
# 585 "/usr/include/c++/7/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "/usr/include/c++/7/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }


      basic_istream(const basic_istream&) = delete;

      basic_istream(basic_istream&& __rhs)
      : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
 __ios_type::move(__rhs);
 __rhs._M_gcount = 0;
      }



      basic_istream& operator=(const basic_istream&) = delete;

      basic_istream&
      operator=(basic_istream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_istream& __rhs)
      {
 __ios_type::swap(__rhs);
 std::swap(_M_gcount, __rhs._M_gcount);
      }


      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 685 "/usr/include/c++/7/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 721 "/usr/include/c++/7/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 732 "/usr/include/c++/7/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 750 "/usr/include/c++/7/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 792 "/usr/include/c++/7/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 823 "/usr/include/c++/7/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }


      basic_iostream(const basic_iostream&) = delete;

      basic_iostream(basic_iostream&& __rhs)
      : __istream_type(std::move(__rhs)), __ostream_type(*this)
      { }



      basic_iostream& operator=(const basic_iostream&) = delete;

      basic_iostream&
      operator=(basic_iostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_iostream& __rhs)
      { __istream_type::swap(__rhs); }

    };
# 906 "/usr/include/c++/7/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);


  template<typename _Ch, typename _Up>
    basic_istream<_Ch, _Up>&
    __is_convertible_to_basic_istream_test(basic_istream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_istream_impl
    {
      using __istream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_istream_impl =
    decltype(__is_convertible_to_basic_istream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_istream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_istream_impl<_Tp>>>
    {
      using __istream_type =
 __do_is_convertible_to_basic_istream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_istream
    : __is_convertible_to_basic_istream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_istream_impl<_Tp>::__istream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Istream, typename _Tp, typename = void>
    struct __is_extractable : false_type {};

  template<typename _Istream, typename _Tp>
    struct __is_extractable<_Istream, _Tp,
       __void_t<decltype(declval<_Istream&>()
           >> declval<_Tp>())>>
    : true_type {};

  template<typename _Istream>
    using __rvalue_istream_type =
      typename __is_convertible_to_basic_istream<
 _Istream>::__istream_type;
# 972 "/usr/include/c++/7/istream" 3
  template<typename _Istream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Istream>>,
         __is_convertible_to_basic_istream<_Istream>,
         __is_extractable<
    __rvalue_istream_type<_Istream>,
    _Tp&&>>::value,
         __rvalue_istream_type<_Istream>>::type
    operator>>(_Istream&& __is, _Tp&& __x)
    {
      __rvalue_istream_type<_Istream> __ret_is = __is;
      __ret_is >> std::forward<_Tp>(__x);
      return __ret_is;
    }



}

# 1 "/usr/include/c++/7/bits/istream.tcc" 1 3
# 37 "/usr/include/c++/7/bits/istream.tcc" 3
       
# 38 "/usr/include/c++/7/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 try
   {
     if (__in.tie())
       __in.tie()->flush();
     if (!__noskip && bool(__in.flags() & ios_base::skipws))
       {
  const __int_type __eof = traits_type::eof();
  __streambuf_type* __sb = __in.rdbuf();
  __int_type __c = __sb->sgetc();

  const __ctype_type& __ct = __check_facet(__in._M_ctype);
  while (!traits_type::eq_int_type(__c, __eof)
         && __ct.is(ctype_base::space,
      traits_type::to_char_type(__c)))
    __c = __sb->snextc();




  if (traits_type::eq_int_type(__c, __eof))
    __err |= ios_base::eofbit;
       }
   }
 catch(__cxxabiv1::__forced_unwind&)
   {
     __in._M_setstate(ios_base::badbit);
     throw;
   }
 catch(...)
   { __in._M_setstate(ios_base::badbit); }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 521 "/usr/include/c++/7/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 992 "/usr/include/c++/7/istream" 2 3
# 41 "/usr/include/c++/7/iostream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/usr/include/c++/7/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
# 16 "/usr/local/include/ibex/ibex_Exception.h" 2 3


namespace ibex {
# 29 "/usr/local/include/ibex/ibex_Exception.h" 3
void ibex_error(const char*) __attribute__ ((noreturn));
void ibex_warning(const char*);
void not_implemented(const char*) __attribute__ ((noreturn));






class Exception { };

}
# 17 "/usr/local/include/ibex/ibex_Interval.h" 2 3





# 1 "/usr/local/include/ibex/ibex_Setting.h" 1 3
# 23 "/usr/local/include/ibex/ibex_Interval.h" 2 3
# 47 "/usr/local/include/ibex/ibex_Interval.h" 3
# 1 "/usr/local/include/interval/interval.hpp" 1 3
# 33 "/usr/local/include/interval/interval.hpp" 3
# 1 "/usr/include/c++/7/cmath" 1 3
# 39 "/usr/include/c++/7/cmath" 3
       
# 40 "/usr/include/c++/7/cmath" 3





# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4






extern "C" {





# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 138 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 139 "/usr/include/math.h" 2 3 4
# 149 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 190 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-logb.h" 1 3 4
# 191 "/usr/include/math.h" 2 3 4
# 233 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-fast.h" 1 3 4
# 234 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 289 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));


extern int __isnan (double __value) throw () __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) throw ();


extern int __issignaling (double __value) throw ()
     __attribute__ ((__const__));
# 290 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


 extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

 extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();



 extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ()
                                                        ;




extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();





 extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


 extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();




extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();




extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();






 extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();



extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();




extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();






extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();
# 182 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();






extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));




extern double nan (const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();





extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();




extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();







extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();






extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw (); extern double __nextafter (double __x, double __y) throw ();

extern double nexttoward (double __x, long double __y) throw (); extern double __nexttoward (double __x, long double __y) throw ();




extern double nextdown (double __x) throw (); extern double __nextdown (double __x) throw ();

extern double nextup (double __x) throw (); extern double __nextup (double __x) throw ();



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern long int llogb (double __x) throw (); extern long int __llogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
__extension__
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
__extension__
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));


extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();




extern double roundeven (double __x) throw () __attribute__ ((__const__)); extern double __roundeven (double __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) throw ()
                               ;


extern double fmaxmag (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) throw () __attribute__ ((__const__));


extern double fminmag (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) throw () __attribute__ ((__const__));


extern int totalorder (double __x, double __y) throw ()
     __attribute__ ((__const__));


extern int totalordermag (double __x, double __y) throw ()
     __attribute__ ((__const__));


extern int canonicalize (double *__cx, const double *__x) throw ();


extern double getpayload (const double *__x) throw (); extern double __getpayload (const double *__x) throw ();


extern int setpayload (double *__x, double __payload) throw ();


extern int setpayloadsig (double *__x, double __payload) throw ();







extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 291 "/usr/include/math.h" 2 3 4
# 306 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));


extern int __isnanf (float __value) throw () __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) throw ();


extern int __issignalingf (float __value) throw ()
     __attribute__ ((__const__));
# 307 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


 extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

 extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();



 extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ()
                                                        ;




extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();





 extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


 extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();




extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();




extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();






 extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();



extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();




extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();






extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff (float __value) throw () __attribute__ ((__const__));




extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();






extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));




extern float nanf (const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (const char *__tagb) throw () __attribute__ ((__const__));
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanf (float __value) throw () __attribute__ ((__const__));





extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();





extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();




extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();







extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();






extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw (); extern float __nextafterf (float __x, float __y) throw ();

extern float nexttowardf (float __x, long double __y) throw (); extern float __nexttowardf (float __x, long double __y) throw ();




extern float nextdownf (float __x) throw (); extern float __nextdownf (float __x) throw ();

extern float nextupf (float __x) throw (); extern float __nextupf (float __x) throw ();



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern long int llogbf (float __x) throw (); extern long int __llogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
__extension__
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
__extension__
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();




extern float roundevenf (float __x) throw () __attribute__ ((__const__)); extern float __roundevenf (float __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) throw ()
                               ;


extern float fmaxmagf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) throw () __attribute__ ((__const__));


extern int totalorderf (float __x, float __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf (float __x, float __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef (float *__cx, const float *__x) throw ();


extern float getpayloadf (const float *__x) throw (); extern float __getpayloadf (const float *__x) throw ();


extern int setpayloadf (float *__x, float __payload) throw ();


extern int setpayloadsigf (float *__x, float __payload) throw ();







extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 308 "/usr/include/math.h" 2 3 4
# 349 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));


extern int __isnanl (long double __value) throw () __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) throw ();


extern int __issignalingl (long double __value) throw ()
     __attribute__ ((__const__));
# 350 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


 extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

 extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ()
                                                        ;




extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();





 extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


 extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();




extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();




extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();






 extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();



extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();




extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();






extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) throw () __attribute__ ((__const__));




extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();






extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));




extern long double nanl (const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) throw () __attribute__ ((__const__));
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) throw () __attribute__ ((__const__));





extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();





extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();




extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();







extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();






extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw (); extern long double __nextafterl (long double __x, long double __y) throw ();

extern long double nexttowardl (long double __x, long double __y) throw (); extern long double __nexttowardl (long double __x, long double __y) throw ();




extern long double nextdownl (long double __x) throw (); extern long double __nextdownl (long double __x) throw ();

extern long double nextupl (long double __x) throw (); extern long double __nextupl (long double __x) throw ();



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long int llogbl (long double __x) throw (); extern long int __llogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
__extension__
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
__extension__
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();




extern long double roundevenl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundevenl (long double __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) throw ()
                               ;


extern long double fmaxmagl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern int totalorderl (long double __x, long double __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagl (long double __x, long double __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizel (long double *__cx, const long double *__x) throw ();


extern long double getpayloadl (const long double *__x) throw (); extern long double __getpayloadl (const long double *__x) throw ();


extern int setpayloadl (long double *__x, long double __payload) throw ();


extern int setpayloadsigl (long double *__x, long double __payload) throw ();







extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 351 "/usr/include/math.h" 2 3 4
# 389 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 acosf32 (_Float32 __x) throw (); extern _Float32 __acosf32 (_Float32 __x) throw ();

extern _Float32 asinf32 (_Float32 __x) throw (); extern _Float32 __asinf32 (_Float32 __x) throw ();

extern _Float32 atanf32 (_Float32 __x) throw (); extern _Float32 __atanf32 (_Float32 __x) throw ();

extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) throw (); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) throw ();


 extern _Float32 cosf32 (_Float32 __x) throw (); extern _Float32 __cosf32 (_Float32 __x) throw ();

 extern _Float32 sinf32 (_Float32 __x) throw (); extern _Float32 __sinf32 (_Float32 __x) throw ();

extern _Float32 tanf32 (_Float32 __x) throw (); extern _Float32 __tanf32 (_Float32 __x) throw ();




extern _Float32 coshf32 (_Float32 __x) throw (); extern _Float32 __coshf32 (_Float32 __x) throw ();

extern _Float32 sinhf32 (_Float32 __x) throw (); extern _Float32 __sinhf32 (_Float32 __x) throw ();

extern _Float32 tanhf32 (_Float32 __x) throw (); extern _Float32 __tanhf32 (_Float32 __x) throw ();



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw (); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw ()
                                                        ;




extern _Float32 acoshf32 (_Float32 __x) throw (); extern _Float32 __acoshf32 (_Float32 __x) throw ();

extern _Float32 asinhf32 (_Float32 __x) throw (); extern _Float32 __asinhf32 (_Float32 __x) throw ();

extern _Float32 atanhf32 (_Float32 __x) throw (); extern _Float32 __atanhf32 (_Float32 __x) throw ();





 extern _Float32 expf32 (_Float32 __x) throw (); extern _Float32 __expf32 (_Float32 __x) throw ();


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) throw (); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) throw ();


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) throw (); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) throw ();


 extern _Float32 logf32 (_Float32 __x) throw (); extern _Float32 __logf32 (_Float32 __x) throw ();


extern _Float32 log10f32 (_Float32 __x) throw (); extern _Float32 __log10f32 (_Float32 __x) throw ();


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) throw (); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float32 exp10f32 (_Float32 __x) throw (); extern _Float32 __exp10f32 (_Float32 __x) throw ();




extern _Float32 expm1f32 (_Float32 __x) throw (); extern _Float32 __expm1f32 (_Float32 __x) throw ();


extern _Float32 log1pf32 (_Float32 __x) throw (); extern _Float32 __log1pf32 (_Float32 __x) throw ();


extern _Float32 logbf32 (_Float32 __x) throw (); extern _Float32 __logbf32 (_Float32 __x) throw ();




extern _Float32 exp2f32 (_Float32 __x) throw (); extern _Float32 __exp2f32 (_Float32 __x) throw ();


extern _Float32 log2f32 (_Float32 __x) throw (); extern _Float32 __log2f32 (_Float32 __x) throw ();






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) throw ();


extern _Float32 sqrtf32 (_Float32 __x) throw (); extern _Float32 __sqrtf32 (_Float32 __x) throw ();



extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) throw ();




extern _Float32 cbrtf32 (_Float32 __x) throw (); extern _Float32 __cbrtf32 (_Float32 __x) throw ();






extern _Float32 ceilf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float32 __nanf32 (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) throw (); extern _Float32 __j0f32 (_Float32) throw ();
extern _Float32 j1f32 (_Float32) throw (); extern _Float32 __j1f32 (_Float32) throw ();
extern _Float32 jnf32 (int, _Float32) throw (); extern _Float32 __jnf32 (int, _Float32) throw ();
extern _Float32 y0f32 (_Float32) throw (); extern _Float32 __y0f32 (_Float32) throw ();
extern _Float32 y1f32 (_Float32) throw (); extern _Float32 __y1f32 (_Float32) throw ();
extern _Float32 ynf32 (int, _Float32) throw (); extern _Float32 __ynf32 (int, _Float32) throw ();





extern _Float32 erff32 (_Float32) throw (); extern _Float32 __erff32 (_Float32) throw ();
extern _Float32 erfcf32 (_Float32) throw (); extern _Float32 __erfcf32 (_Float32) throw ();
extern _Float32 lgammaf32 (_Float32) throw (); extern _Float32 __lgammaf32 (_Float32) throw ();




extern _Float32 tgammaf32 (_Float32) throw (); extern _Float32 __tgammaf32 (_Float32) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) throw (); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) throw ();






extern _Float32 rintf32 (_Float32 __x) throw (); extern _Float32 __rintf32 (_Float32 __x) throw ();


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) throw ();






extern _Float32 nextdownf32 (_Float32 __x) throw (); extern _Float32 __nextdownf32 (_Float32 __x) throw ();

extern _Float32 nextupf32 (_Float32 __x) throw (); extern _Float32 __nextupf32 (_Float32 __x) throw ();



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) throw ();



extern _Float32 scalbnf32 (_Float32 __x, int __n) throw (); extern _Float32 __scalbnf32 (_Float32 __x, int __n) throw ();



extern int ilogbf32 (_Float32 __x) throw (); extern int __ilogbf32 (_Float32 __x) throw ();




extern long int llogbf32 (_Float32 __x) throw (); extern long int __llogbf32 (_Float32 __x) throw ();




extern _Float32 scalblnf32 (_Float32 __x, long int __n) throw (); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) throw ();



extern _Float32 nearbyintf32 (_Float32 __x) throw (); extern _Float32 __nearbyintf32 (_Float32 __x) throw ();



extern _Float32 roundf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) throw () __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) throw () __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) throw (); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) throw ();






extern long int lrintf32 (_Float32 __x) throw (); extern long int __lrintf32 (_Float32 __x) throw ();
__extension__
extern long long int llrintf32 (_Float32 __x) throw (); extern long long int __llrintf32 (_Float32 __x) throw ();



extern long int lroundf32 (_Float32 __x) throw (); extern long int __lroundf32 (_Float32 __x) throw ();
__extension__
extern long long int llroundf32 (_Float32 __x) throw (); extern long long int __llroundf32 (_Float32 __x) throw ();



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) throw ();


extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) throw (); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) throw ();




extern _Float32 roundevenf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern int totalorderf32 (_Float32 __x, _Float32 __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf32 (_Float32 __x, _Float32 __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) throw ();


extern _Float32 getpayloadf32 (const _Float32 *__x) throw (); extern _Float32 __getpayloadf32 (const _Float32 *__x) throw ();


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) throw ();


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) throw ();
# 390 "/usr/include/math.h" 2 3 4
# 406 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 acosf64 (_Float64 __x) throw (); extern _Float64 __acosf64 (_Float64 __x) throw ();

extern _Float64 asinf64 (_Float64 __x) throw (); extern _Float64 __asinf64 (_Float64 __x) throw ();

extern _Float64 atanf64 (_Float64 __x) throw (); extern _Float64 __atanf64 (_Float64 __x) throw ();

extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) throw (); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) throw ();


 extern _Float64 cosf64 (_Float64 __x) throw (); extern _Float64 __cosf64 (_Float64 __x) throw ();

 extern _Float64 sinf64 (_Float64 __x) throw (); extern _Float64 __sinf64 (_Float64 __x) throw ();

extern _Float64 tanf64 (_Float64 __x) throw (); extern _Float64 __tanf64 (_Float64 __x) throw ();




extern _Float64 coshf64 (_Float64 __x) throw (); extern _Float64 __coshf64 (_Float64 __x) throw ();

extern _Float64 sinhf64 (_Float64 __x) throw (); extern _Float64 __sinhf64 (_Float64 __x) throw ();

extern _Float64 tanhf64 (_Float64 __x) throw (); extern _Float64 __tanhf64 (_Float64 __x) throw ();



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw (); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw ()
                                                        ;




extern _Float64 acoshf64 (_Float64 __x) throw (); extern _Float64 __acoshf64 (_Float64 __x) throw ();

extern _Float64 asinhf64 (_Float64 __x) throw (); extern _Float64 __asinhf64 (_Float64 __x) throw ();

extern _Float64 atanhf64 (_Float64 __x) throw (); extern _Float64 __atanhf64 (_Float64 __x) throw ();





 extern _Float64 expf64 (_Float64 __x) throw (); extern _Float64 __expf64 (_Float64 __x) throw ();


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) throw (); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) throw ();


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) throw (); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) throw ();


 extern _Float64 logf64 (_Float64 __x) throw (); extern _Float64 __logf64 (_Float64 __x) throw ();


extern _Float64 log10f64 (_Float64 __x) throw (); extern _Float64 __log10f64 (_Float64 __x) throw ();


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) throw (); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float64 exp10f64 (_Float64 __x) throw (); extern _Float64 __exp10f64 (_Float64 __x) throw ();




extern _Float64 expm1f64 (_Float64 __x) throw (); extern _Float64 __expm1f64 (_Float64 __x) throw ();


extern _Float64 log1pf64 (_Float64 __x) throw (); extern _Float64 __log1pf64 (_Float64 __x) throw ();


extern _Float64 logbf64 (_Float64 __x) throw (); extern _Float64 __logbf64 (_Float64 __x) throw ();




extern _Float64 exp2f64 (_Float64 __x) throw (); extern _Float64 __exp2f64 (_Float64 __x) throw ();


extern _Float64 log2f64 (_Float64 __x) throw (); extern _Float64 __log2f64 (_Float64 __x) throw ();






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float64 sqrtf64 (_Float64 __x) throw (); extern _Float64 __sqrtf64 (_Float64 __x) throw ();



extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) throw ();




extern _Float64 cbrtf64 (_Float64 __x) throw (); extern _Float64 __cbrtf64 (_Float64 __x) throw ();






extern _Float64 ceilf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float64 __nanf64 (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) throw (); extern _Float64 __j0f64 (_Float64) throw ();
extern _Float64 j1f64 (_Float64) throw (); extern _Float64 __j1f64 (_Float64) throw ();
extern _Float64 jnf64 (int, _Float64) throw (); extern _Float64 __jnf64 (int, _Float64) throw ();
extern _Float64 y0f64 (_Float64) throw (); extern _Float64 __y0f64 (_Float64) throw ();
extern _Float64 y1f64 (_Float64) throw (); extern _Float64 __y1f64 (_Float64) throw ();
extern _Float64 ynf64 (int, _Float64) throw (); extern _Float64 __ynf64 (int, _Float64) throw ();





extern _Float64 erff64 (_Float64) throw (); extern _Float64 __erff64 (_Float64) throw ();
extern _Float64 erfcf64 (_Float64) throw (); extern _Float64 __erfcf64 (_Float64) throw ();
extern _Float64 lgammaf64 (_Float64) throw (); extern _Float64 __lgammaf64 (_Float64) throw ();




extern _Float64 tgammaf64 (_Float64) throw (); extern _Float64 __tgammaf64 (_Float64) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) throw (); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) throw ();






extern _Float64 rintf64 (_Float64 __x) throw (); extern _Float64 __rintf64 (_Float64 __x) throw ();


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) throw ();






extern _Float64 nextdownf64 (_Float64 __x) throw (); extern _Float64 __nextdownf64 (_Float64 __x) throw ();

extern _Float64 nextupf64 (_Float64 __x) throw (); extern _Float64 __nextupf64 (_Float64 __x) throw ();



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) throw ();



extern _Float64 scalbnf64 (_Float64 __x, int __n) throw (); extern _Float64 __scalbnf64 (_Float64 __x, int __n) throw ();



extern int ilogbf64 (_Float64 __x) throw (); extern int __ilogbf64 (_Float64 __x) throw ();




extern long int llogbf64 (_Float64 __x) throw (); extern long int __llogbf64 (_Float64 __x) throw ();




extern _Float64 scalblnf64 (_Float64 __x, long int __n) throw (); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) throw ();



extern _Float64 nearbyintf64 (_Float64 __x) throw (); extern _Float64 __nearbyintf64 (_Float64 __x) throw ();



extern _Float64 roundf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) throw () __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) throw () __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) throw (); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) throw ();






extern long int lrintf64 (_Float64 __x) throw (); extern long int __lrintf64 (_Float64 __x) throw ();
__extension__
extern long long int llrintf64 (_Float64 __x) throw (); extern long long int __llrintf64 (_Float64 __x) throw ();



extern long int lroundf64 (_Float64 __x) throw (); extern long int __lroundf64 (_Float64 __x) throw ();
__extension__
extern long long int llroundf64 (_Float64 __x) throw (); extern long long int __llroundf64 (_Float64 __x) throw ();



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) throw (); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) throw ();




extern _Float64 roundevenf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern int totalorderf64 (_Float64 __x, _Float64 __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf64 (_Float64 __x, _Float64 __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) throw ();


extern _Float64 getpayloadf64 (const _Float64 *__x) throw (); extern _Float64 __getpayloadf64 (const _Float64 *__x) throw ();


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) throw ();


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) throw ();
# 407 "/usr/include/math.h" 2 3 4
# 420 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));



extern int __isinff128 (_Float128 __value) throw () __attribute__ ((__const__));


extern int __finitef128 (_Float128 __value) throw () __attribute__ ((__const__));


extern int __isnanf128 (_Float128 __value) throw () __attribute__ ((__const__));


extern int __iseqsigf128 (_Float128 __x, _Float128 __y) throw ();


extern int __issignalingf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));
# 421 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 acosf128 (_Float128 __x) throw (); extern _Float128 __acosf128 (_Float128 __x) throw ();

extern _Float128 asinf128 (_Float128 __x) throw (); extern _Float128 __asinf128 (_Float128 __x) throw ();

extern _Float128 atanf128 (_Float128 __x) throw (); extern _Float128 __atanf128 (_Float128 __x) throw ();

extern _Float128 atan2f128 (_Float128 __y, _Float128 __x) throw (); extern _Float128 __atan2f128 (_Float128 __y, _Float128 __x) throw ();


 extern _Float128 cosf128 (_Float128 __x) throw (); extern _Float128 __cosf128 (_Float128 __x) throw ();

 extern _Float128 sinf128 (_Float128 __x) throw (); extern _Float128 __sinf128 (_Float128 __x) throw ();

extern _Float128 tanf128 (_Float128 __x) throw (); extern _Float128 __tanf128 (_Float128 __x) throw ();




extern _Float128 coshf128 (_Float128 __x) throw (); extern _Float128 __coshf128 (_Float128 __x) throw ();

extern _Float128 sinhf128 (_Float128 __x) throw (); extern _Float128 __sinhf128 (_Float128 __x) throw ();

extern _Float128 tanhf128 (_Float128 __x) throw (); extern _Float128 __tanhf128 (_Float128 __x) throw ();



 extern void sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) throw (); extern void __sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) throw ()
                                                        ;




extern _Float128 acoshf128 (_Float128 __x) throw (); extern _Float128 __acoshf128 (_Float128 __x) throw ();

extern _Float128 asinhf128 (_Float128 __x) throw (); extern _Float128 __asinhf128 (_Float128 __x) throw ();

extern _Float128 atanhf128 (_Float128 __x) throw (); extern _Float128 __atanhf128 (_Float128 __x) throw ();





 extern _Float128 expf128 (_Float128 __x) throw (); extern _Float128 __expf128 (_Float128 __x) throw ();


extern _Float128 frexpf128 (_Float128 __x, int *__exponent) throw (); extern _Float128 __frexpf128 (_Float128 __x, int *__exponent) throw ();


extern _Float128 ldexpf128 (_Float128 __x, int __exponent) throw (); extern _Float128 __ldexpf128 (_Float128 __x, int __exponent) throw ();


 extern _Float128 logf128 (_Float128 __x) throw (); extern _Float128 __logf128 (_Float128 __x) throw ();


extern _Float128 log10f128 (_Float128 __x) throw (); extern _Float128 __log10f128 (_Float128 __x) throw ();


extern _Float128 modff128 (_Float128 __x, _Float128 *__iptr) throw (); extern _Float128 __modff128 (_Float128 __x, _Float128 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float128 exp10f128 (_Float128 __x) throw (); extern _Float128 __exp10f128 (_Float128 __x) throw ();




extern _Float128 expm1f128 (_Float128 __x) throw (); extern _Float128 __expm1f128 (_Float128 __x) throw ();


extern _Float128 log1pf128 (_Float128 __x) throw (); extern _Float128 __log1pf128 (_Float128 __x) throw ();


extern _Float128 logbf128 (_Float128 __x) throw (); extern _Float128 __logbf128 (_Float128 __x) throw ();




extern _Float128 exp2f128 (_Float128 __x) throw (); extern _Float128 __exp2f128 (_Float128 __x) throw ();


extern _Float128 log2f128 (_Float128 __x) throw (); extern _Float128 __log2f128 (_Float128 __x) throw ();






 extern _Float128 powf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __powf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float128 sqrtf128 (_Float128 __x) throw (); extern _Float128 __sqrtf128 (_Float128 __x) throw ();



extern _Float128 hypotf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __hypotf128 (_Float128 __x, _Float128 __y) throw ();




extern _Float128 cbrtf128 (_Float128 __x) throw (); extern _Float128 __cbrtf128 (_Float128 __x) throw ();






extern _Float128 ceilf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __ceilf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 fabsf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __fabsf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 floorf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __floorf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 fmodf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __fmodf128 (_Float128 __x, _Float128 __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 copysignf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __copysignf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));




extern _Float128 nanf128 (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float128 __nanf128 (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 j0f128 (_Float128) throw (); extern _Float128 __j0f128 (_Float128) throw ();
extern _Float128 j1f128 (_Float128) throw (); extern _Float128 __j1f128 (_Float128) throw ();
extern _Float128 jnf128 (int, _Float128) throw (); extern _Float128 __jnf128 (int, _Float128) throw ();
extern _Float128 y0f128 (_Float128) throw (); extern _Float128 __y0f128 (_Float128) throw ();
extern _Float128 y1f128 (_Float128) throw (); extern _Float128 __y1f128 (_Float128) throw ();
extern _Float128 ynf128 (int, _Float128) throw (); extern _Float128 __ynf128 (int, _Float128) throw ();





extern _Float128 erff128 (_Float128) throw (); extern _Float128 __erff128 (_Float128) throw ();
extern _Float128 erfcf128 (_Float128) throw (); extern _Float128 __erfcf128 (_Float128) throw ();
extern _Float128 lgammaf128 (_Float128) throw (); extern _Float128 __lgammaf128 (_Float128) throw ();




extern _Float128 tgammaf128 (_Float128) throw (); extern _Float128 __tgammaf128 (_Float128) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 lgammaf128_r (_Float128, int *__signgamp) throw (); extern _Float128 __lgammaf128_r (_Float128, int *__signgamp) throw ();






extern _Float128 rintf128 (_Float128 __x) throw (); extern _Float128 __rintf128 (_Float128 __x) throw ();


extern _Float128 nextafterf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __nextafterf128 (_Float128 __x, _Float128 __y) throw ();






extern _Float128 nextdownf128 (_Float128 __x) throw (); extern _Float128 __nextdownf128 (_Float128 __x) throw ();

extern _Float128 nextupf128 (_Float128 __x) throw (); extern _Float128 __nextupf128 (_Float128 __x) throw ();



extern _Float128 remainderf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __remainderf128 (_Float128 __x, _Float128 __y) throw ();



extern _Float128 scalbnf128 (_Float128 __x, int __n) throw (); extern _Float128 __scalbnf128 (_Float128 __x, int __n) throw ();



extern int ilogbf128 (_Float128 __x) throw (); extern int __ilogbf128 (_Float128 __x) throw ();




extern long int llogbf128 (_Float128 __x) throw (); extern long int __llogbf128 (_Float128 __x) throw ();




extern _Float128 scalblnf128 (_Float128 __x, long int __n) throw (); extern _Float128 __scalblnf128 (_Float128 __x, long int __n) throw ();



extern _Float128 nearbyintf128 (_Float128 __x) throw (); extern _Float128 __nearbyintf128 (_Float128 __x) throw ();



extern _Float128 roundf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __roundf128 (_Float128 __x) throw () __attribute__ ((__const__));



extern _Float128 truncf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __truncf128 (_Float128 __x) throw () __attribute__ ((__const__));




extern _Float128 remquof128 (_Float128 __x, _Float128 __y, int *__quo) throw (); extern _Float128 __remquof128 (_Float128 __x, _Float128 __y, int *__quo) throw ();






extern long int lrintf128 (_Float128 __x) throw (); extern long int __lrintf128 (_Float128 __x) throw ();
__extension__
extern long long int llrintf128 (_Float128 __x) throw (); extern long long int __llrintf128 (_Float128 __x) throw ();



extern long int lroundf128 (_Float128 __x) throw (); extern long int __lroundf128 (_Float128 __x) throw ();
__extension__
extern long long int llroundf128 (_Float128 __x) throw (); extern long long int __llroundf128 (_Float128 __x) throw ();



extern _Float128 fdimf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __fdimf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float128 fmaxf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fmaxf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fminf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fminf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) throw (); extern _Float128 __fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) throw ();




extern _Float128 roundevenf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __roundevenf128 (_Float128 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float128 fmaxmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fmaxmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fminmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fminmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern int totalorderf128 (_Float128 __x, _Float128 __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf128 (_Float128 __x, _Float128 __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef128 (_Float128 *__cx, const _Float128 *__x) throw ();


extern _Float128 getpayloadf128 (const _Float128 *__x) throw (); extern _Float128 __getpayloadf128 (const _Float128 *__x) throw ();


extern int setpayloadf128 (_Float128 *__x, _Float128 __payload) throw ();


extern int setpayloadsigf128 (_Float128 *__x, _Float128 __payload) throw ();
# 424 "/usr/include/math.h" 2 3 4
# 440 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x acosf32x (_Float32x __x) throw (); extern _Float32x __acosf32x (_Float32x __x) throw ();

extern _Float32x asinf32x (_Float32x __x) throw (); extern _Float32x __asinf32x (_Float32x __x) throw ();

extern _Float32x atanf32x (_Float32x __x) throw (); extern _Float32x __atanf32x (_Float32x __x) throw ();

extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) throw (); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) throw ();


 extern _Float32x cosf32x (_Float32x __x) throw (); extern _Float32x __cosf32x (_Float32x __x) throw ();

 extern _Float32x sinf32x (_Float32x __x) throw (); extern _Float32x __sinf32x (_Float32x __x) throw ();

extern _Float32x tanf32x (_Float32x __x) throw (); extern _Float32x __tanf32x (_Float32x __x) throw ();




extern _Float32x coshf32x (_Float32x __x) throw (); extern _Float32x __coshf32x (_Float32x __x) throw ();

extern _Float32x sinhf32x (_Float32x __x) throw (); extern _Float32x __sinhf32x (_Float32x __x) throw ();

extern _Float32x tanhf32x (_Float32x __x) throw (); extern _Float32x __tanhf32x (_Float32x __x) throw ();



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw (); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw ()
                                                        ;




extern _Float32x acoshf32x (_Float32x __x) throw (); extern _Float32x __acoshf32x (_Float32x __x) throw ();

extern _Float32x asinhf32x (_Float32x __x) throw (); extern _Float32x __asinhf32x (_Float32x __x) throw ();

extern _Float32x atanhf32x (_Float32x __x) throw (); extern _Float32x __atanhf32x (_Float32x __x) throw ();





 extern _Float32x expf32x (_Float32x __x) throw (); extern _Float32x __expf32x (_Float32x __x) throw ();


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) throw (); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) throw ();


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) throw (); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) throw ();


 extern _Float32x logf32x (_Float32x __x) throw (); extern _Float32x __logf32x (_Float32x __x) throw ();


extern _Float32x log10f32x (_Float32x __x) throw (); extern _Float32x __log10f32x (_Float32x __x) throw ();


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) throw (); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float32x exp10f32x (_Float32x __x) throw (); extern _Float32x __exp10f32x (_Float32x __x) throw ();




extern _Float32x expm1f32x (_Float32x __x) throw (); extern _Float32x __expm1f32x (_Float32x __x) throw ();


extern _Float32x log1pf32x (_Float32x __x) throw (); extern _Float32x __log1pf32x (_Float32x __x) throw ();


extern _Float32x logbf32x (_Float32x __x) throw (); extern _Float32x __logbf32x (_Float32x __x) throw ();




extern _Float32x exp2f32x (_Float32x __x) throw (); extern _Float32x __exp2f32x (_Float32x __x) throw ();


extern _Float32x log2f32x (_Float32x __x) throw (); extern _Float32x __log2f32x (_Float32x __x) throw ();






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32x sqrtf32x (_Float32x __x) throw (); extern _Float32x __sqrtf32x (_Float32x __x) throw ();



extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) throw ();




extern _Float32x cbrtf32x (_Float32x __x) throw (); extern _Float32x __cbrtf32x (_Float32x __x) throw ();






extern _Float32x ceilf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float32x __nanf32x (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) throw (); extern _Float32x __j0f32x (_Float32x) throw ();
extern _Float32x j1f32x (_Float32x) throw (); extern _Float32x __j1f32x (_Float32x) throw ();
extern _Float32x jnf32x (int, _Float32x) throw (); extern _Float32x __jnf32x (int, _Float32x) throw ();
extern _Float32x y0f32x (_Float32x) throw (); extern _Float32x __y0f32x (_Float32x) throw ();
extern _Float32x y1f32x (_Float32x) throw (); extern _Float32x __y1f32x (_Float32x) throw ();
extern _Float32x ynf32x (int, _Float32x) throw (); extern _Float32x __ynf32x (int, _Float32x) throw ();





extern _Float32x erff32x (_Float32x) throw (); extern _Float32x __erff32x (_Float32x) throw ();
extern _Float32x erfcf32x (_Float32x) throw (); extern _Float32x __erfcf32x (_Float32x) throw ();
extern _Float32x lgammaf32x (_Float32x) throw (); extern _Float32x __lgammaf32x (_Float32x) throw ();




extern _Float32x tgammaf32x (_Float32x) throw (); extern _Float32x __tgammaf32x (_Float32x) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) throw (); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) throw ();






extern _Float32x rintf32x (_Float32x __x) throw (); extern _Float32x __rintf32x (_Float32x __x) throw ();


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) throw ();






extern _Float32x nextdownf32x (_Float32x __x) throw (); extern _Float32x __nextdownf32x (_Float32x __x) throw ();

extern _Float32x nextupf32x (_Float32x __x) throw (); extern _Float32x __nextupf32x (_Float32x __x) throw ();



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) throw ();



extern _Float32x scalbnf32x (_Float32x __x, int __n) throw (); extern _Float32x __scalbnf32x (_Float32x __x, int __n) throw ();



extern int ilogbf32x (_Float32x __x) throw (); extern int __ilogbf32x (_Float32x __x) throw ();




extern long int llogbf32x (_Float32x __x) throw (); extern long int __llogbf32x (_Float32x __x) throw ();




extern _Float32x scalblnf32x (_Float32x __x, long int __n) throw (); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) throw ();



extern _Float32x nearbyintf32x (_Float32x __x) throw (); extern _Float32x __nearbyintf32x (_Float32x __x) throw ();



extern _Float32x roundf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) throw () __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) throw () __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) throw (); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) throw ();






extern long int lrintf32x (_Float32x __x) throw (); extern long int __lrintf32x (_Float32x __x) throw ();
__extension__
extern long long int llrintf32x (_Float32x __x) throw (); extern long long int __llrintf32x (_Float32x __x) throw ();



extern long int lroundf32x (_Float32x __x) throw (); extern long int __lroundf32x (_Float32x __x) throw ();
__extension__
extern long long int llroundf32x (_Float32x __x) throw (); extern long long int __llroundf32x (_Float32x __x) throw ();



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) throw (); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) throw ();




extern _Float32x roundevenf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern int totalorderf32x (_Float32x __x, _Float32x __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf32x (_Float32x __x, _Float32x __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) throw ();


extern _Float32x getpayloadf32x (const _Float32x *__x) throw (); extern _Float32x __getpayloadf32x (const _Float32x *__x) throw ();


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) throw ();


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) throw ();
# 441 "/usr/include/math.h" 2 3 4
# 457 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x acosf64x (_Float64x __x) throw (); extern _Float64x __acosf64x (_Float64x __x) throw ();

extern _Float64x asinf64x (_Float64x __x) throw (); extern _Float64x __asinf64x (_Float64x __x) throw ();

extern _Float64x atanf64x (_Float64x __x) throw (); extern _Float64x __atanf64x (_Float64x __x) throw ();

extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) throw (); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) throw ();


 extern _Float64x cosf64x (_Float64x __x) throw (); extern _Float64x __cosf64x (_Float64x __x) throw ();

 extern _Float64x sinf64x (_Float64x __x) throw (); extern _Float64x __sinf64x (_Float64x __x) throw ();

extern _Float64x tanf64x (_Float64x __x) throw (); extern _Float64x __tanf64x (_Float64x __x) throw ();




extern _Float64x coshf64x (_Float64x __x) throw (); extern _Float64x __coshf64x (_Float64x __x) throw ();

extern _Float64x sinhf64x (_Float64x __x) throw (); extern _Float64x __sinhf64x (_Float64x __x) throw ();

extern _Float64x tanhf64x (_Float64x __x) throw (); extern _Float64x __tanhf64x (_Float64x __x) throw ();



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw (); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw ()
                                                        ;




extern _Float64x acoshf64x (_Float64x __x) throw (); extern _Float64x __acoshf64x (_Float64x __x) throw ();

extern _Float64x asinhf64x (_Float64x __x) throw (); extern _Float64x __asinhf64x (_Float64x __x) throw ();

extern _Float64x atanhf64x (_Float64x __x) throw (); extern _Float64x __atanhf64x (_Float64x __x) throw ();





 extern _Float64x expf64x (_Float64x __x) throw (); extern _Float64x __expf64x (_Float64x __x) throw ();


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) throw (); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) throw ();


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) throw (); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) throw ();


 extern _Float64x logf64x (_Float64x __x) throw (); extern _Float64x __logf64x (_Float64x __x) throw ();


extern _Float64x log10f64x (_Float64x __x) throw (); extern _Float64x __log10f64x (_Float64x __x) throw ();


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) throw (); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float64x exp10f64x (_Float64x __x) throw (); extern _Float64x __exp10f64x (_Float64x __x) throw ();




extern _Float64x expm1f64x (_Float64x __x) throw (); extern _Float64x __expm1f64x (_Float64x __x) throw ();


extern _Float64x log1pf64x (_Float64x __x) throw (); extern _Float64x __log1pf64x (_Float64x __x) throw ();


extern _Float64x logbf64x (_Float64x __x) throw (); extern _Float64x __logbf64x (_Float64x __x) throw ();




extern _Float64x exp2f64x (_Float64x __x) throw (); extern _Float64x __exp2f64x (_Float64x __x) throw ();


extern _Float64x log2f64x (_Float64x __x) throw (); extern _Float64x __log2f64x (_Float64x __x) throw ();






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64x sqrtf64x (_Float64x __x) throw (); extern _Float64x __sqrtf64x (_Float64x __x) throw ();



extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) throw ();




extern _Float64x cbrtf64x (_Float64x __x) throw (); extern _Float64x __cbrtf64x (_Float64x __x) throw ();






extern _Float64x ceilf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float64x __nanf64x (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) throw (); extern _Float64x __j0f64x (_Float64x) throw ();
extern _Float64x j1f64x (_Float64x) throw (); extern _Float64x __j1f64x (_Float64x) throw ();
extern _Float64x jnf64x (int, _Float64x) throw (); extern _Float64x __jnf64x (int, _Float64x) throw ();
extern _Float64x y0f64x (_Float64x) throw (); extern _Float64x __y0f64x (_Float64x) throw ();
extern _Float64x y1f64x (_Float64x) throw (); extern _Float64x __y1f64x (_Float64x) throw ();
extern _Float64x ynf64x (int, _Float64x) throw (); extern _Float64x __ynf64x (int, _Float64x) throw ();





extern _Float64x erff64x (_Float64x) throw (); extern _Float64x __erff64x (_Float64x) throw ();
extern _Float64x erfcf64x (_Float64x) throw (); extern _Float64x __erfcf64x (_Float64x) throw ();
extern _Float64x lgammaf64x (_Float64x) throw (); extern _Float64x __lgammaf64x (_Float64x) throw ();




extern _Float64x tgammaf64x (_Float64x) throw (); extern _Float64x __tgammaf64x (_Float64x) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) throw (); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) throw ();






extern _Float64x rintf64x (_Float64x __x) throw (); extern _Float64x __rintf64x (_Float64x __x) throw ();


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) throw ();






extern _Float64x nextdownf64x (_Float64x __x) throw (); extern _Float64x __nextdownf64x (_Float64x __x) throw ();

extern _Float64x nextupf64x (_Float64x __x) throw (); extern _Float64x __nextupf64x (_Float64x __x) throw ();



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) throw ();



extern _Float64x scalbnf64x (_Float64x __x, int __n) throw (); extern _Float64x __scalbnf64x (_Float64x __x, int __n) throw ();



extern int ilogbf64x (_Float64x __x) throw (); extern int __ilogbf64x (_Float64x __x) throw ();




extern long int llogbf64x (_Float64x __x) throw (); extern long int __llogbf64x (_Float64x __x) throw ();




extern _Float64x scalblnf64x (_Float64x __x, long int __n) throw (); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) throw ();



extern _Float64x nearbyintf64x (_Float64x __x) throw (); extern _Float64x __nearbyintf64x (_Float64x __x) throw ();



extern _Float64x roundf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) throw () __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) throw () __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) throw (); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) throw ();






extern long int lrintf64x (_Float64x __x) throw (); extern long int __lrintf64x (_Float64x __x) throw ();
__extension__
extern long long int llrintf64x (_Float64x __x) throw (); extern long long int __llrintf64x (_Float64x __x) throw ();



extern long int lroundf64x (_Float64x __x) throw (); extern long int __lroundf64x (_Float64x __x) throw ();
__extension__
extern long long int llroundf64x (_Float64x __x) throw (); extern long long int __llroundf64x (_Float64x __x) throw ();



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) throw (); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) throw ();




extern _Float64x roundevenf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern int totalorderf64x (_Float64x __x, _Float64x __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf64x (_Float64x __x, _Float64x __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) throw ();


extern _Float64x getpayloadf64x (const _Float64x *__x) throw (); extern _Float64x __getpayloadf64x (const _Float64x *__x) throw ();


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) throw ();


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) throw ();
# 458 "/usr/include/math.h" 2 3 4
# 489 "/usr/include/math.h" 3 4
extern int signgam;
# 569 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 684 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     throw () __attribute__ ((__const__));
# 46 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical (float __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (double __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (long double __val) { return __iscanonicall (__val); }

inline int iscanonical (_Float128 __val) { return ((void) (__typeof (__val)) (__val), 1); }

}
# 685 "/usr/include/math.h" 2 3 4
# 696 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}

inline int issignaling (_Float128 __val) { return __issignalingf128 (__val); }

}
# 725 "/usr/include/math.h" 3 4
extern "C++" {
# 754 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 1205 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (double __x, double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};


template<> struct __iseqsig_type<_Float128>
{
  static int __call (_Float128 __x, _Float128 __y) throw ()
  {
    return __iseqsigf128 (__x, __y);
  }
};


template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 46 "/usr/include/c++/7/cmath" 2 3
# 77 "/usr/include/c++/7/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 412 "/usr/include/c++/7/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
# 536 "/usr/include/c++/7/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{





  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 957 "/usr/include/c++/7/cmath" 3

}
# 1075 "/usr/include/c++/7/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }



}
# 1917 "/usr/include/c++/7/cmath" 3
}
# 34 "/usr/local/include/interval/interval.hpp" 2 3
# 1 "/usr/include/c++/7/functional" 1 3
# 46 "/usr/include/c++/7/functional" 3
       
# 47 "/usr/include/c++/7/functional" 3







# 1 "/usr/include/c++/7/tuple" 1 3
# 32 "/usr/include/c++/7/tuple" 3
       
# 33 "/usr/include/c++/7/tuple" 3





# 1 "/usr/include/c++/7/utility" 1 3
# 58 "/usr/include/c++/7/utility" 3
       
# 59 "/usr/include/c++/7/utility" 3
# 69 "/usr/include/c++/7/utility" 3
# 1 "/usr/include/c++/7/bits/stl_relops.h" 1 3
# 67 "/usr/include/c++/7/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace rel_ops
  {
 
# 85 "/usr/include/c++/7/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/usr/include/c++/7/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/usr/include/c++/7/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/usr/include/c++/7/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

 
  }

}
# 70 "/usr/include/c++/7/utility" 2 3
# 78 "/usr/include/c++/7/utility" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp, typename = void>
    struct __tuple_size_cv_impl { };

  template<typename _Tp>
    struct __tuple_size_cv_impl<_Tp, __void_t<decltype(tuple_size<_Tp>::value)>>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };



  template<typename _Tp>
    struct tuple_size<const _Tp> : __tuple_size_cv_impl<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile _Tp> : __tuple_size_cv_impl<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile _Tp> : __tuple_size_cv_impl<_Tp> { };
# 128 "/usr/include/c++/7/utility" 3
  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };




  template<std::size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;





  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }




  template<size_t... _Indexes> struct _Index_tuple { };


  template<typename _Itup1, typename _Itup2> struct _Itup_cat;

  template<size_t... _Ind1, size_t... _Ind2>
    struct _Itup_cat<_Index_tuple<_Ind1...>, _Index_tuple<_Ind2...>>
    {
      using __type = _Index_tuple<_Ind1..., (_Ind2 + sizeof...(_Ind1))...>;
    };


  template<size_t _Num>
    struct _Build_index_tuple
    : _Itup_cat<typename _Build_index_tuple<_Num / 2>::__type,
  typename _Build_index_tuple<_Num - _Num / 2>::__type>
    { };

  template<>
    struct _Build_index_tuple<1>
    {
      typedef _Index_tuple<0> __type;
    };

  template<>
    struct _Build_index_tuple<0>
    {
      typedef _Index_tuple<> __type;
    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() noexcept { return sizeof...(_Idx); }
    };

  template<typename _Tp, _Tp _Num,
    typename _ISeq = typename _Build_index_tuple<_Num>::__type>
    struct _Make_integer_sequence;

  template<typename _Tp, _Tp _Num, size_t... _Idx>
    struct _Make_integer_sequence<_Tp, _Num, _Index_tuple<_Idx...>>
    {
      static_assert( _Num >= 0,
       "Cannot make integer sequence of negative length" );

      typedef integer_sequence<_Tp, static_cast<_Tp>(_Idx)...> __type;
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence
      = typename _Make_integer_sequence<_Tp, _Num>::__type;


  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
# 402 "/usr/include/c++/7/utility" 3

}
# 39 "/usr/include/c++/7/tuple" 2 3
# 1 "/usr/include/c++/7/array" 1 3
# 32 "/usr/include/c++/7/array" 3
       
# 33 "/usr/include/c++/7/array" 3
# 43 "/usr/include/c++/7/array" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];
      typedef __is_swappable<_Tp> _Is_swappable;
      typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }

      static constexpr _Tp*
      _S_ptr(const _Type& __t) noexcept
      { return const_cast<_Tp*>(__t); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };
     typedef true_type _Is_swappable;
     typedef true_type _Is_nothrow_swappable;

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }

     static constexpr _Tp*
     _S_ptr(const _Type&) noexcept
     { return nullptr; }
   };
# 93 "/usr/include/c++/7/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(_AT_Type::_Is_nothrow_swappable::value)
      { std::swap_ranges(begin(), end(), __other.begin()); }


      iterator
      begin() noexcept
      { return iterator(data()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      constexpr bool
      empty() const noexcept { return size() == 0; }


      reference
      operator[](size_type __n) noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                 ,
     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                    ,
        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

      reference
      front() noexcept
      { return *begin(); }

      constexpr const_reference
      front() const noexcept
      { return _AT_Type::_S_ref(_M_elems, 0); }

      reference
      back() noexcept
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const noexcept
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

      pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }

      const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
    };
# 250 "/usr/include/c++/7/array" 3
  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }


  template<typename _Tp, std::size_t _Nm>
    inline


    typename enable_if<
      std::__array_traits<_Tp, _Nm>::_Is_swappable::value
    >::type



    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }


  template<typename _Tp, std::size_t _Nm>
    typename enable_if<
      !std::__array_traits<_Tp, _Nm>::_Is_swappable::value>::type
    swap(array<_Tp, _Nm>&, array<_Tp, _Nm>&) = delete;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{





  template<typename _Tp>
    class tuple_size;


  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    class tuple_element;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<std::array<_Tp, _Nm>> : true_type
    { };


}
# 40 "/usr/include/c++/7/tuple" 2 3
# 1 "/usr/include/c++/7/bits/uses_allocator.h" 1 3
# 35 "/usr/include/c++/7/bits/uses_allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __erased_type { };

  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_same<_Tp, __erased_type>, is_convertible<_Alloc, _Tp>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

  constexpr allocator_arg_t allocator_arg =
    allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    {
      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>,
   is_constructible<_Tp, _Args..., _Alloc>>::value, "construction with"
   " an allocator must be possible if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void
    __use_alloc(const _Alloc&&) = delete;







  template<template<typename...> class _Predicate,
    typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_predicate
    : conditional<uses_allocator<_Tp, _Alloc>::value,
      __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>,
     _Predicate<_Tp, _Args..., _Alloc>>,
      _Predicate<_Tp, _Args...>>::type { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...>
    { };


  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr bool __is_uses_allocator_constructible_v =
      __is_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_nothrow_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_nothrow_constructible,
        _Tp, _Alloc, _Args...>
    { };



  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr bool
    __is_nothrow_uses_allocator_constructible_v =
      __is_nothrow_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc0 __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)...); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    {
      ::new ((void*)__ptr) _Tp(allocator_arg, *__a._M_a,
          std::forward<_Args>(__args)...);
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,
        _Args&&... __args)
    {
      __uses_allocator_construct_impl(__use_alloc<_Tp, _Alloc, _Args...>(__a),
          __ptr, std::forward<_Args>(__args)...);
    }


}
# 41 "/usr/include/c++/7/tuple" 2 3
# 1 "/usr/include/c++/7/bits/invoke.h" 1 3
# 33 "/usr/include/c++/7/bits/invoke.h" 3
       
# 34 "/usr/include/c++/7/bits/invoke.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 52 "/usr/include/c++/7/bits/invoke.h" 3
  template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
    constexpr _Up&&
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    constexpr typename __invoke_result<_Callable, _Args...>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }


}
# 42 "/usr/include/c++/7/tuple" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename... _Elements>
    class tuple;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;

  template<std::size_t _Idx, typename _Head,
    bool = __empty_not_final<_Head>::value>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 176 "/usr/include/c++/7/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 _M_tail(*this) = _M_tail(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_assignable<_Head>,
               is_nothrow_move_assignable<_Inherited>>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 _M_tail(*this) = std::move(_M_tail(__in));
 return *this;
      }

      template<typename... _UElements>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this) = _Tuple_impl<_Idx, _UElements...>::_M_tail(__in);
   return *this;
 }

      template<typename _UHead, typename... _UTails>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this) = std::move
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value
               && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<std::size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr _Tuple_impl()
      : _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head)
      : _Base(__head) { }

      template<typename _UHead>
        explicit
        constexpr _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename _UHead>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _UHead>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_assignable<_Head>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 return *this;
      }

      template<typename _UHead>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UHead>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
   return *this;
 }

      template<typename _UHead>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead>&& __in)
        {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
    };



  template<bool, typename... _Elements>
  struct _TC
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, const _UElements&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return __and_<is_convertible<const _UElements&, _Elements>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, _UElements&&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return __and_<is_convertible<_UElements&&, _Elements>...>::value;
    }

    template<typename _SrcTuple>
    static constexpr bool _NonNestedTuple()
    {
      return __and_<__not_<is_same<tuple<_Elements...>,
                                   typename remove_cv<
                                     typename remove_reference<_SrcTuple>::type
                                   >::type>>,
                     __not_<is_convertible<_SrcTuple, _Elements...>>,
                     __not_<is_constructible<_Elements..., _SrcTuple>>
              >::value;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return __not_<is_same<tuple<_Elements...>,
        typename remove_const<
          typename remove_reference<_UElements...>::type
          >::type>>::value;
    }
  };

  template<typename... _Elements>
  struct _TC<false, _Elements...>
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _NonNestedTuple()
    {
      return true;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return true;
    }
  };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;



      template<typename _Dummy>
      struct _TC2
      {
        static constexpr bool _DefaultConstructibleTuple()
        {
          return __and_<is_default_constructible<_Elements>...>::value;
        }
        static constexpr bool _ImplicitlyDefaultConstructibleTuple()
        {
          return __and_<__is_implicitly_default_constructible<_Elements>...>
            ::value;
        }
      };

    public:
      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = true>
      constexpr tuple()
      : _Inherited() { }

      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _DefaultConstructibleTuple()
                                  &&
                                  !_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = false>
      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value,
            _Elements...>;

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=true>
        constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=false>
      explicit constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }



      template<typename... _UElements> using _TMC =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))
        && (_TC<(sizeof...(_UElements)==1), _Elements...>::
     template _NotSameTuple<_UElements...>()),
                      _Elements...>;



      template<typename... _UElements> using _TMCT =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))
        && !is_same<tuple<_Elements...>,
      tuple<_UElements...>>::value,
                      _Elements...>;

      template<typename... _UElements, typename
        enable_if<
    _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=true>
        constexpr tuple(_UElements&&... __elements)
        : _Inherited(std::forward<_UElements>(__elements)...) { }

      template<typename... _UElements, typename
        enable_if<
    _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=false>
        explicit constexpr tuple(_UElements&&... __elements)
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;



      template<typename _Dummy> using _TNTC =
        _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,
            _Elements...>;

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=true>
        constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=false>
        explicit constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
        constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
        explicit constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename... _UElements>
 typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements), tuple&>::type
        operator=(const tuple<_UElements...>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename... _UElements>
 typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements), tuple&>::type
        operator=(tuple<_UElements...>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };
# 889 "/usr/include/c++/7/tuple" 3
  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }


      tuple() = default;

      template<typename _Alloc>
 tuple(allocator_arg_t, const _Alloc&) { }
      template<typename _Alloc>
 tuple(allocator_arg_t, const _Alloc&, const tuple&) { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;

    public:
      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr tuple()
      : _Inherited() { }

      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<
                  __and_<
                    is_default_constructible<_U1>,
                    is_default_constructible<_U2>,
                    __not_<
                      __and_<__is_implicitly_default_constructible<_U1>,
                             __is_implicitly_default_constructible<_U2>>>>
                  ::value, bool>::type = false>

      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value, _T1, _T2>;

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && _TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = true>
        constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && !_TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = false>
        explicit constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }



      using _TMC = _TC<true, _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
           && !is_same<typename decay<_U1>::type,
         allocator_arg_t>::value,
 bool>::type = true>
        constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
           && !is_same<typename decay<_U1>::type,
         allocator_arg_t>::value,
 bool>::type = false>
        explicit constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=false>

 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const tuple<_U1, _U2>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(tuple<_U1, _U2>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const pair<_U1, _U2>& __in)
        {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(pair<_U1, _U2>&& __in)
        {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };



  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };
# 1278 "/usr/include/c++/7/tuple" 3
  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };




  template<size_t __i>
    struct tuple_element<__i, tuple<>>
    {
      static_assert(__i < tuple_size<tuple<>>::value,
   "tuple index is in range");
    };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type&&>(std::get<__i>(__t));
    }





  template<typename _Head, size_t __i, typename... _Tail>
    constexpr _Head&
    __get_helper2(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<typename _Head, size_t __i, typename... _Tail>
    constexpr const _Head&
    __get_helper2(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&
    get(tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&&
    get(tuple<_Types...>&& __t) noexcept
    { return std::forward<_Tp&&>(std::__get_helper2<_Tp>(__t)); }


  template <typename _Tp, typename... _Types>
    constexpr const _Tp&
    get(const tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }



  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__less(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }


  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }



  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<typename std::remove_cv
            <typename std::remove_reference<_Tuple>::type>::type>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    inline


    typename enable_if<__and_<__is_swappable<_Elements>...>::value
      >::type



    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename... _Elements>
    typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type
    swap(tuple<_Elements...>&, tuple<_Elements...>&) = delete;






  struct _Swallow_assign
  {
    template<class _Tp>
      constexpr const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };



  constexpr _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };


  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }
# 1695 "/usr/include/c++/7/tuple" 3

}
# 55 "/usr/include/c++/7/functional" 2 3



# 1 "/usr/include/c++/7/bits/std_function.h" 1 3
# 33 "/usr/include/c++/7/bits/std_function.h" 3
       
# 34 "/usr/include/c++/7/bits/std_function.h" 3
# 44 "/usr/include/c++/7/bits/std_function.h" 3
# 1 "/usr/include/c++/7/bits/refwrap.h" 1 3
# 33 "/usr/include/c++/7/bits/refwrap.h" 3
       
# 34 "/usr/include/c++/7/bits/refwrap.h" 3
# 43 "/usr/include/c++/7/bits/refwrap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Functor, typename = __void_t<>>
    struct _Maybe_get_result_type
    { };

  template<typename _Functor>
    struct _Maybe_get_result_type<_Functor,
      __void_t<typename _Functor::result_type>>
    { typedef typename _Functor::result_type result_type; };





  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<_Functor>
    { };


  template<typename _Res, typename... _ArgTypes >
    struct _Weak_result_type_impl<_Res(_ArgTypes...) >
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes >
    struct _Weak_result_type_impl<_Res(_ArgTypes......) >
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const volatile>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes >
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...) >
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes >
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes......)
      >
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes
    >
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)
      >
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes
    >
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)
      >
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes
    >
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const
      >
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes
    >
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) const
      >
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes
    >
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile
      >
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes
    >
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) volatile
      >
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes
    >
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)
      const volatile >
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes
    >
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)
      const volatile >
    { typedef _Res result_type; };





  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>
    { };


  template<typename _Tp, typename = __void_t<>>
    struct _Refwrap_base_arg1
    { };


  template<typename _Tp>
    struct _Refwrap_base_arg1<_Tp,
         __void_t<typename _Tp::argument_type>>
    {
      typedef typename _Tp::argument_type argument_type;
    };


  template<typename _Tp, typename = __void_t<>>
    struct _Refwrap_base_arg2
    { };


  template<typename _Tp>
    struct _Refwrap_base_arg2<_Tp,
         __void_t<typename _Tp::first_argument_type,
           typename _Tp::second_argument_type>>
    {
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };







  template<typename _Tp>
    struct _Reference_wrapper_base
    : _Weak_result_type<_Tp>, _Refwrap_base_arg1<_Tp>, _Refwrap_base_arg2<_Tp>
    { };


  template<typename _Res, typename _T1 >
    struct _Reference_wrapper_base<_Res(_T1) >
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) volatile>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const volatile>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base<_Res(_T1, _T2) >
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1 >
    struct _Reference_wrapper_base<_Res(*)(_T1) >
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base<_Res(*)(_T1, _T2) >
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1 >
    struct _Reference_wrapper_base<_Res (_T1::*)() >
    : unary_function<_T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) >
    : binary_function<_T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1 >
    struct _Reference_wrapper_base<_Res (_T1::*)() const >
    : unary_function<const _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const >
    : binary_function<const _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1 >
    struct _Reference_wrapper_base<_Res (_T1::*)() volatile >
    : unary_function<volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile >
    : binary_function<volatile _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1 >
    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile >
    : unary_function<const volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile >
    : binary_function<const volatile _T1*, _T2, _Res>
    { };






  template<typename _Tp>
    class reference_wrapper
    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>
    {
      _Tp* _M_data;

    public:
      typedef _Tp type;

      reference_wrapper(_Tp& __indata) noexcept
      : _M_data(std::__addressof(__indata))
      { }

      reference_wrapper(_Tp&&) = delete;

      reference_wrapper(const reference_wrapper&) = default;

      reference_wrapper&
      operator=(const reference_wrapper&) = default;

      operator _Tp&() const noexcept
      { return this->get(); }

      _Tp&
      get() const noexcept
      { return *_M_data; }

      template<typename... _Args>
 typename result_of<_Tp&(_Args&&...)>::type
 operator()(_Args&&... __args) const
 {
   return std::__invoke(get(), std::forward<_Args>(__args)...);
 }
    };



  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(_Tp& __t) noexcept
    { return reference_wrapper<_Tp>(__t); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t) noexcept
    { return reference_wrapper<const _Tp>(__t); }

  template<typename _Tp>
    void ref(const _Tp&&) = delete;

  template<typename _Tp>
    void cref(const _Tp&&) = delete;


  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t) noexcept
    { return ref(__t.get()); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t) noexcept
    { return cref(__t.get()); }




}
# 45 "/usr/include/c++/7/bits/std_function.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };


  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };







  class bad_function_call : public std::exception
  {
  public:
    virtual ~bad_function_call() noexcept;

    const char* what() const noexcept;
  };







  template<typename _Tp>
    struct __is_location_invariant
    : is_trivially_copyable<_Tp>::type
    { };

  class _Undefined_class;

  union _Nocopy_types
  {
    void* _M_object;
    const void* _M_const_object;
    void (*_M_function_pointer)();
    void (_Undefined_class::*_M_member_pointer)();
  };

  union [[gnu::may_alias]] _Any_data
  {
    void* _M_access() { return &_M_pod_data[0]; }
    const void* _M_access() const { return &_M_pod_data[0]; }

    template<typename _Tp>
      _Tp&
      _M_access()
      { return *static_cast<_Tp*>(_M_access()); }

    template<typename _Tp>
      const _Tp&
      _M_access() const
      { return *static_cast<const _Tp*>(_M_access()); }

    _Nocopy_types _M_unused;
    char _M_pod_data[sizeof(_Nocopy_types)];
  };

  enum _Manager_operation
  {
    __get_type_info,
    __get_functor_ptr,
    __clone_functor,
    __destroy_functor
  };



  template<typename _Tp>
    struct _Simple_type_wrapper
    {
      _Simple_type_wrapper(_Tp __value) : __value(__value) { }

      _Tp __value;
    };

  template<typename _Tp>
    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >
    : __is_location_invariant<_Tp>
    { };

  template<typename _Signature>
    class function;


  class _Function_base
  {
  public:
    static const std::size_t _M_max_size = sizeof(_Nocopy_types);
    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);

    template<typename _Functor>
      class _Base_manager
      {
      protected:
 static const bool __stored_locally =
 (__is_location_invariant<_Functor>::value
  && sizeof(_Functor) <= _M_max_size
  && __alignof__(_Functor) <= _M_max_align
  && (_M_max_align % __alignof__(_Functor) == 0));

 typedef integral_constant<bool, __stored_locally> _Local_storage;


 static _Functor*
 _M_get_pointer(const _Any_data& __source)
 {
   const _Functor* __ptr =
     __stored_locally? std::__addressof(__source._M_access<_Functor>())
                                 : __source._M_access<_Functor*>();
   return const_cast<_Functor*>(__ptr);
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
 {
   ::new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
 {
   __dest._M_access<_Functor*>() =
     new _Functor(*__source._M_access<_Functor*>());
 }



 static void
 _M_destroy(_Any_data& __victim, true_type)
 {
   __victim._M_access<_Functor>().~_Functor();
 }


 static void
 _M_destroy(_Any_data& __victim, false_type)
 {
   delete __victim._M_access<_Functor*>();
 }

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = _M_get_pointer(__source);
       break;

     case __clone_functor:
       _M_clone(__dest, __source, _Local_storage());
       break;

     case __destroy_functor:
       _M_destroy(__dest, _Local_storage());
       break;
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f)
 { _M_init_functor(__functor, std::move(__f), _Local_storage()); }

 template<typename _Signature>
   static bool
   _M_not_empty_function(const function<_Signature>& __f)
   { return static_cast<bool>(__f); }

 template<typename _Tp>
   static bool
   _M_not_empty_function(_Tp* __fp)
   { return __fp != nullptr; }

 template<typename _Class, typename _Tp>
   static bool
   _M_not_empty_function(_Tp _Class::* __mp)
   { return __mp != nullptr; }

 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp&)
   { return true; }

      private:
 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
 { ::new (__functor._M_access()) _Functor(std::move(__f)); }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
 { __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
    {
      if (_M_manager)
 _M_manager(_M_functor, _M_functor, __destroy_functor);
    }

    bool _M_empty() const { return !_M_manager; }

    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
      _Manager_operation);

    _Any_data _M_functor;
    _Manager_type _M_manager;
  };

  template<typename _Signature, typename _Functor>
    class _Function_handler;

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

    public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename _Res,
    typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>
    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>
    {
      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>
 _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return std::__invoke(_Base::_M_get_pointer(__functor)->__value,
        std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Member _Class::*>
    : public _Function_base::_Base_manager<
   _Simple_type_wrapper< _Member _Class::* > >
    {
      typedef _Member _Class::* _Functor;
      typedef _Simple_type_wrapper<_Functor> _Wrapper;
      typedef _Function_base::_Base_manager<_Wrapper> _Base;

    public:
      static bool
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   _Manager_operation __op)
      {
 switch (__op)
   {

   case __get_type_info:
     __dest._M_access<const type_info*>() = &typeid(_Functor);
     break;

   case __get_functor_ptr:
     __dest._M_access<_Functor*>() =
       &_Base::_M_get_pointer(__source)->__value;
     break;

   default:
     _Base::_M_manager(__dest, __source, __op);
   }
 return false;
      }

      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 std::__invoke(_Base::_M_get_pointer(__functor)->__value,
        std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _From, typename _To>
    using __check_func_return_type
      = __or_<is_void<_To>, is_same<_From, _To>, is_convertible<_From, _To>>;







  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
      private _Function_base
    {
      template<typename _Func,
        typename _Res2 = typename result_of<_Func&(_ArgTypes...)>::type>
 struct _Callable : __check_func_return_type<_Res2, _Res> { };



      template<typename _Tp>
 struct _Callable<function, _Tp> : false_type { };

      template<typename _Cond, typename _Tp>
 using _Requires = typename enable_if<_Cond::value, _Tp>::type;

    public:
      typedef _Res result_type;







      function() noexcept
      : _Function_base() { }





      function(nullptr_t) noexcept
      : _Function_base() { }
# 432 "/usr/include/c++/7/bits/std_function.h" 3
      function(const function& __x);
# 441 "/usr/include/c++/7/bits/std_function.h" 3
      function(function&& __x) noexcept : _Function_base()
      {
 __x.swap(*this);
      }
# 462 "/usr/include/c++/7/bits/std_function.h" 3
      template<typename _Functor,
        typename = _Requires<__not_<is_same<_Functor, function>>, void>,
        typename = _Requires<_Callable<_Functor>, void>>
 function(_Functor);
# 479 "/usr/include/c++/7/bits/std_function.h" 3
      function&
      operator=(const function& __x)
      {
 function(__x).swap(*this);
 return *this;
      }
# 497 "/usr/include/c++/7/bits/std_function.h" 3
      function&
      operator=(function&& __x) noexcept
      {
 function(std::move(__x)).swap(*this);
 return *this;
      }
# 511 "/usr/include/c++/7/bits/std_function.h" 3
      function&
      operator=(nullptr_t) noexcept
      {
 if (_M_manager)
   {
     _M_manager(_M_functor, _M_functor, __destroy_functor);
     _M_manager = nullptr;
     _M_invoker = nullptr;
   }
 return *this;
      }
# 539 "/usr/include/c++/7/bits/std_function.h" 3
      template<typename _Functor>
 _Requires<_Callable<typename decay<_Functor>::type>, function&>
 operator=(_Functor&& __f)
 {
   function(std::forward<_Functor>(__f)).swap(*this);
   return *this;
 }


      template<typename _Functor>
 function&
 operator=(reference_wrapper<_Functor> __f) noexcept
 {
   function(__f).swap(*this);
   return *this;
 }
# 565 "/usr/include/c++/7/bits/std_function.h" 3
      void swap(function& __x) noexcept
      {
 std::swap(_M_functor, __x._M_functor);
 std::swap(_M_manager, __x._M_manager);
 std::swap(_M_invoker, __x._M_invoker);
      }
# 582 "/usr/include/c++/7/bits/std_function.h" 3
      explicit operator bool() const noexcept
      { return !_M_empty(); }
# 595 "/usr/include/c++/7/bits/std_function.h" 3
      _Res operator()(_ArgTypes... __args) const;
# 608 "/usr/include/c++/7/bits/std_function.h" 3
      const type_info& target_type() const noexcept;
# 621 "/usr/include/c++/7/bits/std_function.h" 3
      template<typename _Functor> _Functor* target() noexcept;

      template<typename _Functor> const _Functor* target() const noexcept;



    private:
      using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);
      _Invoker_type _M_invoker;
  };
# 670 "/usr/include/c++/7/bits/std_function.h" 3
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 {
   __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   _M_invoker = __x._M_invoker;
   _M_manager = __x._M_manager;
 }
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor, typename, typename>
      function<_Res(_ArgTypes...)>::
      function(_Functor __f)
      : _Function_base()
      {
 typedef _Function_handler<_Res(_ArgTypes...), _Functor> _My_handler;

 if (_My_handler::_M_not_empty_function(__f))
   {
     _My_handler::_M_init_functor(_M_functor, std::move(__f));
     _M_invoker = &_My_handler::_M_invoke;
     _M_manager = &_My_handler::_M_manager;
   }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 __throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
    }


  template<typename _Res, typename... _ArgTypes>
    const type_info&
    function<_Res(_ArgTypes...)>::
    target_type() const noexcept
    {
      if (_M_manager)
 {
   _Any_data __typeinfo_result;
   _M_manager(__typeinfo_result, _M_functor, __get_type_info);
   return *__typeinfo_result._M_access<const type_info*>();
 }
      else
 return typeid(void);
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      _Functor*
      function<_Res(_ArgTypes...)>::
      target() noexcept
      {
 const function* __const_this = this;
 const _Functor* __func = __const_this->template target<_Functor>();
 return const_cast<_Functor*>(__func);
      }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      const _Functor*
      function<_Res(_ArgTypes...)>::
      target() const noexcept
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     _M_manager(__ptr, _M_functor, __get_functor_ptr);
     return __ptr._M_access<const _Functor*>();
   }
 else
   return nullptr;
      }
# 762 "/usr/include/c++/7/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return !static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return !static_cast<bool>(__f); }
# 780 "/usr/include/c++/7/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return static_cast<bool>(__f); }
# 801 "/usr/include/c++/7/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline void
    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y) noexcept
    { __x.swap(__y); }


}
# 59 "/usr/include/c++/7/functional" 2 3
# 67 "/usr/include/c++/7/functional" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 85 "/usr/include/c++/7/functional" 3
  template<typename... _Types>
    struct _Pack : integral_constant<size_t, sizeof...(_Types)>
    { };

  template<typename _From, typename _To, bool = _From::value == _To::value>
    struct _AllConvertible : false_type
    { };

  template<typename... _From, typename... _To>
    struct _AllConvertible<_Pack<_From...>, _Pack<_To...>, true>
    : __and_<is_convertible<_From, _To>...>
    { };

  template<typename _Tp1, typename _Tp2>
    using _NotSame = __not_<is_same<typename std::decay<_Tp1>::type,
        typename std::decay<_Tp2>::type>>;

  template<typename _Signature>
    struct _Mem_fn_traits;

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Mem_fn_traits_base
    {
      using __result_type = _Res;
      using __maybe_type
 = _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;
      using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
    };
# 134 "/usr/include/c++/7/functional" 3
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
# 147 "/usr/include/c++/7/functional" 3
  template<typename _MemFunPtr,
    bool __is_mem_fn = is_member_function_pointer<_MemFunPtr>::value>
    class _Mem_fn_base
    : public _Mem_fn_traits<_MemFunPtr>::__maybe_type
    {
      using _Traits = _Mem_fn_traits<_MemFunPtr>;

      using _Arity = typename _Traits::__arity;
      using _Varargs = typename _Traits::__vararg;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemFunPtr _M_pmf;

    public:

      using result_type = typename _Traits::__result_type;

      explicit constexpr
      _Mem_fn_base(_MemFunPtr __pmf) noexcept : _M_pmf(__pmf) { }

      template<typename... _Args>
 auto
 operator()(_Args&&... __args) const
 noexcept(noexcept(
       std::__invoke(_M_pmf, std::forward<_Args>(__args)...)))
 -> decltype(std::__invoke(_M_pmf, std::forward<_Args>(__args)...))
 { return std::__invoke(_M_pmf, std::forward<_Args>(__args)...); }
    };


  template<typename _MemObjPtr>
    class _Mem_fn_base<_MemObjPtr, false>
    {
      using _Arity = integral_constant<size_t, 0>;
      using _Varargs = false_type;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemObjPtr _M_pm;

    public:
      explicit constexpr
      _Mem_fn_base(_MemObjPtr __pm) noexcept : _M_pm(__pm) { }

      template<typename _Tp>
 auto
 operator()(_Tp&& __obj) const
 noexcept(noexcept(std::__invoke(_M_pm, std::forward<_Tp>(__obj))))
 -> decltype(std::__invoke(_M_pm, std::forward<_Tp>(__obj)))
 { return std::__invoke(_M_pm, std::forward<_Tp>(__obj)); }
    };

  template<typename _MemberPointer>
    struct _Mem_fn;

  template<typename _Res, typename _Class>
    struct _Mem_fn<_Res _Class::*>
    : _Mem_fn_base<_Res _Class::*>
    {
      using _Mem_fn_base<_Res _Class::*>::_Mem_fn_base;
    };
# 219 "/usr/include/c++/7/functional" 3
  template<typename _Tp, typename _Class>
    inline _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::* __pm) noexcept
    {
      return _Mem_fn<_Tp _Class::*>(__pm);
    }
# 234 "/usr/include/c++/7/functional" 3
  template<typename _Tp>
    struct is_bind_expression
    : public false_type { };
# 245 "/usr/include/c++/7/functional" 3
  template<typename _Tp>
    struct is_placeholder
    : public integral_constant<int, 0>
    { };
# 260 "/usr/include/c++/7/functional" 3
  template<int _Num> struct _Placeholder { };

 





  namespace placeholders
  {
 




    extern const _Placeholder<1> _1;
    extern const _Placeholder<2> _2;
    extern const _Placeholder<3> _3;
    extern const _Placeholder<4> _4;
    extern const _Placeholder<5> _5;
    extern const _Placeholder<6> _6;
    extern const _Placeholder<7> _7;
    extern const _Placeholder<8> _8;
    extern const _Placeholder<9> _9;
    extern const _Placeholder<10> _10;
    extern const _Placeholder<11> _11;
    extern const _Placeholder<12> _12;
    extern const _Placeholder<13> _13;
    extern const _Placeholder<14> _14;
    extern const _Placeholder<15> _15;
    extern const _Placeholder<16> _16;
    extern const _Placeholder<17> _17;
    extern const _Placeholder<18> _18;
    extern const _Placeholder<19> _19;
    extern const _Placeholder<20> _20;
    extern const _Placeholder<21> _21;
    extern const _Placeholder<22> _22;
    extern const _Placeholder<23> _23;
    extern const _Placeholder<24> _24;
    extern const _Placeholder<25> _25;
    extern const _Placeholder<26> _26;
    extern const _Placeholder<27> _27;
    extern const _Placeholder<28> _28;
    extern const _Placeholder<29> _29;
 
  }

 






  template<int _Num>
    struct is_placeholder<_Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };

  template<int _Num>
    struct is_placeholder<const _Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };



  template<std::size_t __i, typename _Tuple>
    using _Safe_tuple_element_t
      = typename enable_if<(__i < tuple_size<_Tuple>::value),
      tuple_element<__i, _Tuple>>::type::type;
# 342 "/usr/include/c++/7/functional" 3
  template<typename _Arg,
    bool _IsBindExp = is_bind_expression<_Arg>::value,
    bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
    class _Mu;






  template<typename _Tp>
    class _Mu<reference_wrapper<_Tp>, false, false>
    {
    public:




      template<typename _CVRef, typename _Tuple>
 _Tp&
 operator()(_CVRef& __arg, _Tuple&) const volatile
 { return __arg.get(); }
    };







  template<typename _Arg>
    class _Mu<_Arg, true, false>
    {
    public:
      template<typename _CVArg, typename... _Args>
 auto
 operator()(_CVArg& __arg,
     tuple<_Args...>& __tuple) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {

   typedef typename _Build_index_tuple<sizeof...(_Args)>::__type
     _Indexes;
   return this->__call(__arg, __tuple, _Indexes());
 }

    private:


      template<typename _CVArg, typename... _Args, std::size_t... _Indexes>
 auto
 __call(_CVArg& __arg, tuple<_Args...>& __tuple,
        const _Index_tuple<_Indexes...>&) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {
   return __arg(std::get<_Indexes>(std::move(__tuple))...);
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, true>
    {
    public:
      template<typename _Tuple>
 _Safe_tuple_element_t<(is_placeholder<_Arg>::value - 1), _Tuple>&&
 operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 {
   return
     ::std::get<(is_placeholder<_Arg>::value - 1)>(std::move(__tuple));
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, false>
    {
    public:
      template<typename _CVArg, typename _Tuple>
 _CVArg&&
 operator()(_CVArg&& __arg, _Tuple&) const volatile
 { return std::forward<_CVArg>(__arg); }
    };


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> volatile&
    { return std::get<_Ind>(const_cast<tuple<_Tp...>&>(__tuple)); }


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(const volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> const volatile&
    { return std::get<_Ind>(const_cast<const tuple<_Tp...>&>(__tuple)); }


  template<typename _Signature>
    struct _Bind;

   template<typename _Functor, typename... _Bound_args>
    class _Bind<_Functor(_Bound_args...)>
    : public _Weak_result_type<_Functor>
    {
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_v(tuple<_Args...>&& __args,
   _Index_tuple<_Indexes...>) volatile
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(__volget<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c_v(tuple<_Args...>&& __args,
     _Index_tuple<_Indexes...>) const volatile
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(__volget<_Indexes>(_M_bound_args), __args)...
       );
 }

      template<typename _BoundArg, typename _CallArgs>
 using _Mu_type = decltype(
     _Mu<typename remove_cv<_BoundArg>::type>()(
       std::declval<_BoundArg&>(), std::declval<_CallArgs&>()) );

      template<typename _Fn, typename _CallArgs, typename... _BArgs>
 using _Res_type_impl
   = typename result_of< _Fn&(_Mu_type<_BArgs, _CallArgs>&&...) >::type;

      template<typename _CallArgs>
 using _Res_type = _Res_type_impl<_Functor, _CallArgs, _Bound_args...>;

      template<typename _CallArgs>
 using __dependent = typename
   enable_if<bool(tuple_size<_CallArgs>::value+1), _Functor>::type;

      template<typename _CallArgs, template<class> class __cv_quals>
 using _Res_type_cv = _Res_type_impl<
   typename __cv_quals<__dependent<_CallArgs>>::type,
   _CallArgs,
   typename __cv_quals<_Bound_args>::type...>;

     public:
      template<typename... _Args>
 explicit _Bind(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind(const _Bind&) = default;

      _Bind(_Bind&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args,
        typename _Result = _Res_type<tuple<_Args...>>>
 _Result
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_const>>
 _Result
 operator()(_Args&&... __args) const
 {
   return this->__call_c<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
# 572 "/usr/include/c++/7/functional" 3
      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_volatile>>

 _Result
 operator()(_Args&&... __args) volatile
 {
   return this->__call_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_cv>>

 _Result
 operator()(_Args&&... __args) const volatile
 {
   return this->__call_c_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };


  template<typename _Result, typename _Signature>
    struct _Bind_result;

  template<typename _Result, typename _Functor, typename... _Bound_args>
    class _Bind_result<_Result, _Functor(_Bound_args...)>
    {
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Res>
 using __enable_if_void
   = typename enable_if<is_void<_Res>{}>::type;

      template<typename _Res>
 using __disable_if_void
   = typename enable_if<!is_void<_Res>{}, _Result>::type;


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __disable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return std::__invoke(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __enable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   std::__invoke(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __disable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return std::__invoke(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __enable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   std::__invoke(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __disable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) volatile
 {
   return std::__invoke(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __enable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) volatile
 {
   std::__invoke(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __disable_if_void<_Res>
 __call(tuple<_Args...>&& __args,
        _Index_tuple<_Indexes...>) const volatile
 {
   return std::__invoke(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __enable_if_void<_Res>
 __call(tuple<_Args...>&& __args,
        _Index_tuple<_Indexes...>) const volatile
 {
   std::__invoke(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

    public:
      typedef _Result result_type;

      template<typename... _Args>
 explicit _Bind_result(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind_result(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind_result(const _Bind_result&) = default;

      _Bind_result(_Bind_result&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>

 result_type
 operator()(_Args&&... __args) volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>

 result_type
 operator()(_Args&&... __args) const volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };






  template<typename _Signature>
    struct is_bind_expression<_Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<volatile _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const volatile _Bind<_Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<_Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>
    : public true_type { };

  template<typename _Func, typename... _BoundArgs>
    struct _Bind_check_arity { };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args...), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) == sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args......), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) >= sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Tp, typename _Class, typename... _BoundArgs>
    struct _Bind_check_arity<_Tp _Class::*, _BoundArgs...>
    {
      using _Arity = typename _Mem_fn<_Tp _Class::*>::_Arity;
      using _Varargs = typename _Mem_fn<_Tp _Class::*>::_Varargs;
      static_assert(_Varargs::value
      ? sizeof...(_BoundArgs) >= _Arity::value + 1
      : sizeof...(_BoundArgs) == _Arity::value + 1,
      "Wrong number of arguments for pointer-to-member");
    };




  template<typename _Tp, typename _Tp2 = typename decay<_Tp>::type>
    using __is_socketlike = __or_<is_integral<_Tp2>, is_enum<_Tp2>>;

  template<bool _SocketLike, typename _Func, typename... _BoundArgs>
    struct _Bind_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef typename decay<_Func>::type __func_type;
      typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
    };




  template<typename _Func, typename... _BoundArgs>
    struct _Bind_helper<true, _Func, _BoundArgs...>
    { };





  template<typename _Func, typename... _BoundArgs>
    inline typename
    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
      return typename __helper_type::type(std::forward<_Func>(__f),
       std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Result, typename _Func, typename... _BoundArgs>
    struct _Bindres_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef typename decay<_Func>::type __functor_type;
      typedef _Bind_result<_Result,
      __functor_type(typename decay<_BoundArgs>::type...)>
 type;
    };





  template<typename _Result, typename _Func, typename... _BoundArgs>
    inline
    typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bindres_helper<_Result, _Func, _BoundArgs...> __helper_type;
      return typename __helper_type::type(std::forward<_Func>(__f),
       std::forward<_BoundArgs>(__args)...);
    }



  template<typename _Fn>
    class _Not_fn
    {
      template<typename _Fn2, typename... _Args>
 using __inv_res_t = typename __invoke_result<_Fn2, _Args...>::type;

      template<typename _Tp>
 static decltype(!std::declval<_Tp>())
 _S_not() noexcept(noexcept(!std::declval<_Tp>()));

    public:
      template<typename _Fn2>
 _Not_fn(_Fn2&& __fn, int)
 : _M_fn(std::forward<_Fn2>(__fn)) { }

      _Not_fn(const _Not_fn& __fn) = default;
      _Not_fn(_Not_fn&& __fn) = default;
      ~_Not_fn() = default;
# 940 "/usr/include/c++/7/functional" 3
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn &, _Args...>>()) operator()(_Args&&... __args) & noexcept(__is_nothrow_invocable<_Fn &, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn &, _Args...>>())) { return !std::__invoke(std::forward< _Fn & >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn const &, _Args...>>()) operator()(_Args&&... __args) const & noexcept(__is_nothrow_invocable<_Fn const &, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn const &, _Args...>>())) { return !std::__invoke(std::forward< _Fn const & >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn &&, _Args...>>()) operator()(_Args&&... __args) && noexcept(__is_nothrow_invocable<_Fn &&, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn &&, _Args...>>())) { return !std::__invoke(std::forward< _Fn && >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn const &&, _Args...>>()) operator()(_Args&&... __args) const && noexcept(__is_nothrow_invocable<_Fn const &&, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn const &&, _Args...>>())) { return !std::__invoke(std::forward< _Fn const && >(_M_fn), std::forward<_Args>(__args)...); }


    private:
      _Fn _M_fn;
    };
# 1245 "/usr/include/c++/7/functional" 3

}
# 35 "/usr/local/include/interval/interval.hpp" 2 3
# 1 "/usr/include/c++/7/algorithm" 1 3
# 58 "/usr/include/c++/7/algorithm" 3
       
# 59 "/usr/include/c++/7/algorithm" 3



# 1 "/usr/include/c++/7/bits/stl_algo.h" 1 3
# 59 "/usr/include/c++/7/bits/stl_algo.h" 3
# 1 "/usr/include/c++/7/cstdlib" 1 3
# 39 "/usr/include/c++/7/cstdlib" 3
       
# 40 "/usr/include/c++/7/cstdlib" 3
# 60 "/usr/include/c++/7/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/7/bits/algorithmfwd.h" 1 3
# 33 "/usr/include/c++/7/bits/algorithmfwd.h" 3
       
# 34 "/usr/include/c++/7/bits/algorithmfwd.h" 3
# 42 "/usr/include/c++/7/bits/algorithmfwd.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 195 "/usr/include/c++/7/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _Predicate>
    bool
    all_of(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Predicate>
    bool
    any_of(_IIter, _IIter, _Predicate);


  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);
# 224 "/usr/include/c++/7/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);


  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);

  template<typename _IIter, typename _Size, typename _OIter>
    _OIter
    copy_n(_IIter, _Size, _OIter);





  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);





  template<typename _IIter, typename _Predicate>
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);






  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);


  template<typename _RAIter>
    bool
    is_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    bool
    is_heap(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    _RAIter
    is_heap_until(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    _RAIter
    is_heap_until(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _Predicate>
    bool
    is_partitioned(_IIter, _IIter, _Predicate);

  template<typename _FIter1, typename _FIter2>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2);

  template<typename _FIter1, typename _FIter2,
    typename _BinaryPredicate>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

  template<typename _FIter>
    bool
    is_sorted(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    bool
    is_sorted(_FIter, _FIter, _Compare);

  template<typename _FIter>
    _FIter
    is_sorted_until(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    is_sorted_until(_FIter, _FIter, _Compare);


  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);

  template<typename _FIter>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    min(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    min(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    max(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    max(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);




  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);


  template<typename _IIter, typename _Predicate>
    bool
    none_of(_IIter, _IIter, _Predicate);





  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);




  template<typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate>
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);

  template<typename _FIter, typename _Predicate>
    _FIter
    partition_point(_FIter, _FIter, _Predicate);


  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  inline namespace _V2
  {
    template<typename _FIter>
      _FIter
      rotate(_FIter, _FIter, _FIter);
  }

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 565 "/usr/include/c++/7/bits/algorithmfwd.h" 3
  template<typename _RAIter, typename _UGenerator>
    void
    shuffle(_RAIter, _RAIter, _UGenerator&&);


  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);
# 594 "/usr/include/c++/7/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);





  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,

     _Generator&&);




  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);


}
# 61 "/usr/include/c++/7/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/7/bits/stl_heap.h" 1 3
# 62 "/usr/include/c++/7/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare& __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first + __parent, __first + __child))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      __gnu_cxx::__ops::_Iter_less_iter __comp;
      return std::__is_heap_until(__first, __n, __comp) == __n;
    }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    {
      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return std::__is_heap_until(__first, __n, __cmp) == __n;
    }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      return std::__is_heap(__first, std::move(__comp),
       std::distance(__first, __last));
    }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value,
  _Compare& __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && __comp(__first + __parent, __value))
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
# 152 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;
      ;
      ;

      __gnu_cxx::__ops::_Iter_less_val __comp;
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __comp);
    }
# 187 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;
      ;
      ;

      __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))
 __cmp(std::move(__comp));
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __cmp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(__first + __secondChild,
       __first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)))
                                  ;
   __holeIndex = __secondChild - 1;
 }
      __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))
 __cmp(std::move(__comp));
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value), __cmp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare& __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value), __comp);
    }
# 269 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   --__last;
   __gnu_cxx::__ops::_Iter_less_iter __comp;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 302 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {

     

      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   typedef __decltype(__comp) _Cmp;
   __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
   --__last;
   std::__pop_heap(__first, __last, __last, __cmp);
 }
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare& __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 358 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      std::__make_heap(__first, __last, __comp);
    }
# 384 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      std::__make_heap(__first, __last, __cmp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare& __comp)
    {
      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 420 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      std::__sort_heap(__first, __last, __comp);
    }
# 447 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;
      ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      std::__sort_heap(__first, __last, __cmp);
    }
# 475 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      return __first +
 std::__is_heap_until(__first, std::distance(__first, __last), __comp);
    }
# 503 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {

     

      ;
      ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return __first
 + std::__is_heap_until(__first, std::distance(__first, __last), __cmp);
    }
# 527 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }
# 540 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp)
    {

     

      ;
      ;

      const auto __dist = std::distance(__first, __last);
      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return std::__is_heap_until(__first, __dist, __cmp) == __dist;
    }



}
# 62 "/usr/include/c++/7/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/7/bits/stl_tempbuf.h" 1 3
# 60 "/usr/include/c++/7/bits/stl_tempbuf.h" 3
# 1 "/usr/include/c++/7/bits/stl_construct.h" 1 3
# 63 "/usr/include/c++/7/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
# 87 "/usr/include/c++/7/bits/stl_construct.h" 3
  template<typename _T1>
    inline void
    _Construct_novalue(_T1* __p)
    { ::new(static_cast<void*>(__p)) _T1; }




  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");

      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }

  template<bool>
    struct _Destroy_n_aux
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   for (; __count > 0; (void)++__first, --__count)
     std::_Destroy(std::__addressof(*__first));
   return __first;
 }
    };

  template<>
    struct _Destroy_n_aux<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   std::advance(__first, __count);
   return __first;
 }
    };






  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    _Destroy_n(_ForwardIterator __first, _Size __count)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");

      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
 __destroy_n(__first, __count);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }
# 232 "/usr/include/c++/7/bits/stl_construct.h" 3

}
# 61 "/usr/include/c++/7/bits/stl_tempbuf.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 83 "/usr/include/c++/7/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 110 "/usr/include/c++/7/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if(__first == __last)
     return;

   _Pointer __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         std::move(*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    std::move(*__prev));
       *__seed = std::move(*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
# 229 "/usr/include/c++/7/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            __first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }


}
# 63 "/usr/include/c++/7/bits/stl_algo.h" 2 3



# 1 "/usr/include/c++/7/bits/uniform_int_dist.h" 1 3
# 35 "/usr/include/c++/7/bits/uniform_int_dist.h" 3
# 1 "/usr/include/c++/7/limits" 1 3
# 40 "/usr/include/c++/7/limits" 3
       
# 41 "/usr/include/c++/7/limits" 3
# 158 "/usr/include/c++/7/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "/usr/include/c++/7/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "/usr/include/c++/7/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "/usr/include/c++/7/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 382 "/usr/include/c++/7/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffffffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffffffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffffffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1570 "/usr/include/c++/7/limits" 3
  template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
# 1593 "/usr/include/c++/7/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750796873653722224568e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859811704183484516925e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859811704183484516925e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309023271733240406e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570814527423731704357e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570814527423731704357e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308084726333618164062e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544176568792868221372e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502126385303097021e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502126385303097021e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443400745280086994171e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460252840593361941982e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 36 "/usr/include/c++/7/bits/uniform_int_dist.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace __detail
  {


    template<typename _Tp>
      inline bool
      _Power_of_2(_Tp __x)
      {
 return ((__x - 1) & __x) == 0;
      };

  }








  template<typename _IntType = int>
    class uniform_int_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument must be an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef uniform_int_distribution<_IntType> distribution_type;

 explicit
 param_type(_IntType __a = 0,
     _IntType __b = std::numeric_limits<_IntType>::max())
 : _M_a(__a), _M_b(__b)
 {
   ;
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

 friend bool
 operator!=(const param_type& __p1, const param_type& __p2)
 { return !(__p1 == __p2); }

      private:
 _IntType _M_a;
 _IntType _M_b;
      };

    public:



      explicit
      uniform_int_distribution(_IntType __a = 0,
      _IntType __b = std::numeric_limits<_IntType>::max())
      : _M_param(__a, __b)
      { }

      explicit
      uniform_int_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const uniform_int_distribution& __d1,
   const uniform_int_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename uniform_int_distribution<_IntType>::result_type
      uniform_int_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {

     const __uctype __uerange = __urange + 1;
     const __uctype __scaling = __urngrange / __uerange;
     const __uctype __past = __uerange * __scaling;
     do
       __ret = __uctype(__urng()) - __urngmin;
     while (__ret >= __past);
     __ret /= __scaling;
   }
 else if (__urngrange < __urange)
   {
# 267 "/usr/include/c++/7/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     do
       {
  const __uctype __uerngrange = __urngrange + 1;
  __tmp = (__uerngrange * operator()
    (__urng, param_type(0, __urange / __uerngrange)));
  __ret = __tmp + (__uctype(__urng()) - __urngmin);
       }
     while (__ret > __urange || __ret < __tmp);
   }
 else
   __ret = __uctype(__urng()) - __urngmin;

 return __ret + __param.a();
      }


  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      uniform_int_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {

 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {
     if (__detail::_Power_of_2(__urngrange + 1)
  && __detail::_Power_of_2(__urange + 1))
       {
  while (__f != __t)
    {
      __ret = __uctype(__urng()) - __urngmin;
      *__f++ = (__ret & __urange) + __param.a();
    }
       }
     else
       {

  const __uctype __uerange = __urange + 1;
  const __uctype __scaling = __urngrange / __uerange;
  const __uctype __past = __uerange * __scaling;
  while (__f != __t)
    {
      do
        __ret = __uctype(__urng()) - __urngmin;
      while (__ret >= __past);
      *__f++ = __ret / __scaling + __param.a();
    }
       }
   }
 else if (__urngrange < __urange)
   {
# 351 "/usr/include/c++/7/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     while (__f != __t)
       {
  do
    {
      const __uctype __uerngrange = __urngrange + 1;
      __tmp = (__uerngrange * operator()
        (__urng, param_type(0, __urange / __uerngrange)));
      __ret = __tmp + (__uctype(__urng()) - __urngmin);
    }
  while (__ret > __urange || __ret < __tmp);
  *__f++ = __ret;
       }
   }
 else
   while (__f != __t)
     *__f++ = __uctype(__urng()) - __urngmin + __param.a();
      }




}
# 67 "/usr/include/c++/7/bits/stl_algo.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Iterator, typename _Compare>
    void
    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
      _Iterator __c, _Compare __comp)
    {
      if (__comp(__a, __b))
 {
   if (__comp(__b, __c))
     std::iter_swap(__result, __b);
   else if (__comp(__a, __c))
     std::iter_swap(__result, __c);
   else
     std::iter_swap(__result, __a);
 }
      else if (__comp(__a, __c))
 std::iter_swap(__result, __a);
      else if (__comp(__b, __c))
 std::iter_swap(__result, __c);
      else
 std::iter_swap(__result, __b);
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred)
    {
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__negate(__pred),
       std::__iterator_category(__first));
    }




  template<typename _InputIterator, typename _Predicate, typename _Distance>
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, ++__first)
 if (!__pred(__first))
   break;
      return __first;
    }
# 202 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }






  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::forward_iterator_tag)
    {
      __first = std::__find_if(__first, __last, __unary_pred);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __unary_pred(__i))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::__find_if(++__i, __last, __unary_pred);
 }
      return __last;
    }





  template<typename _RandomAccessIter, typename _Integer,
    typename _UnaryPredicate>
    _RandomAccessIter
    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize)
 {
   __first += __remainder;
   __tailSize -= __remainder;


   _RandomAccessIter __backTrack = __first;
   while (__unary_pred(--__backTrack))
     {
       if (--__remainder == 0)
  return (__first - __count);
     }
   __remainder = __count + 1 - (__first - __backTrack);
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count,
        _UnaryPredicate __unary_pred)
    {
      if (__count <= 0)
 return __first;

      if (__count == 1)
 return std::__find_if(__first, __last, __unary_pred);

      return std::__search_n_aux(__first, __last, __count, __unary_pred,
     std::__iterator_category(__first));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;

      _ForwardIterator1 __result = __last1;
      while (1)
 {
   _ForwardIterator1 __new_result
     = std::__search(__first1, __last1, __first2, __last2, __comp);
   if (__new_result == __last1)
     return __result;
   else
     {
       __result = __new_result;
       __first1 = __new_result;
       ++__first1;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
           _RevIterator2(__last2), __rlast2,
           __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 423 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 471 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 506 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }
# 523 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if(__first, __last, __pred); }
# 541 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }
# 556 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
  _Predicate __pred)
    {

     
     

      ;
      return std::__find_if_not(__first, __last,
    __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 580 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      if (__first == __last)
 return true;
      ++__first;
      return std::none_of(__first, __last, __pred);
    }
# 601 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {

     
     



      ;

      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__pred(*__middle))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }


  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    __remove_copy_if(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _Predicate __pred)
    {
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 668 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {

     
     

     

      ;

      return std::__remove_copy_if(__first, __last, __result,
 __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 700 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    inline _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      return std::__remove_copy_if(__first, __last, __result,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 734 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator>
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }
# 797 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {

     
     


      return std::__copy_n(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 825 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate>
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred)
    {

     
     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__out_true = *__first;
     ++__out_true;
   }
 else
   {
     *__out_false = *__first;
     ++__out_false;
   }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }
# 894 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {

     

     

      ;

      return std::__remove_if(__first, __last,
  __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 927 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__remove_if(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while (++__next != __last)
 {
   if (__binary_pred(__first, __next))
     return __first;
   __first = __next;
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __unique(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {

      __first = std::__adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(__dest, __first))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
# 993 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {

     

     

      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1023 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     

     


      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {

     



      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!__binary_pred(__first, __next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {

     



      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
 __rebound_pred
 = __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
      *__result = __value;
      while (++__first != __last)
 if (!__rebound_pred(__first, __value))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {

     


      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(__result, __first))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1178 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {

     

      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1205 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {

     

     

      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }

  inline namespace _V2
  {


  template<typename _ForwardIterator>
    _ForwardIterator
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      _ForwardIterator __ret = __first;

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
      return __ret;
    }


  template<typename _BidirectionalIterator>
    _BidirectionalIterator
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {

     


      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 {
   std::__reverse(__middle, __last, bidirectional_iterator_tag());
   return __last;
 }
      else
 {
   std::__reverse(__first, __middle, bidirectional_iterator_tag());
   return __first;
 }
    }


  template<typename _RandomAccessIterator>
    _RandomAccessIterator
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {

     


      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return __middle;
 }

      _RandomAccessIterator __p = __first;
      _RandomAccessIterator __ret = __first + (__last - __middle);

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*__p);
    std::move(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*(__p + __n - 1));
    std::move_backward(__p, __p + __n - 1, __p + __n);
    *__p = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
     }
 }
    }
# 1432 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {

     

      ;
      ;

      return std::__rotate(__first, __middle, __last,
      std::__iterator_category(__first));
    }

  }
# 1469 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    inline _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
  _ForwardIterator __last, _OutputIterator __result)
    {

     
     

      ;
      ;

      return std::copy(__first, __middle,
         std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
# 1546 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len == 1)
 return __first;

      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;




   *__result2 = std::move(*__first);
   ++__result2;
   ++__first;
   for (; __first != __last; ++__first)
     if (__pred(__first))
       {
  *__result1 = std::move(*__first);
  ++__result1;
       }
     else
       {
  *__result2 = std::move(*__first);
  ++__result2;
       }

   std::move(__buffer, __result2, __result1);
   return __result1;
 }

      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
 std::__stable_partition_adaptive(__first, __middle, __pred,
      __len / 2, __buffer,
      __buffer_size);



      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
 std::__find_if_not_n(__middle, __right_len, __pred);

      if (__right_len)
 __right_split =
   std::__stable_partition_adaptive(__right_split, __last, __pred,
        __right_len,
        __buffer, __buffer_size);

      std::rotate(__left_split, __middle, __right_split);
      std::advance(__left_split, std::distance(__middle, __right_split));
      return __left_split;
    }

  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
         _Predicate __pred)
    {
      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
 return __first;

      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first, __last);
      return
 std::__stable_partition_adaptive(__first, __last, __pred,
      _DistanceType(__buf.requested_size()),
      __buf.begin(),
      _DistanceType(__buf.size()));
    }
# 1649 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__stable_partition(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::__make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(__i, __first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    _RandomAccessIterator
    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
   _RandomAccessIterator __result_first,
   _RandomAccessIterator __result_last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
      typedef typename _RItTraits::difference_type _DistanceType;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while (__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }

      std::__make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(__first, __result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first), __comp);
   ++__first;
 }
      std::__sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
# 1735 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
# 1749 "/usr/include/c++/7/bits/stl_algo.h" 3
     
     

     

     
      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
          __gnu_cxx::__ops::__iter_less_iter());
    }
# 1784 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
# 1800 "/usr/include/c++/7/bits/stl_algo.h" 3
     
     

     

     

     

      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, __next))
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(__i, __first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _RandomAccessIterator __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, __last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
      __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __partial_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __middle,
     _RandomAccessIterator __last,
     _Compare __comp)
    {
      std::__heap_select(__first, __middle, __last, __comp);
      std::__sort_heap(__first, __middle, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::__partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2,
    __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2021 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, __middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2075 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2105 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Tp,
    typename _CompareItTp, typename _CompareTpIt>
    pair<_ForwardIterator, _ForwardIterator>
    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val,
    _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp_it_val(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp_val_it(__val, __middle))
     __len = __half;
   else
     {
       _ForwardIterator __left
  = std::__lower_bound(__first, __middle, __val, __comp_it_val);
       std::advance(__first, __len);
       _ForwardIterator __right
  = std::__upper_bound(++__middle, __first, __val, __comp_val_it);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2176 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

     

      ;
      ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val(),
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2212 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     

     
                    ;
     
                    ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp),
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }
# 2245 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val)
    {

     
     

      ;
      ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_less_val());
      return __i != __last && !(__val < *__i);
    }
# 2278 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;
     
                    ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_comp_val(__comp));
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::move(__first1, __last1, __result);
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 {
   std::move_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(__last2, __last1))
     {
       *--__result = std::move(*__last1);
       if (__first1 == __last1)
  {
    std::move_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = std::move(*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   if (__len2)
     {
       __buffer_end = std::move(__middle, __last, __buffer);
       std::move_backward(__first, __middle, __last);
       return std::move(__buffer, __buffer_end, __first);
     }
   else
     return __first;
 }
      else if (__len1 <= __buffer_size)
 {
   if (__len1)
     {
       __buffer_end = std::move(__first, __middle, __buffer);
       std::move(__middle, __last, __first);
       return std::move_backward(__buffer, __buffer_end, __last);
     }
   else
     return __last;
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
       _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut
  = std::__lower_bound(__middle, __last, *__first_cut,
         __gnu_cxx::__ops::__iter_comp_val(__comp));
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut
  = std::__upper_bound(__first, __middle, *__second_cut,
         __gnu_cxx::__ops::__val_comp_iter(__comp));
       __len11 = std::distance(__first, __first_cut);
     }

   _BidirectionalIterator __new_middle
     = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
         __len1 - __len11, __len22, __buffer,
         __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;

      if (__len1 + __len2 == 2)
 {
   if (__comp(__middle, __first))
     std::iter_swap(__first, __middle);
   return;
 }

      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut
     = std::__lower_bound(__middle, __last, *__first_cut,
     __gnu_cxx::__ops::__iter_comp_val(__comp));
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut
     = std::__upper_bound(__first, __middle, *__second_cut,
     __gnu_cxx::__ops::__val_comp_iter(__comp));
   __len11 = std::distance(__first, __first_cut);
 }

      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }

  template<typename _BidirectionalIterator, typename _Compare>
    void
    __inplace_merge(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
   _DistanceType;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__merge_without_buffer
   (__first, __middle, __last, __len1, __len2, __comp);
      else
 std::__merge_adaptive
   (__first, __middle, __last, __len1, __len2, __buf.begin(),
    _DistanceType(__buf.size()), __comp);
    }
# 2572 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_less_iter());
    }
# 2613 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {

     

     


      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator __first1, _InputIterator __last1,
   _InputIterator __first2, _InputIterator __last2,
   _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::move(__first2, __last2, std::move(__first1, __last1, __result))

                  ;
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first, __first + __step_size,
   __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
        _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Pointer __buffer, _Distance __buffer_size,
      _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 2785 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first2, __first1))
   return false;
 else if (__comp(__first1, __first2))
   ++__first1;
 else
   {
     ++__first1;
     ++__first2;
   }

      return __first2 == __last2;
    }
# 2824 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


     


      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 2868 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {

     
     
     


     


      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 2903 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __next_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__i, __ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(__i, --__j))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 2952 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 2984 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __prev_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__ii, __i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(--__j, __i))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 3052 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;
      ;

      return std::__prev_permutation(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 3084 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;
      ;

      return std::__prev_permutation(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }




  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    __replace_copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result,
        _Predicate __pred, const _Tp& __new_value)
    {
      for (; __first != __last; ++__first, (void)++__result)
 if (__pred(__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3134 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     

      ;

      return std::__replace_copy_if(__first, __last, __result,
   __gnu_cxx::__ops::__iter_equals_val(__old_value),
           __new_value);
    }
# 3168 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    inline _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {

     
     

     

      ;

      return std::__replace_copy_if(__first, __last, __result,
    __gnu_cxx::__ops::__pred_iter(__pred),
           __new_value);
    }

  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }
# 3207 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }
# 3221 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }

  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
        _Compare __comp)
    {
      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, (void)++__next)
 if (__comp(__next, __first))
   return __next;
      return __next;
    }
# 3250 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 3274 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {

     
     


      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 3299 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _Tp>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {

     

      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }
# 3320 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    pair<_ForwardIterator, _ForwardIterator>
    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    {
      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min{}, __max{};
      if (__comp(__next, __first))
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (__comp(__first, __min))
  __min = __first;
       else if (!__comp(__first, __max))
  __max = __first;
       break;
     }

   if (__comp(__next, __first))
     {
       if (__comp(__next, __min))
  __min = __next;
       if (!__comp(__first, __max))
  __max = __first;
     }
   else
     {
       if (__comp(__first, __min))
  __min = __first;
       if (!__comp(__next, __max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }
# 3400 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 3428 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp)
    {

     
     


      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _Tp>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3540 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3571 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
       _BinaryPredicate __pred)
    {
      using _Cat1
 = typename iterator_traits<_ForwardIterator1>::iterator_category;
      using _Cat2
 = typename iterator_traits<_ForwardIterator2>::iterator_category;
      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
      constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
      if (__ra_iters)
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
 }



      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__ra_iters)
 {
   if (__first1 == __last1)
     return true;
 }
      else
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 == 0 && __d2 == 0)
     return true;
   if (__d1 != __d2)
     return false;
 }

      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches = std::__count_if(__first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches
       || std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3664 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      ;
      ;

      return
 std::__is_permutation(__first1, __last1, __first2, __last2,
         __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3691 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
     _BinaryPredicate __pred)
    {
      ;
      ;

      return std::__is_permutation(__first1, __last1, __first2, __last2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }
# 3767 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _IntType, typename _UniformRandomBitGenerator>
    pair<_IntType, _IntType>
    __gen_two_uniform_ints(_IntType __b0, _IntType __b1,
      _UniformRandomBitGenerator&& __g)
    {
      _IntType __x
 = uniform_int_distribution<_IntType>{0, (__b0 * __b1) - 1}(__g);
      return std::make_pair(__x / __b1, __x % __b1);
    }
# 3789 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator,
    typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _UniformRandomNumberGenerator&& __g)
    {

     

      ;

      if (__first == __last)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;

      typedef typename remove_reference<_UniformRandomNumberGenerator>::type
 _Gen;
      typedef typename common_type<typename _Gen::result_type, __ud_type>::type
 __uc_type;

      const __uc_type __urngrange = __g.max() - __g.min();
      const __uc_type __urange = __uc_type(__last - __first);

      if (__urngrange / __urange >= __urange)

      {
 _RandomAccessIterator __i = __first + 1;





 if ((__urange % 2) == 0)
 {
   __distr_type __d{0, 1};
   std::iter_swap(__i++, __first + __d(__g));
 }





 while (__i != __last)
 {
   const __uc_type __swap_range = __uc_type(__i - __first) + 1;

   const pair<__uc_type, __uc_type> __pospos =
     __gen_two_uniform_ints(__swap_range, __swap_range + 1, __g);

   std::iter_swap(__i++, __first + __pospos.first);
   std::iter_swap(__i++, __first + __pospos.second);
 }

 return;
      }

      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }







# 3876 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {

     
      ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }
# 3897 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {

     
     

      ;
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 3921 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {

     
     

      ;

      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 3952 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 3992 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4024 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      return std::__adjacent_find(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4049 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     
     


      ;

      return std::__adjacent_find(__first, __last,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
# 4074 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {

     
     

      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 4097 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {

     
     

      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 4137 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4176 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }
# 4211 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {

     
     

      ;

      return std::__search_n(__first, __last, __count,
        __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 4244 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {

     
     

      ;

      return std::__search_n(__first, __last, __count,
  __gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
    }
# 4292 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {

     
     


      ;

      for (; __first != __last; ++__first, (void)++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4329 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {

     
     
     


      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4362 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 4394 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 4426 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {

     
     

      ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 4457 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {

     



      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __gen();
      return __first;
    }
# 4493 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    __gnu_cxx::__ops::__iter_equal_to_iter(),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4533 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4566 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   {

     _RandomAccessIterator __j = __first
     + std::rand() % ((__i - __first) + 1);
     if (__i != __j)
       std::iter_swap(__i, __j);
   }
    }
# 4601 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

     _RandomNumberGenerator&& __rand)



    {

     

      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
   if (__i != __j)
     std::iter_swap(__i, __j);
 }
    }
# 4641 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 4674 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 4712 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {

     

     


      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4748 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 4787 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {

     

     


      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4824 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 4854 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {

     

     


      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 4915 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {

     
     
     

     

     


      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 4965 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {

     
     
     

     

     


      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 5029 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 5063 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {

     

     


      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
  _InputIterator2 __first2, _InputIterator2 __last2,
  _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first1, __first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5131 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5180 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   ++__first1;
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5250 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 5298 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5370 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 5420 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_symmetric_difference(_InputIterator1 __first1,
          _InputIterator1 __last1,
          _InputIterator2 __first2,
          _InputIterator2 __last2,
          _OutputIterator __result,
          _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5498 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
     __first2, __last2, __result,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 5548 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __min_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__first, __result))
   __result = __first;
      return __result;
    }
# 5601 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    _ForwardIterator
    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5626 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __max_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__result, __first))
   __result = __first;
      return __result;
    }
# 5665 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5690 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
           typename _Size, typename _UniformRandomBitGenerator>
    _RandomAccessIterator
    __sample(_InputIterator __first, _InputIterator __last, input_iterator_tag,
      _RandomAccessIterator __out, random_access_iterator_tag,
      _Size __n, _UniformRandomBitGenerator&& __g)
    {
      using __distrib_type = uniform_int_distribution<_Size>;
      using __param_type = typename __distrib_type::param_type;
      __distrib_type __d{};
      _Size __sample_sz = 0;
      while (__first != __last && __sample_sz != __n)
 {
   __out[__sample_sz++] = *__first;
   ++__first;
 }
      for (auto __pop_sz = __sample_sz; __first != __last;
   ++__first, (void) ++__pop_sz)
 {
   const auto __k = __d(__g, __param_type{0, __pop_sz});
   if (__k < __n)
     __out[__k] = *__first;
 }
      return __out + __sample_sz;
    }


  template<typename _ForwardIterator, typename _OutputIterator, typename _Cat,
           typename _Size, typename _UniformRandomBitGenerator>
    _OutputIterator
    __sample(_ForwardIterator __first, _ForwardIterator __last,
      forward_iterator_tag,
      _OutputIterator __out, _Cat,
      _Size __n, _UniformRandomBitGenerator&& __g)
    {
      using __distrib_type = uniform_int_distribution<_Size>;
      using __param_type = typename __distrib_type::param_type;
      using _USize = make_unsigned_t<_Size>;
      using _Gen = remove_reference_t<_UniformRandomBitGenerator>;
      using __uc_type = common_type_t<typename _Gen::result_type, _USize>;

      __distrib_type __d{};
      _Size __unsampled_sz = std::distance(__first, __last);
      __n = std::min(__n, __unsampled_sz);




      const __uc_type __urngrange = __g.max() - __g.min();
      if (__urngrange / __uc_type(__unsampled_sz) >= __uc_type(__unsampled_sz))


        {
   while (__n != 0 && __unsampled_sz >= 2)
     {
       const pair<_Size, _Size> __p =
  __gen_two_uniform_ints(__unsampled_sz, __unsampled_sz - 1, __g);

       --__unsampled_sz;
       if (__p.first < __n)
  {
    *__out++ = *__first;
    --__n;
  }

       ++__first;

       if (__n == 0) break;

       --__unsampled_sz;
       if (__p.second < __n)
  {
    *__out++ = *__first;
    --__n;
  }

       ++__first;
     }
        }



      for (; __n != 0; ++__first)
 if (__d(__g, __param_type{0, --__unsampled_sz}) < __n)
   {
     *__out++ = *__first;
     --__n;
   }
      return __out;
    }
# 5833 "/usr/include/c++/7/bits/stl_algo.h" 3

}
# 63 "/usr/include/c++/7/algorithm" 2 3
# 36 "/usr/local/include/interval/interval.hpp" 2 3


# 1 "/usr/local/include/fp_traits/fp_traits.hpp" 1 3
# 30 "/usr/local/include/fp_traits/fp_traits.hpp" 3
# 1 "/usr/include/c++/7/cmath" 1 3
# 39 "/usr/include/c++/7/cmath" 3
       
# 40 "/usr/include/c++/7/cmath" 3
# 31 "/usr/local/include/fp_traits/fp_traits.hpp" 2 3


# 1 "/usr/local/include/rounding_control/rounding_control.hpp" 1 3
# 30 "/usr/local/include/rounding_control/rounding_control.hpp" 3
# 1 "/usr/local/include/rounding_control/rounding_control_config.hpp" 1 3
# 31 "/usr/local/include/rounding_control/rounding_control.hpp" 2 3





namespace filib
{



 template <typename N, bool C>
 class





 rounding_control
 {
  public:



  static inline void setup();



  static inline void downward();



  static inline void upward();



  static inline void tozero();



  static inline void tonearest();



  static inline void reset();
 };
}

# 1 "/usr/local/include/rounding_control/rounding_control_double.hpp" 1 3
# 33 "/usr/local/include/rounding_control/rounding_control_double.hpp" 3
namespace filib
{



 template <bool C>
 class





 rounding_control<double,C>
 {
  public:



  static inline void setup();



  static inline void downward();



  static inline void upward();



  static inline void tozero();



  static inline void tonearest();



  static inline void reset();
 };
}
# 83 "/usr/local/include/rounding_control/rounding_control_double.hpp" 3
# 1 "/usr/local/include/rounding_control/rounding_control_double_iso9x.icc" 1 3
# 27 "/usr/local/include/rounding_control/rounding_control_double_iso9x.icc" 3
# 1 "/usr/include/c++/7/fenv.h" 1 3
# 32 "/usr/include/c++/7/fenv.h" 3
       
# 33 "/usr/include/c++/7/fenv.h" 3



# 1 "/usr/include/fenv.h" 1 3 4
# 26 "/usr/include/fenv.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/fenv.h" 2 3 4
# 64 "/usr/include/fenv.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fenv.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/fenv.h" 3 4
enum
  {
    FE_INVALID =

      0x01,
    __FE_DENORM = 0x02,
    FE_DIVBYZERO =

      0x04,
    FE_OVERFLOW =

      0x08,
    FE_UNDERFLOW =

      0x10,
    FE_INEXACT =

      0x20
  };







enum
  {
    FE_TONEAREST =

      0,
    FE_DOWNWARD =

      0x400,
    FE_UPWARD =

      0x800,
    FE_TOWARDZERO =

      0xc00
  };



typedef unsigned short int fexcept_t;






typedef struct
  {
    unsigned short int __control_word;
    unsigned short int __glibc_reserved1;
    unsigned short int __status_word;
    unsigned short int __glibc_reserved2;
    unsigned short int __tags;
    unsigned short int __glibc_reserved3;
    unsigned int __eip;
    unsigned short int __cs_selector;
    unsigned int __opcode:11;
    unsigned int __glibc_reserved4:5;
    unsigned int __data_offset;
    unsigned short int __data_selector;
    unsigned short int __glibc_reserved5;

    unsigned int __mxcsr;

  }
fenv_t;
# 106 "/usr/include/x86_64-linux-gnu/bits/fenv.h" 3 4
typedef struct
  {
    unsigned short int __control_word;
    unsigned short int __glibc_reserved;
    unsigned int __mxcsr;
  }
femode_t;
# 65 "/usr/include/fenv.h" 2 3 4

extern "C" {




extern int feclearexcept (int __excepts) throw ();



extern int fegetexceptflag (fexcept_t *__flagp, int __excepts) throw ();


extern int feraiseexcept (int __excepts) throw ();




extern int fesetexcept (int __excepts) throw ();




extern int fesetexceptflag (const fexcept_t *__flagp, int __excepts) throw ();



extern int fetestexcept (int __excepts) throw ();




extern int fetestexceptflag (const fexcept_t *__flagp, int __excepts) throw ();






extern int fegetround (void) throw () __attribute__ ((__pure__));


extern int fesetround (int __rounding_direction) throw ();






extern int fegetenv (fenv_t *__envp) throw ();




extern int feholdexcept (fenv_t *__envp) throw ();



extern int fesetenv (const fenv_t *__envp) throw ();




extern int feupdateenv (const fenv_t *__envp) throw ();







extern int fegetmode (femode_t *__modep) throw ();



extern int fesetmode (const femode_t *__modep) throw ();
# 161 "/usr/include/fenv.h" 3 4
extern int feenableexcept (int __excepts) throw ();




extern int fedisableexcept (int __excepts) throw ();


extern int fegetexcept (void) throw ();


}
# 37 "/usr/include/c++/7/fenv.h" 2 3
# 55 "/usr/include/c++/7/fenv.h" 3
namespace std
{

  using ::fenv_t;
  using ::fexcept_t;


  using ::feclearexcept;
  using ::fegetexceptflag;
  using ::feraiseexcept;
  using ::fesetexceptflag;
  using ::fetestexcept;

  using ::fegetround;
  using ::fesetround;

  using ::fegetenv;
  using ::feholdexcept;
  using ::fesetenv;
  using ::feupdateenv;
}
# 28 "/usr/local/include/rounding_control/rounding_control_double_iso9x.icc" 2 3
#pragma STDC FENV_ACCESS ON






   template<bool C>
   inline void filib::rounding_control<double,C>::setup()
   {



    fenv_t env;
    fegetenv(&env);
    feholdexcept(&env);



   }




   template<bool C>
   inline void filib::rounding_control<double,C>::downward()
   {
    fesetround(0x400);
   }




   template<bool C>
   inline void filib::rounding_control<double,C>::upward()
   {
    fesetround(0x800);
   }




   template<bool C>
   inline void filib::rounding_control<double,C>::tozero()
   {
    fesetround(0xc00);
   }




   template<bool C>
   inline void filib::rounding_control<double,C>::tonearest()
   {
    fesetround(0);
   }




   template<bool C>
   inline void filib::rounding_control<double,C>::reset()
   {
    if ( C )
     filib::rounding_control<double,C>::tonearest();
   }
# 84 "/usr/local/include/rounding_control/rounding_control_double.hpp" 2 3
# 79 "/usr/local/include/rounding_control/rounding_control.hpp" 2 3
# 1 "/usr/local/include/rounding_control/rounding_control_float.hpp" 1 3
# 33 "/usr/local/include/rounding_control/rounding_control_float.hpp" 3
namespace filib
{



 template <bool C>
 class





 rounding_control<float,C>
 {
  public:



  static inline void setup();



  static inline void downward();



  static inline void upward();



  static inline void tozero();



  static inline void tonearest();



  static inline void reset();
 };
}
# 83 "/usr/local/include/rounding_control/rounding_control_float.hpp" 3
# 1 "/usr/local/include/rounding_control/rounding_control_float_iso9x.icc" 1 3
# 28 "/usr/local/include/rounding_control/rounding_control_float_iso9x.icc" 3
#pragma STDC FENV_ACCESS ON






   template<bool C>
   inline void filib::rounding_control<float,C>::setup()
   {



    fenv_t env;
    fegetenv(&env);
    feholdexcept(&env);



   }




   template<bool C>
   inline void filib::rounding_control<float,C>::downward()
   {
    fesetround(0x400);
   }




   template<bool C>
   inline void filib::rounding_control<float,C>::upward()
   {
    fesetround(0x800);
   }




   template<bool C>
   inline void filib::rounding_control<float,C>::tozero()
   {
    fesetround(0xc00);
   }




   template<bool C>
   inline void filib::rounding_control<float,C>::tonearest()
   {
    fesetround(0);
   }




   template<bool C>
   inline void filib::rounding_control<float,C>::reset()
   {
    if ( C )
     filib::rounding_control<float,C>::tonearest();
   }
# 84 "/usr/local/include/rounding_control/rounding_control_float.hpp" 2 3
# 80 "/usr/local/include/rounding_control/rounding_control.hpp" 2 3
# 34 "/usr/local/include/fp_traits/fp_traits.hpp" 2 3
# 1 "/usr/local/include/rounding_control/rounding_control_stub.hpp" 1 3
# 30 "/usr/local/include/rounding_control/rounding_control_stub.hpp" 3
namespace filib
{
 struct rounding_control_stub
 {
  static void setup() {}
  static void downward() {}
  static void upward() {}
  static void tozero() {}
  static void tonearest() {}
  static void reset() {}
 };
}
# 35 "/usr/local/include/fp_traits/fp_traits.hpp" 2 3




namespace filib
{
 template<typename N>
 class





 fp_traits_base
 {
  public:



  static inline bool sign(N const &) ;



  static inline bool IsNaN(N const &) ;



  static inline bool IsInf(N const &) ;



  static inline N const & infinity() ;



  static inline N const & ninfinity() ;



  static inline N const & quiet_NaN() ;



  static inline N const & l_pi() ;



  static inline N const & u_pi() ;



  static inline int const & precision();



  static inline int precision(int);



  static inline N abs(N const &);
 };
# 105 "/usr/local/include/fp_traits/fp_traits.hpp" 3
 enum rounding_strategy
 {
  native_switched = 0,
  native_directed = 1,
  multiplicative = 2,
  no_rounding = 3,
  native_onesided_global = 5,
  pred_succ_rounding = 6
 };







 template <typename N, rounding_strategy K = native_switched>
 class





 fp_traits
 {
  public:



  static inline bool sign(N const &) ;



  static inline bool IsNaN(N const &) ;



  static inline bool IsInf(N const &) ;



  static inline N const & infinity() ;



  static inline N const & ninfinity() ;



  static inline N const & quiet_NaN() ;



  static inline N const & l_pi() ;



  static inline N const & u_pi() ;



  static inline int const & precision();



  static inline int precision(int);



  static inline N abs(N const &);




  template<bool r>
  static inline N upward_plus(
   N const &,
   N const &);



  template<bool r>
  static inline N downward_plus(
   N const &,
   N const &);



  template<bool r>
  static inline N tozero_plus(
   N const &,
   N const &);



  template<bool r>
  static inline N tonearest_plus(
   N const &,
   N const &);




  template<bool r>
  static inline N upward_minus(
   N const &,
   N const &);



  template<bool r>
  static inline N downward_minus(
   N const &,
   N const &);



  template<bool r>
  static inline N tozero_minus(
   N const &,
   N const &);



  template<bool r>
  static inline N tonearest_minus(
   N const &,
   N const &);




  template<bool r>
  static inline N upward_multiplies(
   N const &,
   N const &);



  template<bool r>
  static inline N downward_multiplies(
   N const &,
   N const &);



  template<bool r>
  static inline N tozero_multiplies(
   N const &,
   N const &);



  template<bool r>
  static inline N tonearest_multiplies(
   N const &,
   N const &);




  template<bool r>
  static inline N upward_divides(
   N const &,
   N const &);



  template<bool r>
  static inline N downward_divides(
   N const &,
   N const &);



  template<bool r>
  static inline N tozero_divides(
   N const &,
   N const &);



  template<bool r>
  static inline N tonearest_divides(
   N const &,
   N const &);
 };
}


# 1 "/usr/local/include/fp_traits/fp_traits_sse_const.hpp" 1 3
# 15 "/usr/local/include/fp_traits/fp_traits_sse_const.hpp" 3
namespace filib {
 namespace sse {
  enum rounddir {
   dir_nearest = 0,
   dir_down = 1,
   dir_up = 2,
   dir_trunc = 3
  };

  struct sseConstants {
   static u_int32_t mxcsr_down;
   static u_int32_t mxcsr_near;
   static u_int32_t mxcsr_up;
   static u_int32_t mxcsr_trunc;

   static void ssesetrounding(rounddir dir);
  };


  inline void sseroundnear() { sseConstants::ssesetrounding(dir_nearest); }
  inline void sserounddown() { sseConstants::ssesetrounding(dir_down); }
  inline void sseroundup() { sseConstants::ssesetrounding(dir_up); }
  inline void sseroundtrunc() { sseConstants::ssesetrounding(dir_trunc); }

  inline double sseadd(double a, double b, bool const reset) {
   if ( ! reset )
    asm volatile ("addsd %1, %0\n" : "+x" (a) : "x" (b) );
   else
    asm volatile ("addsd %1, %0\n" "ldmxcsr %2\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
   return a;
  }
  inline double ssesub(double a, double b, bool const reset) {
   if ( ! reset )
    asm volatile ("subsd %1, %0\n" : "+x" (a) : "x" (b) );
   else
    asm volatile ("subsd %1, %0\n" "ldmxcsr %2\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
   return a;
  }
  inline double ssemul(double a, double b, bool const reset) {
   if ( ! reset )
    asm volatile ("mulsd %1, %0\n" : "+x" (a) : "x" (b) );
   else
    asm volatile ("mulsd %1, %0\n" "ldmxcsr %2\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
   return a;
  }
  inline double ssediv(double a, double b, bool const reset) {
   if ( ! reset )
    asm volatile ("divsd %1, %0\n" : "+x" (a) : "x" (b) );
   else
    asm volatile ("divsd %1, %0\n" "ldmxcsr %2\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
   return a;
  }

  inline double sseadd(double a, double b, rounddir dir, bool const reset) {
   if ( ! reset ) {
    switch ( dir ) {
     case dir_nearest:
      asm volatile ("ldmxcsr %2\n" "addsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_down:
      asm volatile ("ldmxcsr %2\n" "addsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_down) );
      break;
     case dir_up:
      asm volatile ("ldmxcsr %2\n" "addsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_up) );
      break;
     case dir_trunc:
      asm volatile ("ldmxcsr %2\n" "addsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_trunc) );
      break;
    }
   }
   else {
    switch ( dir ) {
     case dir_nearest:
      asm volatile ("ldmxcsr %2\n" "addsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_down:
      asm volatile ("ldmxcsr %2\n" "addsd %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_down), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_up:
      asm volatile ("ldmxcsr %2\n" "addsd %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_up), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_trunc:
      asm volatile ("ldmxcsr %2\n" "addsd %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_trunc), "m" (sseConstants::mxcsr_near) );
      break;
    }
   }
   return a;
  }

  inline double ssesub(double a, double b, rounddir dir, bool const reset) {
   if ( ! reset ) {
    switch ( dir ) {
     case dir_nearest:
      asm volatile ("ldmxcsr %2\n" "subsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_down:
      asm volatile ("ldmxcsr %2\n" "subsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_down) );
      break;
     case dir_up:
      asm volatile ("ldmxcsr %2\n" "subsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_up) );
      break;
     case dir_trunc:
      asm volatile ("ldmxcsr %2\n" "subsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_trunc) );
      break;
    }
   }
   else {
    switch ( dir ) {
     case dir_nearest:
      asm volatile ("ldmxcsr %2\n" "subsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_down:
      asm volatile ("ldmxcsr %2\n" "subsd %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_down), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_up:
      asm volatile ("ldmxcsr %2\n" "subsd %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_up), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_trunc:
      asm volatile ("ldmxcsr %2\n" "subsd %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_trunc), "m" (sseConstants::mxcsr_near) );
      break;
    }
   }
   return a;
  }

  inline double ssemul(double a, double b, rounddir dir, bool const reset) {
   if ( ! reset ) {
    switch ( dir ) {
     case dir_nearest:
      asm volatile ("ldmxcsr %2\n" "mulsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_down:
      asm volatile ("ldmxcsr %2\n" "mulsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_down) );
      break;
     case dir_up:
      asm volatile ("ldmxcsr %2\n" "mulsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_up) );
      break;
     case dir_trunc:
      asm volatile ("ldmxcsr %2\n" "mulsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_trunc) );
      break;
    }
   }
   else {
    switch ( dir ) {
     case dir_nearest:
      asm volatile ("ldmxcsr %2\n" "mulsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_down:
      asm volatile ("ldmxcsr %2\n" "mulsd %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_down), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_up:
      asm volatile ("ldmxcsr %2\n" "mulsd %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_up), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_trunc:
      asm volatile ("ldmxcsr %2\n" "mulsd %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_trunc), "m" (sseConstants::mxcsr_near) );
      break;
    }
   }
   return a;
  }

  inline double ssediv(double a, double b, rounddir dir, bool const reset) {
   if ( ! reset ) {
    switch ( dir ) {
     case dir_nearest:
      asm volatile ("ldmxcsr %2\n" "divsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_down:
      asm volatile ("ldmxcsr %2\n" "divsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_down) );
      break;
     case dir_up:
      asm volatile ("ldmxcsr %2\n" "divsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_up) );
      break;
     case dir_trunc:
      asm volatile ("ldmxcsr %2\n" "divsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_trunc) );
      break;
    }
   }
   else {
    switch ( dir ) {
     case dir_nearest:
      asm volatile ("ldmxcsr %2\n" "divsd %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_down:
      asm volatile ("ldmxcsr %2\n" "divsd %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_down), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_up:
      asm volatile ("ldmxcsr %2\n" "divsd %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_up), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_trunc:
      asm volatile ("ldmxcsr %2\n" "divsd %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_trunc), "m" (sseConstants::mxcsr_near) );
      break;
    }
   }
   return a;
  }

  inline float sseadd(float a, float b, bool const reset) {
   if ( ! reset )
    asm volatile ("addss %1, %0\n" : "+x" (a) : "x" (b) );
   else
    asm volatile ("addss %1, %0\n" "ldmxcsr %2\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
   return a;
  }
  inline float ssesub(float a, float b, bool const reset) {
   if ( ! reset )
    asm volatile ("subss %1, %0\n" : "+x" (a) : "x" (b) );
   else
    asm volatile ("subss %1, %0\n" "ldmxcsr %2\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
   return a;
  }
  inline float ssemul(float a, float b, bool const reset) {
   if ( ! reset )
    asm volatile ("mulss %1, %0\n" : "+x" (a) : "x" (b) );
   else
    asm volatile ("mulss %1, %0\n" "ldmxcsr %2\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
   return a;
  }
  inline float ssediv(float a, float b, bool const reset) {
   if ( ! reset )
    asm volatile ("divss %1, %0\n" : "+x" (a) : "x" (b) );
   else
    asm volatile ("divss %1, %0\n" "ldmxcsr %2\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
   return a;
  }

  inline float sseadd(float a, float b, rounddir dir, bool const reset) {
   if ( ! reset ) {
    switch ( dir ) {
     case dir_nearest:
      asm volatile ("ldmxcsr %2\n" "addss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_down:
      asm volatile ("ldmxcsr %2\n" "addss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_down) );
      break;
     case dir_up:
      asm volatile ("ldmxcsr %2\n" "addss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_up) );
      break;
     case dir_trunc:
      asm volatile ("ldmxcsr %2\n" "addss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_trunc) );
      break;
    }
   }
   else {
    switch ( dir ) {
     case dir_nearest:
      asm volatile ("ldmxcsr %2\n" "addss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_down:
      asm volatile ("ldmxcsr %2\n" "addss %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_down), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_up:
      asm volatile ("ldmxcsr %2\n" "addss %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_up), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_trunc:
      asm volatile ("ldmxcsr %2\n" "addss %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_trunc), "m" (sseConstants::mxcsr_near) );
      break;
    }
   }
   return a;
  }

  inline float ssesub(float a, float b, rounddir dir, bool const reset) {
   if ( ! reset ) {
    switch ( dir ) {
     case dir_nearest:
      asm volatile ("ldmxcsr %2\n" "subss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_down:
      asm volatile ("ldmxcsr %2\n" "subss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_down) );
      break;
     case dir_up:
      asm volatile ("ldmxcsr %2\n" "subss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_up) );
      break;
     case dir_trunc:
      asm volatile ("ldmxcsr %2\n" "subss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_trunc) );
      break;
    }
   }
   else {
    switch ( dir ) {
     case dir_nearest:
      asm volatile ("ldmxcsr %2\n" "subss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_down:
      asm volatile ("ldmxcsr %2\n" "subss %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_down), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_up:
      asm volatile ("ldmxcsr %2\n" "subss %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_up), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_trunc:
      asm volatile ("ldmxcsr %2\n" "subss %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_trunc), "m" (sseConstants::mxcsr_near) );
      break;
    }
   }
   return a;
  }

  inline float ssemul(float a, float b, rounddir dir, bool const reset) {
   if ( ! reset ) {
    switch ( dir ) {
     case dir_nearest:
      asm volatile ("ldmxcsr %2\n" "mulss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_down:
      asm volatile ("ldmxcsr %2\n" "mulss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_down) );
      break;
     case dir_up:
      asm volatile ("ldmxcsr %2\n" "mulss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_up) );
      break;
     case dir_trunc:
      asm volatile ("ldmxcsr %2\n" "mulss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_trunc) );
      break;
    }
   }
   else {
    switch ( dir ) {
     case dir_nearest:
      asm volatile ("ldmxcsr %2\n" "mulss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_down:
      asm volatile ("ldmxcsr %2\n" "mulss %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_down), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_up:
      asm volatile ("ldmxcsr %2\n" "mulss %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_up), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_trunc:
      asm volatile ("ldmxcsr %2\n" "mulss %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_trunc), "m" (sseConstants::mxcsr_near) );
      break;
    }
   }
   return a;
  }

  inline float ssediv(float a, float b, rounddir dir, bool const reset) {
   if ( ! reset ) {
    switch ( dir ) {
     case dir_nearest:
      asm volatile ("ldmxcsr %2\n" "divss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_down:
      asm volatile ("ldmxcsr %2\n" "divss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_down) );
      break;
     case dir_up:
      asm volatile ("ldmxcsr %2\n" "divss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_up) );
      break;
     case dir_trunc:
      asm volatile ("ldmxcsr %2\n" "divss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_trunc) );
      break;
    }
   }
   else {
    switch ( dir ) {
     case dir_nearest:
      asm volatile ("ldmxcsr %2\n" "divss %1, %0\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_down:
      asm volatile ("ldmxcsr %2\n" "divss %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_down), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_up:
      asm volatile ("ldmxcsr %2\n" "divss %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_up), "m" (sseConstants::mxcsr_near) );
      break;
     case dir_trunc:
      asm volatile ("ldmxcsr %2\n" "divss %1, %0\n" "ldmxcsr %3\n" : "+x" (a) : "x" (b), "m" (sseConstants::mxcsr_trunc), "m" (sseConstants::mxcsr_near) );
      break;
    }
   }
   return a;
  }


 }
}
# 296 "/usr/local/include/fp_traits/fp_traits.hpp" 2 3
# 306 "/usr/local/include/fp_traits/fp_traits.hpp" 3
# 1 "/usr/local/include/fp_traits/fp_traits_double.hpp" 1 3
# 33 "/usr/local/include/fp_traits/fp_traits_double.hpp" 3
namespace filib
{
 template<>
 class





 fp_traits_base<double>
 {
  public:



   static double const min_val;



   static double const max_val;



   static double const nan_val;



   static double const inf_val;



   static double const ninf_val;



   static double const l_pi_val;



   static double const u_pi_val;




   static inline bool sign(double const &) ;



   static inline bool IsNaN(double const &) ;



    static inline bool IsInf(double const &) ;



   static inline double const & infinity() ;



   static inline double const & ninfinity() ;



   static inline double const & quiet_NaN() ;



   static inline double const & l_pi() ;



   static inline double const & u_pi() ;



   static inline double const & min() ;



   static inline double const & max() ;



   static inline double abs(double const &);
 };






 template<>
 class





  fp_traits<double,native_switched>
  :
  public rounding_control<double,true>,
  public fp_traits_base<double>
 {
  protected:



   static int precision_val;
  public:
  fp_traits();




  static inline void setup();




  static inline void reset();




  static inline int const & precision()
  {
   return precision_val;
  }



  static inline int precision(int const & new_val)
  {
   int old_val = precision_val;
   precision_val = new_val;
   return old_val;
  }





  template<bool r>
  static inline double upward_plus(
   double const &,
   double const &);



  template<bool r>
  static inline double downward_plus(
   double const &,
   double const &);



  template<bool r>
  static inline double tozero_plus(
   double const &,
   double const &);



  template<bool r>
  static inline double tonearest_plus(
   double const &,
   double const &);




  template<bool r>
  static inline double upward_minus(
   double const &,
   double const &);



  template<bool r>
  static inline double downward_minus(
   double const &,
   double const &);



  template<bool r>
  static inline double tozero_minus(
   double const &,
   double const &);



  template<bool r>
  static inline double tonearest_minus(
   double const &,
   double const &);




  template<bool r>
  static inline double upward_multiplies(
   double const &,
   double const &);



  template<bool r>
  static inline double downward_multiplies(
   double const &,
   double const &);



  template<bool r>
  static inline double tozero_multiplies(
   double const &,
   double const &);



  template<bool r>
  static inline double tonearest_multiplies(
   double const &,
   double const &);




  template<bool r>
  static inline double upward_divides(
   double const &,
   double const &);



  template<bool r>
  static inline double downward_divides(
   double const &,
   double const &);



  template<bool r>
  static inline double tozero_divides(
   double const &,
   double const &);



  template<bool r>
  static inline double tonearest_divides(
   double const &,
   double const &);


  static inline double upward_plus(double const &a, double const & b, bool r) {
   if ( r ) return upward_plus<true>(a,b); else return upward_plus<false>(a,b);
  }
  static inline double upward_minus(double const &a, double const & b, bool r) {
   if ( r ) return upward_minus<true>(a,b); else return upward_minus<false>(a,b);
  }
  static inline double upward_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return upward_multiplies<true>(a,b); else return upward_multiplies<false>(a,b);
  }
  static inline double upward_divides(double const &a, double const & b, bool r) {
   if ( r ) return upward_divides<true>(a,b); else return upward_divides<false>(a,b);
  }
  static inline double downward_plus(double const &a, double const & b, bool r) {
   if ( r ) return downward_plus<true>(a,b); else return downward_plus<false>(a,b);
  }
  static inline double downward_minus(double const &a, double const & b, bool r) {
   if ( r ) return downward_minus<true>(a,b); else return downward_minus<false>(a,b);
  }
  static inline double downward_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return downward_multiplies<true>(a,b); else return downward_multiplies<false>(a,b);
  }
  static inline double downward_divides(double const &a, double const & b, bool r) {
   if ( r ) return downward_divides<true>(a,b); else return downward_divides<false>(a,b);
  }
  static inline double tozero_plus(double const &a, double const & b, bool r) {
   if ( r ) return tozero_plus<true>(a,b); else return tozero_plus<false>(a,b);
  }
  static inline double tozero_minus(double const &a, double const & b, bool r) {
   if ( r ) return tozero_minus<true>(a,b); else return tozero_minus<false>(a,b);
  }
  static inline double tozero_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return tozero_multiplies<true>(a,b); else return tozero_multiplies<false>(a,b);
  }
  static inline double tozero_divides(double const &a, double const & b, bool r) {
   if ( r ) return tozero_divides<true>(a,b); else return tozero_divides<false>(a,b);
  }
  static inline double tonearest_plus(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_plus<true>(a,b); else return tonearest_plus<false>(a,b);
  }
  static inline double tonearest_minus(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_minus<true>(a,b); else return tonearest_minus<false>(a,b);
  }
  static inline double tonearest_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_multiplies<true>(a,b); else return tonearest_multiplies<false>(a,b);
  }
  static inline double tonearest_divides(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_divides<true>(a,b); else return tonearest_divides<false>(a,b);
  }

 };
 template<>
 class





  fp_traits<double,native_directed>
  :
  public rounding_control<double,false>,
  public fp_traits_base<double>
 {
  protected:



   static int precision_val;
  public:






  fp_traits();




  static inline void setup();




  static inline void reset();




  static inline int const & precision()
  {
   return precision_val;
  }



  static inline int precision(int const & new_val)
  {
   int old_val = precision_val;
   precision_val = new_val;
   return old_val;
  }




  template<bool r> static inline double upward_plus(
   double const &,
   double const &);



  template<bool r> static inline double downward_plus(
   double const &,
   double const &);



  template<bool r> static inline double tozero_plus(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_plus(
   double const &,
   double const &);




  template<bool r> static inline double upward_minus(
   double const &,
   double const &);



  template<bool r> static inline double downward_minus(
   double const &,
   double const &);



  template<bool r> static inline double tozero_minus(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_minus(
   double const &,
   double const &);




  template<bool r> static inline double upward_multiplies(
   double const &,
   double const &);



  template<bool r> static inline double downward_multiplies(
   double const &,
   double const &);



  template<bool r> static inline double tozero_multiplies(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_multiplies(
   double const &,
   double const &);




  template<bool r> static inline double upward_divides(
   double const &,
   double const &);



  template<bool r> static inline double downward_divides(
   double const &,
   double const &);



  template<bool r> static inline double tozero_divides(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_divides(
   double const &,
   double const &);

  static inline double upward_plus(double const &a, double const & b, bool r) {
   if ( r ) return upward_plus<true>(a,b); else return upward_plus<false>(a,b);
  }
  static inline double upward_minus(double const &a, double const & b, bool r) {
   if ( r ) return upward_minus<true>(a,b); else return upward_minus<false>(a,b);
  }
  static inline double upward_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return upward_multiplies<true>(a,b); else return upward_multiplies<false>(a,b);
  }
  static inline double upward_divides(double const &a, double const & b, bool r) {
   if ( r ) return upward_divides<true>(a,b); else return upward_divides<false>(a,b);
  }
  static inline double downward_plus(double const &a, double const & b, bool r) {
   if ( r ) return downward_plus<true>(a,b); else return downward_plus<false>(a,b);
  }
  static inline double downward_minus(double const &a, double const & b, bool r) {
   if ( r ) return downward_minus<true>(a,b); else return downward_minus<false>(a,b);
  }
  static inline double downward_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return downward_multiplies<true>(a,b); else return downward_multiplies<false>(a,b);
  }
  static inline double downward_divides(double const &a, double const & b, bool r) {
   if ( r ) return downward_divides<true>(a,b); else return downward_divides<false>(a,b);
  }
  static inline double tozero_plus(double const &a, double const & b, bool r) {
   if ( r ) return tozero_plus<true>(a,b); else return tozero_plus<false>(a,b);
  }
  static inline double tozero_minus(double const &a, double const & b, bool r) {
   if ( r ) return tozero_minus<true>(a,b); else return tozero_minus<false>(a,b);
  }
  static inline double tozero_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return tozero_multiplies<true>(a,b); else return tozero_multiplies<false>(a,b);
  }
  static inline double tozero_divides(double const &a, double const & b, bool r) {
   if ( r ) return tozero_divides<true>(a,b); else return tozero_divides<false>(a,b);
  }
  static inline double tonearest_plus(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_plus<true>(a,b); else return tonearest_plus<false>(a,b);
  }
  static inline double tonearest_minus(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_minus<true>(a,b); else return tonearest_minus<false>(a,b);
  }
  static inline double tonearest_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_multiplies<true>(a,b); else return tonearest_multiplies<false>(a,b);
  }
  static inline double tonearest_divides(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_divides<true>(a,b); else return tonearest_divides<false>(a,b);
  }

 };





 template<>
 class





 fp_traits<double,multiplicative>
  :
  public rounding_control_stub,
  public fp_traits_base<double>
 {
  protected:



   static int precision_val;
  public:






  fp_traits();




  static inline void setup();




  static inline void reset();




  static inline int const & precision()
  {
   return precision_val;
  }



  static inline int precision(int const & new_val)
  {
   int old_val = precision_val;
   precision_val = new_val;
   return old_val;
  }




  template<bool r> static inline double upward_plus(
   double const &,
   double const &);



  template<bool r> static inline double downward_plus(
   double const &,
   double const &);



  template<bool r> static inline double tozero_plus(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_plus(
   double const &,
   double const &);




  template<bool r> static inline double upward_minus(
   double const &,
   double const &);



  template<bool r> static inline double downward_minus(
   double const &,
   double const &);



  template<bool r> static inline double tozero_minus(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_minus(
   double const &,
   double const &);




  template<bool r> static inline double upward_multiplies(
   double const &,
   double const &);



  template<bool r> static inline double downward_multiplies(
   double const &,
   double const &);



  template<bool r> static inline double tozero_multiplies(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_multiplies(
   double const &,
   double const &);




  template<bool r> static inline double upward_divides(
   double const &,
   double const &);



  template<bool r> static inline double downward_divides(
   double const &,
   double const &);



  template<bool r> static inline double tozero_divides(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_divides(
   double const &,
   double const &);



  static inline double low ( double const & );



  static inline double high ( double const & );

  static inline double upward_plus(double const &a, double const & b, bool r) {
   if ( r ) return upward_plus<true>(a,b); else return upward_plus<false>(a,b);
  }
  static inline double upward_minus(double const &a, double const & b, bool r) {
   if ( r ) return upward_minus<true>(a,b); else return upward_minus<false>(a,b);
  }
  static inline double upward_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return upward_multiplies<true>(a,b); else return upward_multiplies<false>(a,b);
  }
  static inline double upward_divides(double const &a, double const & b, bool r) {
   if ( r ) return upward_divides<true>(a,b); else return upward_divides<false>(a,b);
  }
  static inline double downward_plus(double const &a, double const & b, bool r) {
   if ( r ) return downward_plus<true>(a,b); else return downward_plus<false>(a,b);
  }
  static inline double downward_minus(double const &a, double const & b, bool r) {
   if ( r ) return downward_minus<true>(a,b); else return downward_minus<false>(a,b);
  }
  static inline double downward_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return downward_multiplies<true>(a,b); else return downward_multiplies<false>(a,b);
  }
  static inline double downward_divides(double const &a, double const & b, bool r) {
   if ( r ) return downward_divides<true>(a,b); else return downward_divides<false>(a,b);
  }
  static inline double tozero_plus(double const &a, double const & b, bool r) {
   if ( r ) return tozero_plus<true>(a,b); else return tozero_plus<false>(a,b);
  }
  static inline double tozero_minus(double const &a, double const & b, bool r) {
   if ( r ) return tozero_minus<true>(a,b); else return tozero_minus<false>(a,b);
  }
  static inline double tozero_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return tozero_multiplies<true>(a,b); else return tozero_multiplies<false>(a,b);
  }
  static inline double tozero_divides(double const &a, double const & b, bool r) {
   if ( r ) return tozero_divides<true>(a,b); else return tozero_divides<false>(a,b);
  }
  static inline double tonearest_plus(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_plus<true>(a,b); else return tonearest_plus<false>(a,b);
  }
  static inline double tonearest_minus(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_minus<true>(a,b); else return tonearest_minus<false>(a,b);
  }
  static inline double tonearest_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_multiplies<true>(a,b); else return tonearest_multiplies<false>(a,b);
  }
  static inline double tonearest_divides(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_divides<true>(a,b); else return tonearest_divides<false>(a,b);
  }

 };




 template<>
 class





  fp_traits<double,no_rounding>
  :
  public rounding_control_stub,
  public fp_traits_base<double>
 {
  protected:



   static int precision_val;
  public:






  fp_traits();




  static inline void setup();




  static inline void reset();




  static inline int const & precision()
  {
   return precision_val;
  }



  static inline int precision(int const & new_val)
  {
   int old_val = precision_val;
   precision_val = new_val;
   return old_val;
  }




  template<bool r> static inline double upward_plus(
   double const &,
   double const &);



  template<bool r> static inline double downward_plus(
   double const &,
   double const &);



  template<bool r> static inline double tozero_plus(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_plus(
   double const &,
   double const &);




  template<bool r> static inline double upward_minus(
   double const &,
   double const &);



  template<bool r> static inline double downward_minus(
   double const &,
   double const &);



  template<bool r> static inline double tozero_minus(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_minus(
   double const &,
   double const &);




  template<bool r> static inline double upward_multiplies(
   double const &,
   double const &);



  template<bool r> static inline double downward_multiplies(
   double const &,
   double const &);



  template<bool r> static inline double tozero_multiplies(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_multiplies(
   double const &,
   double const &);




  template<bool r> static inline double upward_divides(
   double const &,
   double const &);



  template<bool r> static inline double downward_divides(
   double const &,
   double const &);



  template<bool r> static inline double tozero_divides(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_divides(
   double const &,
   double const &);

  static inline double upward_plus(double const &a, double const & b, bool r) {
   if ( r ) return upward_plus<true>(a,b); else return upward_plus<false>(a,b);
  }
  static inline double upward_minus(double const &a, double const & b, bool r) {
   if ( r ) return upward_minus<true>(a,b); else return upward_minus<false>(a,b);
  }
  static inline double upward_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return upward_multiplies<true>(a,b); else return upward_multiplies<false>(a,b);
  }
  static inline double upward_divides(double const &a, double const & b, bool r) {
   if ( r ) return upward_divides<true>(a,b); else return upward_divides<false>(a,b);
  }
  static inline double downward_plus(double const &a, double const & b, bool r) {
   if ( r ) return downward_plus<true>(a,b); else return downward_plus<false>(a,b);
  }
  static inline double downward_minus(double const &a, double const & b, bool r) {
   if ( r ) return downward_minus<true>(a,b); else return downward_minus<false>(a,b);
  }
  static inline double downward_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return downward_multiplies<true>(a,b); else return downward_multiplies<false>(a,b);
  }
  static inline double downward_divides(double const &a, double const & b, bool r) {
   if ( r ) return downward_divides<true>(a,b); else return downward_divides<false>(a,b);
  }
  static inline double tozero_plus(double const &a, double const & b, bool r) {
   if ( r ) return tozero_plus<true>(a,b); else return tozero_plus<false>(a,b);
  }
  static inline double tozero_minus(double const &a, double const & b, bool r) {
   if ( r ) return tozero_minus<true>(a,b); else return tozero_minus<false>(a,b);
  }
  static inline double tozero_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return tozero_multiplies<true>(a,b); else return tozero_multiplies<false>(a,b);
  }
  static inline double tozero_divides(double const &a, double const & b, bool r) {
   if ( r ) return tozero_divides<true>(a,b); else return tozero_divides<false>(a,b);
  }
  static inline double tonearest_plus(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_plus<true>(a,b); else return tonearest_plus<false>(a,b);
  }
  static inline double tonearest_minus(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_minus<true>(a,b); else return tonearest_minus<false>(a,b);
  }
  static inline double tonearest_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_multiplies<true>(a,b); else return tonearest_multiplies<false>(a,b);
  }
  static inline double tonearest_divides(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_divides<true>(a,b); else return tonearest_divides<false>(a,b);
  }

 };





 template<>
 class





 fp_traits<double,pred_succ_rounding>
  :
  public rounding_control_stub,
  public fp_traits_base<double>
 {
  protected:



   static int precision_val;
  public:






  fp_traits();




  static inline void setup();




  static inline void reset();




  static inline int const & precision()
  {
   return precision_val;
  }



  static inline int precision(int const & new_val)
  {
   int old_val = precision_val;
   precision_val = new_val;
   return old_val;
  }




  template<bool r> static inline double upward_plus(
   double const &,
   double const &);



  template<bool r> static inline double downward_plus(
   double const &,
   double const &);



  template<bool r> static inline double tozero_plus(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_plus(
   double const &,
   double const &);




  template<bool r> static inline double upward_minus(
   double const &,
   double const &);



  template<bool r> static inline double downward_minus(
   double const &,
   double const &);



  template<bool r> static inline double tozero_minus(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_minus(
   double const &,
   double const &);




  template<bool r> static inline double upward_multiplies(
   double const &,
   double const &);



  template<bool r> static inline double downward_multiplies(
   double const &,
   double const &);



  template<bool r> static inline double tozero_multiplies(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_multiplies(
   double const &,
   double const &);




  template<bool r> static inline double upward_divides(
   double const &,
   double const &);



  template<bool r> static inline double downward_divides(
   double const &,
   double const &);



  template<bool r> static inline double tozero_divides(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_divides(
   double const &,
   double const &);

  static inline double upward_plus(double const &a, double const & b, bool r) {
   if ( r ) return upward_plus<true>(a,b); else return upward_plus<false>(a,b);
  }
  static inline double upward_minus(double const &a, double const & b, bool r) {
   if ( r ) return upward_minus<true>(a,b); else return upward_minus<false>(a,b);
  }
  static inline double upward_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return upward_multiplies<true>(a,b); else return upward_multiplies<false>(a,b);
  }
  static inline double upward_divides(double const &a, double const & b, bool r) {
   if ( r ) return upward_divides<true>(a,b); else return upward_divides<false>(a,b);
  }
  static inline double downward_plus(double const &a, double const & b, bool r) {
   if ( r ) return downward_plus<true>(a,b); else return downward_plus<false>(a,b);
  }
  static inline double downward_minus(double const &a, double const & b, bool r) {
   if ( r ) return downward_minus<true>(a,b); else return downward_minus<false>(a,b);
  }
  static inline double downward_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return downward_multiplies<true>(a,b); else return downward_multiplies<false>(a,b);
  }
  static inline double downward_divides(double const &a, double const & b, bool r) {
   if ( r ) return downward_divides<true>(a,b); else return downward_divides<false>(a,b);
  }
  static inline double tozero_plus(double const &a, double const & b, bool r) {
   if ( r ) return tozero_plus<true>(a,b); else return tozero_plus<false>(a,b);
  }
  static inline double tozero_minus(double const &a, double const & b, bool r) {
   if ( r ) return tozero_minus<true>(a,b); else return tozero_minus<false>(a,b);
  }
  static inline double tozero_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return tozero_multiplies<true>(a,b); else return tozero_multiplies<false>(a,b);
  }
  static inline double tozero_divides(double const &a, double const & b, bool r) {
   if ( r ) return tozero_divides<true>(a,b); else return tozero_divides<false>(a,b);
  }
  static inline double tonearest_plus(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_plus<true>(a,b); else return tonearest_plus<false>(a,b);
  }
  static inline double tonearest_minus(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_minus<true>(a,b); else return tonearest_minus<false>(a,b);
  }
  static inline double tonearest_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_multiplies<true>(a,b); else return tonearest_multiplies<false>(a,b);
  }
  static inline double tonearest_divides(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_divides<true>(a,b); else return tonearest_divides<false>(a,b);
  }

 };





 template<>
 class





 fp_traits<double,native_onesided_global>
  :
  public rounding_control<double,false>,
  public fp_traits_base<double>
 {
  protected:



   static int precision_val;
  public:






  fp_traits();




  static inline void setup();




  static inline void reset();




  static inline int const & precision()
  {
   return precision_val;
  }



  static inline int precision(int const & new_val)
  {
   int old_val = precision_val;
   precision_val = new_val;
   return old_val;
  }




  template<bool r> static inline double upward_plus(
   double const &,
   double const &);



  template<bool r> static inline double downward_plus(
   double const &,
   double const &);



  template<bool r> static inline double tozero_plus(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_plus(
   double const &,
   double const &);




  template<bool r> static inline double upward_minus(
   double const &,
   double const &);



  template<bool r> static inline double downward_minus(
   double const &,
   double const &);



  template<bool r> static inline double tozero_minus(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_minus(
   double const &,
   double const &);




  template<bool r> static inline double upward_multiplies(
   double const &,
   double const &);



  template<bool r> static inline double downward_multiplies(
   double const &,
   double const &);



  template<bool r> static inline double tozero_multiplies(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_multiplies(
   double const &,
   double const &);




  template<bool r> static inline double upward_divides(
   double const &,
   double const &);



  template<bool r> static inline double downward_divides(
   double const &,
   double const &);



  template<bool r> static inline double tozero_divides(
   double const &,
   double const &);



  template<bool r> static inline double tonearest_divides(
   double const &,
   double const &);

  static inline double upward_plus(double const &a, double const & b, bool r) {
   if ( r ) return upward_plus<true>(a,b); else return upward_plus<false>(a,b);
  }
  static inline double upward_minus(double const &a, double const & b, bool r) {
   if ( r ) return upward_minus<true>(a,b); else return upward_minus<false>(a,b);
  }
  static inline double upward_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return upward_multiplies<true>(a,b); else return upward_multiplies<false>(a,b);
  }
  static inline double upward_divides(double const &a, double const & b, bool r) {
   if ( r ) return upward_divides<true>(a,b); else return upward_divides<false>(a,b);
  }
  static inline double downward_plus(double const &a, double const & b, bool r) {
   if ( r ) return downward_plus<true>(a,b); else return downward_plus<false>(a,b);
  }
  static inline double downward_minus(double const &a, double const & b, bool r) {
   if ( r ) return downward_minus<true>(a,b); else return downward_minus<false>(a,b);
  }
  static inline double downward_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return downward_multiplies<true>(a,b); else return downward_multiplies<false>(a,b);
  }
  static inline double downward_divides(double const &a, double const & b, bool r) {
   if ( r ) return downward_divides<true>(a,b); else return downward_divides<false>(a,b);
  }
  static inline double tozero_plus(double const &a, double const & b, bool r) {
   if ( r ) return tozero_plus<true>(a,b); else return tozero_plus<false>(a,b);
  }
  static inline double tozero_minus(double const &a, double const & b, bool r) {
   if ( r ) return tozero_minus<true>(a,b); else return tozero_minus<false>(a,b);
  }
  static inline double tozero_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return tozero_multiplies<true>(a,b); else return tozero_multiplies<false>(a,b);
  }
  static inline double tozero_divides(double const &a, double const & b, bool r) {
   if ( r ) return tozero_divides<true>(a,b); else return tozero_divides<false>(a,b);
  }
  static inline double tonearest_plus(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_plus<true>(a,b); else return tonearest_plus<false>(a,b);
  }
  static inline double tonearest_minus(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_minus<true>(a,b); else return tonearest_minus<false>(a,b);
  }
  static inline double tonearest_multiplies(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_multiplies<true>(a,b); else return tonearest_multiplies<false>(a,b);
  }
  static inline double tonearest_divides(double const &a, double const & b, bool r) {
   if ( r ) return tonearest_divides<true>(a,b); else return tonearest_divides<false>(a,b);
  }

 };
}

# 1 "/usr/local/include/ieee/primitive.hpp" 1 3
# 31 "/usr/local/include/ieee/primitive.hpp" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 36 "/usr/include/c++/7/stdlib.h" 3
# 1 "/usr/include/c++/7/cstdlib" 1 3
# 39 "/usr/include/c++/7/cstdlib" 3
       
# 40 "/usr/include/c++/7/cstdlib" 3
# 37 "/usr/include/c++/7/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;


  using std::at_quick_exit;


  using std::quick_exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 32 "/usr/local/include/ieee/primitive.hpp" 2 3




# 1 "/usr/include/c++/7/vector" 1 3
# 58 "/usr/include/c++/7/vector" 3
       
# 59 "/usr/include/c++/7/vector" 3




# 1 "/usr/include/c++/7/bits/stl_uninitialized.h" 1 3
# 67 "/usr/include/c++/7/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, (void)++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 113 "/usr/include/c++/7/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;




      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;


      return std::__uninitialized_copy<__is_trivial(_ValueType1)
           && __is_trivial(_ValueType2)
           && __assignable>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 179 "/usr/include/c++/7/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;


      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { return std::fill_n(__first, __n, __x); }
    };
# 242 "/usr/include/c++/7/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, (void)++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { return std::uninitialized_fill_n(__first, __n, __x); }
# 378 "/usr/include/c++/7/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }





  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   return std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
         && __assignable>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_default_n_1<__is_trivial(_ValueType)
           && __assignable>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { return std::__uninitialized_default_n(__first, __n); }

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_1
    {
      template<typename _ForwardIterator>
 static void
 __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_n_1
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 { return std::next(__first, __n); }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default_novalue(_ForwardIterator __first,
        _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_novalue_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      return __uninitialized_default_novalue_n_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue_n(__first, __n);
    }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return {__first, __cur};
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline pair<_RandomAccessIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    {
      auto __second_res = uninitialized_copy(__first, __first + __n, __result);
      auto __first_res = std::next(__first, __n);
      return {__first_res, __second_res};
    }
# 810 "/usr/include/c++/7/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }

  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
         _ForwardIterator __result)
    {
      return
 std::__uninitialized_copy_n_pair(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 882 "/usr/include/c++/7/bits/stl_uninitialized.h" 3

}
# 64 "/usr/include/c++/7/vector" 2 3
# 1 "/usr/include/c++/7/bits/stl_vector.h" 1 3
# 68 "/usr/include/c++/7/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 { }

 _Vector_impl(_Tp_alloc_type const& __a) noexcept
 : _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Vector_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a)),
   _M_start(), _M_finish(), _M_end_of_storage()
 { }


 void _M_swap_data(_Vector_impl& __x) noexcept
 {
   std::swap(_M_start, __x._M_start);
   std::swap(_M_finish, __x._M_finish);
   std::swap(_M_end_of_storage, __x._M_end_of_storage);
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a) noexcept
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Tp_alloc_type&& __a) noexcept
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_swap_data(__x._M_impl); }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      ~_Vector_base() noexcept
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
      }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 if (__p)
   _Tr::deallocate(_M_impl, __p, __n);
      }

    private:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 215 "/usr/include/c++/7/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
# 227 "/usr/include/c++/7/bits/stl_vector.h" 3
      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:






      vector()

      noexcept(is_nothrow_default_constructible<_Alloc>::value)

      : _Base() { }





      explicit
      vector(const allocator_type& __a) noexcept
      : _Base(__a) { }
# 282 "/usr/include/c++/7/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_default_initialize(__n); }
# 295 "/usr/include/c++/7/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 326 "/usr/include/c++/7/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
 _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 344 "/usr/include/c++/7/bits/stl_vector.h" 3
      vector(vector&& __x) noexcept
      : _Base(std::move(__x)) { }


      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }


      vector(vector&& __rv, const allocator_type& __m)
      noexcept(_Alloc_traits::_S_always_equal())
      : _Base(std::move(__rv), __m)
      {
 if (__rv.get_allocator() != __m)
   {
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }
# 383 "/usr/include/c++/7/bits/stl_vector.h" 3
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 409 "/usr/include/c++/7/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 { _M_initialize_dispatch(__first, __last, __false_type()); }
# 433 "/usr/include/c++/7/bits/stl_vector.h" 3
      ~vector() noexcept
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 446 "/usr/include/c++/7/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 460 "/usr/include/c++/7/bits/stl_vector.h" 3
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
 constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign()
   || _Alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 return *this;
      }
# 481 "/usr/include/c++/7/bits/stl_vector.h" 3
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
 return *this;
      }
# 500 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 517 "/usr/include/c++/7/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_dispatch(__first, __last, __false_type()); }
# 545 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      assign(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      using _Base::get_allocator;







      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
# 688 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 708 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   _M_fill_insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 740 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      size_type
      capacity() const noexcept
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const noexcept
      { return begin() == end(); }
# 779 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 794 "/usr/include/c++/7/bits/stl_vector.h" 3
      reference
      operator[](size_type __n) noexcept
      {
 ;
 return *(this->_M_impl._M_start + __n);
      }
# 812 "/usr/include/c++/7/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      {
 ;
 return *(this->_M_impl._M_start + __n);
      }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
# 843 "/usr/include/c++/7/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 861 "/usr/include/c++/7/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      {
 ;
 return *begin();
      }





      const_reference
      front() const noexcept
      {
 ;
 return *begin();
      }





      reference
      back() noexcept
      {
 ;
 return *(end() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return *(end() - 1);
      }
# 919 "/usr/include/c++/7/bits/stl_vector.h" 3
      _Tp*
      data() noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }

      const _Tp*
      data() const noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }
# 938 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_realloc_insert(end(), __x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>



 void

 emplace_back(_Args&&... __args);
# 974 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      pop_back() noexcept
      {
 ;
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      }
# 995 "/usr/include/c++/7/bits/stl_vector.h" 3
      template<typename... _Args>
 iterator
 emplace(const_iterator __position, _Args&&... __args)
 { return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }
# 1011 "/usr/include/c++/7/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1041 "/usr/include/c++/7/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_insert_rval(__position, std::move(__x)); }
# 1058 "/usr/include/c++/7/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, initializer_list<value_type> __l)
      {
 auto __offset = __position - cbegin();
 _M_range_insert(begin() + __offset, __l.begin(), __l.end(),
   std::random_access_iterator_tag());
 return begin() + __offset;
      }
# 1083 "/usr/include/c++/7/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(begin() + __offset, __n, __x);
 return begin() + __offset;
      }
# 1125 "/usr/include/c++/7/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(begin() + __offset,
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1177 "/usr/include/c++/7/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __position)
      { return _M_erase(begin() + (__position - cbegin())); }
# 1204 "/usr/include/c++/7/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)
      {
 const auto __beg = begin();
 const auto __cbeg = cbegin();
 return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
      }
# 1228 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      swap(vector& __x) noexcept
      {


                                                          ;

 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
      __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
 pointer
 _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
 {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1281 "/usr/include/c++/7/bits/stl_vector.h" 3
      template<typename _Integer>
 void
 _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
 {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
 void
 _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
 {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
 void
 _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   try {
     for (; __first != __last; ++__first)

       emplace_back(*__first);



   } catch(...) {
     clear();
     throw;
   }
 }


      template<typename _ForwardIterator>
 void
 _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
      }



      void
      _M_default_initialize(size_type __n)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
        _M_get_Tp_allocator());
      }
# 1364 "/usr/include/c++/7/bits/stl_vector.h" 3
      template<typename _Integer>
 void
 _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
 { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
 void
 _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }


      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);







      template<typename _Integer>
 void
 _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
 { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
 void
 _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
 {
   _M_range_insert(__pos, __first, __last,
     std::__iterator_category(__first));
 }


      template<typename _InputIterator>
 void
 _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();
# 1451 "/usr/include/c++/7/bits/stl_vector.h" 3
      struct _Temporary_value
      {
 template<typename... _Args>
   explicit
   _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
   {
     _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
         std::forward<_Args>(__args)...);
   }

 ~_Temporary_value()
 { _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }

 value_type&
 _M_val() { return *reinterpret_cast<_Tp*>(&__buf); }

      private:
 pointer
 _M_ptr() { return pointer_traits<pointer>::pointer_to(_M_val()); }

 vector* _M_this;
 typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
      };



      template<typename _Arg>
 void
 _M_insert_aux(iterator __position, _Arg&& __arg);

      template<typename... _Args>
 void
 _M_realloc_insert(iterator __position, _Args&&... __args);


      iterator
      _M_insert_rval(const_iterator __position, value_type&& __v);


      template<typename... _Args>
 iterator
 _M_emplace_aux(const_iterator __position, _Args&&... __args);


      iterator
      _M_emplace_aux(const_iterator __position, value_type&& __v)
      { return _M_insert_rval(__position, std::move(__v)); }



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos) noexcept
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }

      iterator
      _M_erase(iterator __position);

      iterator
      _M_erase(iterator __first, iterator __last);


    private:



      void
      _M_move_assign(vector&& __x, std::true_type) noexcept
      {
 vector __tmp(get_allocator());
 this->_M_impl._M_swap_data(__tmp._M_impl);
 this->_M_impl._M_swap_data(__x._M_impl);
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }



      void
      _M_move_assign(vector&& __x, std::false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), std::true_type());
 else
   {


     this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
    std::__make_move_if_noexcept_iterator(__x.end()));
     __x.clear();
   }
      }


      template<typename _Up>
 _Up*
 _M_data_ptr(_Up* __ptr) const noexcept
 { return __ptr; }


      template<typename _Ptr>
 typename std::pointer_traits<_Ptr>::element_type*
 _M_data_ptr(_Ptr __ptr) const
 { return empty() ? nullptr : std::__addressof(*__ptr); }
# 1586 "/usr/include/c++/7/bits/stl_vector.h" 3
    };
# 1599 "/usr/include/c++/7/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1616 "/usr/include/c++/7/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


}
# 65 "/usr/include/c++/7/vector" 2 3
# 1 "/usr/include/c++/7/bits/stl_bvector.h" 1 3
# 63 "/usr/include/c++/7/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }

    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() noexcept
    { *_M_p ^= _M_mask; }
  };


  inline void
  swap(_Bit_reference __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(_Bit_reference __x, bool& __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(bool& __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }


  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    iterator
    _M_const_cast() const
    { return *this; }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    _Bit_iterator
    _M_const_cast() const
    { return _Bit_iterator(_M_p, _M_offset); }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Bit_type>::other _Bit_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
 _Bit_alloc_traits;
      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_pointer _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Bvector_impl(_Bit_alloc_type&& __a)
 : _Bit_alloc_type(std::move(__a)), _M_start(), _M_finish(),
   _M_end_of_storage()
 { }


 _Bit_type*
 _M_end_addr() const noexcept
 {
   if (_M_end_of_storage)
     return std::__addressof(_M_end_of_storage[-1]) + 1;
   return 0;
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Bit_allocator()))
      {
 this->_M_impl._M_start = __x._M_impl._M_start;
 this->_M_impl._M_finish = __x._M_impl._M_finish;
 this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
 __x._M_impl._M_start = _Bit_iterator();
 __x._M_impl._M_finish = _Bit_iterator();
 __x._M_impl._M_end_of_storage = nullptr;
      }


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_pointer
      _M_allocate(size_t __n)
      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   {
     const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
     _Bit_alloc_traits::deallocate(_M_impl,
       _M_impl._M_end_of_storage - __n,
       __n);
     _M_impl._M_start = _M_impl._M_finish = _Bit_iterator();
     _M_impl._M_end_of_storage = _Bit_pointer();
   }
      }

      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };


}




namespace std __attribute__ ((__visibility__ ("default")))
{

# 542 "/usr/include/c++/7/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;
    typedef typename _Base::_Bit_pointer _Bit_pointer;
    typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;


    template<typename> friend struct hash;


  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_S_nword;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()

      noexcept(is_nothrow_default_constructible<allocator_type>::value)

    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }


    explicit
    vector(size_type __n, const allocator_type& __a = allocator_type())
    : vector(__n, false, __a)
    { }

    vector(size_type __n, const bool& __value,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_addr(),
  __value ? ~0 : 0);
    }
# 613 "/usr/include/c++/7/bits/stl_bvector.h" 3
    vector(const vector& __x)
    : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }


    vector(vector&& __x) noexcept
    : _Base(std::move(__x)) { }

    vector(vector&& __x, const allocator_type& __a)
    noexcept(_Bit_alloc_traits::_S_always_equal())
    : _Base(__a)
    {
      if (__x.get_allocator() == __a)
 {
   this->_M_impl._M_start = __x._M_impl._M_start;
   this->_M_impl._M_finish = __x._M_impl._M_finish;
   this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
   __x._M_impl._M_start = _Bit_iterator();
   __x._M_impl._M_finish = _Bit_iterator();
   __x._M_impl._M_end_of_storage = nullptr;
 }
      else
 {
   _M_initialize(__x.size());
   _M_copy_aligned(__x.begin(), __x.end(), begin());
   __x.clear();
 }
    }

    vector(const vector& __x, const allocator_type& __a)
    : _Base(__a)
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }

    vector(initializer_list<bool> __l,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize_range(__l.begin(), __l.end(),
     random_access_iterator_tag());
    }



    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_initialize_dispatch(__first, __last, __false_type()); }
# 679 "/usr/include/c++/7/bits/stl_bvector.h" 3
    ~vector() noexcept { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;

      if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
 {
   if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
     {
       this->_M_deallocate();
       std::__alloc_on_copy(_M_get_Bit_allocator(),
       __x._M_get_Bit_allocator());
       _M_initialize(__x.size());
     }
   else
     std::__alloc_on_copy(_M_get_Bit_allocator(),
     __x._M_get_Bit_allocator());
 }

      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }


    vector&
    operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
    {
      if (_Bit_alloc_traits::_S_propagate_on_move_assign()
   || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())
 {
   this->_M_deallocate();
   this->_M_impl._M_start = __x._M_impl._M_start;
   this->_M_impl._M_finish = __x._M_impl._M_finish;
   this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
   __x._M_impl._M_start = _Bit_iterator();
   __x._M_impl._M_finish = _Bit_iterator();
   __x._M_impl._M_end_of_storage = nullptr;
   std::__alloc_on_move(_M_get_Bit_allocator(),
          __x._M_get_Bit_allocator());
 }
      else
 {
   if (__x.size() > capacity())
     {
       this->_M_deallocate();
       _M_initialize(__x.size());
     }
   this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
          begin());
   __x.clear();
 }
      return *this;
    }

    vector&
    operator=(initializer_list<bool> __l)
    {
      this->assign (__l.begin(), __l.end());
      return *this;
    }






    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      void
      assign(_InputIterator __first, _InputIterator __last)
      { _M_assign_dispatch(__first, __last, __false_type()); }
# 775 "/usr/include/c++/7/bits/stl_bvector.h" 3
    void
    assign(initializer_list<bool> __l)
    { this->assign(__l.begin(), __l.end()); }


    iterator
    begin() noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const noexcept
    { return this->_M_impl._M_start; }

    iterator
    end() noexcept
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const noexcept
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin() noexcept
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const noexcept
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend() noexcept
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const noexcept
    { return const_reverse_iterator(begin()); }


    const_iterator
    cbegin() const noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    cend() const noexcept
    { return this->_M_impl._M_finish; }

    const_reverse_iterator
    crbegin() const noexcept
    { return const_reverse_iterator(end()); }

    const_reverse_iterator
    crend() const noexcept
    { return const_reverse_iterator(begin()); }


    size_type
    size() const noexcept
    { return size_type(end() - begin()); }

    size_type
    max_size() const noexcept
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize
 = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const noexcept
    { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
         - begin()); }

    bool
    empty() const noexcept
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
 __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                          ,
     __n, this->size());
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n)
    {
      if (__n > max_size())
 __throw_length_error(("vector::reserve"));
      if (capacity() < __n)
 _M_reallocate(__n);
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() noexcept { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x) noexcept
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);
      _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
        __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y) noexcept
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator

    insert(const_iterator __position, const bool& __x = bool())



    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position._M_const_cast(), __x);
      return begin() + __n;
    }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      iterator
      insert(const_iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 difference_type __offset = __position - cbegin();
 _M_insert_dispatch(__position._M_const_cast(),
      __first, __last, __false_type());
 return begin() + __offset;
      }
# 991 "/usr/include/c++/7/bits/stl_bvector.h" 3
    iterator
    insert(const_iterator __position, size_type __n, const bool& __x)
    {
      difference_type __offset = __position - cbegin();
      _M_fill_insert(__position._M_const_cast(), __n, __x);
      return begin() + __offset;
    }







    iterator
    insert(const_iterator __p, initializer_list<bool> __l)
    { return this->insert(__p, __l.begin(), __l.end()); }


    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator

    erase(const_iterator __position)



    { return _M_erase(__position._M_const_cast()); }

    iterator

    erase(const_iterator __first, const_iterator __last)



    { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }


    void
    shrink_to_fit()
    { _M_shrink_to_fit(); }


    void
    flip() noexcept
    {
      _Bit_type * const __end = this->_M_impl._M_end_addr();
      for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
        *__p = ~*__p;
    }

    void
    clear() noexcept
    { _M_erase_at_end(begin()); }


    template<typename... _Args>



      void

      emplace_back(_Args&&... __args)
      {
 push_back(bool(__args...));



      }

    template<typename... _Args>
      iterator
      emplace(const_iterator __pos, _Args&&... __args)
      { return insert(__pos, bool(__args...)); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      if (__n)
 {
   _Bit_pointer __q = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
   this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
 }
      else
 {
   this->_M_impl._M_end_of_storage = _Bit_pointer();
   this->_M_impl._M_start = iterator(0, 0);
 }
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }

    void
    _M_reallocate(size_type __n);


    bool
    _M_shrink_to_fit();






    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_addr(), __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_addr(), __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_addr(), __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }

    iterator
    _M_erase(iterator __pos);

    iterator
    _M_erase(iterator __first, iterator __last);
  };


}





namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };


}
# 66 "/usr/include/c++/7/vector" 2 3



# 1 "/usr/include/c++/7/bits/vector.tcc" 1 3
# 59 "/usr/include/c++/7/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>



      void

      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_realloc_insert(end(), std::forward<_Args>(__args)...);



      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == end())
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
   }
 else
   {

     const auto __pos = begin() + (__position - cbegin());


     _Temporary_value __x_copy(this, __x);
     _M_insert_aux(__pos, std::move(__x_copy._M_val()));



   }
      else

 _M_realloc_insert(begin() + (__position - cbegin()), __x);




      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
    this->_M_impl._M_start = nullptr;
    this->_M_impl._M_finish = nullptr;
    this->_M_impl._M_end_of_storage = nullptr;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp._M_impl._M_swap_data(this->_M_impl);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   this->_M_impl._M_finish =
     std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
       __n - size(), __val,
       _M_get_Tp_allocator());
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   _M_range_insert(end(), __first, __last,
     std::__iterator_category(__first));
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }


  template<typename _Tp, typename _Alloc>
    auto
    vector<_Tp, _Alloc>::
    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator
    {
      const auto __n = __position - cbegin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == cend())
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::move(__v));
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(begin() + __n, std::move(__v));
      else
 _M_realloc_insert(begin() + __n, std::move(__v));

      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      auto
      vector<_Tp, _Alloc>::
      _M_emplace_aux(const_iterator __position, _Args&&... __args)
      -> iterator
      {
 const auto __n = __position - cbegin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   if (__position == cend())
     {
       _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
           std::forward<_Args>(__args)...);
       ++this->_M_impl._M_finish;
     }
   else
     {



       _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
       _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
     }
 else
   _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);

 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _Arg>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Arg&& __arg)






    {
      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
          std::move(*(this->_M_impl._M_finish - 1))
                 );
      ++this->_M_impl._M_finish;



      std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                     ;



      *__position = std::forward<_Arg>(__arg);

    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_realloc_insert(iterator __position, _Args&&... __args)






    {
      const size_type __len =
 _M_check_len(size_type(1), "vector::_M_realloc_insert");
      const size_type __elems_before = __position - begin();
      pointer __new_start(this->_M_allocate(__len));
      pointer __new_finish(__new_start);
      try
 {





   _Alloc_traits::construct(this->_M_impl,
       __new_start + __elems_before,

       std::forward<_Args>(__args)...);



   __new_finish = pointer();

   __new_finish
     = std::__uninitialized_move_if_noexcept_a
     (this->_M_impl._M_start, __position.base(),
      __new_start, _M_get_Tp_allocator());

   ++__new_finish;

   __new_finish
     = std::__uninitialized_move_if_noexcept_a
     (__position.base(), this->_M_impl._M_finish,
      __new_finish, _M_get_Tp_allocator());
 }
      catch(...)
 {
   if (!__new_finish)
     _Alloc_traits::destroy(this->_M_impl,
       __new_start + __elems_before);
   else
     std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
   _M_deallocate(__new_start, __len);
   throw;
 }
      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      _M_deallocate(this->_M_impl._M_start,
      this->_M_impl._M_end_of_storage
      - this->_M_impl._M_start);
      this->_M_impl._M_start = __new_start;
      this->_M_impl._M_finish = __new_finish;
      this->_M_impl._M_end_of_storage = __new_start + __len;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {



       _Temporary_value __tmp(this, __x);
       value_type& __x_copy = __tmp._M_val();

       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    this->_M_impl._M_finish =
      std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
        __n - __elems_after,
        __x_copy,
        _M_get_Tp_allocator());
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = pointer();

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       this->_M_impl._M_finish =
  std::__uninitialized_default_n_a(this->_M_impl._M_finish,
       __n, _M_get_Tp_allocator());
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       const size_type __size = this->size();
       pointer __new_start(this->_M_allocate(__len));
       pointer __destroy_from = pointer();
       try
  {
    std::__uninitialized_default_n_a(__new_start + __size,
         __n, _M_get_Tp_allocator());
    __destroy_from = __new_start + __size;
    std::__uninitialized_move_if_noexcept_a(
        this->_M_impl._M_start, this->_M_impl._M_finish,
        __new_start, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (__destroy_from)
      std::_Destroy(__destroy_from, __destroy_from + __n,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_start + __size + __n;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      iterator __start(std::__addressof(*__q), 0);
      iterator __finish(_M_copy_aligned(begin(), end(), __start));
      this->_M_deallocate();
      this->_M_impl._M_start = __start;
      this->_M_impl._M_finish = __finish;
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   std::fill(__i, __i + difference_type(__n), __x);
   iterator __finish = std::copy(__position, end(),
     __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_pointer __q = this->_M_allocate(__len);
  iterator __start(std::__addressof(*__q), 0);
  iterator __i = _M_copy_aligned(begin(), __position, __start);
  __i = std::copy(__first, __last, __i);
  iterator __finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = __start;
  this->_M_impl._M_finish = __finish;
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   *__i++ = __x;
   iterator __finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }


  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      try
 {
   _M_reallocate(size());
   return true;
 }
      catch(...)
 { return false; }
    }



}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
# 70 "/usr/include/c++/7/vector" 2 3
# 37 "/usr/local/include/ieee/primitive.hpp" 2 3







namespace filib
{
 struct interval_io_exception : public std::exception
 {
  private:
  std::string desc;

  public:
  interval_io_exception(std::string const & rdesc) throw()
  : desc(rdesc) {}
  virtual ~interval_io_exception() throw() {};
  virtual char const * what() const throw()
  { return desc.c_str(); }
 };

 typedef union
 {
  double f;

  struct
  {
# 93 "/usr/local/include/ieee/primitive.hpp" 3
    unsigned int mant1 :32;
    unsigned int mant0 :20;
    unsigned int expo :11;
    unsigned int sign : 1;
# 107 "/usr/local/include/ieee/primitive.hpp" 3
  } ieee;
 } a_diee;

 typedef union
 {
  float f;

  struct
  {

    unsigned int mant :23;
    unsigned int expo : 8;
    unsigned int sign : 1;
# 129 "/usr/local/include/ieee/primitive.hpp" 3
  } ieee;
 } a_fiee;

 class





 primitive
 {
  public:

  static inline double const & MIN()
  {
   return min;
  }

  static inline double const & MIN_NORM()
  {
   return minNorm;
  }

  static inline double const & MAX()
  {
   return max;
  }

  static inline double const & POS_INFTY()
  {
   return posInf;
  }

  static inline double const & NEG_INFTY()
  {
   return negInf;
  }

  static inline double const & QUIET_NAN()
  {
   return qNaN;
  }

  static void basicBitImage(double const & d, std::ostream &os);
  static void basicBitImage(float const & d, std::ostream &os);
  static void basicHexImage(double const & d, std::ostream &os);
  static void basicHexImage(float const & d, std::ostream &os);

  static inline bool isInfinite(double const & x)
  {
   a_diee const * y = reinterpret_cast<a_diee const *>(&x);
   return
    y->ieee.expo == 0x7FF &&
    y->ieee.mant0 == 0 &&
    y->ieee.mant1 == 0;
  }

  static inline bool isNaN(double const & x)
  {
# 199 "/usr/local/include/ieee/primitive.hpp" 3
    return x != x;

  }

  static inline bool isRegular(double const & x)
  {
   return !(isInfinite(x) || isNaN(x));
  }

  static inline bool sign(double const & x)
  {
   a_diee const * y = reinterpret_cast<a_diee const *>(&x);
   return y->ieee.sign;
  }

  static inline double abs(double const & x)
  {
   a_diee y;
   y.f = x;
   y.ieee.sign = 0;
   return y.f;
  }

  static inline bool isdenorm(double const & x)
  {
   a_diee y;
   y.f = x;
   return (y.ieee.expo == 0) && (y.ieee.mant0 || y.ieee.mant1);
  }

  static inline bool isdenormorzero(double const & x)
  {
   a_diee y;
   y.f = x;
   return (y.ieee.expo == 0);
  }

  static inline bool isdenormorzerof(float const & x)
  {
   a_fiee y;
   y.f = x;
   return (y.ieee.expo == 0);
  }

  static inline double compose(
   unsigned int const & rsign,
   unsigned int const & rexpo,
   unsigned int const & rmantUpper,
   unsigned int const & rmantLower
  )
  {
   a_diee f;
   f.ieee.sign = rsign;
   f.ieee.expo = rexpo;
   f.ieee.mant0 = rmantUpper;
   f.ieee.mant1 = rmantLower;

   return f.f;
  }

  static inline float composef(
   unsigned int const & rsign,
   unsigned int const & rexpo,
   unsigned int const & rmant
  )
  {
   a_fiee f;
   f.ieee.sign = rsign;
   f.ieee.expo = rexpo;
   f.ieee.mant = rmant;
   return f.f;
  }

  static inline void decompose(
   double const & rx,
   unsigned int & rsign,
   unsigned int & rexpo,
   unsigned int & rmantUpper,
   unsigned int & rmantLower
  )
  {
   a_diee const * f = reinterpret_cast<a_diee const *>(&rx);
   rsign = f->ieee.sign;
   rexpo = f->ieee.expo;
   rmantUpper = f->ieee.mant0;
   rmantLower = f->ieee.mant1;
  }

  static inline void decomposef(
   float const & rx,
   unsigned int & rsign,
   unsigned int & rexpo,
   unsigned int & rmant
  )
  {
   a_fiee const * f = reinterpret_cast<a_fiee const *>(&rx);
   rsign = f->ieee.sign;
   rexpo = f->ieee.expo;
   rmant = f->ieee.mant;
  }

  static inline double ulp(double const & x)
  {
   if (isInfinite(x))
   {
    return POS_INFTY();
   }
   else if (isNaN(x))
   {
    return x;
   }
   else
   {
    a_diee ulpx;
    ulpx.f = x;
    ulpx.ieee.sign = 0;




    if (ulpx.ieee.expo == 0)
    {
     ulpx.ieee.mant0 = 0;
     ulpx.ieee.mant1 = 1;
     return ulpx.f;
    }



    else if (ulpx.ieee.expo > 52)
    {
     ulpx.ieee.expo -= 52;
     ulpx.ieee.mant0 = 0;
     ulpx.ieee.mant1 = 0;
     return ulpx.f;
    }



    else
    {
     unsigned int n = 52-ulpx.ieee.expo;
     ulpx.ieee.expo = 0;
     if (n < 20)
     {
      ulpx.ieee.mant0 = (0x80000 >> n);
      ulpx.ieee.mant1 = 0;
     }
     else
     {
      ulpx.ieee.mant0 = 0;
      ulpx.ieee.mant1 = (0x80000000 >> (n-20));
     }
     return ulpx.f;
    }
   }
  }

  static void print(double const & x, std::ostream &os);
  static void bitImage(double const & x, std::ostream &os);
# 367 "/usr/local/include/ieee/primitive.hpp" 3
  static inline double basic_pred(double const & y)
  {
   a_diee su;
   su.f=y;




   if (su.ieee.sign==1)
   {
    if (su.ieee.expo != 2047) {
     if (su.ieee.mant1==0xffffffff)
     {
      su.ieee.mant1=0;

      if (su.ieee.mant0==0xfffff)
      {
       su.ieee.mant0=0;
       su.ieee.expo++;
      }
      else
      {
       su.ieee.mant0++;
      }
     }
     else
     {
      su.ieee.mant1++;
     }
    }
   }



   else
   {
    if (su.ieee.expo != 2047)
    {
     if (su.ieee.sign==0 && su.ieee.expo==0 && su.ieee.mant0==0 && su.ieee.mant1==0)
     {
      su.ieee.sign=1;
      su.ieee.mant1=1;
     }
     else
     {
      if (su.ieee.mant1==0)
      {
       su.ieee.mant1=0xffffffff;

       if (su.ieee.mant0==0)
       {
        su.ieee.mant0=0xfffff;
        su.ieee.expo--;
       }
       else
       {
        su.ieee.mant0--;
       }
      }
      else
      {
       su.ieee.mant1--;
      }
     }
    }



    else if (su.ieee.mant0 == 0 && su.ieee.mant1 == 0)
    {
     su.ieee.expo = 2046;
     su.ieee.mant0 = 0xfffff;
     su.ieee.mant1 = 0xffffffff;
    }
   }

   return su.f;
  }




  static inline double basic_succ(double const & y)
  {
   a_diee su;
   su.f=y;




   if (su.ieee.sign==0)
   {
    if (su.ieee.expo!=2047)
    {
     if (su.ieee.mant1==0xffffffff)
     {
      su.ieee.mant1=0;

      if (su.ieee.mant0==1048575)
      {
       su.ieee.mant0=0;
       su.ieee.expo++;
      }
      else
      {
       su.ieee.mant0++;
      }
     }
     else
     {
      su.ieee.mant1++;
     }
    }
   }



   else
   {
    if (su.ieee.expo!=2047)
    {
     if (su.ieee.sign==1 && su.ieee.expo==0 && su.ieee.mant0==0 && su.ieee.mant1==0)
     {
      su.ieee.sign=0;
      su.ieee.mant1=1;
     }
     else
     {
      if (su.ieee.mant1==0)
      {
       su.ieee.mant1=0xffffffff;

       if (su.ieee.mant0==0)
       {
        su.ieee.mant0=1048575;
        su.ieee.expo--;
       }
       else
       {
        su.ieee.mant0--;
       }
      }
      else
      {
       su.ieee.mant1--;
      }
     }
    }



    else if (su.ieee.mant0 == 0 && su.ieee.mant1 == 0)
    {
     su.ieee.expo = 2046;
     su.ieee.mant0 = 0xfffff;
     su.ieee.mant1 = 0xffffffff;
    }
   }

   return su.f;
  }

  static inline double pred(double const & x)
  {
   a_diee f;
   f.f = x;

   unsigned int index = f.ieee.expo;

   if (f.ieee.sign == 0)
   {
    if (f.ieee.mant1 == 0 && f.ieee.mant0 == 0)
    {



     if (f.ieee.expo == 2047)
      return MAX();



     else if (f.ieee.expo != 0)
      index--;
    }
   }



   else if (
    f.ieee.expo == 0x7FE &&
    f.ieee.mant0 == 0xFFFFF &&
    f.ieee.mant1 == 0xFFFFFFFF)
    return NEG_INFTY();

   return x-psTable.ULP[index];
  }
  static inline double succ(double const & x)
  {
   a_diee f;
   f.f = x;

   unsigned int index = f.ieee.expo;

   if (f.ieee.sign == 1)
   {
    if (f.ieee.mant1 == 0 && f.ieee.mant0 == 0)
    {



     if (f.ieee.expo == 2047)
      return -MAX();



     else if (f.ieee.expo != 0)
      index--;
    }
   }



   else if (
    f.ieee.expo == 0x7FE &&
    f.ieee.mant0 == 0xFFFFF &&
    f.ieee.mant1 == 0xFFFFFFFF)
    return POS_INFTY();

   return x+psTable.ULP[index];
  }
# 609 "/usr/local/include/ieee/primitive.hpp" 3
  private:

  static double min;
  static double minNorm;
  static double max;
  static double posInf;
  static double negInf;
  static double qNaN;

  static double computeMin();
  static double computeMinNorm();
  static double computeMax();
  static double computePosInf();
  static double computeNegInf();
  static double computeQNaN();





  class PredSuccTable
  {
   public:
    PredSuccTable();
    ~PredSuccTable();

    double *ULP;
  };

  static PredSuccTable psTable;


  public:




  static double const zero_pred;
  static double const zero_succ;
  static double const one_pred;
  static double const one_succ;

  static float const zero_fpred;
  static float const zero_fsucc;
  static float const one_fpred;
  static float const one_fsucc;
 };






 void readBitSet(std::istream & in, unsigned int n0, unsigned char * a) throw(interval_io_exception);






 void readHexSet(std::istream & in, unsigned int n0, unsigned char * a) throw(interval_io_exception);






 void readChar(std::istream& in, char c0) throw(interval_io_exception);

 template <typename N>
 N constructFromBitSet(std::istream & in) throw(interval_io_exception)
 {
  throw interval_io_exception("constructFromBitSet() called for unsupported type");
 }
 template <typename N>
 N constructFromBitSet(std::string & in) throw(interval_io_exception)
 {
  throw interval_io_exception("constructFromBitSet() called for unsupported type");
 }
 template <typename N>
 N constructFromBitSet(char const * in) throw(interval_io_exception)
 {
  throw interval_io_exception("constructFromBitSet() called for unsupported type");
 }

 template <typename N>
 N constructFromHexSet(std::istream & in) throw(interval_io_exception)
 {
  throw interval_io_exception("constructFromHexSet() called for unsupported type");
 }
 template <typename N>
 N constructFromHexSet(std::string & in) throw(interval_io_exception)
 {
  throw interval_io_exception("constructFromHexSet() called for unsupported type");
 }
 template <typename N>
 N constructFromHexSet(char const * in) throw(interval_io_exception)
 {
  throw interval_io_exception("constructFromHexSet() called for unsupported type");
 }

 template<typename WS>
 void eatWS(std::istream & in)
 {
  char c = in.get();

  while ( in.good() && WS::isSpace(c) )
   c = in.get();

  in.putback(c);
 }

 template<typename T>
 struct





 whitespace
 {
  static int isSpace(int);
 };

 template <>





 double constructFromBitSet<double>(std::istream & in) throw(interval_io_exception);
 template <>





 float constructFromBitSet<float>(std::istream & in) throw(interval_io_exception);
 template <>





 float constructFromBitSet<float>(std::string & in) throw(interval_io_exception);
 template <>





 double constructFromBitSet<double>(std::string & in) throw(interval_io_exception);
 template <>





 float constructFromBitSet<float>(char const * in) throw(interval_io_exception);
 template <>





 double constructFromBitSet<double>(char const * in) throw(interval_io_exception);

 template <>
 double constructFromHexSet<double>(std::istream & in) throw(interval_io_exception);
 template <>
 float constructFromHexSet<float>(std::istream & in) throw(interval_io_exception);
 template <>
 float constructFromHexSet<float>(std::string & in) throw(interval_io_exception);
 template <>
 double constructFromHexSet<double>(std::string & in) throw(interval_io_exception);
 template <>
 float constructFromHexSet<float>(char const * in) throw(interval_io_exception);
 template <>
 double constructFromHexSet<double>(char const * in) throw(interval_io_exception);

 template<>
 int whitespace<char>::isSpace(int arg);

 template <typename N, bool upDo>
 N inferFromString(std::string const &) throw(interval_io_exception)
 {
  throw interval_io_exception("inferFromString() called for unsupported type");
 }
 template <>





 double inferFromString<double,false>(std::string const & )
 throw(interval_io_exception);
 template <>





 double inferFromString<double,true>(std::string const & )
 throw(interval_io_exception);
 template <>





 float inferFromString<float,false>(std::string const & )
 throw(interval_io_exception);
 template <>





 float inferFromString<float,true>(std::string const & )
 throw(interval_io_exception);
}
# 1385 "/usr/local/include/fp_traits/fp_traits_double.hpp" 2 3
# 1 "/usr/local/include/fp_traits/fp_traits_base_double.icc" 1 3
# 28 "/usr/local/include/fp_traits/fp_traits_base_double.icc" 3

 inline bool filib::fp_traits_base<double>::sign(double const & n)
 {
  filib::a_diee const * t = reinterpret_cast<filib::a_diee const *>(&n);
  return t->ieee.sign;
 }

 inline bool filib::fp_traits_base<double>::IsNaN(double const & n)
 {
  return (n != n);
 }

 inline bool filib::fp_traits_base<double>::IsInf(double const & n)
 {
  return (n < -max_val) || (n > max_val);
 }

 inline double filib::fp_traits_base<double>::abs(double const & n)
 {
  filib::a_diee d;
  d.f = n;
  d.ieee.sign = false;
  return d.f;
 }

 inline double const & filib::fp_traits_base<double>::infinity()
 {
  return inf_val;
 }

 inline double const & filib::fp_traits_base<double>::ninfinity()
 {
  return ninf_val;
 }

 inline double const & filib::fp_traits_base<double>::quiet_NaN()
 {
  return nan_val;
 }

 inline double const & filib::fp_traits_base<double>::min()
 {
  return min_val;
 }

 inline double const & filib::fp_traits_base<double>::max()
 {
  return max_val;
 }

 inline double const & filib::fp_traits_base<double>::l_pi()
 {
  return l_pi_val;
 }

 inline double const & filib::fp_traits_base<double>::u_pi()
 {
  return u_pi_val;
 }
# 1386 "/usr/local/include/fp_traits/fp_traits_double.hpp" 2 3


# 1 "/usr/local/include/fp_traits/fp_traits_double_sse_native_switched.icc" 1 3
# 27 "/usr/local/include/fp_traits/fp_traits_double_sse_native_switched.icc" 3

 inline void filib::fp_traits<double,filib::native_switched>::setup()
 {
  ::filib::sse::sseroundnear();
 }

 inline void filib::fp_traits<double,filib::native_switched>::reset()
 {
  ::filib::sse::sseroundnear();
 }


 inline filib::fp_traits<double,filib::native_switched>::fp_traits()
 {
 }


 template<bool r> inline double filib::fp_traits<double,filib::native_switched>::upward_plus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,::filib::sse::dir_up,r);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_switched>::downward_plus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,::filib::sse::dir_down,r);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_switched>::tozero_plus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,::filib::sse::dir_trunc,r);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_switched>::tonearest_plus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,::filib::sse::dir_nearest,r);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_switched>::upward_minus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,::filib::sse::dir_up,r);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_switched>::downward_minus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,::filib::sse::dir_down,r);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_switched>::tozero_minus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,::filib::sse::dir_trunc,r);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_switched>::tonearest_minus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,::filib::sse::dir_nearest,r);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_switched>::upward_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,::filib::sse::dir_up,r);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_switched>::downward_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,::filib::sse::dir_down,r);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_switched>::tozero_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,::filib::sse::dir_trunc,r);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_switched>::tonearest_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,::filib::sse::dir_nearest,r);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_switched>::upward_divides(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,::filib::sse::dir_up,r);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_switched>::downward_divides(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,::filib::sse::dir_down,r);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_switched>::tozero_divides(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,::filib::sse::dir_trunc,r);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_switched>::tonearest_divides(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,::filib::sse::dir_nearest,r);
 }
# 1389 "/usr/local/include/fp_traits/fp_traits_double.hpp" 2 3
# 1 "/usr/local/include/fp_traits/fp_traits_double_sse_native_directed.icc" 1 3
# 27 "/usr/local/include/fp_traits/fp_traits_double_sse_native_directed.icc" 3

 inline void filib::fp_traits<double,filib::native_directed>::setup()
 {
 }

 inline void filib::fp_traits<double,filib::native_directed>::reset()
 {
 }


 inline filib::fp_traits<double,filib::native_directed>::fp_traits()
 {
 }


 template<bool r> inline double filib::fp_traits<double,filib::native_directed>::upward_plus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,::filib::sse::dir_up,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_directed>::downward_plus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,::filib::sse::dir_down,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_directed>::tozero_plus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,::filib::sse::dir_trunc,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_directed>::tonearest_plus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,::filib::sse::dir_nearest,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_directed>::upward_minus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,::filib::sse::dir_up,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_directed>::downward_minus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,::filib::sse::dir_down,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_directed>::tozero_minus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,::filib::sse::dir_trunc,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_directed>::tonearest_minus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,::filib::sse::dir_nearest,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_directed>::upward_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,::filib::sse::dir_up,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_directed>::downward_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,::filib::sse::dir_down,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_directed>::tozero_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,::filib::sse::dir_trunc,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_directed>::tonearest_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,::filib::sse::dir_nearest,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_directed>::upward_divides(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,::filib::sse::dir_up,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_directed>::downward_divides(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,::filib::sse::dir_down,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_directed>::tozero_divides(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,::filib::sse::dir_trunc,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_directed>::tonearest_divides(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,::filib::sse::dir_nearest,false);
 }
# 1390 "/usr/local/include/fp_traits/fp_traits_double.hpp" 2 3
# 1 "/usr/local/include/fp_traits/fp_traits_double_sse_native_onesided_global.icc" 1 3
# 27 "/usr/local/include/fp_traits/fp_traits_double_sse_native_onesided_global.icc" 3

 inline void filib::fp_traits<double,filib::native_onesided_global>::setup() {
  ::filib::sse::sserounddown();
 }

 inline void filib::fp_traits<double,filib::native_onesided_global>::reset() {
  ::filib::sse::sseroundnear();
 }


 inline filib::fp_traits<double,filib::native_onesided_global>::fp_traits()
 {
 }


 template<bool r> inline double filib::fp_traits<double,filib::native_onesided_global>::upward_plus(
   double const & op1,
   double const & op2
  )
 {
  return -::filib::sse::ssesub(-op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_onesided_global>::downward_plus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_onesided_global>::tozero_plus(
   double const &,
   double const &
  )
 {
  std::cerr
   << "filib.0: filib::fp_traits<double,filib::native_onesided_global>::tozero_plus" << std::endl
   << "is not supported." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_onesided_global>::tonearest_plus(
   double const &,
   double const &
  )
 {
  std::cerr
   << "filib.0: filib::fp_traits<double,filib::native_onesided_global>::tonearest_plus" << std::endl
   << "is not supported." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_onesided_global>::upward_minus(
   double const & op1,
   double const & op2
  )
 {
  return -::filib::sse::sseadd(-op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_onesided_global>::downward_minus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_onesided_global>::tozero_minus(
   double const &,
   double const &
  )
 {
  std::cerr
   << "filib.0: filib::fp_traits<double,filib::native_onesided_global>::tozero_minus" << std::endl
   << "is not supported." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_onesided_global>::tonearest_minus(
   double const &,
   double const &
  )
 {
  std::cerr
   << "filib.0: filib::fp_traits<double,filib::native_onesided_global>::tonearest_minus" << std::endl
   << "is not supported." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_onesided_global>::upward_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return -::filib::sse::ssemul(-op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_onesided_global>::downward_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_onesided_global>::tozero_multiplies(
   double const &,
   double const &
  )
 {
  std::cerr
   << "filib.0: filib::fp_traits<double,filib::native_onesided_global>::tozero_multiplies" << std::endl
   << "is not supported." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_onesided_global>::tonearest_multiplies(
   double const &,
   double const &
  )
 {
  std::cerr
   << "filib.0: filib::fp_traits<double,filib::native_onesided_global>::tonearest_multiplies" << std::endl
   << "is not supported." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_onesided_global>::upward_divides(
   double const & op1,
   double const & op2
  )
 {
  return -::filib::sse::ssediv(-op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_onesided_global>::downward_divides(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_onesided_global>::tozero_divides(
   double const &,
   double const &
  )
 {
  std::cerr
   << "filib.0: filib::fp_traits<double,filib::native_onesided_global>::tozero_divides" << std::endl
   << "is not supported." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline double filib::fp_traits<double,filib::native_onesided_global>::tonearest_divides(
   double const &,
   double const &
  )
 {
  std::cerr
   << "filib.0: filib::fp_traits<double,filib::native_onesided_global>::tonearest_divides" << std::endl
   << "is not supported." << std::endl;
  std::terminate(); return 0.0;
 }
# 1391 "/usr/local/include/fp_traits/fp_traits_double.hpp" 2 3
# 1 "/usr/local/include/fp_traits/fp_traits_double_sse_pred_succ_rounding.icc" 1 3
# 27 "/usr/local/include/fp_traits/fp_traits_double_sse_pred_succ_rounding.icc" 3

 inline void filib::fp_traits<double,filib::pred_succ_rounding>::setup()
 {
  ::filib::sse::sseroundnear();
 }

 inline void filib::fp_traits<double,filib::pred_succ_rounding>::reset()
 {
  ::filib::sse::sseroundnear();
 }


 inline filib::fp_traits<double,filib::pred_succ_rounding>::fp_traits()
 {
 }


 template<bool r> inline double filib::fp_traits<double,filib::pred_succ_rounding>::upward_plus(
   double const & op1,
   double const & op2
  )
 {
  return op1 == -op2 ? 0.0 : primitive::succ(::filib::sse::sseadd(op1,op2,false));
 }

 template<bool r> inline double filib::fp_traits<double,filib::pred_succ_rounding>::downward_plus(
   double const & op1,
   double const & op2
  )
 {
  return op1 == -op2 ? 0.0 : primitive::pred(::filib::sse::sseadd(op1,op2,false));
 }

 template<bool r> inline double filib::fp_traits<double,filib::pred_succ_rounding>::tozero_plus(
   double const &,
   double const &
  )
 {
  std::cerr << "fp_traits<>::tozero_plus is not supported for "
     << "primitive (non-native) rounding." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline double filib::fp_traits<double,filib::pred_succ_rounding>::tonearest_plus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::pred_succ_rounding>::upward_minus(
   double const & op1,
   double const & op2
  )
 {
  return op1 == op2 ? 0.0 : primitive::succ(::filib::sse::ssesub(op1,op2,false));
 }

 template<bool r> inline double filib::fp_traits<double,filib::pred_succ_rounding>::downward_minus(
   double const & op1,
   double const & op2
  )
 {
  return op1 == op2 ? 0.0 : primitive::pred(::filib::sse::ssesub(op1,op2,false));
 }

 template<bool r> inline double filib::fp_traits<double,filib::pred_succ_rounding>::tozero_minus(
   double const &,
   double const &
  )
 {
  std::cerr << "fp_traits<>::tozero_minus is not supported for "
     << "primitive (non-native) rounding." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline double filib::fp_traits<double,filib::pred_succ_rounding>::tonearest_minus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::pred_succ_rounding>::upward_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return primitive::succ(::filib::sse::ssemul(op1,op2,false));
 }

 template<bool r> inline double filib::fp_traits<double,filib::pred_succ_rounding>::downward_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return primitive::pred(::filib::sse::ssemul(op1,op2,false));
 }

 template<bool r> inline double filib::fp_traits<double,filib::pred_succ_rounding>::tozero_multiplies(
   double const &,
   double const &
  )
 {
  std::cerr << "fp_traits<>::tozero_multiplies is not supported for "
     << "primitive (non-native) rounding." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline double filib::fp_traits<double,filib::pred_succ_rounding>::tonearest_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::pred_succ_rounding>::upward_divides(
   double const & op1,
   double const & op2
  )
 {
  return primitive::succ(::filib::sse::ssediv(op1,op2,false));
 }

 template<bool r> inline double filib::fp_traits<double,filib::pred_succ_rounding>::downward_divides(
   double const & op1,
   double const & op2
  )
 {
  return primitive::pred(::filib::sse::ssediv(op1,op2,false));
 }

 template<bool r> inline double filib::fp_traits<double,filib::pred_succ_rounding>::tozero_divides(
   double const &,
   double const &
  )
 {
  std::cerr << "fp_traits<>::tozero_divides is not supported for "
     << "primitive (non-native) rounding." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline double filib::fp_traits<double,filib::pred_succ_rounding>::tonearest_divides(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,false);
 }
# 1392 "/usr/local/include/fp_traits/fp_traits_double.hpp" 2 3
# 1 "/usr/local/include/fp_traits/fp_traits_double_sse_multiplicative.icc" 1 3
# 27 "/usr/local/include/fp_traits/fp_traits_double_sse_multiplicative.icc" 3

 inline void filib::fp_traits<double,filib::multiplicative>::setup()
 {
  ::filib::sse::sseroundnear();
 }

 inline void filib::fp_traits<double,filib::multiplicative>::reset()
 {
  ::filib::sse::sseroundnear();
 }


 inline filib::fp_traits<double,filib::multiplicative>::fp_traits()
 {
 }

 template<bool r> inline double filib::fp_traits<double,filib::multiplicative>::upward_plus(
   double const & op1,
   double const & op2
  )
 {
  return high(::filib::sse::sseadd(op1,op2,false));
 }

 template<bool r> inline double filib::fp_traits<double,filib::multiplicative>::downward_plus(
   double const & op1,
   double const & op2
  )
 {
  return low(::filib::sse::sseadd(op1,op2,false));
 }

 template<bool r> inline double filib::fp_traits<double,filib::multiplicative>::tozero_plus(
   double const &,
   double const &
  )
 {
  std::cerr << "filib.0: filib::fp_traits<double,filib::multiplicative>::tozero_plus"
     << std::endl
     << "is not supported for multiplicative rounding."
     << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline double filib::fp_traits<double,filib::multiplicative>::tonearest_plus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::multiplicative>::upward_minus(
   double const & op1,
   double const & op2
  )
 {
  return high(::filib::sse::ssesub(op1,op2,false));
 }

 template<bool r> inline double filib::fp_traits<double,filib::multiplicative>::downward_minus(
   double const & op1,
   double const & op2
  )
 {
  return low(::filib::sse::ssesub(op1,op2,false));
 }

 template<bool r> inline double filib::fp_traits<double,filib::multiplicative>::tozero_minus(
   double const &,
   double const &
  )
 {
  std::cerr << "filib.0: filib::fp_traits<double,filib::multiplicative>::tozero_minus"
     << std::endl
     << "is not supported for multiplicative rounding."
     << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline double filib::fp_traits<double,filib::multiplicative>::tonearest_minus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::multiplicative>::upward_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return high(::filib::sse::ssemul(op1,op2,false));
 }

 template<bool r> inline double filib::fp_traits<double,filib::multiplicative>::downward_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return low(::filib::sse::ssemul(op1,op2,false));
 }

 template<bool r> inline double filib::fp_traits<double,filib::multiplicative>::tozero_multiplies(
   double const &,
   double const &
  )
 {
  std::cerr << "filib.0: filib::fp_traits<double,filib::multiplicative>::tozero_multiplies"
     << std::endl
     << "is not supported for multiplicative rounding."
     << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline double filib::fp_traits<double,filib::multiplicative>::tonearest_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::multiplicative>::upward_divides(
   double const & op1,
   double const & op2
  )
 {
  return high(::filib::sse::ssediv(op1,op2,false));
 }

 template<bool r> inline double filib::fp_traits<double,filib::multiplicative>::downward_divides(
   double const & op1,
   double const & op2
  )
 {
  return low(::filib::sse::ssediv(op1,op2,false));
 }

 template<bool r> inline double filib::fp_traits<double,filib::multiplicative>::tozero_divides(
   double const &,
   double const &
  )
 {
  std::cerr << "filib.0: filib::fp_traits<double,filib::multiplicative>::tozero_divides"
     << std::endl
     << "is not supported for multiplicative rounding."
     << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline double filib::fp_traits<double,filib::multiplicative>::tonearest_divides(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,false);
 }

 inline double filib::fp_traits<double,filib::multiplicative>::low(
   double const & v
  )
 {
  if ( primitive::isdenormorzero(v) )
  {
   if ( v > 0.0 )
    return 0.0;
   else
    return primitive::zero_pred;
  }
  else if ( v > 0.0 )
   return (v * primitive::one_pred);
  else
   return (v * primitive::one_succ);
 }

 inline double filib::fp_traits<double,filib::multiplicative>::high(
   double const & v
  )
 {
  if ( primitive::isdenormorzero(v) )
  {
   if ( v < 0.0 )
    return 0.0;
   else
    return primitive::zero_succ;
  }
  else if ( v > 0.0 )
   return (v * primitive::one_succ);
  else
   return (v * primitive::one_pred);
 }
# 1393 "/usr/local/include/fp_traits/fp_traits_double.hpp" 2 3
# 1 "/usr/local/include/fp_traits/fp_traits_double_sse_no_rounding.icc" 1 3
# 27 "/usr/local/include/fp_traits/fp_traits_double_sse_no_rounding.icc" 3

 inline void filib::fp_traits<double,filib::no_rounding>::setup()
 {
  ::filib::sse::sseroundnear();
 }

 inline void filib::fp_traits<double,filib::no_rounding>::reset()
 {
  ::filib::sse::sseroundnear();
 }


 inline filib::fp_traits<double,filib::no_rounding>::fp_traits()
 {
 }

 template<bool r> inline double filib::fp_traits<double,filib::no_rounding>::upward_plus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::no_rounding>::downward_plus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::no_rounding>::tozero_plus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::no_rounding>::tonearest_plus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::no_rounding>::upward_minus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::no_rounding>::downward_minus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::no_rounding>::tozero_minus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::no_rounding>::tonearest_minus(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::no_rounding>::upward_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::no_rounding>::downward_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::no_rounding>::tozero_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::no_rounding>::tonearest_multiplies(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::no_rounding>::upward_divides(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::no_rounding>::downward_divides(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::no_rounding>::tozero_divides(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,false);
 }

 template<bool r> inline double filib::fp_traits<double,filib::no_rounding>::tonearest_divides(
   double const & op1,
   double const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,false);
 }
# 1394 "/usr/local/include/fp_traits/fp_traits_double.hpp" 2 3
# 307 "/usr/local/include/fp_traits/fp_traits.hpp" 2 3
# 1 "/usr/local/include/fp_traits/fp_traits_float.hpp" 1 3
# 33 "/usr/local/include/fp_traits/fp_traits_float.hpp" 3
namespace filib
{
 template<>
 class





  fp_traits_base<float>
 {
  public:



   static float const min_val;



   static float const max_val;



   static float const nan_val;



   static float const inf_val;



   static float const ninf_val;



   static float const l_pi_val;



   static float const u_pi_val;




   static inline bool sign(float const &) ;



   static inline bool IsNaN(float const &) ;



    static inline bool IsInf(float const &) ;



   static inline float const & infinity() ;



   static inline float const & ninfinity() ;



   static inline float const & quiet_NaN() ;



   static inline float const & l_pi() ;



   static inline float const & u_pi() ;



   static inline float const & min() ;



   static inline float const & max() ;



   static inline float abs(float const &);
 };




 template<>
 class





  fp_traits<float,native_switched>
  :
  public rounding_control<float,true>,
  public fp_traits_base<float>
 {
  protected:



   static int precision_val;
  public:






  fp_traits();




  static inline void setup();




  static inline void reset();




  static inline int const & precision()
  {
   return precision_val;
  }



  static inline int precision(int const & new_val)
  {
   int old_val = precision_val;
   precision_val = new_val;
   return old_val;
  }




  template<bool r> static inline float upward_plus(
   float const &,
   float const &);



  template<bool r> static inline float downward_plus(
   float const &,
   float const &);



  template<bool r> static inline float tozero_plus(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_plus(
   float const &,
   float const &);




  template<bool r> static inline float upward_minus(
   float const &,
   float const &);



  template<bool r> static inline float downward_minus(
   float const &,
   float const &);



  template<bool r> static inline float tozero_minus(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_minus(
   float const &,
   float const &);




  template<bool r> static inline float upward_multiplies(
   float const &,
   float const &);



  template<bool r> static inline float downward_multiplies(
   float const &,
   float const &);



  template<bool r> static inline float tozero_multiplies(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_multiplies(
   float const &,
   float const &);




  template<bool r> static inline float upward_divides(
   float const &,
   float const &);



  template<bool r> static inline float downward_divides(
   float const &,
   float const &);



  template<bool r> static inline float tozero_divides(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_divides(
   float const &,
   float const &);


  static inline float upward_plus(float const &a, float const & b, bool r) {
   if ( r ) return upward_plus<true>(a,b); else return upward_plus<false>(a,b);
  }
  static inline float upward_minus(float const &a, float const & b, bool r) {
   if ( r ) return upward_minus<true>(a,b); else return upward_minus<false>(a,b);
  }
  static inline float upward_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return upward_multiplies<true>(a,b); else return upward_multiplies<false>(a,b);
  }
  static inline float upward_divides(float const &a, float const & b, bool r) {
   if ( r ) return upward_divides<true>(a,b); else return upward_divides<false>(a,b);
  }
  static inline float downward_plus(float const &a, float const & b, bool r) {
   if ( r ) return downward_plus<true>(a,b); else return downward_plus<false>(a,b);
  }
  static inline float downward_minus(float const &a, float const & b, bool r) {
   if ( r ) return downward_minus<true>(a,b); else return downward_minus<false>(a,b);
  }
  static inline float downward_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return downward_multiplies<true>(a,b); else return downward_multiplies<false>(a,b);
  }
  static inline float downward_divides(float const &a, float const & b, bool r) {
   if ( r ) return downward_divides<true>(a,b); else return downward_divides<false>(a,b);
  }
  static inline float tozero_plus(float const &a, float const & b, bool r) {
   if ( r ) return tozero_plus<true>(a,b); else return tozero_plus<false>(a,b);
  }
  static inline float tozero_minus(float const &a, float const & b, bool r) {
   if ( r ) return tozero_minus<true>(a,b); else return tozero_minus<false>(a,b);
  }
  static inline float tozero_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return tozero_multiplies<true>(a,b); else return tozero_multiplies<false>(a,b);
  }
  static inline float tozero_divides(float const &a, float const & b, bool r) {
   if ( r ) return tozero_divides<true>(a,b); else return tozero_divides<false>(a,b);
  }
  static inline float tonearest_plus(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_plus<true>(a,b); else return tonearest_plus<false>(a,b);
  }
  static inline float tonearest_minus(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_minus<true>(a,b); else return tonearest_minus<false>(a,b);
  }
  static inline float tonearest_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_multiplies<true>(a,b); else return tonearest_multiplies<false>(a,b);
  }
  static inline float tonearest_divides(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_divides<true>(a,b); else return tonearest_divides<false>(a,b);
  }

 };
 template<>
 class





  fp_traits<float,native_directed>
  :
  public rounding_control<float,false>,
  public fp_traits_base<float>
 {
  protected:



   static int precision_val;
  public:






  fp_traits();




  static inline void setup();




  static inline void reset();




  static inline int const & precision()
  {
   return precision_val;
  }



  static inline int precision(int const & new_val)
  {
   int old_val = precision_val;
   precision_val = new_val;
   return old_val;
  }





  template<bool r> static inline float upward_plus(
   float const &,
   float const &);



  template<bool r> static inline float downward_plus(
   float const &,
   float const &);



  template<bool r> static inline float tozero_plus(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_plus(
   float const &,
   float const &);




  template<bool r> static inline float upward_minus(
   float const &,
   float const &);



  template<bool r> static inline float downward_minus(
   float const &,
   float const &);



  template<bool r> static inline float tozero_minus(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_minus(
   float const &,
   float const &);




  template<bool r> static inline float upward_multiplies(
   float const &,
   float const &);



  template<bool r> static inline float downward_multiplies(
   float const &,
   float const &);



  template<bool r> static inline float tozero_multiplies(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_multiplies(
   float const &,
   float const &);




  template<bool r> static inline float upward_divides(
   float const &,
   float const &);



  template<bool r> static inline float downward_divides(
   float const &,
   float const &);



  template<bool r> static inline float tozero_divides(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_divides(
   float const &,
   float const &);

  static inline float upward_plus(float const &a, float const & b, bool r) {
   if ( r ) return upward_plus<true>(a,b); else return upward_plus<false>(a,b);
  }
  static inline float upward_minus(float const &a, float const & b, bool r) {
   if ( r ) return upward_minus<true>(a,b); else return upward_minus<false>(a,b);
  }
  static inline float upward_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return upward_multiplies<true>(a,b); else return upward_multiplies<false>(a,b);
  }
  static inline float upward_divides(float const &a, float const & b, bool r) {
   if ( r ) return upward_divides<true>(a,b); else return upward_divides<false>(a,b);
  }
  static inline float downward_plus(float const &a, float const & b, bool r) {
   if ( r ) return downward_plus<true>(a,b); else return downward_plus<false>(a,b);
  }
  static inline float downward_minus(float const &a, float const & b, bool r) {
   if ( r ) return downward_minus<true>(a,b); else return downward_minus<false>(a,b);
  }
  static inline float downward_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return downward_multiplies<true>(a,b); else return downward_multiplies<false>(a,b);
  }
  static inline float downward_divides(float const &a, float const & b, bool r) {
   if ( r ) return downward_divides<true>(a,b); else return downward_divides<false>(a,b);
  }
  static inline float tozero_plus(float const &a, float const & b, bool r) {
   if ( r ) return tozero_plus<true>(a,b); else return tozero_plus<false>(a,b);
  }
  static inline float tozero_minus(float const &a, float const & b, bool r) {
   if ( r ) return tozero_minus<true>(a,b); else return tozero_minus<false>(a,b);
  }
  static inline float tozero_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return tozero_multiplies<true>(a,b); else return tozero_multiplies<false>(a,b);
  }
  static inline float tozero_divides(float const &a, float const & b, bool r) {
   if ( r ) return tozero_divides<true>(a,b); else return tozero_divides<false>(a,b);
  }
  static inline float tonearest_plus(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_plus<true>(a,b); else return tonearest_plus<false>(a,b);
  }
  static inline float tonearest_minus(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_minus<true>(a,b); else return tonearest_minus<false>(a,b);
  }
  static inline float tonearest_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_multiplies<true>(a,b); else return tonearest_multiplies<false>(a,b);
  }
  static inline float tonearest_divides(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_divides<true>(a,b); else return tonearest_divides<false>(a,b);
  }

 };





 template<>
 class





  fp_traits<float,multiplicative>
  :
  public rounding_control_stub,
  public fp_traits_base<float>
 {
  protected:



   static int precision_val;
  public:






  fp_traits();




  static inline void setup();




  static inline void reset();




  static inline int const & precision()
  {
   return precision_val;
  }



  static inline int precision(int const & new_val)
  {
   int old_val = precision_val;
   precision_val = new_val;
   return old_val;
  }




  template<bool r> static inline float upward_plus(
   float const &,
   float const &);



  template<bool r> static inline float downward_plus(
   float const &,
   float const &);



  template<bool r> static inline float tozero_plus(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_plus(
   float const &,
   float const &);




  template<bool r> static inline float upward_minus(
   float const &,
   float const &);



  template<bool r> static inline float downward_minus(
   float const &,
   float const &);



  template<bool r> static inline float tozero_minus(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_minus(
   float const &,
   float const &);




  template<bool r> static inline float upward_multiplies(
   float const &,
   float const &);



  template<bool r> static inline float downward_multiplies(
   float const &,
   float const &);



  template<bool r> static inline float tozero_multiplies(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_multiplies(
   float const &,
   float const &);




  template<bool r> static inline float upward_divides(
   float const &,
   float const &);



  template<bool r> static inline float downward_divides(
   float const &,
   float const &);



  template<bool r> static inline float tozero_divides(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_divides(
   float const &,
   float const &);



  static inline float low ( float const & );



  static inline float high ( float const & );

  static inline float upward_plus(float const &a, float const & b, bool r) {
   if ( r ) return upward_plus<true>(a,b); else return upward_plus<false>(a,b);
  }
  static inline float upward_minus(float const &a, float const & b, bool r) {
   if ( r ) return upward_minus<true>(a,b); else return upward_minus<false>(a,b);
  }
  static inline float upward_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return upward_multiplies<true>(a,b); else return upward_multiplies<false>(a,b);
  }
  static inline float upward_divides(float const &a, float const & b, bool r) {
   if ( r ) return upward_divides<true>(a,b); else return upward_divides<false>(a,b);
  }
  static inline float downward_plus(float const &a, float const & b, bool r) {
   if ( r ) return downward_plus<true>(a,b); else return downward_plus<false>(a,b);
  }
  static inline float downward_minus(float const &a, float const & b, bool r) {
   if ( r ) return downward_minus<true>(a,b); else return downward_minus<false>(a,b);
  }
  static inline float downward_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return downward_multiplies<true>(a,b); else return downward_multiplies<false>(a,b);
  }
  static inline float downward_divides(float const &a, float const & b, bool r) {
   if ( r ) return downward_divides<true>(a,b); else return downward_divides<false>(a,b);
  }
  static inline float tozero_plus(float const &a, float const & b, bool r) {
   if ( r ) return tozero_plus<true>(a,b); else return tozero_plus<false>(a,b);
  }
  static inline float tozero_minus(float const &a, float const & b, bool r) {
   if ( r ) return tozero_minus<true>(a,b); else return tozero_minus<false>(a,b);
  }
  static inline float tozero_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return tozero_multiplies<true>(a,b); else return tozero_multiplies<false>(a,b);
  }
  static inline float tozero_divides(float const &a, float const & b, bool r) {
   if ( r ) return tozero_divides<true>(a,b); else return tozero_divides<false>(a,b);
  }
  static inline float tonearest_plus(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_plus<true>(a,b); else return tonearest_plus<false>(a,b);
  }
  static inline float tonearest_minus(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_minus<true>(a,b); else return tonearest_minus<false>(a,b);
  }
  static inline float tonearest_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_multiplies<true>(a,b); else return tonearest_multiplies<false>(a,b);
  }
  static inline float tonearest_divides(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_divides<true>(a,b); else return tonearest_divides<false>(a,b);
  }

 };




 template<>
 class





 fp_traits<float,no_rounding>
  :
  public rounding_control_stub,
  public fp_traits_base<float>
 {
  protected:



   static int precision_val;
  public:






  fp_traits();




  static inline int const & precision()
  {
   return precision_val;
  }



  static inline int precision(int const & new_val)
  {
   int old_val = precision_val;
   precision_val = new_val;
   return old_val;
  }




  template<bool r> static inline float upward_plus(
   float const &,
   float const &);



  template<bool r> static inline float downward_plus(
   float const &,
   float const &);



  template<bool r> static inline float tozero_plus(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_plus(
   float const &,
   float const &);




  template<bool r> static inline float upward_minus(
   float const &,
   float const &);



  template<bool r> static inline float downward_minus(
   float const &,
   float const &);



  template<bool r> static inline float tozero_minus(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_minus(
   float const &,
   float const &);




  template<bool r> static inline float upward_multiplies(
   float const &,
   float const &);



  template<bool r> static inline float downward_multiplies(
   float const &,
   float const &);



  template<bool r> static inline float tozero_multiplies(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_multiplies(
   float const &,
   float const &);




  template<bool r> static inline float upward_divides(
   float const &,
   float const &);



  template<bool r> static inline float downward_divides(
   float const &,
   float const &);



  template<bool r> static inline float tozero_divides(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_divides(
   float const &,
   float const &);

  static inline float upward_plus(float const &a, float const & b, bool r) {
   if ( r ) return upward_plus<true>(a,b); else return upward_plus<false>(a,b);
  }
  static inline float upward_minus(float const &a, float const & b, bool r) {
   if ( r ) return upward_minus<true>(a,b); else return upward_minus<false>(a,b);
  }
  static inline float upward_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return upward_multiplies<true>(a,b); else return upward_multiplies<false>(a,b);
  }
  static inline float upward_divides(float const &a, float const & b, bool r) {
   if ( r ) return upward_divides<true>(a,b); else return upward_divides<false>(a,b);
  }
  static inline float downward_plus(float const &a, float const & b, bool r) {
   if ( r ) return downward_plus<true>(a,b); else return downward_plus<false>(a,b);
  }
  static inline float downward_minus(float const &a, float const & b, bool r) {
   if ( r ) return downward_minus<true>(a,b); else return downward_minus<false>(a,b);
  }
  static inline float downward_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return downward_multiplies<true>(a,b); else return downward_multiplies<false>(a,b);
  }
  static inline float downward_divides(float const &a, float const & b, bool r) {
   if ( r ) return downward_divides<true>(a,b); else return downward_divides<false>(a,b);
  }
  static inline float tozero_plus(float const &a, float const & b, bool r) {
   if ( r ) return tozero_plus<true>(a,b); else return tozero_plus<false>(a,b);
  }
  static inline float tozero_minus(float const &a, float const & b, bool r) {
   if ( r ) return tozero_minus<true>(a,b); else return tozero_minus<false>(a,b);
  }
  static inline float tozero_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return tozero_multiplies<true>(a,b); else return tozero_multiplies<false>(a,b);
  }
  static inline float tozero_divides(float const &a, float const & b, bool r) {
   if ( r ) return tozero_divides<true>(a,b); else return tozero_divides<false>(a,b);
  }
  static inline float tonearest_plus(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_plus<true>(a,b); else return tonearest_plus<false>(a,b);
  }
  static inline float tonearest_minus(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_minus<true>(a,b); else return tonearest_minus<false>(a,b);
  }
  static inline float tonearest_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_multiplies<true>(a,b); else return tonearest_multiplies<false>(a,b);
  }
  static inline float tonearest_divides(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_divides<true>(a,b); else return tonearest_divides<false>(a,b);
  }

 };





 template<>
 class





 fp_traits<float,native_onesided_global>
  :
  public rounding_control<float,false>,
  public fp_traits_base<float>
 {
  protected:



   static int precision_val;
  public:






  fp_traits();


  static void setup();

  static void reset();




  static inline int const & precision()
  {
   return precision_val;
  }



  static inline int precision(int const & new_val)
  {
   int old_val = precision_val;
   precision_val = new_val;
   return old_val;
  }




  template<bool r> static inline float upward_plus(
   float const &,
   float const &);



  template<bool r> static inline float downward_plus(
   float const &,
   float const &);



  template<bool r> static inline float tozero_plus(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_plus(
   float const &,
   float const &);




  template<bool r> static inline float upward_minus(
   float const &,
   float const &);



  template<bool r> static inline float downward_minus(
   float const &,
   float const &);



  template<bool r> static inline float tozero_minus(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_minus(
   float const &,
   float const &);




  template<bool r> static inline float upward_multiplies(
   float const &,
   float const &);



  template<bool r> static inline float downward_multiplies(
   float const &,
   float const &);



  template<bool r> static inline float tozero_multiplies(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_multiplies(
   float const &,
   float const &);




  template<bool r> static inline float upward_divides(
   float const &,
   float const &);



  template<bool r> static inline float downward_divides(
   float const &,
   float const &);



  template<bool r> static inline float tozero_divides(
   float const &,
   float const &);



  template<bool r> static inline float tonearest_divides(
   float const &,
   float const &);

  static inline float upward_plus(float const &a, float const & b, bool r) {
   if ( r ) return upward_plus<true>(a,b); else return upward_plus<false>(a,b);
  }
  static inline float upward_minus(float const &a, float const & b, bool r) {
   if ( r ) return upward_minus<true>(a,b); else return upward_minus<false>(a,b);
  }
  static inline float upward_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return upward_multiplies<true>(a,b); else return upward_multiplies<false>(a,b);
  }
  static inline float upward_divides(float const &a, float const & b, bool r) {
   if ( r ) return upward_divides<true>(a,b); else return upward_divides<false>(a,b);
  }
  static inline float downward_plus(float const &a, float const & b, bool r) {
   if ( r ) return downward_plus<true>(a,b); else return downward_plus<false>(a,b);
  }
  static inline float downward_minus(float const &a, float const & b, bool r) {
   if ( r ) return downward_minus<true>(a,b); else return downward_minus<false>(a,b);
  }
  static inline float downward_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return downward_multiplies<true>(a,b); else return downward_multiplies<false>(a,b);
  }
  static inline float downward_divides(float const &a, float const & b, bool r) {
   if ( r ) return downward_divides<true>(a,b); else return downward_divides<false>(a,b);
  }
  static inline float tozero_plus(float const &a, float const & b, bool r) {
   if ( r ) return tozero_plus<true>(a,b); else return tozero_plus<false>(a,b);
  }
  static inline float tozero_minus(float const &a, float const & b, bool r) {
   if ( r ) return tozero_minus<true>(a,b); else return tozero_minus<false>(a,b);
  }
  static inline float tozero_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return tozero_multiplies<true>(a,b); else return tozero_multiplies<false>(a,b);
  }
  static inline float tozero_divides(float const &a, float const & b, bool r) {
   if ( r ) return tozero_divides<true>(a,b); else return tozero_divides<false>(a,b);
  }
  static inline float tonearest_plus(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_plus<true>(a,b); else return tonearest_plus<false>(a,b);
  }
  static inline float tonearest_minus(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_minus<true>(a,b); else return tonearest_minus<false>(a,b);
  }
  static inline float tonearest_multiplies(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_multiplies<true>(a,b); else return tonearest_multiplies<false>(a,b);
  }
  static inline float tonearest_divides(float const &a, float const & b, bool r) {
   if ( r ) return tonearest_divides<true>(a,b); else return tonearest_divides<false>(a,b);
  }

 };
}


# 1 "/usr/local/include/fp_traits/fp_traits_base_float.icc" 1 3
# 27 "/usr/local/include/fp_traits/fp_traits_base_float.icc" 3

 inline bool filib::fp_traits_base<float>::sign(float const & n)
 {
  filib::a_fiee const * t = reinterpret_cast<filib::a_fiee const *>(&n);
  return t->ieee.sign;
 }

 inline bool filib::fp_traits_base<float>::IsNaN(float const & n)
 {
  return (n != n);
 }

 inline bool filib::fp_traits_base<float>::IsInf(float const & n)
 {
  return (n < -max_val) || (n > max_val);
 }

 inline float filib::fp_traits_base<float>::abs(float const & n)
 {
  filib::a_fiee d;
  d.f = n;
  d.ieee.sign = false;
  return d.f;
 }

 inline float const & filib::fp_traits_base<float>::infinity()
 {
  return inf_val;
 }

 inline float const & filib::fp_traits_base<float>::ninfinity()
 {
  return ninf_val;
 }

 inline float const & filib::fp_traits_base<float>::quiet_NaN()
 {
  return nan_val;
 }

 inline float const & filib::fp_traits_base<float>::min()
 {
  return min_val;
 }

 inline float const & filib::fp_traits_base<float>::max()
 {
  return max_val;
 }

 inline float const & filib::fp_traits_base<float>::l_pi()
 {
  return l_pi_val;
 }

 inline float const & filib::fp_traits_base<float>::u_pi()
 {
  return u_pi_val;
 }
# 1151 "/usr/local/include/fp_traits/fp_traits_float.hpp" 2 3


# 1 "/usr/local/include/fp_traits/fp_traits_float_sse_native_switched.icc" 1 3
# 27 "/usr/local/include/fp_traits/fp_traits_float_sse_native_switched.icc" 3

 inline void filib::fp_traits<float,filib::native_switched>::setup()
 {
  ::filib::sse::sseroundnear();
 }

 inline void filib::fp_traits<float,filib::native_switched>::reset()
 {
  ::filib::sse::sseroundnear();
 }


 inline filib::fp_traits<float,filib::native_switched>::fp_traits()
 {
 }


 template<bool r> inline float filib::fp_traits<float,filib::native_switched>::upward_plus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,::filib::sse::dir_up,r);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_switched>::downward_plus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,::filib::sse::dir_down,r);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_switched>::tozero_plus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,::filib::sse::dir_trunc,r);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_switched>::tonearest_plus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,::filib::sse::dir_nearest,r);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_switched>::upward_minus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,::filib::sse::dir_up,r);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_switched>::downward_minus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,::filib::sse::dir_down,r);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_switched>::tozero_minus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,::filib::sse::dir_trunc,r);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_switched>::tonearest_minus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,::filib::sse::dir_nearest,r);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_switched>::upward_multiplies(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,::filib::sse::dir_up,r);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_switched>::downward_multiplies(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,::filib::sse::dir_down,r);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_switched>::tozero_multiplies(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,::filib::sse::dir_trunc,r);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_switched>::tonearest_multiplies(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,::filib::sse::dir_nearest,r);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_switched>::upward_divides(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,::filib::sse::dir_up,r);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_switched>::downward_divides(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,::filib::sse::dir_down,r);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_switched>::tozero_divides(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,::filib::sse::dir_trunc,r);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_switched>::tonearest_divides(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,::filib::sse::dir_nearest,r);
 }
# 1154 "/usr/local/include/fp_traits/fp_traits_float.hpp" 2 3
# 1 "/usr/local/include/fp_traits/fp_traits_float_sse_native_directed.icc" 1 3
# 27 "/usr/local/include/fp_traits/fp_traits_float_sse_native_directed.icc" 3

 inline void filib::fp_traits<float,filib::native_directed>::setup()
 {
  ::filib::sse::sseroundnear();
 }

 inline void filib::fp_traits<float,filib::native_directed>::reset()
 {
  ::filib::sse::sseroundnear();
 }


 inline filib::fp_traits<float,filib::native_directed>::fp_traits()
 {
 }


 template<bool r> inline float filib::fp_traits<float,filib::native_directed>::upward_plus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,::filib::sse::dir_up,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_directed>::downward_plus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,::filib::sse::dir_down,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_directed>::tozero_plus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,::filib::sse::dir_trunc,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_directed>::tonearest_plus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,::filib::sse::dir_nearest,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_directed>::upward_minus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,::filib::sse::dir_up,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_directed>::downward_minus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,::filib::sse::dir_down,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_directed>::tozero_minus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,::filib::sse::dir_trunc,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_directed>::tonearest_minus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,::filib::sse::dir_nearest,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_directed>::upward_multiplies(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,::filib::sse::dir_up,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_directed>::downward_multiplies(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,::filib::sse::dir_down,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_directed>::tozero_multiplies(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,::filib::sse::dir_trunc,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_directed>::tonearest_multiplies(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,::filib::sse::dir_nearest,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_directed>::upward_divides(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,::filib::sse::dir_up,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_directed>::downward_divides(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,::filib::sse::dir_down,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_directed>::tozero_divides(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,::filib::sse::dir_trunc,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_directed>::tonearest_divides(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,::filib::sse::dir_nearest,false);
 }
# 1155 "/usr/local/include/fp_traits/fp_traits_float.hpp" 2 3
# 1 "/usr/local/include/fp_traits/fp_traits_float_sse_native_onesided_global.icc" 1 3
# 27 "/usr/local/include/fp_traits/fp_traits_float_sse_native_onesided_global.icc" 3

 inline void filib::fp_traits<float,filib::native_onesided_global>::setup() {
  ::filib::sse::sserounddown();
 }

 inline void filib::fp_traits<float,filib::native_onesided_global>::reset() {
  ::filib::sse::sseroundnear();
 }


 inline filib::fp_traits<float,filib::native_onesided_global>::fp_traits()
 {
 }


 template<bool r> inline float filib::fp_traits<float,filib::native_onesided_global>::upward_plus(
   float const & op1,
   float const & op2
  )
 {
  return -::filib::sse::ssesub(-op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_onesided_global>::downward_plus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_onesided_global>::tozero_plus(
   float const &,
   float const &
  )
 {
  std::cerr
   << "filib.0: filib::fp_traits<float,filib::native_onesided_global>::tozero_plus" << std::endl
   << "is not supported." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_onesided_global>::tonearest_plus(
   float const &,
   float const &
  )
 {
  std::cerr
   << "filib.0: filib::fp_traits<float,filib::native_onesided_global>::tonearest_plus" << std::endl
   << "is not supported." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_onesided_global>::upward_minus(
   float const & op1,
   float const & op2
  )
 {
  return -::filib::sse::sseadd(-op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_onesided_global>::downward_minus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_onesided_global>::tozero_minus(
   float const &,
   float const &
  )
 {
  std::cerr
   << "filib.0: filib::fp_traits<float,filib::native_onesided_global>::tozero_minus" << std::endl
   << "is not supported." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_onesided_global>::tonearest_minus(
   float const &,
   float const &
  )
 {
  std::cerr
   << "filib.0: filib::fp_traits<float,filib::native_onesided_global>::tonearest_minus" << std::endl
   << "is not supported." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_onesided_global>::upward_multiplies(
   float const & op1,
   float const & op2
  )
 {
  return -::filib::sse::ssemul(-op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_onesided_global>::downward_multiplies(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_onesided_global>::tozero_multiplies(
   float const &,
   float const &
  )
 {
  std::cerr
   << "filib.0: filib::fp_traits<float,filib::native_onesided_global>::tozero_multiplies" << std::endl
   << "is not supported." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_onesided_global>::tonearest_multiplies(
   float const &,
   float const &
  )
 {
  std::cerr
   << "filib.0: filib::fp_traits<float,filib::native_onesided_global>::tonearest_multiplies" << std::endl
   << "is not supported." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_onesided_global>::upward_divides(
   float const & op1,
   float const & op2
  )
 {
  return -::filib::sse::ssediv(-op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_onesided_global>::downward_divides(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_onesided_global>::tozero_divides(
   float const &,
   float const &
  )
 {
  std::cerr
   << "filib.0: filib::fp_traits<float,filib::native_onesided_global>::tozero_divides" << std::endl
   << "is not supported." << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline float filib::fp_traits<float,filib::native_onesided_global>::tonearest_divides(
   float const &,
   float const &
  )
 {
  std::cerr
   << "filib.0: filib::fp_traits<float,filib::native_onesided_global>::tonearest_divides" << std::endl
   << "is not supported." << std::endl;
  std::terminate(); return 0.0;
 }
# 1156 "/usr/local/include/fp_traits/fp_traits_float.hpp" 2 3
# 1 "/usr/local/include/fp_traits/fp_traits_float_sse_multiplicative.icc" 1 3
# 27 "/usr/local/include/fp_traits/fp_traits_float_sse_multiplicative.icc" 3

 inline void filib::fp_traits<float,filib::multiplicative>::setup()
 {
  ::filib::sse::sseroundnear();
 }

 inline void filib::fp_traits<float,filib::multiplicative>::reset()
 {
  ::filib::sse::sseroundnear();
 }


 inline filib::fp_traits<float,filib::multiplicative>::fp_traits()
 {
 }

 template<bool r> inline float filib::fp_traits<float,filib::multiplicative>::upward_plus(
   float const & op1,
   float const & op2
  )
 {
  return high(::filib::sse::sseadd(op1,op2,false));
 }

 template<bool r> inline float filib::fp_traits<float,filib::multiplicative>::downward_plus(
   float const & op1,
   float const & op2
  )
 {
  return low(::filib::sse::sseadd(op1,op2,false));
 }

 template<bool r> inline float filib::fp_traits<float,filib::multiplicative>::tozero_plus(
   float const &,
   float const &
  )
 {
  std::cerr << "filib.0: filib::fp_traits<float,filib::multiplicative>::tozero_plus"
     << std::endl
     << "is not supported for multiplicative rounding."
     << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline float filib::fp_traits<float,filib::multiplicative>::tonearest_plus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::multiplicative>::upward_minus(
   float const & op1,
   float const & op2
  )
 {
  return high(::filib::sse::ssesub(op1,op2,false));
 }

 template<bool r> inline float filib::fp_traits<float,filib::multiplicative>::downward_minus(
   float const & op1,
   float const & op2
  )
 {
  return low(::filib::sse::ssesub(op1,op2,false));
 }

 template<bool r> inline float filib::fp_traits<float,filib::multiplicative>::tozero_minus(
   float const &,
   float const &
  )
 {
  std::cerr << "filib.0: filib::fp_traits<float,filib::multiplicative>::tozero_minus"
     << std::endl
     << "is not supported for multiplicative rounding."
     << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline float filib::fp_traits<float,filib::multiplicative>::tonearest_minus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::multiplicative>::upward_multiplies(
   float const & op1,
   float const & op2
  )
 {
  return high(::filib::sse::ssemul(op1,op2,false));
 }

 template<bool r> inline float filib::fp_traits<float,filib::multiplicative>::downward_multiplies(
   float const & op1,
   float const & op2
  )
 {
  return low(::filib::sse::ssemul(op1,op2,false));
 }

 template<bool r> inline float filib::fp_traits<float,filib::multiplicative>::tozero_multiplies(
   float const &,
   float const &
  )
 {
  std::cerr << "filib.0: filib::fp_traits<float,filib::multiplicative>::tozero_multiplies"
     << std::endl
     << "is not supported for multiplicative rounding."
     << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline float filib::fp_traits<float,filib::multiplicative>::tonearest_multiplies(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::multiplicative>::upward_divides(
   float const & op1,
   float const & op2
  )
 {
  return high(::filib::sse::ssediv(op1,op2,false));
 }

 template<bool r> inline float filib::fp_traits<float,filib::multiplicative>::downward_divides(
   float const & op1,
   float const & op2
  )
 {
  return low(::filib::sse::ssediv(op1,op2,false));
 }

 template<bool r> inline float filib::fp_traits<float,filib::multiplicative>::tozero_divides(
   float const &,
   float const &
  )
 {
  std::cerr << "filib.0: filib::fp_traits<float,filib::multiplicative>::tozero_divides"
     << std::endl
     << "is not supported for multiplicative rounding."
     << std::endl;
  std::terminate(); return 0.0;
 }

 template<bool r> inline float filib::fp_traits<float,filib::multiplicative>::tonearest_divides(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,false);
 }

 inline float filib::fp_traits<float,filib::multiplicative>::low(
   float const & v
  )
 {
  if ( primitive::isdenormorzero(v) )
  {
   if ( v > 0.0 )
    return 0.0;
   else
    return primitive::zero_pred;
  }
  else if ( v > 0.0 )
   return (v * primitive::one_pred);
  else
   return (v * primitive::one_succ);
 }

 inline float filib::fp_traits<float,filib::multiplicative>::high(
   float const & v
  )
 {
  if ( primitive::isdenormorzero(v) )
  {
   if ( v < 0.0 )
    return 0.0;
   else
    return primitive::zero_succ;
  }
  else if ( v > 0.0 )
   return (v * primitive::one_succ);
  else
   return (v * primitive::one_pred);
 }
# 1157 "/usr/local/include/fp_traits/fp_traits_float.hpp" 2 3
# 1 "/usr/local/include/fp_traits/fp_traits_float_sse_no_rounding.icc" 1 3
# 27 "/usr/local/include/fp_traits/fp_traits_float_sse_no_rounding.icc" 3

 inline filib::fp_traits<float,filib::no_rounding>::fp_traits()
 {
 }

 template<bool r> inline float filib::fp_traits<float,filib::no_rounding>::upward_plus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::no_rounding>::downward_plus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::no_rounding>::tozero_plus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::no_rounding>::tonearest_plus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::sseadd(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::no_rounding>::upward_minus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::no_rounding>::downward_minus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::no_rounding>::tozero_minus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::no_rounding>::tonearest_minus(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssesub(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::no_rounding>::upward_multiplies(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::no_rounding>::downward_multiplies(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::no_rounding>::tozero_multiplies(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::no_rounding>::tonearest_multiplies(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssemul(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::no_rounding>::upward_divides(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::no_rounding>::downward_divides(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::no_rounding>::tozero_divides(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,false);
 }

 template<bool r> inline float filib::fp_traits<float,filib::no_rounding>::tonearest_divides(
   float const & op1,
   float const & op2
  )
 {
  return ::filib::sse::ssediv(op1,op2,false);
 }
# 1158 "/usr/local/include/fp_traits/fp_traits_float.hpp" 2 3
# 308 "/usr/local/include/fp_traits/fp_traits.hpp" 2 3
# 39 "/usr/local/include/interval/interval.hpp" 2 3


namespace filib
{



 enum interval_mode
 {
  i_mode_normal = 0,
  i_mode_extended = 1,
  i_mode_extended_flag = 2
 };

 template <typename N, rounding_strategy K, interval_mode E>
 class interval;

 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E> operator+ (
  interval<N,K,E> const & a,
  interval<N,K,E> const & b);
 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E> operator+ (
  interval<N,K,E> const & a,
  N const & b);
 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E> operator+ (
  N const & b,
  interval<N,K,E> const & a);

 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E> operator- (
  interval<N,K,E> const & a,
  interval<N,K,E> const & b);
 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E> operator- (
  interval<N,K,E> const & a,
  N const & b);
 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E> operator- (
  N const & b,
  interval<N,K,E> const & a);

 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E> cancel (
  interval<N,K,E> const & a,
  interval<N,K,E> const & b);

 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E> operator* (
  interval<N,K,E> const & a,
  interval<N,K,E> const & b);
 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E> operator* (
  interval<N,K,E> const & a,
  N const & b);
 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E> operator* (
  N const & b,
  interval<N,K,E> const & a);

 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E> operator/ (
  interval<N,K,E> const & a,
  interval<N,K,E> const & b);
 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E> operator/ (
  interval<N,K,E> const & a,
  N const & b);
 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E> operator/ (
  N const & b,
  interval<N,K,E> const & a);




 template < typename N, rounding_strategy K, interval_mode E > N const & inf (interval<N,K,E> const &);



 template < typename N, rounding_strategy K, interval_mode E > N const & sup (interval<N,K,E> const &);



 template < typename N, rounding_strategy K, interval_mode E > N inf_by_value (interval<N,K,E> const &);



 template < typename N, rounding_strategy K, interval_mode E > N sup_by_value (interval<N,K,E> const &);



 template < typename N, rounding_strategy K, interval_mode E > bool isPoint (interval<N,K,E> const &);




 template < typename N, rounding_strategy K, interval_mode E > bool isInfinite (interval<N,K,E> const &);



 template < typename N, rounding_strategy K, interval_mode E > bool isEmpty (interval<N,K,E> const &);




 template < typename N, rounding_strategy K, interval_mode E > bool hasUlpAcc (interval<N,K,E> const &, unsigned int const &);



 template < typename N, rounding_strategy K, interval_mode E > N mid(interval<N,K,E> const &);



 template < typename N, rounding_strategy K, interval_mode E > N diam(interval<N,K,E> const &);
 template < typename N, rounding_strategy K, interval_mode E > N width(interval<N,K,E> const &);



 template < typename N, rounding_strategy K, interval_mode E > N relDiam(interval<N,K,E> const &);



 template < typename N, rounding_strategy K, interval_mode E > N rad(interval<N,K,E> const &);



 template < typename N, rounding_strategy K, interval_mode E > N mig(interval<N,K,E> const &);



 template < typename N, rounding_strategy K, interval_mode E > N mag(interval<N,K,E> const &);



 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E> abs(interval<N,K,E> const &);



 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E> imin(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E> imax(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E > N dist(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E> blow(interval<N,K,E> const & x, N const & eps);



 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E>
 intersect(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E>
 hull(interval<N,K,E> const & x, interval<N,K,E> const & y);
 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E>
 interval_hull(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E>
 hull(N const & x, interval<N,K,E> const & y);
 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E>
 interval_hull(N const & x, interval<N,K,E> const & y);
# 206 "/usr/local/include/interval/interval.hpp" 3
 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E>
 hull(N const & x, N const & y);
 template < typename N, rounding_strategy K, interval_mode E > interval<N,K,E>
 interval_hull(N const & x, N const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool disjoint(interval<N,K,E> const & x, interval<N,K,E> const & y);
# 223 "/usr/local/include/interval/interval.hpp" 3
 template < typename N, rounding_strategy K, interval_mode E >
 bool in(N const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool interior(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool proper_subset(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool subset(interval<N,K,E> const & x, interval<N,K,E> const & y);




 template < typename N, rounding_strategy K, interval_mode E >
 bool operator <=(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool proper_superset(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool superset(interval<N,K,E> const & x, interval<N,K,E> const & y);




 template < typename N, rounding_strategy K, interval_mode E >
 bool operator >=(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool seq(interval<N,K,E> const & x, interval<N,K,E> const & y);




 template < typename N, rounding_strategy K, interval_mode E >
 bool operator ==(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool sne(interval<N,K,E> const & x, interval<N,K,E> const & y);




 template < typename N, rounding_strategy K, interval_mode E >
 bool operator !=(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool sge(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool sgt(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool sle(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool slt(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool ceq(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool cne(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool cge(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool cgt(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool cle(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool clt(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool peq(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool pne(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool pge(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool pgt(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool ple(interval<N,K,E> const & x, interval<N,K,E> const & y);



 template < typename N, rounding_strategy K, interval_mode E >
 bool plt(interval<N,K,E> const & x, interval<N,K,E> const & y);




 template < typename N, rounding_strategy K, interval_mode E >
 std::ostream & operator <<(
  std::ostream & out,
  interval<N,K,E> const & a);
 template < typename N, rounding_strategy K, interval_mode E >
 std::ostream & corebench_out(
  std::ostream & out,
  interval<N,K,E> const & a);



 template < typename N, rounding_strategy K, interval_mode E >
 std::istream & operator >>(
  std::istream & out,
  interval<N,K,E> & a)
 throw(interval_io_exception)
 ;




 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> acos(interval<N,K,E> const & x);





 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> acosh(interval<N,K,E> const & x);





 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> acot(interval<N,K,E> const & x);





 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> acoth(interval<N,K,E> const & x);




 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> asin(interval<N,K,E> const & x);





 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> asinh(interval<N,K,E> const & x);




 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> atan(interval<N,K,E> const & x);





 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> atanh(interval<N,K,E> const & x);




 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> cos(interval<N,K,E> const & x);




 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> cosh(interval<N,K,E> const & x);




 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> cot(interval<N,K,E> const & x);





 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> coth(interval<N,K,E> const & x);




 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> exp(interval<N,K,E> const & x);





 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> exp10(interval<N,K,E> const & x);





 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> exp2(interval<N,K,E> const & x);




 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> expm1(interval<N,K,E> const & x);





 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> log(interval<N,K,E> const & x);





 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> log10(interval<N,K,E> const & x);




 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> log1p(interval<N,K,E> const & x);





 template < typename N, rounding_strategy K, interval_mode E >

 interval<N,K,E> log2(interval<N,K,E> const & x);







 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> pow(interval<N,K,E> const & x, int const &);




 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> power(interval<N,K,E> const & x, interval<N,K,E> const & y);




 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> sin(interval<N,K,E> const & x);




 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> sinh(interval<N,K,E> const & x);




 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> sqr(interval<N,K,E> const & x);




 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> sqrt(interval<N,K,E> const & x);




 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> tan(interval<N,K,E> const & x);





 template < typename N, rounding_strategy K, interval_mode E >
 interval<N,K,E> tanh(interval<N,K,E> const & x);
# 578 "/usr/local/include/interval/interval.hpp" 3
 template <typename N = double, rounding_strategy K = native_switched, interval_mode E = i_mode_normal >
 class interval
 {
  protected:



   N INF;



   N SUP;

  public:
   typedef N value_type;
   static const rounding_strategy rounding_type = K;
   typedef fp_traits<N,K> traits_type;

   static bool extended_error_flag;

   static bool getExtendedErrorFlag()
   {
    return extended_error_flag;
   }
   static void resetExtendedErrorFlag()
   {
    extended_error_flag = false;
   }

   static inline interval<N,K,E> constructIntervalNoChecks(N const & rl, N const & ru)
   {
    interval<N,K,E> I;
    I.INF = rl;
    I.SUP = ru;
    return I;
   }

   inline interval<N,K,E> uncheckedIntersect(N const & rl, N const & ru) const
   {
    interval<N,K,E> domain = constructIntervalNoChecks(rl,ru);
    return intersect(domain);
   }






   inline explicit interval(
    N const & rl, N const & ru, char const &);

   inline interval(
    std::string const & infs, std::string const & sups)
   throw(interval_io_exception);




   inline void checkInf();





   inline interval();





   inline interval(N const & rp);






   inline interval(N const & rl, N const & ru);




   inline interval(interval<N,K,E> const & o);




   inline ~interval();




   inline interval<N,K,E> & operator= (interval<N,K,E> const & o);




   inline interval<N,K,E> const & operator+() const;




   inline interval<N,K,E> operator-() const;




   inline N const & inf() const;




   inline N const & sup() const;




   inline interval<N,K,E> & operator +=(interval<N,K,E> const & o);




   inline interval<N,K,E> & operator +=(N const & a);




   inline interval<N,K,E> & operator -=(interval<N,K,E> const & o);




   inline interval<N,K,E> & operator -=(N const & a);




   inline interval<N,K,E> & operator *= (interval<N,K,E> const & a);




   inline interval<N,K,E> & operator *=(N const & a);




   inline interval<N,K,E> & operator /= (interval<N,K,E> const & a);



   inline interval<N,K,E> & operator/= (N const & a);




   inline bool isEmpty() const;
   inline bool isInfinite() const;
   static inline interval<N,K,E> EMPTY();
   static inline interval<N,K,E> ENTIRE();
   static inline interval<N,K,E> NEG_INFTY();
   static inline interval<N,K,E> POS_INFTY();

   static inline interval<N,K,E> ZERO();
   static inline interval<N,K,E> ONE();
   static inline interval<N,K,E> PI();

   inline bool isPoint() const;
# 756 "/usr/local/include/interval/interval.hpp" 3
   bool hasUlpAcc(unsigned int const & n) const;



   static bool isExtended();
# 775 "/usr/local/include/interval/interval.hpp" 3
   N mid() const;
# 787 "/usr/local/include/interval/interval.hpp" 3
   N diam() const;
   N width() const;
# 805 "/usr/local/include/interval/interval.hpp" 3
   N relDiam() const;
# 818 "/usr/local/include/interval/interval.hpp" 3
   N rad() const;
# 830 "/usr/local/include/interval/interval.hpp" 3
   N mig() const;
# 843 "/usr/local/include/interval/interval.hpp" 3
   N mag() const;
# 856 "/usr/local/include/interval/interval.hpp" 3
   interval<N,K,E> abs() const;
# 869 "/usr/local/include/interval/interval.hpp" 3
   interval<N,K,E> imin(interval<N,K,E> const & x) const;
# 882 "/usr/local/include/interval/interval.hpp" 3
   interval<N,K,E> imax(interval<N,K,E> const & x) const;
# 895 "/usr/local/include/interval/interval.hpp" 3
   N dist(interval<N,K,E> const & x) const;






   interval<N,K,E> blow(N const & eps) const;
# 912 "/usr/local/include/interval/interval.hpp" 3
   interval<N,K,E> intersect(interval<N,K,E> const & x) const;
# 922 "/usr/local/include/interval/interval.hpp" 3
   interval<N,K,E> hull(interval<N,K,E> const & x) const;
   interval<N,K,E> interval_hull(interval<N,K,E> const & x) const;
# 933 "/usr/local/include/interval/interval.hpp" 3
   interval<N,K,E> hull(N const & x) const;
   interval<N,K,E> interval_hull(N const & x) const;
# 944 "/usr/local/include/interval/interval.hpp" 3
   bool disjoint(interval<N,K,E> const & x) const;
# 954 "/usr/local/include/interval/interval.hpp" 3
   bool contains(N x) const;
# 964 "/usr/local/include/interval/interval.hpp" 3
   bool interior(interval<N,K,E> const & x) const;
# 974 "/usr/local/include/interval/interval.hpp" 3
   bool proper_subset(interval<N,K,E> const & x) const;
# 984 "/usr/local/include/interval/interval.hpp" 3
   bool subset(interval<N,K,E> const & x) const;
# 994 "/usr/local/include/interval/interval.hpp" 3
   bool proper_superset(interval<N,K,E> const & x) const;
# 1004 "/usr/local/include/interval/interval.hpp" 3
   bool superset(interval<N,K,E> const & x) const;
# 1014 "/usr/local/include/interval/interval.hpp" 3
   bool seq(interval<N,K,E> const & x) const;




   bool sne(interval<N,K,E> const & x) const;
# 1030 "/usr/local/include/interval/interval.hpp" 3
   bool sge(interval<N,K,E> const & x) const;
# 1040 "/usr/local/include/interval/interval.hpp" 3
   bool sgt(interval<N,K,E> const & x) const;
# 1051 "/usr/local/include/interval/interval.hpp" 3
   bool sle(interval<N,K,E> const & x) const;
# 1061 "/usr/local/include/interval/interval.hpp" 3
   bool slt(interval<N,K,E> const & x) const;
# 1071 "/usr/local/include/interval/interval.hpp" 3
   bool ceq(interval<N,K,E> const & x) const;
# 1081 "/usr/local/include/interval/interval.hpp" 3
   bool cne(interval<N,K,E> const & x) const;
# 1092 "/usr/local/include/interval/interval.hpp" 3
   bool cge(interval<N,K,E> const & x) const;
# 1102 "/usr/local/include/interval/interval.hpp" 3
   bool cgt(interval<N,K,E> const & x) const;
# 1113 "/usr/local/include/interval/interval.hpp" 3
   bool cle(interval<N,K,E> const & x) const;
# 1123 "/usr/local/include/interval/interval.hpp" 3
   bool clt(interval<N,K,E> const & x) const;
# 1133 "/usr/local/include/interval/interval.hpp" 3
   bool peq(interval<N,K,E> const & x) const;
# 1143 "/usr/local/include/interval/interval.hpp" 3
   bool pne(interval<N,K,E> const & x) const;
# 1154 "/usr/local/include/interval/interval.hpp" 3
   bool pge(interval<N,K,E> const & x) const;
# 1164 "/usr/local/include/interval/interval.hpp" 3
   bool pgt(interval<N,K,E> const & x) const;
# 1175 "/usr/local/include/interval/interval.hpp" 3
   bool ple(interval<N,K,E> const & x) const;
# 1185 "/usr/local/include/interval/interval.hpp" 3
   bool plt(interval<N,K,E> const & x) const;




   std::ostream & bitImage(std::ostream & os) const;



   std::ostream & hexImage(std::ostream & os) const;




   static int const & precision();



   static int precision (int const &);



   inline N amin() const;



   inline N amax() const;

   static interval<N,K,E> readBitImage(std::istream &)
    throw(interval_io_exception);
   static interval<N,K,E> readHexImage(std::istream &)
    throw(interval_io_exception);
 };

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::extended_error_flag = false;
}

# 1 "/usr/local/include/interval/tools.icc" 1 3
# 29 "/usr/local/include/interval/tools.icc" 3
namespace filib
{
 template <typename N>
 inline long int long_int_cast(N const & a)
 {
  return static_cast<long int>(a);
 }

 template <typename N>
 inline float float_cast(N const & a)
 {
  return static_cast<float>(a);
 }
}
# 1224 "/usr/local/include/interval/interval.hpp" 2 3
# 1 "/usr/local/include/interval/interval.icc" 1 3
# 30 "/usr/local/include/interval/interval.icc" 3
# 1 "/usr/include/c++/7/cctype" 1 3
# 39 "/usr/include/c++/7/cctype" 3
       
# 40 "/usr/include/c++/7/cctype" 3
# 31 "/usr/local/include/interval/interval.icc" 2 3




namespace filib
{



 template<typename N,rounding_strategy K,interval_mode E>
 interval<N,K,E> const & interval<N,K,E>::operator+() const
 {
  return *this;
 }




 template<typename N,rounding_strategy K,interval_mode E>
 interval<N,K,E> interval<N,K,E>::operator-() const
 {
  return interval<N,K,E>(-SUP,-INF);
 }






 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E>::interval(
  N const & rl,
  N const & ru,
  char const &
 ) : INF(rl), SUP(ru)
 {
  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsNaN(rl) || fp_traits<N,K>::IsNaN(ru) ) )
   interval<N,K,E>::extended_error_flag = true;
 }




 template <typename N,rounding_strategy K,interval_mode E>
 inline interval<N,K,E>::interval(
  std::string const & infs, std::string const & sups
 ) throw(interval_io_exception)
  :
  INF(inferFromString<N,false>(infs)),
  SUP(inferFromString<N,true> (sups))
 {
  checkInf();

  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsNaN(INF) || fp_traits<N,K>::IsNaN(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;
  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;
 }




 template <typename N, rounding_strategy K, interval_mode E>
 inline void interval<N,K,E>::checkInf()
 {
  if ( E )
  {
   if ( SUP < -fp_traits<N,K>::max_val )
   {
    SUP = -fp_traits<N,K>::max_val;
    if ( E == i_mode_extended_flag )
     interval<N,K,E>::extended_error_flag = true;
   }

   else if ( INF > fp_traits<N,K>::max_val )
   {
    INF = fp_traits<N,K>::max_val;
    if ( E == i_mode_extended_flag )
     interval<N,K,E>::extended_error_flag = true;
   }
  }
 }





 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E>::interval()
 : INF(0.0), SUP(0.0)
 {
 }






 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E>::interval(N const & rl, N const & ru)
 : INF(rl), SUP(ru)
 {
  if ( E )
  {
   if ( INF <= SUP )
   {
    checkInf();
    if ( E == i_mode_extended_flag && (fp_traits<N,K>::IsNaN(INF) || fp_traits<N,K>::IsNaN(SUP)) )
     interval<N,K,E>::extended_error_flag = true;
    if ( E == i_mode_extended_flag && (fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP)) )
     interval<N,K,E>::extended_error_flag = true;
   }
   else
   {
    INF = SUP = fp_traits<N,K>::nan_val;

    if ( E == i_mode_extended_flag )
     interval<N,K,E>::extended_error_flag = true;
   }
  }
 }





 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E>::interval(N const & rp)
 : INF(rp), SUP(rp)
 {
  if ( E )
   checkInf();

  if ( E == i_mode_extended_flag && (fp_traits<N,K>::IsNaN(rp)) )
   interval<N,K,E>::extended_error_flag = true;
 }




 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E>::interval(interval<N,K,E> const & o)
 : INF(o.INF), SUP(o.SUP)
 {
 }




 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E>::~interval() {}




 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> & interval<N,K,E>::operator= (interval<N,K,E> const & o)
 {
# 200 "/usr/local/include/interval/interval.icc" 3
  if ( this != &o )

  {
   INF = o.INF;
   SUP = o.SUP;
  }
  return *this;
 }




 template <typename N, rounding_strategy K, interval_mode E>
 inline N const & interval<N,K,E>::inf() const
 {
  return INF;
 }



 template <typename N, rounding_strategy K, interval_mode E>
 inline N const & interval<N,K,E>::sup() const
 {
  return SUP;
 }

 template<typename N,rounding_strategy K,interval_mode E>
 inline bool interval<N,K,E>::isEmpty() const
 {
  if ( E )
   return fp_traits<N,K>::IsNaN(INF);
  else
  {
   std::cerr << "filib: Can not call isEmpty for non extended interval." << std::endl;
   std::terminate();
  }
 }

 template<typename N,rounding_strategy K, interval_mode E>
 inline bool isEmpty(interval<N,K,E> const & a)
 {
  return a.isEmpty();
 }

 template<typename N,rounding_strategy K,interval_mode E>
 inline bool interval<N,K,E>::isPoint() const
 {
  return INF == SUP;
 }

 template<typename N,rounding_strategy K,interval_mode E>
 inline bool isPoint(interval<N,K,E> const & a)
 {
  return a.isPoint();
 }

 template<typename N,rounding_strategy K, interval_mode E>
 inline bool interval<N,K,E>::isInfinite() const
 {
  if ( E )
   return fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP);
  else
  {
   std::cerr << "filib: Can not call isInfinite for non extended interval." << std::endl;
   std::terminate();
  }
 }

 template<typename N,rounding_strategy K, interval_mode E>
 inline bool isInfinite(interval<N,K,E> const & a)
 {
  return a.isInfinite();
 }

 template<typename N,rounding_strategy K, interval_mode E>
 inline interval<N,K,E> interval<N,K,E>::EMPTY()
 {
  if ( E )
  {
   if ( E == i_mode_extended_flag )
    interval<N,K,E>::extended_error_flag = true;

   return
   interval<N,K,E>(
    fp_traits<N,K>::nan_val,
    fp_traits<N,K>::nan_val,
    '-');
  }
  else
  {
   std::cerr << "filib: Can not call EMPTY for non extended interval." << std::endl;
   std::terminate();
  }
 }

 template<typename N,rounding_strategy K, interval_mode E>
 inline interval<N,K,E> interval<N,K,E>::NEG_INFTY()
 {
  if ( E )
  {
   if ( E == i_mode_extended_flag )
    interval<N,K,E>::extended_error_flag = true;

   return
    interval<N,K,E>(
     fp_traits<N,K>::ninf_val,
     -fp_traits<N,K>::max_val,
     '-');
  }
  else
  {
   std::cerr << "filib: Can not call NEG_INFTY for non extended interval." << std::endl;
   std::terminate();
  }
 }

 template<typename N,rounding_strategy K, interval_mode E>
 inline interval<N,K,E> interval<N,K,E>::POS_INFTY()
 {
  if ( E )
  {
   if ( E == i_mode_extended_flag )
    interval<N,K,E>::extended_error_flag = true;
   return
    interval<N,K,E>(
     fp_traits<N,K>::max_val,
     fp_traits<N,K>::inf_val,
     '-');
  }
  else
  {
   std::cerr << "filib: Can not call POS_INFTY for non extended interval." << std::endl;
   std::terminate();
  }
 }

 template<typename N,rounding_strategy K,interval_mode E>
 inline interval<N,K,E> interval<N,K,E>::ENTIRE()
 {
  if ( E )
  {
   if ( E == i_mode_extended_flag )
    interval<N,K,E>::extended_error_flag = true;

   return interval<N,K,E>(
    fp_traits<N,K>::ninf_val,
    fp_traits<N,K>::inf_val,
    '-');
  }
  {
   std::cerr << "filib: Can not call ENTIRE for non extended interval." << std::endl;
   std::terminate();
  }
 }

 template<typename N,rounding_strategy K,interval_mode E>
 inline interval<N,K,E> interval<N,K,E>::PI()
 {
  return interval<N,K,E>(
    fp_traits<N,K>::l_pi_val,
    fp_traits<N,K>::u_pi_val,
    '-');
 }

 template<typename N,rounding_strategy K,interval_mode E>
 inline interval<N,K,E> interval<N,K,E>::ZERO()
 {
  return interval<N,K,E>(0.0,0.0,'-');
 }

 template<typename N,rounding_strategy K,interval_mode E>
 inline interval<N,K,E> interval<N,K,E>::ONE()
 {
  return interval<N,K,E>(1.0,1.0,'-');
 }

# 1 "/usr/local/include/interval/interval_arith.icc" 1 3
# 30 "/usr/local/include/interval/interval_arith.icc" 3
 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> & interval<N,K,E>::operator +=(interval<N,K,E> const & o)
 {
  INF=fp_traits<N,K>::downward_plus(INF,o.INF,false);
  SUP=fp_traits<N,K>::upward_plus(SUP,o.SUP,true);

  if ( E )
   checkInf();

  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;

  return *this;
 }




 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> & interval<N,K,E>::operator +=(N const & a)
 {
  if ( E )
   if ( fp_traits<N,K>::IsInf(a) )
    return (*this += interval<N,K,E>(a));

  INF=fp_traits<N,K>::downward_plus(INF,a,false);
  SUP=fp_traits<N,K>::upward_plus(SUP,a,true);

  if ( E )
   checkInf();

  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsNaN(INF) || fp_traits<N,K>::IsNaN(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;
  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;

  return *this;
 }




 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> & interval<N,K,E>::operator -=(interval<N,K,E> const & o)
 {
  if ( this == &o )
  {
   interval<N,K,E> t = *this-o;
   *this = t;
  }
  else
  {
   INF=fp_traits<N,K>::downward_minus(INF,o.SUP,false);
   SUP=fp_traits<N,K>::upward_minus(SUP,o.INF,true);

   if ( E )
    checkInf();
  }

  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;

  return *this;
 }



 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> & interval<N,K,E>::operator -=(N const & a)
 {
  if ( E )
   if ( fp_traits<N,K>::IsInf(a) )
    return (*this -= interval<N,K,E>(a));

  INF=fp_traits<N,K>::downward_minus(INF,a,false);
  SUP=fp_traits<N,K>::upward_minus(SUP,a,true);

  if ( E )
   checkInf();

  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsNaN(INF) || fp_traits<N,K>::IsNaN(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;
  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;

  return *this;
 }



 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> & interval<N,K,E>::operator *= (interval<N,K,E> const & a)
 {
  if ( this == &a )
  {
   interval<N,K,E> t = *this*a;
   *this = t;
   return *this;
  }

  bool was_empty;

  if ( E )
  {
   was_empty = isEmpty();



   if ( INF > 0.0 )
   {



    if ( a.INF > 0.0 )
    {
     INF=fp_traits<N,K>::downward_multiplies(INF,a.INF,false);
     SUP=fp_traits<N,K>::upward_multiplies(SUP,a.SUP,true);
    }



    else if ( a.SUP < 0.0 )
    {
     N tmp = INF;
     INF=fp_traits<N,K>::downward_multiplies(SUP,a.INF,false);
     SUP=fp_traits<N,K>::upward_multiplies(tmp,a.SUP,true);
    }



    else
    {
     INF=fp_traits<N,K>::downward_multiplies(SUP,a.INF,false);
     SUP=fp_traits<N,K>::upward_multiplies(SUP,a.SUP,true);
    }
   }



   else if ( SUP < 0.0 )
   {



    if ( a.INF > 0.0 )
    {
     INF=fp_traits<N,K>::downward_multiplies(INF,a.SUP,false);
     SUP=fp_traits<N,K>::upward_multiplies(SUP,a.INF,true);
    }



    else if ( a.SUP < 0.0 )
    {
     N tmp = INF;
     INF=fp_traits<N,K>::downward_multiplies(SUP,a.SUP,false);
     SUP=fp_traits<N,K>::upward_multiplies(tmp,a.INF,true);
    }



    else
    {
     N tmp = INF;
     INF=fp_traits<N,K>::downward_multiplies(INF,a.SUP,false);
     SUP=fp_traits<N,K>::upward_multiplies(tmp,a.INF,true);
    }
   }



   else
   {
    if ( a.INF > 0.0 )
    {
     INF=fp_traits<N,K>::downward_multiplies(INF,a.SUP,false);
     SUP=fp_traits<N,K>::upward_multiplies(SUP,a.SUP,true);
    }
    else if ( a.SUP < 0.0 )
    {
     N tmp = INF;
     INF=fp_traits<N,K>::downward_multiplies(SUP,a.INF,false);
     SUP=fp_traits<N,K>::upward_multiplies(tmp,a.INF,true);
    }
    else
    {
     if (
      isInfinite() && ! a.isEmpty() ||
      a.isInfinite() && ! isEmpty()
     )
     {
      *this = ENTIRE();
      return *this;
     }
     else
     {
      N tmp, tmp2 = INF;

      INF=fp_traits<N,K>::downward_multiplies(INF,a.SUP,false);
      tmp=fp_traits<N,K>::downward_multiplies(SUP,a.INF,true);
      INF = std::min(tmp,INF);

      SUP=fp_traits<N,K>::upward_multiplies(SUP,a.SUP,false);
      tmp=fp_traits<N,K>::upward_multiplies(tmp2,a.INF,true);
      SUP = std::max(tmp,SUP);
     }
    }
   }
  }
  else
  {
   if ( INF >= 0 )
   {
    if ( a.INF >= 0.0 )
    {
     INF=fp_traits<N,K>::downward_multiplies(INF,a.INF,false);
     SUP=fp_traits<N,K>::upward_multiplies(SUP,a.SUP,true);
    }
    else if ( a.SUP <= 0.0 )
    {
     N tmp = INF;
     INF=fp_traits<N,K>::downward_multiplies(SUP,a.INF,false);
     SUP=fp_traits<N,K>::upward_multiplies(tmp,a.SUP,true);
    }
    else
    {
     INF=fp_traits<N,K>::downward_multiplies(SUP,a.INF,false);
     SUP=fp_traits<N,K>::upward_multiplies(SUP,a.SUP,true);
    }
   }
   else if ( SUP <= 0 )
   {
    if ( a.INF >= 0.0 )
    {
     INF=fp_traits<N,K>::downward_multiplies(INF,a.SUP,false);
     SUP=fp_traits<N,K>::upward_multiplies(SUP,a.INF,true);
    }
    else if ( a.SUP <= 0.0 )
    {
     N tmp = INF;
     INF=fp_traits<N,K>::downward_multiplies(SUP,a.SUP,false);
     SUP=fp_traits<N,K>::upward_multiplies(tmp,a.INF,true);
    }
    else
    {
     N tmp = INF;
     INF=fp_traits<N,K>::downward_multiplies(INF,a.SUP,false);
     SUP=fp_traits<N,K>::upward_multiplies(tmp,a.INF,true);
    }
   }
   else
   {
    if ( a.INF >= 0.0 )
    {
     INF=fp_traits<N,K>::downward_multiplies(INF,a.SUP,false);
     SUP=fp_traits<N,K>::upward_multiplies(SUP,a.SUP,true);
    }
    else if ( a.SUP <= 0.0 )
    {
     N tmp = INF;
     INF=fp_traits<N,K>::downward_multiplies(SUP,a.INF,false);
     SUP=fp_traits<N,K>::upward_multiplies(tmp,a.INF,true);
    }
    else
    {
     N tmp, tmp2 = INF;

     INF=fp_traits<N,K>::downward_multiplies(INF,a.SUP,false);
     tmp=fp_traits<N,K>::downward_multiplies(SUP,a.INF,true);
     INF = std::min(tmp,INF);

     SUP=fp_traits<N,K>::upward_multiplies(SUP,a.SUP,false);
     tmp=fp_traits<N,K>::upward_multiplies(tmp2,a.INF,true);
     SUP = std::max(SUP,tmp);
    }
   }
  }

  if ( E )
   checkInf();

  if ( E )
   if ( fp_traits<N,K>::IsNaN(INF) || fp_traits<N,K>::IsNaN(SUP) )
    if ( ! ( was_empty || a.isEmpty() ) )
     *this = ENTIRE();

  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;

  return *this;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> & interval<N,K,E>::operator *=(N const & a)
 {
   if ( E && isEmpty() )
    return *this;
   else if ( E && fp_traits<N,K>::IsNaN(a) )
   {
    *this = EMPTY();
    if ( E == i_mode_extended_flag )
     interval<N,K,E>::extended_error_flag = true;
    return *this;
   }
   else
   {
    if ( a >= 0.0 )
    {
     INF=fp_traits<N,K>::downward_multiplies(INF,a,false);
     SUP=fp_traits<N,K>::upward_multiplies(SUP,a,true);
    }
    else
    {
     N tmp = INF;
     INF=fp_traits<N,K>::downward_multiplies(SUP,a,false);
     SUP=fp_traits<N,K>::upward_multiplies(tmp,a,true);
    }
   }

   if ( E )
   {
    if ( fp_traits<N,K>::IsNaN(INF) || fp_traits<N,K>::IsNaN(SUP) )
     *this = ENTIRE();
    else
     checkInf();
   }

   if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP)) )
    interval<N,K,E>::extended_error_flag = true;

   return *this;
 }




 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> & interval<N,K,E>::operator /= (interval<N,K,E> const & a)
 {
  if ( this == &a )
  {
   interval<N,K,E> t = *this/a;
   *this = t;
   return *this;
  }

   if ( E && isEmpty() )
    return *this;
   else if ( E && a.isEmpty() )
   {
    *this = EMPTY();
    return *this;
   }
   else
   {
    if ( a.INF > 0.0 )
    {
     if ( INF >= 0.0 )
     {
      INF=fp_traits<N,K>::downward_divides(INF,a.SUP,false);
      SUP=fp_traits<N,K>::upward_divides(SUP,a.INF,true);
     }
     else if ( SUP <= 0.0 )
     {
      INF=fp_traits<N,K>::downward_divides(INF,a.INF,false);
      SUP=fp_traits<N,K>::upward_divides(SUP,a.SUP,true);
     }
     else
     {
      INF=fp_traits<N,K>::downward_divides(INF,a.INF,false);
      SUP=fp_traits<N,K>::upward_divides(SUP,a.INF,true);
     }
    }
    else if ( a.SUP < 0.0 )
    {
     if ( INF >= 0.0 )
     {
      N tmp = INF;
      INF=fp_traits<N,K>::downward_divides(SUP,a.SUP,false);
      SUP=fp_traits<N,K>::upward_divides(tmp,a.INF,true);
     }
     else if ( SUP <= 0.0 )
     {
      N tmp = INF;
      INF=fp_traits<N,K>::downward_divides(SUP,a.INF,false);
      SUP=fp_traits<N,K>::upward_divides(tmp,a.SUP,true);
     }
     else
     {
      N tmp = INF;
      INF=fp_traits<N,K>::downward_divides(SUP,a.SUP,false);
      SUP=fp_traits<N,K>::upward_divides(tmp,a.SUP,true);
     }
    }
    else
    {
     if ( E )
     {
      if ( contains(0.) )
      {
       *this = ENTIRE();
      }
      else if ( a.inf() == 0. )
      {
       if ( sup() < 0. )
       {
        N nSUP; nSUP=fp_traits<N,K>::upward_divides(SUP,a.SUP,true);
        INF = fp_traits<N,K>::ninf_val;
        SUP = nSUP;
       }
       else
       {
        N nINF; nINF=fp_traits<N,K>::downward_divides(inf(),a.sup(),true);
        INF = nINF;
        SUP = fp_traits<N,K>::inf_val;
       }
      }
      else if ( a.sup() == 0. )
      {
       if ( sup() < 0. )
       {
        N nINF; nINF=fp_traits<N,K>::downward_divides(sup(),a.inf(),true);
        INF = nINF;
        SUP = fp_traits<N,K>::inf_val;
       }
       else
       {
        N nSUP; nSUP=fp_traits<N,K>::upward_divides(inf(),a.inf(),true);
        INF = fp_traits<N,K>::ninf_val;
        SUP = nSUP;
       }
      }
      else
      {
       *this = ENTIRE();
      }
     }
     else
     {
      std::cerr
       << std::endl
       << "error in filib-- operator/=, division by zero."
       << std::endl
       << "divident: " << *this << " "
       << "divisor: " << a
       << std::endl;
      std::terminate();
     }
    }

    if ( E )
     checkInf();

    if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsNaN(INF) || fp_traits<N,K>::IsNaN(SUP) ) )
     interval<N,K,E>::extended_error_flag = true;
    if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
     interval<N,K,E>::extended_error_flag = true;

    return *this;
   }
 }




 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> & interval<N,K,E>::operator/= (N const & a)
 {
   if ( E && fp_traits<N,K>::IsInf(a) )
    return (*this /= interval<N,K,E>(a));
   else if ( E && isEmpty() )
    return *this;
   else if ( E && fp_traits<N,K>::IsNaN(a) )
   {
    *this = EMPTY();
    return *this;
   }
   else
   {
    if ( a == 0.0 )
    {
     if ( E )
     {
      *this = ENTIRE();
      return *this;
     }
     else
     {
      std::cerr
       << std::endl
       << "error in filib.2 operator/=, division by zero."
       << std::endl
       << "divident: " << *this << " "
       << "divisor: " << interval<N,K,E>(a)
       << std::endl;
      std::terminate();
     }
    }
    else if ( a > 0.0 )
    {
     INF=fp_traits<N,K>::downward_divides(INF,a,false);
     SUP=fp_traits<N,K>::upward_divides(SUP,a,true);
    }
    else
    {
     N tmp = INF;
     INF=fp_traits<N,K>::downward_divides(SUP,a,false);
     SUP=fp_traits<N,K>::upward_divides(tmp,a,true);
    }

    if ( E )
    {
     if ( fp_traits<N,K>::IsNaN(INF) )
      INF = fp_traits<N,K>::ninf_val;
     if ( fp_traits<N,K>::IsNaN(SUP) )
      SUP = fp_traits<N,K>::inf_val;
    }

    if ( E )
     checkInf();

    if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsNaN(INF) || fp_traits<N,K>::IsNaN(SUP) ) )
     interval<N,K,E>::extended_error_flag = true;
    if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
     interval<N,K,E>::extended_error_flag = true;

    return *this;
   }
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> operator+(
  interval<N,K,E> const & a,
  interval<N,K,E> const & b)
 {
  N INF; INF=fp_traits<N,K>::downward_plus(a.inf(),b.inf(),false);
  N SUP; SUP=fp_traits<N,K>::upward_plus(a.sup(),b.sup(),true);
  interval<N,K,E> r(INF,SUP);

  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;
  return r;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> operator+ (
  interval<N,K,E> const & a,
  N const & b)
 {
  if ( E )
   if ( fp_traits<N,K>::IsInf(b) )
    return a+interval<N,K,E>(b);

  N INF; INF=fp_traits<N,K>::downward_plus(a.inf(),b,false);
  N SUP; SUP=fp_traits<N,K>::upward_plus(a.sup(),b,true);
  interval<N,K,E> r(INF,SUP);

  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsNaN(INF) || fp_traits<N,K>::IsNaN(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;
  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;

  return r;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> operator+ (
  N const & b,
  interval<N,K,E> const & a)
 {
  if ( E )
   if ( fp_traits<N,K>::IsInf(b) )
    return a+interval<N,K,E>(b);

  N INF; INF=fp_traits<N,K>::downward_plus(a.inf(),b,false);
  N SUP; SUP=fp_traits<N,K>::upward_plus(a.sup(),b,true);
  interval<N,K,E> r(INF,SUP);

  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsNaN(INF) || fp_traits<N,K>::IsNaN(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;
  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;

  return r;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> operator-(
  interval<N,K,E> const & a,
  interval<N,K,E> const & b)
 {
  N INF; INF=fp_traits<N,K>::downward_minus(a.inf(),b.sup(),false);
  N SUP; SUP=fp_traits<N,K>::upward_minus(a.sup(),b.inf(),true);
  interval<N,K,E> r(INF,SUP);

  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;

  return r;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> cancel(
  interval<N,K,E> const & a,
  interval<N,K,E> const & b)
 {
  N INF; INF=fp_traits<N,K>::downward_minus(a.inf(),b.inf(),false);
  N SUP; SUP=fp_traits<N,K>::upward_minus(a.sup(),b.sup(),true);
  interval<N,K,E> r(INF,SUP);

  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;

  return r;
 }

 template<typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> operator- (
   interval<N,K,E> const & a,
   N const & b)
 {
  if ( E )
   if ( fp_traits<N,K>::IsInf(b) )
    return (a-interval<N,K,E>(b));

  N INF; INF=fp_traits<N,K>::downward_minus(a.inf(),b,false);
  N SUP; SUP=fp_traits<N,K>::upward_minus(a.sup(),b,true);
  interval<N,K,E> r(INF,SUP);

  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsNaN(INF) || fp_traits<N,K>::IsNaN(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;
  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;

  return r;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> operator- (
   N const & b,
   interval<N,K,E> const & a)
 {
  if ( E )
   if ( fp_traits<N,K>::IsInf(b) )
    return (interval<N,K,E>(b)-a);

  N INF; INF=fp_traits<N,K>::downward_minus(b,a.sup(),false);
  N SUP; SUP=fp_traits<N,K>::upward_minus(b,a.inf(),true);
  interval<N,K,E> r(INF,SUP);

  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsNaN(INF) || fp_traits<N,K>::IsNaN(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;
  if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
   interval<N,K,E>::extended_error_flag = true;

  return r;
 }


 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> operator*(
  interval<N,K,E> const & a,
  interval<N,K,E> const & b)
 {
  struct { N INF; N SUP; } res;

  if ( E )
  {

   if (a.inf() > 0)
   {

    if (b.inf() > 0.0)
    {
     res.INF=fp_traits<N,K>::downward_multiplies(a.inf(),b.inf(),false);
     res.SUP=fp_traits<N,K>::upward_multiplies(a.sup(),b.sup(),true);
    }

    else if (b.sup() < 0.0)
    {
     res.INF=fp_traits<N,K>::downward_multiplies(a.sup(),b.inf(),false);
     res.SUP=fp_traits<N,K>::upward_multiplies(a.inf(),b.sup(),true);
    }
    else

    {
     res.INF=fp_traits<N,K>::downward_multiplies(a.sup(),b.inf(),false);
     res.SUP=fp_traits<N,K>::upward_multiplies(a.sup(),b.sup(),true);
    }
   }

   else if (a.sup() < 0.0)
   {

    if (b.inf() > 0.0)
    {
     res.INF=fp_traits<N,K>::downward_multiplies(a.inf(),b.sup(),false);
     res.SUP=fp_traits<N,K>::upward_multiplies(a.sup(),b.inf(),true);
    }

    else if (b.sup() < 0.0)
    {
     res.INF=fp_traits<N,K>::downward_multiplies(a.sup(),b.sup(),false);
     res.SUP=fp_traits<N,K>::upward_multiplies(a.inf(),b.inf(),true);
    }

    else
    {
     res.INF=fp_traits<N,K>::downward_multiplies(a.inf(),b.sup(),false);
     res.SUP=fp_traits<N,K>::upward_multiplies(a.inf(),b.inf(),true);
    }
   }

   else
   {

    if (b.inf() > 0.0)
    {
     res.INF=fp_traits<N,K>::downward_multiplies(a.inf(),b.sup(),false);
     res.SUP=fp_traits<N,K>::upward_multiplies(a.sup(),b.sup(),true);
    }

    else if (b.sup() < 0.0)
    {
     res.INF=fp_traits<N,K>::downward_multiplies(a.sup(),b.inf(),false);
     res.SUP=fp_traits<N,K>::upward_multiplies(a.inf(),b.inf(),true);
    }

    else
    {
     if (
      (a.isInfinite() && !b.isEmpty()) ||
      (b.isInfinite() && !a.isEmpty())
     )
      return interval<N,K,E>::ENTIRE();
     else
     {
      N tmp;
      res.INF=fp_traits<N,K>::downward_multiplies(a.inf(),b.sup(),false);
      tmp=fp_traits<N,K>::downward_multiplies(a.sup(),b.inf(),false);

      if (tmp < res.INF)
       res.INF = tmp;

      res.SUP=fp_traits<N,K>::upward_multiplies(a.sup(),b.sup(),false);
      tmp=fp_traits<N,K>::upward_multiplies(a.inf(),b.inf(),true);

      if (tmp > res.SUP)
       res.SUP = tmp;
     }
    }
   }
  }
  else
  {
   if (a.inf() >= 0)
   {
    if (b.inf() >= 0.0)
    {
     res.INF=fp_traits<N,K>::downward_multiplies(a.inf(),b.inf(),false);
     res.SUP=fp_traits<N,K>::upward_multiplies(a.sup(),b.sup(),true);
    }
    else if (b.sup() <=0.0)
    {
     res.INF=fp_traits<N,K>::downward_multiplies(a.sup(),b.inf(),false);
     res.SUP=fp_traits<N,K>::upward_multiplies(a.inf(),b.sup(),true);
    }
    else
    {
     res.INF=fp_traits<N,K>::downward_multiplies(a.sup(),b.inf(),false);
     res.SUP=fp_traits<N,K>::upward_multiplies(a.sup(),b.sup(),true);
    }
   }
   else if (a.sup() <= 0.0)
   {
    if (b.inf() >= 0.0)
    {
     res.INF=fp_traits<N,K>::downward_multiplies(a.inf(),b.sup(),false);
     res.SUP=fp_traits<N,K>::upward_multiplies(a.sup(),b.inf(),true);
    }
    else if (b.sup() <=0.0)
    {
     res.INF=fp_traits<N,K>::downward_multiplies(a.sup(),b.sup(),false);
     res.SUP=fp_traits<N,K>::upward_multiplies(a.inf(),b.inf(),true);
    }
    else
    {
     res.INF=fp_traits<N,K>::downward_multiplies(a.inf(),b.sup(),false);
     res.SUP=fp_traits<N,K>::upward_multiplies(a.inf(),b.inf(),true);
    }
   }
   else
   {
    if (b.inf() >= 0.0)
    {
     res.INF=fp_traits<N,K>::downward_multiplies(a.inf(),b.sup(),false);
     res.SUP=fp_traits<N,K>::upward_multiplies(a.sup(),b.sup(),true);
    }
    else if (b.sup() <=0.0)
    {
     res.INF=fp_traits<N,K>::downward_multiplies(a.sup(),b.inf(),false);
     res.SUP=fp_traits<N,K>::upward_multiplies(a.inf(),b.inf(),true);
    }
    else
    {
     N tmp;
     res.INF=fp_traits<N,K>::downward_multiplies(a.inf(),b.sup(),false);
     tmp=fp_traits<N,K>::downward_multiplies(a.sup(),b.inf(),false);

     if (tmp < res.INF)
      res.INF = tmp;

     res.SUP=fp_traits<N,K>::upward_multiplies(a.sup(),b.sup(),false);
     tmp=fp_traits<N,K>::upward_multiplies(a.inf(),b.inf(),true);

     if (tmp > res.SUP)
      res.SUP = tmp;
    }
   }
  }

  if ( E )
  {
   if ( fp_traits<N,K>::IsNaN(res.INF) || fp_traits<N,K>::IsNaN(res.SUP))
    if (! (a.isEmpty() || b.isEmpty()))
     return interval<N,K,E>::ENTIRE();
  }

  return interval<N,K,E>(res.INF,res.SUP);
 }

 template<typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> operator* (
  interval<N,K,E> const & a,
  N const & b)
 {
   if ( E && a.isEmpty() )
    return a;
   else if ( E && fp_traits<N,K>::IsNaN(b) )
    return interval<N,K,E>::EMPTY();
   else
   {
    if ( b >= 0.0 )
    {
     N INF; INF=fp_traits<N,K>::downward_multiplies(a.inf(),b,false);
     N SUP; SUP=fp_traits<N,K>::upward_multiplies(a.sup(),b,true);
     interval<N,K,E> r(INF,SUP);

     if ( E )
     {
      if ( fp_traits<N,K>::IsNaN(INF) || fp_traits<N,K>::IsNaN(SUP) )
       r = interval<N,K,E>::ENTIRE();
      else
       r.checkInf();
     }

     if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
      interval<N,K,E>::extended_error_flag = true;

     return r;
    }
    else
    {
     N INF; INF=fp_traits<N,K>::downward_multiplies(a.sup(),b,false);
     N SUP; SUP=fp_traits<N,K>::upward_multiplies(a.inf(),b,true);
     interval<N,K,E> r(INF,SUP);

     if ( E )
     {
      if ( fp_traits<N,K>::IsNaN(r.inf()) || fp_traits<N,K>::IsNaN(r.sup()) )
       r = interval<N,K,E>::ENTIRE();
      else
       r.checkInf();
     }

     if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsNaN(INF) || fp_traits<N,K>::IsNaN(SUP) ) )
      interval<N,K,E>::extended_error_flag = true;
     if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
      interval<N,K,E>::extended_error_flag = true;

     return r;
    }
   }
 }

 template<typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> operator* (
  N const & b,
  interval<N,K,E> const & a)
 {
   if ( E && a.isEmpty() )
    return a;
   else if ( E && fp_traits<N,K>::IsNaN(b) )
    return interval<N,K,E>::EMPTY();
   else
   {
    if ( b >= 0.0 )
    {
     N INF; INF=fp_traits<N,K>::downward_multiplies(a.inf(),b,false);
     N SUP; SUP=fp_traits<N,K>::upward_multiplies(a.sup(),b,true);
     interval<N,K,E> r(INF,SUP);

     if ( E )
     {
      if ( fp_traits<N,K>::IsNaN(r.inf()) || fp_traits<N,K>::IsNaN(r.sup()) )
       r = interval<N,K,E>::ENTIRE();
      else
       r.checkInf();
     }

     if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
      interval<N,K,E>::extended_error_flag = true;

     return r;
    }
    else
    {
     N INF; INF=fp_traits<N,K>::downward_multiplies(a.sup(),b,false);
     N SUP; SUP=fp_traits<N,K>::upward_multiplies(a.inf(),b,true);
     interval<N,K,E> r(INF,SUP);

     if ( E )
     {
      if ( fp_traits<N,K>::IsNaN(r.inf()) || fp_traits<N,K>::IsNaN(r.sup()) )
       r = interval<N,K,E>::ENTIRE();
      else
       r.checkInf();
     }

     if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsNaN(INF) || fp_traits<N,K>::IsNaN(SUP) ) )
      interval<N,K,E>::extended_error_flag = true;
     if ( E == i_mode_extended_flag && ( fp_traits<N,K>::IsInf(INF) || fp_traits<N,K>::IsInf(SUP) ) )
      interval<N,K,E>::extended_error_flag = true;

     return r;
    }
   }
 }

 template <typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> operator/ (interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  if ( E && ( a.isEmpty() || b.isEmpty() ) )
   return interval<N,K,E>::EMPTY();




  if ( b.inf() > 0.0 )
  {



   if ( a.inf() >= 0.0 )
   {
    N INF; INF=fp_traits<N,K>::downward_divides(a.inf(),b.sup(),false);
    N SUP; SUP=fp_traits<N,K>::upward_divides(a.sup(),b.inf(),true);
    interval<N,K,E> r(INF,SUP);
    return r;
   }



   else if ( a.sup() <= 0.0 )
   {
    N INF; INF=fp_traits<N,K>::downward_divides(a.inf(),b.inf(),false);
    N SUP; SUP=fp_traits<N,K>::upward_divides(a.sup(),b.sup(),true);
    interval<N,K,E> r(INF,SUP);
    return r;
   }



   else
   {
    N INF; INF=fp_traits<N,K>::downward_divides(a.inf(),b.inf(),false);
    N SUP; SUP=fp_traits<N,K>::upward_divides(a.sup(),b.inf(),true);
    interval<N,K,E> r(INF,SUP);
    return r;
   }
  }



  else if ( b.sup() < 0.0 )
  {



   if ( a.inf() >= 0.0 )
   {
    N INF; INF=fp_traits<N,K>::downward_divides(a.sup(),b.sup(),false);
    N SUP; SUP=fp_traits<N,K>::upward_divides(a.inf(),b.inf(),true);
    interval<N,K,E> r(INF,SUP);
    return r;
   }



   else if ( a.sup() <= 0.0 )
   {
    N INF; INF=fp_traits<N,K>::downward_divides(a.sup(),b.inf(),false);
    N SUP; SUP=fp_traits<N,K>::upward_divides(a.inf(),b.sup(),true);
    interval<N,K,E> r(INF,SUP);
    return r;
   }



   else
   {
    N INF; INF=fp_traits<N,K>::downward_divides(a.sup(),b.sup(),false);
    N SUP; SUP=fp_traits<N,K>::upward_divides(a.inf(),b.sup(),true);
    interval<N,K,E> r(INF,SUP);
    return r;
   }
  }



  else
  {
   if ( E )
   {
    interval<N,K,E>::extended_error_flag = true;

    if(a.contains(0.))
     return interval<N,K,E>::ENTIRE();
    if(b.inf() == 0.)
    {
     if(a.sup() < 0.)
     {
      N SUP; SUP=fp_traits<N,K>::upward_divides(a.sup(),b.sup(),true);
      interval<N,K,E> r(fp_traits<N,K>::ninf_val,SUP);
      return r;
     }



     else
     {
      N INF; INF=fp_traits<N,K>::downward_divides(a.inf(),b.sup(),true);
      interval<N,K,E> r(INF,fp_traits<N,K>::inf_val);
      return r;
     }
    }
    else if(b.sup() == 0.)
    {
     if(a.sup() < 0.)
     {
      N INF; INF=fp_traits<N,K>::downward_divides(a.sup(),b.inf(),true);
      interval<N,K,E> r(INF,fp_traits<N,K>::inf_val);
      return r;
     }



     else
     {
      N SUP; SUP=fp_traits<N,K>::upward_divides(a.inf(),b.inf(),true);
      interval<N,K,E> r(fp_traits<N,K>::ninf_val,SUP);
      return r;
     }
    }



    else
     return interval<N,K,E>::ENTIRE();
   }
   else
   {
    std::cerr
     << std::endl
     << "error in filib.2 operator/, division by zero."
     << std::endl
     << "divident: " << a << " "
     << "divisor: " << b
     << std::endl;
    std::terminate();
   }
  }
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> operator/(
  interval<N,K,E> const & a,
  N const & b)
 {
   if ( E && fp_traits<N,K>::IsInf(b) )
    return (a/interval<N,K,E>(b));

   if ( b == 0.0 )
   {
    if ( E )
    {
     if ( a.isEmpty() )
      return interval<N,K,E>::EMPTY();
     else
      return interval<N,K,E>::ENTIRE();
    }
    else
    {
     std::cerr
      << std::endl
      << "error in filib.2 operator/, division by zero."
      << std::endl
      << "divident: " << a << " "
      << "divisor: " << interval<N,K,E>(b)
      << std::endl;
     std::terminate();
    }
   }
   else if ( b > 0.0 )
   {
    N INF; INF=fp_traits<N,K>::downward_divides(a.inf(),b,false);
    N SUP; SUP=fp_traits<N,K>::upward_divides(a.sup(),b,true);
    interval<N,K,E> r(INF,SUP);
    return r;
   }
   else
   {
    N INF; INF=fp_traits<N,K>::downward_divides(a.sup(),b,false);
    N SUP; SUP=fp_traits<N,K>::upward_divides(a.inf(),b,true);
    interval<N,K,E> r(INF,SUP);
    return r;
   }
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline N interval<N,K,E>::diam() const
 {
  N t;
  t=fp_traits<N,K>::upward_minus(SUP,INF,true);
  return t;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline N interval<N,K,E>::width() const
 {
  N t;

  t=fp_traits<N,K>::upward_minus(SUP,INF,true);
  return t;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline N interval<N,K,E>::relDiam() const
 {
  if ( isPoint() )
   return 0.0;
  else if ( contains(static_cast<N>(0.0)) || mig() < fp_traits<N,K>::min_val )
   return diam();
  else
  {
   N res = diam();

   res=fp_traits<N,K>::upward_divides(res,mig(),true);
   return res;
  }
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline N interval<N,K,E>::rad() const
 {
  if ( -INF == SUP )
   return SUP;
  else
  {
   N res;
   res=fp_traits<N,K>::upward_minus(static_cast<N>(0.5)*SUP,static_cast<N>(0.5)*INF,true);
   return res;
  }
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline N interval<N,K,E>::dist(interval<N,K,E> const & a) const
 {
   if ( E && (isEmpty() || a.isEmpty()) )
    return fp_traits<N,K>::nan_val;

   if ( *this == a )
    return static_cast<N>(0.0);

   if ( E && ( isInfinite() || a.isInfinite() ) )
    return fp_traits<N,K>::inf_val;

   N tmp1; tmp1=fp_traits<N,K>::upward_minus(INF,a.INF,false);
   N tmp2; tmp2=fp_traits<N,K>::upward_minus(SUP,a.SUP,true);

   N res = std::max(
    fp_traits<N,K>::abs(tmp1),
    fp_traits<N,K>::abs(tmp2));

   if ( E && fp_traits<N,K>::IsNaN(res) )
    return fp_traits<N,K>::nan_val;
   else
    return res;
 }
# 377 "/usr/local/include/interval/interval.icc" 2 3

 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> operator/(
  N const & b,
  interval<N,K,E> const & a)
 {
  return interval<N,K,E>(b)/a;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline N const & inf(interval<N,K,E> const & a)
 {
  return a.inf();
 }
 template <typename N, rounding_strategy K, interval_mode E>
 inline N const & sup(interval<N,K,E> const & a)
 {
  return a.sup();
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline N inf_by_value(interval<N,K,E> const & a)
 {
  return inf<N,K,E>(a);
 }
 template <typename N, rounding_strategy K, interval_mode E>
 inline N sup_by_value(interval<N,K,E> const & a)
 {
  return sup<N,K,E>(a);
 }


 template <typename N, rounding_strategy K, interval_mode E>
 inline bool interval<N,K,E>::hasUlpAcc(unsigned int const & n) const
 {
   if ( E && isInfinite() )
    return false;
   else
   {
    N x = INF;
    unsigned int i = 0;

    while ( i++ < n && x < SUP )
     x = primitive::succ(x);

    return x == SUP;
   }
 }
 template <typename N, rounding_strategy K, interval_mode E>
 inline bool hasUlpAcc(interval<N,K,E> const & a, unsigned int const & n)
 {
  return a.hasUlpAcc(n);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline bool interval<N,K,E>::isExtended()
 {
  if ( E )
   return true;
  else
   return false;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline N interval<N,K,E>::mid() const
 {
   if ( isPoint() )
   return INF;
  else if ( fp_traits<N,K>::abs(INF) == fp_traits<N,K>::abs(SUP) )
   return static_cast<N>(0.0);
  else
   return
    static_cast<N>(0.5) * INF +
    static_cast<N>(0.5) * SUP;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline N mid(interval<N,K,E> const & a)
 {
  return a.mid();
 }


 template <typename N, rounding_strategy K, interval_mode E>
 inline N diam(interval<N,K,E> const & a)
 {
  return a.diam();
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline N width(interval<N,K,E> const & a)
 {
  return a.width();
 }


 template <typename N, rounding_strategy K, interval_mode E>
 inline N relDiam(interval<N,K,E> const & a)
 {
  return a.relDiam();
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline N rad(interval<N,K,E> const & a)
 {
  return a.rad();
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline N interval<N,K,E>::mig() const
 {
  if ( contains(static_cast<N>(0.0)) )
   return static_cast<N>(0.0);
  else
   return std::min(fp_traits<N,K>::abs(INF),fp_traits<N,K>::abs(SUP));
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline N mig(interval<N,K,E> const & a)
 {
  return a.mig();
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline N interval<N,K,E>::mag() const
 {
   return std::max(fp_traits<N,K>::abs(INF),fp_traits<N,K>::abs(SUP));
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline N mag(interval<N,K,E> const & a)
 {
  return a.mag();
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> interval<N,K,E>::abs() const
 {
  return interval<N,K,E>(mig(),mag());
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> abs(interval<N,K,E> const & a)
 {
  return a.abs();
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> interval<N,K,E>::imin(interval<N,K,E> const & a) const
 {
   if ( E && isEmpty() )
    return a;
   else if ( E && a.isEmpty() )
    return *this;
   else
    return interval<N,K,E>(
     std::min(INF,a.INF),std::min(SUP,a.SUP));
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> imin(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.imin(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> interval<N,K,E>::imax(interval<N,K,E> const & a) const
 {
   if ( E && isEmpty() )
    return a;
   else if ( E && a.isEmpty() )
    return *this;
   else
    return interval<N,K,E>(
     std::max(INF,a.INF),std::max(SUP,a.SUP));
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline interval<N,K,E> imax(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.imax(b);
 }


 template <typename N, rounding_strategy K, interval_mode E>
 inline N dist(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.dist(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> interval<N,K,E>::blow(N const & eps) const
 {
  interval<N,K,E> res =
   (static_cast<N>(1.0)+eps) * *this - eps * *this;
  res.INF = primitive::pred(res.INF);
  res.SUP = primitive::succ(res.SUP);

  if ( E == i_mode_extended_flag && (fp_traits<N,K>::IsInf(res.INF) || fp_traits<N,K>::IsInf(res.SUP)) )
   interval<N,K,E>::extended_error_flag = true;

  return res;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> blow(interval<N,K,E> const & a, N const & eps)
 {
  return a.blow(eps);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> interval<N,K,E>::intersect(interval<N,K,E> const & a) const
 {
   if ( E && ( isEmpty() || a.isEmpty() ) )
   {
    if ( E == i_mode_extended_flag )
     interval<N,K,E>::extended_error_flag = true;
    return EMPTY();
   }
   else
    return interval<N,K,E>(std::max(INF,a.INF),std::min(SUP,a.SUP));
 }

 template <typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> intersect(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.intersect(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> interval<N,K,E>::hull(interval<N,K,E> const & a) const
 {
   if ( E && isEmpty() )
    return a;
   else if ( E && a.isEmpty())
    return *this;
   else
    return interval<N,K,E>(std::min(INF, a.INF), std::max(SUP, a.SUP));
 }

 template <typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> interval<N,K,E>::interval_hull(interval<N,K,E> const & a) const
 {
  return hull(a);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> hull(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.hull(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> interval_hull(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.hull(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> interval<N,K,E>::hull(N const & a) const
 {
   if (E && isEmpty())
    return interval<N,K,E>(a);
   else if (E && fp_traits<N,K>::IsNaN(a))
    return *this;
   else
    return interval<N,K,E>(std::min(INF, a), std::max(SUP, a));
 }

 template <typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> interval<N,K,E>::interval_hull(N const & a) const
 {
  return hull(a);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> hull(interval<N,K,E> const & a, N const & b)
 {
  return a.hull(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> interval_hull(interval<N,K,E> const & a, N const & b)
 {
  return a.hull(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> hull(N const & b, interval<N,K,E> const & a)
 {
  return a.hull(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> interval_hull(N const & b, interval<N,K,E> const & a)
 {
  return a.hull(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> hull(N const & a, N const & b)
 {
   if ( E && fp_traits<N,K>::IsNaN(a) )
    return interval<N,K,E>(b);
   else if ( E && fp_traits<N,K>::IsNaN(b) )
    return interval<N,K,E>(a);
   else
   {
    if ( a <= b )
     return interval<N,K,E>(a,b);
    else
     return interval<N,K,E>(b,a);
   }
 }

 template <typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> interval_hull(N const & a, N const & b)
 {
  return hull(a,b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::disjoint(interval<N,K,E> const & a) const
 {
  return ! (INF <= a.SUP && a.INF <= SUP);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool disjoint(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.disjoint(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::contains(N a) const
 {
  return INF <= a && a <= SUP;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool in(N const & a, interval<N,K,E> const & b)
 {
  return b.contains(a);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::interior(interval<N,K,E> const & a) const
 {
  if ( E )
   return a.INF < INF && SUP < a.SUP || isEmpty();
  else
   return a.INF < INF && SUP < a.SUP;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interior(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.interior(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::proper_subset(interval<N,K,E> const & a) const
 {
  if ( E )
   return (INF >= a.INF && SUP <= a.SUP && (INF > a.INF || SUP < a.SUP)) ||
    (isEmpty() && ! a.isEmpty());
  else
   return (INF >= a.INF && SUP <= a.SUP && (INF > a.INF || SUP < a.SUP));
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool proper_subset(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.proper_subset(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::subset(interval<N,K,E> const & a) const
 {
  if ( E )
   return ((a.INF <= INF && SUP <= a.SUP) || isEmpty());
  else
   return (a.INF <= INF && SUP <= a.SUP);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool subset(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.subset(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool operator<=(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.subset(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::proper_superset(interval<N,K,E> const & a) const
 {
  if ( E )
   return (INF <= a.INF && a.SUP <= SUP && (INF < a.INF || a.SUP < SUP)) ||
    (a.isEmpty() && ! isEmpty());
  else
   return (INF <= a.INF && a.SUP <= SUP && (INF < a.INF || a.SUP < SUP));
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool proper_superset(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.proper_superset(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::superset(interval<N,K,E> const & a) const
 {
  if ( E )
   return ((INF <= a.INF && a.SUP <= SUP) || a.isEmpty());
  else
   return (INF <= a.INF && a.SUP <= SUP);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool superset(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.superset(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool operator >=(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.superset(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::seq(interval<N,K,E> const & a) const
 {
  if ( E )
   return ((INF == a.INF && SUP == a.SUP) || (isEmpty() && a.isEmpty()));
  else
   return (INF == a.INF && SUP == a.SUP);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool seq(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.seq(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool operator ==(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.seq(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::sne(interval<N,K,E> const & a) const
 {
  return !seq(a);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool sne(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.sne(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool operator !=(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.sne(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::sge(interval<N,K,E> const & a) const
 {
  if ( E )
   return ((INF >= a.INF && SUP >= a.SUP) || (isEmpty() && a.isEmpty()));
  else
   return (INF >= a.INF && SUP >= a.SUP);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool sge(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.sge(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::sgt(interval<N,K,E> const & a) const
 {
  return INF > a.INF && SUP > a.SUP;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool sgt(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.sgt(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::sle(interval<N,K,E> const & a) const
 {
  if ( E )
   return ((INF <= a.INF && SUP <= a.SUP) || (isEmpty() && a.isEmpty()));
  else
   return (INF <= a.INF && SUP <= a.SUP);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool sle(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.sle(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::slt(interval<N,K,E> const & a) const
 {
  return INF < a.INF && SUP < a.SUP;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool slt(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.slt(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::ceq(interval<N,K,E> const & a) const
 {
  return SUP <= a.INF && INF >= a.SUP;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool ceq(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.ceq(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::cne(interval<N,K,E> const & a) const
 {
  return ! (INF <= a.SUP && a.INF <= SUP);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool cne(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.cne(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::cge(interval<N,K,E> const & a) const
 {
  return INF >= a.SUP;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool cge(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.cge(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::cgt(interval<N,K,E> const & a) const
 {
  return INF > a.SUP;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool cgt(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.cgt(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::cle(interval<N,K,E> const & a) const
 {
  return SUP <= a.INF;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool cle(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.cle(b);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::clt(interval<N,K,E> const & a) const
 {
  return SUP < a.INF;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 bool clt(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.clt(b);
 }

        template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::peq(interval<N,K,E> const & a) const
 {
  return INF <= a.SUP && SUP >= a.INF;
 }

        template <typename N, rounding_strategy K, interval_mode E>
 bool peq(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.peq(b);
 }

        template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::pne(interval<N,K,E> const & a) const
 {
  return ! (SUP <= a.INF && INF >= a.SUP);
 }

        template <typename N, rounding_strategy K, interval_mode E>
 bool pne(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.pne(b);
 }

        template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::pge(interval<N,K,E> const & a) const
 {
  return SUP >= a.INF;
 }

        template <typename N, rounding_strategy K, interval_mode E>
 bool pge(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.pge(b);
 }

        template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::pgt(interval<N,K,E> const & a) const
 {
  return SUP > a.INF;
 }

        template <typename N, rounding_strategy K, interval_mode E>
 bool pgt(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.pgt(b);
 }

        template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::ple(interval<N,K,E> const & a) const
 {
  return INF <= a.SUP;
 }

        template <typename N, rounding_strategy K, interval_mode E>
 bool ple(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.ple(b);
 }

        template <typename N, rounding_strategy K, interval_mode E>
 bool interval<N,K,E>::plt(interval<N,K,E> const & a) const
 {
  return INF < a.SUP;
 }

  template <typename N, rounding_strategy K, interval_mode E>
 bool plt(interval<N,K,E> const & a, interval<N,K,E> const & b)
 {
  return a.plt(b);
 }

  template <typename N, rounding_strategy K, interval_mode E>
 std::ostream & interval<N,K,E>::bitImage(std::ostream & os) const
 {
  os << "[ ";
  primitive::basicBitImage(INF,os);
  os << " ," << "\n" << "  ";
  primitive::basicBitImage(SUP,os);
  os << " ]" << "\n";
  return os;
 }

        template <typename N, rounding_strategy K, interval_mode E>
 std::ostream & interval<N,K,E>::hexImage(std::ostream & os) const
 {
  os << "[ ";
  primitive::basicHexImage(INF,os);
  os << " ," << "\n" << "  ";
  primitive::basicHexImage(SUP,os);
  os << " ]" << "\n";
  return os;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 inline std::ostream & corebench_out (
  std::ostream & out,
  interval<N,K,E> const & obj)
 {
  out << "(";

  switch(K)
  {
   case native_switched:
    out << "native_switched";
    break;
   case native_directed:
    out << "native_directed";
    break;
   case multiplicative:
    out << "multiplicative";
    break;
   case no_rounding:
    out << "no_rounding";
    break;
   case pred_succ_rounding:
    out << "pred_succ_rounding";
    break;
   default:
    out << "unknown";
    break;
  }

  out << ")";
  out << "[" << " " << obj.inf() << " ; " << obj.sup() << " " << "]";
  return out;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 std::ostream &operator <<(std::ostream &os, interval<N,K,E> const & x)
 {
   if (E && x.isEmpty())
    os << "[ EMPTY ]";
   else if (E && (x == interval<N,K,E>::constructIntervalNoChecks(fp_traits<N,K>::ninf_val,-fp_traits<N,K>::max_val)) )
    os << "[ -INFTY ]";
   else if (E && (x == interval<N,K,E>::constructIntervalNoChecks(fp_traits<N,K>::max_val,fp_traits<N,K>::inf_val)) )
    os << "[ +INFTY ]";
   else if (E && (x == interval<N,K,E>::constructIntervalNoChecks(fp_traits<N,K>::ninf_val,fp_traits<N,K>::inf_val)) )
    os << "[ ENTIRE ]";
   else if (!E && (!(primitive::isRegular(x.inf()) && primitive::isRegular(x.sup())) ||
     x.inf() > x.sup()))
     os << "[ UNDEFINED ]";
   else
   {
    int old_dec = os.precision();
    os.precision(interval<N,K,E>::precision());
    os << '[' << x.inf() << ", " << x.sup() << ']';
    os.precision(old_dec);
   }
  return os;
 }

 template <typename N, rounding_strategy K, interval_mode E>
 int const & interval<N,K,E>::precision()
 {
  return fp_traits<N,K>::precision();
 }

 template <typename N, rounding_strategy K, interval_mode E>
 int interval<N,K,E>::precision(int const & prec)
 {
  return fp_traits<N,K>::precision(prec);
 }

        template <typename N, rounding_strategy K, interval_mode E>
 N interval<N,K,E>::amin() const
 {
   if ( E && ( (fp_traits<N,K>::IsNaN(INF)) || (fp_traits<N,K>::IsNaN(SUP)) ) )
    return fp_traits<N,K>::nan_val;
   else
    return std::min(INF < N() ? -INF : INF,SUP < N() ? -SUP : SUP);
 }

        template <typename N, rounding_strategy K, interval_mode E>
 N interval<N,K,E>::amax() const
 {
   if ( E && ( (fp_traits<N,K>::IsNaN(INF)) || (fp_traits<N,K>::IsNaN(SUP)) ) )
    return fp_traits<N,K>::nan_val;
   else
    return std::max(INF < N() ? -INF : INF,SUP < N() ? -SUP : SUP);
 }

 template<typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> interval<N,K,E>::readBitImage(std::istream & in)
  throw(interval_io_exception)
 {
  eatWS< whitespace<char> >(in);

  readChar(in,'[');
  eatWS< whitespace<char> >(in);
  N left = constructFromBitSet<N>(in);
  eatWS< whitespace<char> >(in);
  readChar(in,',');
  eatWS< whitespace<char> >(in);
  N righ = constructFromBitSet<N>(in);
  eatWS< whitespace<char> >(in);
  readChar(in,']');

  return interval<N,K,E>(left,righ);
 }

 template<typename N, rounding_strategy K, interval_mode E>
 interval<N,K,E> interval<N,K,E>::readHexImage(std::istream & in)
  throw(interval_io_exception)
 {
  eatWS< whitespace<char> >(in);

  readChar(in,'[');
  eatWS< whitespace<char> >(in);
  N left = constructFromHexSet<N>(in);
  eatWS< whitespace<char> >(in);
  readChar(in,',');
  eatWS< whitespace<char> >(in);
  N righ = constructFromHexSet<N>(in);
  eatWS< whitespace<char> >(in);
  readChar(in,']');

  return interval<N,K,E>(left,righ);
 }

 template <typename N, rounding_strategy K, interval_mode E>
 std::istream &operator >>(std::istream &is, interval<N,K,E> &x)
 throw(interval_io_exception)
 {
  N inf, sup;
  std::string s;

  eatWS< whitespace<char> >(is);
  readChar(is,'[');
  eatWS< whitespace<char> >(is);

  char ch = is.get();

  while ( (!isspace(ch)) && (ch != ',') && (ch != ']') )
  {
   s += ch;
   ch = is.get();
  }

  is.putback(ch);

  if ( E && (s == "-INFTY") )
  {
   eatWS< whitespace<char> >(is);
   readChar(is,']');
   x = interval<N,K,E>::NEG_INFTY();
  }
  else if ( E && ( s == "+INFTY" ) )
  {
   eatWS< whitespace<char> >(is);
   readChar(is,']');
   x = interval<N,K,E>::POS_INFTY();
  }
  else if ( E && ( s == "ENTIRE" ) )
  {
   eatWS< whitespace<char> >(is);
   readChar(is,']');
   x = interval<N,K,E>::ENTIRE();
  }
  else if ( E && ( s == "EMPTY" ) )
  {
   eatWS< whitespace<char> >(is);
   readChar(is,']');
   x = interval<N,K,E>::EMPTY();
  }
  else
  {
   if ( s == "UNDEFINED" )
   {
    eatWS< whitespace<char> >(is);
    readChar(is,']');
    x = interval<N,K,E>::EMPTY();
   }
   else
   {
    char * endptr = 0;
    char const * nptr = s.c_str();
    inf = strtod(s.c_str(),&endptr);

    if ( endptr != (nptr+s.length()) )
     throw interval_io_exception(std::string("Failed parsing infimum, wanted value, got ")+s+" .");

    eatWS< whitespace<char> >(is);
    readChar(is,',');
    eatWS< whitespace<char> >(is);

    s="";

    ch = is.get();

    while ( (!isspace(ch)) && (ch != ']') )
    {
     s += ch;
     ch = is.get();
    }

    is.putback(ch);

    nptr = s.c_str();

    sup = strtod(s.c_str(),&endptr);

    if ( endptr != (nptr+s.length()) )
     throw interval_io_exception(std::string("Failed parsing supremum, wanted value, got ")+s+" .");

    eatWS< whitespace<char> >(is);
    readChar(is,']');

    if (!(is.fail() || is.bad()))
    {
     x = interval<N,K,E>(inf, sup);
    }
   }
  }

  return is;
 }
}
# 1225 "/usr/local/include/interval/interval.hpp" 2 3
# 1 "/usr/local/include/interval/filib.hpp" 1 3
# 30 "/usr/local/include/interval/filib.hpp" 3
# 1 "/usr/local/include/interval/stdfun/filib_tools.icc" 1 3
# 32 "/usr/local/include/interval/stdfun/filib_tools.icc" 3
namespace filib
{





 inline void power2(double & x, int const & k)
 {
  if (x!=0)
  {





   a_diee test;
   test.f = x;
   test.ieee.expo += k;
   x = test.f;
  }
 }






 inline void frexpo(double const & x, int & k)
 {
  if (x!=0)
  {




   a_diee test;
   test.f = x;
   k=test.ieee.expo;
  }
  else
   k=0;
 }





 inline float cut24(double const & x)
 {
  return static_cast<float>(x);
 }





 inline long int cutint(double const & x)
 {
  return static_cast<long int>(x);
 }
}
# 31 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/filib_consts.hpp" 1 3
# 30 "/usr/local/include/interval/stdfun/filib_consts.hpp" 3
namespace filib
{
 template < typename N >
 struct





 filib_consts
 {



  static N const q_atnt;
  static N const q_atna[7];
  static N const q_atnb[8];
  static N const q_atnc[7];
  static N const q_atnd[6];




  static N const q_ccsm;

  static N const q_ccsp;


  static N const q_pi;

  static N const q_piha;





  static N const q_exem;

  static N const q_exep;





  static N const q_exmm;

  static N const q_exmp;





  static N const q_logm;

  static N const q_logp;





  static N const q_lgpm;

  static N const q_lgpp;





  static N const q_sqtm;

  static N const q_sqtp;





  static N const q_snhm;

  static N const q_snhp;





  static N const q_cshm;

  static N const q_cshp;





  static N const q_cthm;

  static N const q_cthp;





  static N const q_tnhm;

  static N const q_tnhp;




  static N const q_asnm;
  static N const q_asnp;




  static N const q_acsm;
  static N const q_acsp;




  static N const q_actm;
  static N const q_actp;




  static N const q_atnm;
  static N const q_atnp;





  static N const q_csnm;

  static N const q_csnp;





  static N const q_cctm;

  static N const q_cctp;





  static N const q_ctnm;

  static N const q_ctnp;




  static N const q_sinm;
  static N const q_sinp;




  static N const q_cosm;
  static N const q_cosp;




  static N const q_cotm;
  static N const q_cotp;




  static N const q_tanm;
  static N const q_tanp;




  static N const q_lg2m;
  static N const q_lg2p;




  static N const q_l10m;
  static N const q_l10p;




  static N const q_e2em;
  static N const q_e2ep;




  static N const q_e10m;
  static N const q_e10p;


  static N const q_minr;

  static N const q_mine;

  static N const q_sqra;

  static N const q_ctht;


  static N const q_ln2h;

  static N const q_l10i;

  static N const q_l2i;

  static N const q_l10;

  static N const q_l2;


  static N const q_p2h;

  static N const q_p2mh;


  static N const q_pih[7];


  static N const q_pi2p[3];


  static N const q_pi2i;


  static N const q_pi2d;


  static N const q_pi2u;






  static N const q_ext1;

  static N const q_ext2;

  static N const q_ex2a;

  static N const q_ex2b;

  static N const q_ex2c;

  static N const q_ext3;

  static N const q_ext4;

  static N const q_ext5;

  static N const q_extm;

  static N const q_extn;


  static N const q_exil;

  static N const q_exl1;

  static N const q_exl2;

  static N const q_e10i;

  static N const q_e1l1;

  static N const q_e1l2;

  static N const q_exa[5];






  static N const q_exb[9];
# 327 "/usr/local/include/interval/stdfun/filib_consts.hpp" 3
  static N const q_exc[7];
# 337 "/usr/local/include/interval/stdfun/filib_consts.hpp" 3
  static N const q_exd[7];
# 346 "/usr/local/include/interval/stdfun/filib_consts.hpp" 3
  static N const q_exld[32];
# 380 "/usr/local/include/interval/stdfun/filib_consts.hpp" 3
  static N const q_extl[32];
# 419 "/usr/local/include/interval/stdfun/filib_consts.hpp" 3
  static N const q_lgt1;

  static N const q_lgt2;

  static N const q_lgt3;

  static N const q_lgt4;

  static N const q_lgt5;

  static N const q_lgt6;

  static N const q_lgb[2];



  static N const q_lgc[4];





  static N const q_lgld[129];
# 571 "/usr/local/include/interval/stdfun/filib_consts.hpp" 3
  static N const q_lgtl[129];
# 704 "/usr/local/include/interval/stdfun/filib_consts.hpp" 3
  static N const q_sinc[6];
  static N const q_sins[6];
  static N const q_sint[5];
# 716 "/usr/local/include/interval/stdfun/filib_consts.hpp" 3
  static N const q_at3i;
 };

}
# 32 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/acos.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/acos.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_atn1.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_atn1.icc" 3
namespace filib
{
 inline double q_atn1(double const & x)
 {
  double res;
  double absx,ym,y,ysq;
  int ind,sgn;

  if (x < 0.0)
   absx=-x;
  else
   absx=x;

  if (absx <= filib_consts<double>::q_atnt)
   res=x;
  else
  {
   if (absx<8)
   {
    sgn=1;
    ym=0;
   }
   else
   {
    sgn=-1;
    ym=filib_consts<double>::q_piha;
    absx=1/absx;
   }

   ind=0;

   while (absx >= filib_consts<double>::q_atnb[ind+1])
    ind+=1;

   y=(absx-filib_consts<double>::q_atnc[ind])/(1+absx*filib_consts<double>::q_atnc[ind]);
   ysq=y*y;
   res =
    (y+y*(ysq*(((((filib_consts<double>::q_atnd[5]*ysq+filib_consts<double>::q_atnd[4])
    *ysq+filib_consts<double>::q_atnd[3])*ysq+filib_consts<double>::q_atnd[2])
    *ysq+filib_consts<double>::q_atnd[1])*ysq+filib_consts<double>::q_atnd[0])))+filib_consts<double>::q_atna[ind];

   if (x<0)
    res=-(res*sgn+ym);
   else
    res= (res*sgn+ym);
  }
  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/acos.icc" 2 3
# 1 "/usr/local/include/interval/stdfun/point/q_acos.icc" 1 3
# 31 "/usr/local/include/interval/stdfun/point/q_acos.icc" 3
# 1 "/usr/include/c++/7/cmath" 1 3
# 39 "/usr/include/c++/7/cmath" 3
       
# 40 "/usr/include/c++/7/cmath" 3
# 32 "/usr/local/include/interval/stdfun/point/q_acos.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_acos(double const & x)
 {
  double res;




  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib::q_acos: called with NaN value." << std::endl;
    std::terminate();
   }
  }
  else
  {
   if ((x<-1.0)||(1.0<x))
   {
    if ( E )
     return fp_traits<double,K>::quiet_NaN();
    else
    {
     std::cerr << "filib::q_acos: called with NaN value." << std::endl;
     std::terminate();
    }
   }
   else
   {



    if (
     (-1e-17<x)
     &&
     (x<1e-17)
    )
     res=filib_consts<double>::q_piha;
    else if (x < 0.0)
    {
     double t = std::sqrt((1+x)*(1-x))/x;
     res = filib_consts<double>::q_pi+q_atn1(t);
    }
    else
    {
     double t = std::sqrt((1+x)*(1-x))/x;
     res = q_atn1(t);
    }
   }
  }

  return(res);
 }
}
# 32 "/usr/local/include/interval/stdfun/interval/acos.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E>
 interval<double,K,E> acos(interval<double,K,E> const & y)
 {



  interval<double,K,E> x = y;

  if ( E == i_mode_extended)
  {
   interval<double,K,E> ACOS_DOMAIN(-1, 1);
   x = x.intersect(ACOS_DOMAIN);
   if (x.isEmpty())
     return interval<double,K,E>::EMPTY();
  }
  else if ( E == i_mode_extended_flag)
  {
   interval<double,K,E> ACOS_DOMAIN(-1, 1);
   interval<double,K,E> z = x.intersect(ACOS_DOMAIN);

   if ( x != z )
    interval<double,K,E>::extended_error_flag = true;

   x = z;
   if (x.isEmpty())
     return interval<double,K,E>::EMPTY();
  }

  double rinf, rsup;

  if (x.isPoint())
  {
   rinf = q_acos<K,E>(x.inf());
   rsup = rinf * filib_consts<double>::q_ccsp;
   rinf *= filib_consts<double>::q_ccsm;
  }
  else
  {
   rinf = q_acos<K,E>(x.sup())*filib_consts<double>::q_ccsm;
   rsup = q_acos<K,E>(x.inf())*filib_consts<double>::q_ccsp;
  }

  return interval<double,K,E>(rinf,rsup);
 }
}
# 33 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/acosh.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/acosh.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_acsh.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_acsh.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_log1.icc" 1 3
# 36 "/usr/local/include/interval/stdfun/point/q_log1.icc" 3
namespace filib
{

 template <rounding_strategy K, interval_mode E>
 inline static double q_p1l1(int m, double fg, double fk, double y)
 {
  int j;
  double l_lead,l_trail,u,q;
  double v;


  j=cutint((fg-1.0)*128);
  l_lead =m*filib_consts<double>::q_lgld[128]+filib_consts<double>::q_lgld[j];
  l_trail=m*filib_consts<double>::q_lgtl[128]+filib_consts<double>::q_lgtl[j];


  u=(fk+fk)/(y+fg);
  v=u*u;
  q=u*v*(filib_consts<double>::q_lgb[0]+v*filib_consts<double>::q_lgb[1]);


  return(l_lead+(u+(q+l_trail)));
 }



 template <rounding_strategy K, interval_mode E>
 inline static double q_p2l1(double fk)
 {
  double g,q,u,v,u1,f1,f2,u2;


  g=1/(2+fk);
  u=2*fk*g;
  v=u*u;


  q=u*v*(filib_consts<double>::q_lgc[0]+v*(filib_consts<double>::q_lgc[1]+v*(filib_consts<double>::q_lgc[2]+v*filib_consts<double>::q_lgc[3])));


  u1=cut24(u);
  f1=cut24(fk);
  f2=fk-f1;
  u2=((2*(fk-u1)-u1*f1)-u1*f2)*g;


  return(u1+(u2+q));
 }



 template <rounding_strategy K, interval_mode E>
 double q_log1(double x)
 {
  int m;
  double fg,fk,y,res;


  if (x<filib_consts<double>::q_minr)
  {
   if ( E )
    res = fp_traits<double,K>::ninfinity();
   else
    {

     std::cerr << "filib: out of range arguemtn in q_log1" << std::endl;
     std::terminate();
    }
  }

  else if (E && (x == fp_traits<double,K>::infinity()))
   res = fp_traits<double,K>::infinity();

  else if (x==1) res=0.0;
  else if ((filib_consts<double>::q_lgt1<x) && (x<filib_consts<double>::q_lgt2))
  {
   fk=x-1;
   res=q_p2l1<K,E>(fk);
  }
  else
  {
   frexpo(x,m);
   m-=1023;

   y=x;
   power2(y,-m);
   fg=cutint(128*y+0.5);
   fg=0.0078125*fg;
   fk=y-fg;

   res=q_p1l1<K,E>(m,fg,fk,y);
  }

  return(res);

 }





 template <rounding_strategy K, interval_mode E>
 double q_l1p1(double x)
 {
  int m;
  double fg,fk,y,t,h,res;


  if (x<=-1)
  {

   std::cerr << "filib: out of range arguemtn in q_l1p1" << std::endl;
   std::terminate();
  }
  else if (x==0) res=x;
  else if ((-filib_consts<double>::q_lgt5<x) && (x<filib_consts<double>::q_lgt5)) res=x;

  else if ((filib_consts<double>::q_lgt3<x) && (x<filib_consts<double>::q_lgt4))
  {
   fk=x;
   res=q_p2l1<K,E>(fk);
  }
  else
  {
   t=filib_consts<double>::q_lgt6;
   if (x<t) y=1+x;
   else y=x;
   frexpo(y,m);
   m-=1023;

   power2(y,-m);
   fg=cutint(128*y+0.5);
   fg=0.0078125*fg;

   if (m<=-2)
    fk=y-fg;
   else if ((-1<=m) && (m<=52))
   {
    fk=1.0;
    power2(fk,-m);
    h=x;
    power2(h,-m);
    fk=(fk-fg)+h;
   }
   else
   {
    fk=1.0;
    power2(fk,-m);
    h=x;
    power2(h,-m);
    fk=(h-fg)+fk;
   }

   res=q_p1l1<K,E>(m,fg,fk,y);
  }
  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/point/q_acsh.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_acsh(double const & x)
 {
  double res;



  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: NaN value in q_acsh." << std::endl;
    std::terminate();
   }
  }
  else
  {
   if (x < 1.0)
   {
    if ( E )
     return fp_traits<double,K>::quiet_NaN();
    else {
     std::cerr << "filib: value out of range in q_acsh." << std::endl;
     std::terminate();
    }
   }

   if (x < 1.025)
    res = q_l1p1<K,E>(x-1+std::sqrt((x-1)*(x+1)));
   else if ( x > 1e150 )
    res = filib_consts<double>::q_l2+q_log1<K,E>(x);
   else res=q_log1<K,E>(x+std::sqrt((x-1)*(x+1)));
  }
  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/acosh.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> acosh(interval<double,K,E> const & y)
 {
  interval<double,K,E> x = y;

  if ( E == i_mode_extended)
  {
   interval<double,K,E> ACSH_DOMAIN(1, fp_traits<double,K>::infinity());
   x = x.intersect(ACSH_DOMAIN);

   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();
  }
  if ( E == i_mode_extended_flag)
  {
   interval<double,K,E> z = x.uncheckedIntersect(1, fp_traits<double,K>::infinity());

   if ( z != x )
    interval<double,K,E>::extended_error_flag = true;

   x = z;

   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();
  }

  if (!E && x.inf() < 1)
  {
   std::cerr << "filib: q_acosh called with invalid interval." << std::endl;
   std::terminate();
  }

  double rinf, rsup;

  if (x.isPoint())
  {
   if (x.inf()==1)
    rinf=rsup=0;
   else
   {
    rinf=q_acsh<K,E>(x.inf());
    rsup=rinf*filib_consts<double>::q_acsp;
    rinf*=filib_consts<double>::q_acsm;
   }
  }
  else
  {
   rinf=q_acsh<K,E>(x.inf())*filib_consts<double>::q_acsm;
   rsup=q_acsh<K,E>(x.sup())*filib_consts<double>::q_acsp;
  }

  return interval<double,K,E> (rinf,rsup);
 }
}
# 34 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/acot.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/acot.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_acot.icc" 1 3
# 32 "/usr/local/include/interval/stdfun/point/q_acot.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E>
 double q_acot(double const & x)
 {
  double res;

  if ( fp_traits<double,K>::IsNaN(x) )
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: NaN value i q_acot." << std::endl;
    std::terminate();
   }
  }
  else
  {

   if (
    (-1e-17<x)
    &&
    (x<1e-17)
   )
    res=filib_consts<double>::q_piha;
   else if (x<0)
    res=filib_consts<double>::q_pi+q_atn1(1.0/x);
   else if (x<1e10)
    res=q_atn1(1.0/x);
   else
    res=1.0/x;
  }

  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/acot.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E>
           interval<double,K,E> acot(interval<double,K,E> const & x)
 {
  if (E && x.isEmpty())
   return interval<double,K,E>::EMPTY();

  double rinf, rsup;

  if (x.isPoint())
  {
   rinf = q_acot<K,E>(x.inf());
   rsup = rinf*filib_consts<double>::q_cctp;
   rinf *= filib_consts<double>::q_cctm;
  }
  else
  {
   rinf =q_acot<K,E>(x.sup())*filib_consts<double>::q_cctm;
   rsup =q_acot<K,E>(x.inf())*filib_consts<double>::q_cctp;
  }

  return interval<double,K,E>(rinf,rsup);
 }
}
# 35 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/acoth.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/acoth.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_acth.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_acth.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_acth(double const & x)
 {
  double absx, res;
  int sgn;

  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_acth called with NaN value." << std::endl;
    std::terminate();
   }
  }
  else
  {
   if (x<0)
   {
    sgn = -1;
    absx=-x;
   }
   else
   {
    sgn = 1;
    absx=x;
   }

   if (absx<=1.0)
   {
    if ( E )
    {
     return fp_traits<double,K>::quiet_NaN();
    }
    else
    {
     std::cerr << "filib: q_acth called with value out of range." << std::endl;
     std::terminate();
    }
   }

   res=0.5*q_l1p1<K,E>(2.0/(absx-1.0));
  }

  return(sgn*res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/acoth.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> acoth(interval<double,K,E> const & x)
 {
  if ( E )
   if ((x.inf() > -1 && x.sup() < 1) || x.isEmpty())
    return interval<double,K,E>::EMPTY();

  if (x.sup()<-1)
  {
   double rinf, rsup;
   if (x.isPoint())
   {
    rinf = q_acth<K,E>(x.inf());
    rsup = rinf*filib_consts<double>::q_actm;
    rinf *= filib_consts<double>::q_actp;
   }
   else
   {
    rinf = q_acth<K,E>(x.sup())*filib_consts<double>::q_actp;
    rsup = q_acth<K,E>(x.inf())*filib_consts<double>::q_actm;
   }
   return interval<double,K,E>(rinf,rsup);
  }
  else if(x.inf()>1)
  {
   double rinf, rsup;
   if (x.isPoint())
   {
    rinf = q_acth<K,E>(x.inf());
    rsup = rinf*filib_consts<double>::q_actp;
    rinf *= filib_consts<double>::q_actm;
   }
   else
   {
    rinf= q_acth<K,E>(x.sup())*filib_consts<double>::q_actm;
    rsup= q_acth<K,E>(x.inf())*filib_consts<double>::q_actp;
   }
   return interval<double,K,E>(rinf,rsup);
  }
  else
  {
   if ( E )
   {
    if (x.inf() < -1.0)
    {
     if (x.sup() < 1.0)
     {
      double rinf, rsup;
      rinf = fp_traits<double,K>::ninfinity();
      rsup = q_acth<K,E>(x.inf())*filib_consts<double>::q_actm;
      return interval<double,K,E>(rinf,rsup);
     }
     else
      return interval<double,K,E>::ENTIRE();
    }
    else if (x.inf() == -1.0)
    {
     if (x.sup() < 1.0)
      return interval<double,K,E>::NEG_INFTY();
     else
      return interval<double,K,E>::ENTIRE();
    }
    else
    {
     if (x.sup() == 1.0)
      return interval<double,K,E>::POS_INFTY();
     else
     {
      double rinf, rsup;
      rinf = q_acth<K,E>(x.sup())*filib_consts<double>::q_actp;
      rsup = fp_traits<double,K>::infinity();
      return interval<double,K,E>(rinf,rsup);
     }
    }
   }
   else
   {
    std::cerr << "filib: acoth called with invalid argument." << std::endl;
    std::terminate();
   }
  }
 }
}
# 36 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/asin.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/asin.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_asin.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_asin.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_asin(double const & x)
 {
  double res;


  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_asin called with NaN value." << std::endl;
    std::terminate();
   }
  }
  else
  {
   if (
    (x<-1.0)
    ||
    (1.0<x)
   )
   {
    if ( E )
     return fp_traits<double,K>::quiet_NaN();
    else
    {
     std::cerr << "filib: q_asin called with value out of range." << std::endl;
     std::terminate();
    }
   }
   else
   {



    if (x == -1)
     res=-filib_consts<double>::q_piha;
    else if (x==1)
     res=filib_consts<double>::q_piha;
    else if (
     (-filib_consts<double>::q_atnt <= x)
     &&
     (x <= filib_consts<double>::q_atnt)
    )
     res=x;
    else
     res=q_atn1(x/std::sqrt((1.0+x)*(1.0-x)));
   }
  }

  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/asin.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> asin(interval<double,K,E> const & y)
 {
  interval<double,K,E> x = y;

  if ( E == i_mode_extended )
  {
   interval<double,K,E> ASIN_DOMAIN(-1, 1);
   x = x.intersect(ASIN_DOMAIN);
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();
  }
  if ( E == i_mode_extended_flag )
  {
   interval<double,K,E> ASIN_DOMAIN(-1, 1);
   interval<double,K,E> z = x.intersect(ASIN_DOMAIN);

   if ( x != z )
    interval<double,K,E>::extended_error_flag = true;

   x = z;

   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();
  }

  double rinf, rsup;

  if (x.isPoint())
  {
   if (x.inf()<0)
   {
    if (x.inf()>-filib_consts<double>::q_atnt)
    {
     rinf=primitive::pred(x.inf());
     rsup=x.inf();
    }
    else
    {
     rinf=q_asin<K,E>(x.inf());
     rsup=rinf*filib_consts<double>::q_csnm;
     rinf*=filib_consts<double>::q_csnp;
     if (rsup>x.inf()) rsup=x.inf();
    }
   }
   else
   {
    if (x.inf()<filib_consts<double>::q_atnt)
    {
     rinf=x.inf();
     if (x.inf()==0)
      rsup=0;
     else
      rsup=primitive::succ(x.inf());
    }
    else
    {
     rinf=q_asin<K,E>(x.inf());
     rsup=rinf*filib_consts<double>::q_csnp;
     rinf*=filib_consts<double>::q_csnm;
     if (rinf<x.inf()) rinf=x.inf();
    }
   }
  }
  else
  {
   if (x.inf()<0)
   {
    if (x.inf()>-filib_consts<double>::q_atnt)
     rinf=primitive::pred(x.inf());
    else
     rinf=q_asin<K,E>(x.inf())*filib_consts<double>::q_csnp;
   }
   else
   {
    if (x.inf()<filib_consts<double>::q_atnt)
     rinf=x.inf();
    else
    {
     rinf=q_asin<K,E>(x.inf())*filib_consts<double>::q_csnm;
     if (rinf<x.inf()) rinf=x.inf();
    }
   }
   if (x.sup()<=0)
   {
    if (x.sup()>-filib_consts<double>::q_atnt)
     rsup=x.sup();
    else
    {
     rsup=q_asin<K,E>(x.sup())*filib_consts<double>::q_csnm;
     if (rsup>x.sup()) rsup=x.sup();
    }
   }
   else
   {
    if (x.sup()<filib_consts<double>::q_atnt)
     rsup=primitive::succ(x.sup());
    else
     rsup=q_asin<K,E>(x.sup())*filib_consts<double>::q_csnp;
   }
      }

  return interval<double,K,E>(rinf,rsup);
 }
}
# 37 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/asinh.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/asinh.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_asnh.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_asnh.icc" 3
# 1 "/usr/include/c++/7/cmath" 1 3
# 39 "/usr/include/c++/7/cmath" 3
       
# 40 "/usr/include/c++/7/cmath" 3
# 31 "/usr/local/include/interval/stdfun/point/q_asnh.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_asnh(double const & y)
 {
  double h, res;
  int neg;

  double x = y;

  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_asnh called with NaN value." << std::endl;
    std::terminate();
   }
  }
  else
  {
   if (
    (x>2.5e-8)
    &&
    (x<2.5e-8)
   )
    res=x;
   else
   {
    if (x<0)
    {
     x=-x; neg=1;
    }
    else
     neg=0;

    if (x>1e150)
    {
     if ( neg == 1.0 )
      res=-(filib_consts<double>::q_l2+q_log1<K,E>(x));
     else
      res= filib_consts<double>::q_l2+q_log1<K,E>(x);
    }
    else
    {
     if (x>=1.25)
     {
      if (neg==1)
       res=-q_log1<K,E>(x+std::sqrt(x*x+1));
      else
       res= q_log1<K,E>(x+std::sqrt(x*x+1));
     }
     else
     {
      h=1/x;
      if (neg==1)
       res=-q_l1p1<K,E>(x+x/(std::sqrt(1+h*h)+h));
      else
       res= q_l1p1<K,E>(x+x/(std::sqrt(1+h*h)+h));
     }
    }
   }
  }

    return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/asinh.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> asinh(interval<double,K,E> const & x)
 {
  fp_traits<double,K>::reset();

  if ( E )
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();

  double rinf,rsup;

  if (x.inf()==x.sup())
  {
   if (x.inf()<0)
   {
    if (x.inf()>-filib_consts<double>::q_minr)
    {
     rinf=x.inf();
     rsup=primitive::succ(x.inf());
    }
    else
    {
     rinf=q_asnh<K,E>(x.inf());
     rsup=rinf*filib_consts<double>::q_asnm;
     rinf*=filib_consts<double>::q_asnp;
     if (rinf<x.inf()) rinf=x.inf();
    }
   }
   else
   {
    if (x.inf()<filib_consts<double>::q_minr)
    {
     rsup=x.inf();
     if (x.inf()==0)
      rinf=0;
     else
      rinf=primitive::pred(x.inf());
                }
    else
    {
     rinf=q_asnh<K,E>(x.inf());
     rsup=rinf*filib_consts<double>::q_asnp;
     rinf*=filib_consts<double>::q_asnm;
     if (rsup>x.inf()) rsup=x.inf();
    }
   }
  }
  else
  {
   if (x.inf()<=0)
   {
    if (x.inf()>-filib_consts<double>::q_minr)
     rinf=x.inf();
    else
    {
     rinf=q_asnh<K,E>(x.inf())*filib_consts<double>::q_asnp;
     if (rinf<x.inf()) rinf=x.inf();
    }
   }
   else
   {
    if (x.inf()<filib_consts<double>::q_minr)
     rinf=primitive::pred(x.inf());
    else
     rinf=q_asnh<K,E>(x.inf())*filib_consts<double>::q_asnm;
   }

   if (x.sup()<0)
   {
    if (x.sup()>-filib_consts<double>::q_minr)
     rsup=primitive::succ(x.sup());
    else
     rsup=q_asnh<K,E>(x.sup())*filib_consts<double>::q_asnm;
   }
   else
   {
    if (x.sup()<filib_consts<double>::q_minr)
     rsup=x.sup();
    else
    {
     rsup=q_asnh<K,E>(x.sup())*filib_consts<double>::q_asnp;
     if (rsup>x.sup()) rsup=x.sup();
    }
   }
  }

  return interval<double,K,E>(rinf,rsup);
 }
}
# 38 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/atan.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/atan.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_atan.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_atan.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_atan(double const & x)
 {
  double res;

  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_atan called with NaN value." << std::endl;
    std::terminate();
   }
  }
  else
  {
   double absx,ym,y,ysq;
   int ind,sgn;

   if (x<0) absx=-x; else absx=x;
   if (absx<=filib_consts<double>::q_atnt) res=x;
   else {
    if (absx<8)
    {
     sgn=1;
     ym=0;
    }
    else
    {
     sgn=-1;
     ym=filib_consts<double>::q_piha;
     absx=1/absx;
    }

    ind=0;
    while (absx >= filib_consts<double>::q_atnb[ind+1])
     ind+=1;

    y = (absx-filib_consts<double>::q_atnc[ind])/(1+absx*filib_consts<double>::q_atnc[ind]);
    ysq = y*y;
    res = (y+y*(ysq*(((((filib_consts<double>::q_atnd[5]*ysq+filib_consts<double>::q_atnd[4])
     *ysq+filib_consts<double>::q_atnd[3])*ysq+filib_consts<double>::q_atnd[2])
     *ysq+filib_consts<double>::q_atnd[1])*ysq+filib_consts<double>::q_atnd[0])))+filib_consts<double>::q_atna[ind];

    if (x<0)
     res = -(res*sgn+ym);
    else
     res = (res*sgn+ym);
   }
  }

  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/atan.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> atan(interval<double,K,E> const & x)
 {
  if ( E )
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();

  double rinf,rsup;

  if (x.isPoint())
  {
   if (x.inf()<0)
   {
    if (x.inf()>-filib_consts<double>::q_atnt)
    {
     rinf=x.inf();
     rsup=primitive::succ(x.inf());
    }
    else
    {
     rinf=q_atan<K,E>(x.inf());
     rsup=rinf*filib_consts<double>::q_ctnm;
     rinf*=filib_consts<double>::q_ctnp;
     if (rinf<x.inf()) rinf=x.inf();
    }
   }
   else
   {
    if (x.inf()<filib_consts<double>::q_atnt)
    {
     rsup=x.inf();
     if (x.inf()==0)
      rinf=0;
     else
      rinf=primitive::pred(x.inf());
    }
    else
    {
     rinf=q_atan<K,E>(x.inf());
     rsup=rinf*filib_consts<double>::q_ctnp;
     rinf*=filib_consts<double>::q_ctnm;
     if (rsup>x.inf()) rsup=x.inf();
    }
   }
  }
  else
  {
   if (x.inf()<=0)
   {
    if (x.inf()>-filib_consts<double>::q_atnt)
     rinf=x.inf();
    else
    {
     rinf=q_atan<K,E>(x.inf())*filib_consts<double>::q_ctnp;
     if (rinf<x.inf()) rinf=x.inf();
    }
   }
   else
   {
    if (x.inf()<filib_consts<double>::q_atnt)
     rinf=primitive::pred(x.inf());
    else
     rinf=q_atan<K,E>(x.inf())*filib_consts<double>::q_ctnm;
   }
   if (x.sup()<0)
   {
    if (x.sup()>-filib_consts<double>::q_atnt)
     rsup=primitive::succ(x.sup());
    else
     rsup=q_atan<K,E>(x.sup())*filib_consts<double>::q_ctnm;
   }
   else
   {
    if (x.sup()<filib_consts<double>::q_atnt)
     rsup=x.sup();
    else
    {
     rsup=q_atan<K,E>(x.sup())*filib_consts<double>::q_ctnp;
     if (rsup>x.sup()) rsup=x.sup();
    }
   }
  }

  return interval<double,K,E>(rinf,rsup);
 }
}
# 39 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/atanh.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/atanh.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_atnh.icc" 1 3
# 32 "/usr/local/include/interval/stdfun/point/q_atnh.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E>
 double q_atnh(double x)
 {
  double absx, res;

  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_atnh called with NaN value." << std::endl;
    std::terminate();
   }
  }
  else
  {
   if ((x<=-1.0)||(1.0<=x))
   {
    if ( E )
     return fp_traits<double,K>::quiet_NaN();
    else
     {
      std::cerr << "filib: q_atnh called with invalid argument." << std::endl;
      std::terminate();
     }
   }

   if (x<0) absx=-x; else absx=x;
   if (absx>=filib_consts<double>::q_at3i) res=0.5*q_log1<K,E>((1+absx)/(1-absx));
   else res=0.5*q_l1p1<K,E>((2*absx)/(1-absx));
   if (x<0) res=-res;
  }

  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/atanh.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E>
 interval<double,K,E> atanh(interval<double,K,E> const & y)
 {
  interval<double,K,E> x = y;

  double rinf,rsup;

   if ( E == i_mode_extended )
   {
    interval<double,K,E> ATNH_DOMAIN(-1.0, 1.0);
    x = x.intersect(ATNH_DOMAIN);
   }
   if ( E == i_mode_extended_flag )
   {
    interval<double,K,E> ATNH_DOMAIN(-1.0, 1.0);
    interval<double,K,E> z = x.intersect(ATNH_DOMAIN);

    if ( x != z )
     interval<double,K,E>::extended_error_flag = true;

    x = z;
   }

   if ( E && x.isEmpty())
    return interval<double,K,E>::EMPTY();
   else if ( ! E && (x.inf() <= -1 || x.sup() >= 1))
   {
    std::cerr << "filib: atanh called with invalid argument." << std::endl;
    std::terminate();
   }
     else
   {
    if (x.isPoint())
    {
     if (x.inf()<0)
     {
      if (x.inf()>-filib_consts<double>::q_minr)
      {
       rinf=primitive::pred(x.inf());
       rsup=x.inf();
      }
      else
      {
       rinf=q_atnh<K,E>(x.inf());

       if (E && fp_traits<double,K>::IsNaN(rinf))
        return interval<double,K,E>::NEG_INFTY();
       else
           {
        rsup=rinf*filib_consts<double>::q_atnm;
        rinf*=filib_consts<double>::q_atnp;
        if (rsup>x.inf()) rsup=x.inf();
       }
      }
     }
     else
     {
      if (x.inf()<filib_consts<double>::q_minr)
      {
       rinf=x.inf();

       if (x.inf()==0)
        rsup=0;
       else
        rsup=primitive::succ(x.inf());
      }
      else
      {
       rinf=q_atnh<K,E>(x.inf());

        if (E && fp_traits<double,K>::IsNaN(rinf))
         return interval<double,K,E>::POS_INFTY();
        else
        {
         rsup=rinf*filib_consts<double>::q_atnp;
         rinf*=filib_consts<double>::q_atnm;
         if (rinf<x.inf()) rinf=x.inf();
        }
      }
     }
    }
    else
    {
     if (x.inf()<0)
     {
      if (x.inf()>-filib_consts<double>::q_minr)
       rinf=primitive::pred(x.inf());
      else
       rinf=q_atnh<K,E>(x.inf())*filib_consts<double>::q_atnp;
     }
     else
     {
      if (x.inf()<filib_consts<double>::q_minr)
       rinf=x.inf();
      else
      {
       rinf=q_atnh<K,E>(x.inf())*filib_consts<double>::q_atnm;

       if (rinf<x.inf())
        rinf=x.inf();
      }
     }

     if (x.sup()<=0)
     {
      if (x.sup()>-filib_consts<double>::q_minr)
       rsup=x.sup();
      else
      {
       rsup=q_atnh<K,E>(x.sup())*filib_consts<double>::q_atnm;
       if (rsup>x.sup())
        rsup=x.sup();
      }
     }
     else
     {
      if (x.sup()<filib_consts<double>::q_minr)
       rsup=primitive::succ(x.sup());
      else
       rsup=q_atnh<K,E>(x.sup())*filib_consts<double>::q_atnp;
     }

     if ( E )
     {
      if (fp_traits<double,K>::IsNaN(rinf))
       rinf = fp_traits<double,K>::ninfinity();
      if (fp_traits<double,K>::IsNaN(rsup))
       rsup = fp_traits<double,K>::infinity();
     }
    }
   }
  return interval<double,K,E>(rinf,rsup);
 }
}
# 40 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/cos.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/cos.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_cos.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_cos.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_rtrg.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_rtrg.icc" 3
namespace filib
{
 template <typename N> double q_r2tr(N r, long int k);

 template <typename N>
 double q_rtrg(N x, long int k)
 {
  double red,h;
  a_diee r1,r2;

  if ((-512<k)&&(k<512))
  {
   r2.f = x-k*(filib_consts<double>::q_pih[0]+filib_consts<double>::q_pih[1]);
   red = q_r2tr<double>(r2.f,k);
  }
  else
  {
   r1.f = x-k*filib_consts<double>::q_pih[0];
   h = k*filib_consts<double>::q_pih[1];
   r2.f = r1.f-h;
   if (r1.ieee.expo == r2.ieee.expo )
    red = r1.f - ( ((((k*filib_consts<double>::q_pih[6] + k*filib_consts<double>::q_pih[5]) + k*filib_consts<double>::q_pih[4])
     + k*filib_consts<double>::q_pih[3]) + k*filib_consts<double>::q_pih[2]) + h );
   else
    red = q_r2tr<double>(r2.f,k);
  }
  return(red);
 }

 template <typename N>
 double q_r2tr(N r, long int k)
 {
  double red,h;
  a_diee r1,r2;

  r2.f = r;
  h = k*filib_consts<double>::q_pih[2];
  r1.f = r2.f-h;
  if (r1.ieee.expo == r2.ieee.expo )
   red = r2.f - ( (((k*filib_consts<double>::q_pih[6] + k*filib_consts<double>::q_pih[5]) + k*filib_consts<double>::q_pih[4])
    + k*filib_consts<double>::q_pih[3]) + h);
  else
  {
   h = k*filib_consts<double>::q_pih[3];
   r2.f = r1.f-h;
   if (r1.ieee.expo == r2.ieee.expo )
    red = r1.f - ( ((k*filib_consts<double>::q_pih[6] + k*filib_consts<double>::q_pih[5]) + k*filib_consts<double>::q_pih[4]) + h);
   else
   {
    h = k*filib_consts<double>::q_pih[4];
    r1.f = r2.f-h;
    if (r1.ieee.expo == r2.ieee.expo )
     red = r2.f - ( (k*filib_consts<double>::q_pih[6] + k*filib_consts<double>::q_pih[5]) + h);
    else
    {
     h = k*filib_consts<double>::q_pih[5];
     r2.f = r1.f-h;
     if (r1.ieee.expo == r2.ieee.expo )
      red = r1.f - (k*filib_consts<double>::q_pih[6] + h);
     else
      red = r2.f - k*filib_consts<double>::q_pih[6];
    }
   }
  }
  return(red);
 }
}
# 31 "/usr/local/include/interval/stdfun/point/q_cos.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_cos(double const & x)
 {
  double res;

  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_cos called with NaN value." << std::endl;
    std::terminate();
   }
  }

  long int m,n,k;
  double ysq,y,q;

  if ((x<-filib_consts<double>::q_sint[2])||(x>filib_consts<double>::q_sint[2]))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_cos called with out of range value." << std::endl;
    std::terminate();
   }
  }


  y=x*filib_consts<double>::q_pi2i;

  if (y>0)
   k=long_int_cast(y+0.5);
  else
   k=long_int_cast(y-0.5);

  y=q_rtrg<double>(x,k);
  n=(k+1)%4;
  if(n<0)
   n+=4;
  m=n%2;


  ysq=y*y;

  if (m==0)
  {
   if ((-filib_consts<double>::q_sint[3]<y)&&(y<filib_consts<double>::q_sint[3]))
   {
    if (n==0) res=y;
    else res=-y;
   }
   else
   {
    q=ysq*(((((((filib_consts<double>::q_sins[5]*ysq)+filib_consts<double>::q_sins[4])
    *ysq+filib_consts<double>::q_sins[3])*ysq+filib_consts<double>::q_sins[2])*ysq+filib_consts<double>::q_sins[1])*ysq)+filib_consts<double>::q_sins[0]);

    if (n==0)
     res=y+y*q;
    else
     res=-(y+y*q);
       }
  }
  else
  {
   q=ysq*ysq*(((((((filib_consts<double>::q_sinc[5]*ysq)+filib_consts<double>::q_sinc[4])
    *ysq+filib_consts<double>::q_sinc[3])*ysq+filib_consts<double>::q_sinc[2])*ysq+filib_consts<double>::q_sinc[1])*ysq)+filib_consts<double>::q_sinc[0]);

   if (ysq >= filib_consts<double>::q_sint[0])
    res=0.625+(0.375-(0.5*ysq)+q);
   else if (ysq >= filib_consts<double>::q_sint[1])
    res=0.8125+((0.1875-(0.5*ysq))+q);
   else
    res=1.0-(0.5*ysq - q);
   if (n==3)
    res=-res;
  }

  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/cos.icc" 2 3
# 1 "/usr/local/include/interval/stdfun/point/q_cos1.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_cos1.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_cos1(double const & x, long int k)
 {
  double res;
  long int m,n;
  double ysq,q;


  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_cos1 called with NaN value." << std::endl;
    std::terminate();
   }
  }
  else
  {
   if ((x<-filib_consts<double>::q_sint[2])||(x>filib_consts<double>::q_sint[2]))
   {
    if ( E )
     return fp_traits<double,K>::quiet_NaN();
    else
    {
     std::cerr << "filib: q_cos1 called with out of range value." << std::endl;
     std::terminate();
    }
   }

   n=(k+1)%4; if (n<0) n+=4; m=n%2;


   ysq=x*x;
   if (m==0)
   {
    if ((-filib_consts<double>::q_sint[3]<x)&&(x<filib_consts<double>::q_sint[3]))
    {
     if (n==0) res=x;
     else res=-x;
    }
    else
    {
     q=ysq*(((((((filib_consts<double>::q_sins[5]*ysq)+filib_consts<double>::q_sins[4])
      *ysq+filib_consts<double>::q_sins[3])*ysq+filib_consts<double>::q_sins[2])*ysq+filib_consts<double>::q_sins[1])*ysq)+filib_consts<double>::q_sins[0]);

     if (n==0)
      res=x+x*q;
     else
      res=-(x+x*q);
    }
   }
   else
   {
    q=ysq*ysq*(((((((filib_consts<double>::q_sinc[5]*ysq)+filib_consts<double>::q_sinc[4])
     *ysq+filib_consts<double>::q_sinc[3])*ysq+filib_consts<double>::q_sinc[2])*ysq+filib_consts<double>::q_sinc[1])*ysq)+filib_consts<double>::q_sinc[0]);

    if (ysq >= filib_consts<double>::q_sint[0])
     res=0.625+(0.375-(0.5*ysq)+q);
    else if (ysq >= filib_consts<double>::q_sint[1])
     res=0.8125+((0.1875-(0.5*ysq))+q);
    else
     res=1.0-(0.5*ysq - q);
    if (n==3) res=-res;
   }
  }

  return(res);
 }
}
# 32 "/usr/local/include/interval/stdfun/interval/cos.icc" 2 3


namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> cos(interval<double,K,E> const & x)
 {
  if ( E )
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();

  double rinf,rsup;
  double erg1,erg2,y1,y2;
  long int k1,k2,q1,q2;

  if (x.isPoint())
  {
   if ((x.inf()<-filib_consts<double>::q_sint[2])||(x.sup()>filib_consts<double>::q_sint[2]))
    { rinf=-1.0; rsup=1.0; }
   else
   {
    rinf=q_cos<K,E>(x.inf());
    if (rinf<0)
    {
     rsup=rinf*filib_consts<double>::q_cosm;
     rinf*=filib_consts<double>::q_cosp;
    }
    else
    {
     rsup=rinf*filib_consts<double>::q_cosp;
     rinf*=filib_consts<double>::q_cosm;
    }
   }
  }
  else
  {
   if ((x.sup()-x.inf())>=(2.0*filib_consts<double>::q_pi))
   {
    rinf=-1.0;
    rsup=1.0;
   }
   else if ((x.inf()<-filib_consts<double>::q_sint[2])||(x.sup()>filib_consts<double>::q_sint[2]))
   {
    rinf=-1.0;
    rsup=1.0;
   }
   else
   {

    erg1=x.inf()*filib_consts<double>::q_pi2i;
    if (erg1>0)
    {
     k1=long_int_cast(erg1+0.5);
     q1=((long_int_cast(erg1))+1)%4;
    }
    else
    {
     k1=long_int_cast(erg1-0.5);
     q1=(long_int_cast(erg1))%4;
    }

    y1=q_rtrg<double>(x.inf(),k1);


    erg2=x.sup()*filib_consts<double>::q_pi2i;

    if (erg2>0)
    {
     k2=long_int_cast(erg2+0.5);
     q2=((long_int_cast(erg2))+1)%4;
    }
    else
    {
     k2=long_int_cast(erg2-0.5);
     q2=(long_int_cast(erg2))%4;
    }

    y2=q_rtrg<double>(x.sup(),k2);

    if (q1<0)
     q1+=4;
    if (q2<0)
     q2+=4;

    if (q1==q2)
    {
     if ((x.sup()-x.inf())>=filib_consts<double>::q_pi)
     {
      rinf=-1.0;
      rsup=1.0;
     }
     else if ((q1==1) || (q1==2))
     {
      rinf=q_cos1<K,E>(y2,k2);

      if (rinf<0)
       rinf*=filib_consts<double>::q_sinp;
      else
       rinf*=filib_consts<double>::q_sinm;

      rsup=q_cos1<K,E>(y1,k1);

      if (rsup<0)
       rsup*=filib_consts<double>::q_sinm;
      else
       rsup*=filib_consts<double>::q_sinp;
     }
     else
     {
      rinf=q_cos1<K,E>(y1,k1);

      if (rinf<0)
       rinf*=filib_consts<double>::q_sinp;
      else
       rinf*=filib_consts<double>::q_sinm;

      rsup=q_cos1<K,E>(y2,k2);

      if (rsup<0)
       rsup*=filib_consts<double>::q_sinm;
      else
       rsup*=filib_consts<double>::q_sinp;
     }
    }
    else
    {
     if (q1==0)
     {
      if (q2==1)
      {
       erg1=q_cos1<K,E>(y1,k1);
       erg2=q_cos1<K,E>(y2,k2);

       if (erg1<erg2)
        rinf=erg1*filib_consts<double>::q_sinm;
       else
        rinf=erg2*filib_consts<double>::q_sinm;

       rsup=1.0;
      }
      else if (q2==2)
      {
       rinf=q_cos1<K,E>(y2,k2)*filib_consts<double>::q_sinp;
       rsup=1.0;
      }
      else
      {
       rinf=-1.0;
       rsup=1.0;
      }
     }
     else if (q1==1)
     {
      if (q2==0)
      {
       rinf=-1.0;
       erg1=q_cos1<K,E>(y1,k1);
       erg2=q_cos1<K,E>(y2,k2);

       if (erg1>erg2)
        rsup=erg1*filib_consts<double>::q_sinp;
       else
        rsup=erg2*filib_consts<double>::q_sinp;
      }
      else if (q2==2)
      {
       rinf=q_cos1<K,E>(y2,k2)*filib_consts<double>::q_sinp;
       rsup=q_cos1<K,E>(y1,k1)*filib_consts<double>::q_sinp;
      }
      else
      {
       rinf=-1.0;
       rsup=q_cos1<K,E>(y1,k1)*filib_consts<double>::q_sinp;
      }
     }
     else if (q1==2)
     {
      if (q2==0)
      {
       rinf=-1.0;
       rsup=q_cos1<K,E>(y2,k2)*filib_consts<double>::q_sinp;
      }
      else if (q2==1)
      {
       rinf=-1.0;
       rsup=1.0;
      }
      else
      {
       rinf=-1.0;
       erg1=q_cos1<K,E>(y1,k1);
       erg2=q_cos1<K,E>(y2,k2);

       if (erg1>erg2)
        rsup=erg1*filib_consts<double>::q_sinm;
       else
        rsup=erg2*filib_consts<double>::q_sinm;
      }
     }
     else
     {
      if (q2==0)
      {
       rinf=q_cos1<K,E>(y1,k1)*filib_consts<double>::q_sinp;
       rsup=q_cos1<K,E>(y2,k2)*filib_consts<double>::q_sinp;
      }
      else if (q2==1)
      {
       rinf=q_cos1<K,E>(y1,k1)*filib_consts<double>::q_sinp;
       rsup=1.0;
      }
      else
      {
       erg1=q_cos1<K,E>(y1,k1);
       erg2=q_cos1<K,E>(y2,k2);

       if (erg1<erg2)
        rinf=erg1*filib_consts<double>::q_sinp;
       else
        rinf=erg2*filib_consts<double>::q_sinp;

       rsup=1.0;
      }
     }
    }
   }
  }

  if (rinf<-1.0)
   rinf=-1.0;
  if (rsup>1.0)
   rsup=1.0;

  return interval<double,K,E>(rinf,rsup);
 }
}
# 41 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/cosh.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/cosh.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_cosh.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_cosh.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_ep1.icc" 1 3
# 36 "/usr/local/include/interval/stdfun/point/q_ep1.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_ep1(double const & x)
 {
  int j;
  long int n,m;
  double r,r1,r2,q,s;
  double res;


  if ((-filib_consts<double>::q_ext1<x) && (x<filib_consts<double>::q_ext1))
   res=x+1;
  else
  {
   if (filib_consts<double>::q_ex2a<x)
   {
    std::cerr << "filib: q_coth called with out of range value." << std::endl;
    std::terminate();
   }
   else
   {
    if (x<filib_consts<double>::q_ex2b)
     res=0;
    else
    {

     if (x>0)
      n=long_int_cast((x*filib_consts<double>::q_exil)+0.5);
     else
      n=long_int_cast((x*filib_consts<double>::q_exil)-0.5);

     j=n % 32;

     if (j<0)
      j+=32;

     m=(n-j)/32;
     r1=x-n*filib_consts<double>::q_exl1;
     r2=-(n*filib_consts<double>::q_exl2);


     r=r1+r2;
     q=(((filib_consts<double>::q_exa[4]*r+filib_consts<double>::q_exa[3])*r+filib_consts<double>::q_exa[2])*r+filib_consts<double>::q_exa[1])*r+filib_consts<double>::q_exa[0];
     q=r*r*q;
     q=r1+(r2+q);


     s=filib_consts<double>::q_exld[j]+filib_consts<double>::q_extl[j];
     res=(filib_consts<double>::q_exld[j]+(filib_consts<double>::q_extl[j]+s*q));
     res = ldexp(res,m);
    }
   }
  }
  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/point/q_cosh.icc" 2 3
# 1 "/usr/local/include/interval/stdfun/point/q_exp.icc" 1 3
# 35 "/usr/local/include/interval/stdfun/point/q_exp.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_exp(double const & x)
 {
  double res;

  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_exp called with NaN value." << std::endl;
    std::terminate();
   }
  }
  else
  {
   int j;
   long int n,m;
   double r,r1,r2,q,s;


   if ((-filib_consts<double>::q_ext1<x) && (x<filib_consts<double>::q_ext1))
    res=x+1;
   else
   {
    if (filib_consts<double>::q_ex2a<x)
    {
     if ( E )
      res = fp_traits<double,K>::infinity();
     else
      {
       std::cerr << "filib: q_exp overflow." << std::endl;
       std::terminate();
      }
    }
    else
    {
     if (x<filib_consts<double>::q_mine)
      res=0;
     else
     {

      if (x>0) n=long_int_cast((x*filib_consts<double>::q_exil)+0.5);
      else n=long_int_cast((x*filib_consts<double>::q_exil)-0.5);

      j=n % 32;

      if (j<0) j+=32;

      m=(n-j)/32;
      r1=x-n*filib_consts<double>::q_exl1;
      r2=-(n*filib_consts<double>::q_exl2);


      r=r1+r2;
      q=(((filib_consts<double>::q_exa[4]*r+filib_consts<double>::q_exa[3])*r+filib_consts<double>::q_exa[2])*r+filib_consts<double>::q_exa[1])*r+filib_consts<double>::q_exa[0];
      q=r*r*q;
      q=r1+(r2+q);


      s=filib_consts<double>::q_exld[j]+filib_consts<double>::q_extl[j];
      res=(filib_consts<double>::q_exld[j]+(filib_consts<double>::q_extl[j]+s*q));
      res = ldexp(res,m);
     }
    }
   }
  }
     return(res);
 }
}
# 32 "/usr/local/include/interval/stdfun/point/q_cosh.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_cosh(double const & x)
 {
  double res;

  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_cosh called with NaN value." << std::endl;
    std::terminate();
   }
  }
  else
  {
   if ((x>=-filib_consts<double>::q_ex2c)&&(x<=filib_consts<double>::q_ex2c))
    res=0.5*(q_ep1<K,E>(x)+q_ep1<K,E>(-x));
   else if ((x>=-filib_consts<double>::q_ex2a)&&(x<=filib_consts<double>::q_ex2a))
    res=(0.5*q_exp<K,E>(x))+(0.5*q_exp<K,E>(-x));
   else
   {
    if ( E )
     res = fp_traits<double,K>::infinity();
    else
    {
     std::cerr << "filib: q_cosh overflow." << std::endl;
     std::terminate();
    }
   }
  }

  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/cosh.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> cosh(interval<double,K,E> const & x)
 {
  if ( E )
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();

  double rinf, rsup;

  if (x.sup()<0)
  {
   if (x.isPoint())
   {
    rinf=q_cosh<K,E>(x.inf());
    rsup=rinf*filib_consts<double>::q_cshp;
    rinf*=filib_consts<double>::q_cshm;
   }
   else
   {
    rinf=q_cosh<K,E>(x.sup())*filib_consts<double>::q_cshm;
    rsup=q_cosh<K,E>(x.inf())*filib_consts<double>::q_cshp;
   }

   if (rinf<1.0)
    rinf=1.0;
  }
  else if (x.inf()>0)
  {
   if (x.isPoint())
   {
    rinf=q_cosh<K,E>(x.inf());
    rsup=rinf*filib_consts<double>::q_cshp;
    rinf*=filib_consts<double>::q_cshm;
   }
   else
   {
    rinf=q_cosh<K,E>(x.inf())*filib_consts<double>::q_cshm;
    rsup=q_cosh<K,E>(x.sup())*filib_consts<double>::q_cshp;
   }

   if (rinf<1.0)
    rinf=1.0;
  }
  else if (-x.inf()>x.sup())
  {
   rinf=1.0;
   rsup=q_cosh<K,E>(x.inf())*filib_consts<double>::q_cshp;
  }
  else
  {
   rinf=1.0;
   rsup=q_cosh<K,E>(x.sup())*filib_consts<double>::q_cshp;
  }

  if ( E )
   if (rinf == fp_traits<double,K>::infinity())
    rinf = fp_traits<double,K>::max();

  return interval<double,K,E>(rinf,rsup);
 }
}
# 42 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/cot.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/cot.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_cot.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_cot.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_cot(double const & x)
 {
  double res;
  long int m,n,k;
  double ysq,y,q,s,c;



  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_cot called with NaN value." << std::endl;
    std::terminate();
   }
  }
  else
  {
   if (
    (x<-filib_consts<double>::q_sint[2])
    ||
    (x>filib_consts<double>::q_sint[2])
   )
   {
    if ( E )
     return fp_traits<double,K>::quiet_NaN();
    else
    {
     std::cerr << "filib: argument in q_cot out of range." << std::endl;
     std::cerr << "Argument is " << x <<
      " low is " << -filib_consts<double>::q_sint[2] <<
      " high is " << filib_consts<double>::q_sint[2] << std::endl;
     std::terminate();
    }
   }


   if ((x>-filib_consts<double>::q_minr)&&(x<filib_consts<double>::q_minr))
   {
    if ( E )
     return fp_traits<double,K>::quiet_NaN();
    else {
     std::cerr << "filib: argument in q_cot out of range." << std::endl;
     std::terminate();
    }
   }
   else {
    y=x*filib_consts<double>::q_pi2i;
    if (y>0) k=long_int_cast(y+0.5); else k=long_int_cast(y-0.5);
    y=q_rtrg<double>(x,k);
    n=k%4; if (n<0) n+=4; m=n%2;


    ysq=y*y;


    if ((-filib_consts<double>::q_sint[3]<y)&&(y<filib_consts<double>::q_sint[3]))
    {
     if (n==0) s=y;
     else s=-y;
    }
    else
    {
     q=ysq*(((((((filib_consts<double>::q_sins[5]*ysq)+filib_consts<double>::q_sins[4])
      *ysq+filib_consts<double>::q_sins[3])*ysq+filib_consts<double>::q_sins[2])*ysq+filib_consts<double>::q_sins[1])*ysq)+filib_consts<double>::q_sins[0]);

     if (n==0)
      s=y+y*q;
     else
      s=-(y+y*q);
    }


    q=ysq*ysq*(((((((filib_consts<double>::q_sinc[5]*ysq)+filib_consts<double>::q_sinc[4])
     *ysq+filib_consts<double>::q_sinc[3])*ysq+filib_consts<double>::q_sinc[2])*ysq+filib_consts<double>::q_sinc[1])*ysq)+filib_consts<double>::q_sinc[0]);

    if (ysq >= filib_consts<double>::q_sint[0])
     c=0.625+(0.375-(0.5*ysq)+q);
    else if (ysq >= filib_consts<double>::q_sint[1])
     c=0.8125+((0.1875-(0.5*ysq))+q);
    else
     c=1.0-(0.5*ysq - q);
    if (n==2) c=-c;


    if (m==0) res=c/s;
    else res=s/c;
   }
  }

   return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/cot.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> cot(interval<double,K,E> const & x)
 {
  if ( E )
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();

  double rinf,rsup;
  double h1,h2;
  long int k1,k2,q1;

  if ((x.inf()<-filib_consts<double>::q_sint[2])||(x.sup()>filib_consts<double>::q_sint[2]))
  {
   if ( E )
    return interval<double,K,E>::ENTIRE();
   else
    {
     std::cerr << "filib: cot called with invalid argument." << std::endl;
     std::terminate();
    }
  }
  else if (x.isPoint())
  {
   if ( E )
    if (x.inf() == 0.0)
     return interval<double,K,E>::ENTIRE();

   rinf=q_cot<K,E>(x.inf());

   if ( E )
   {

    if (fp_traits<double,K>::IsNaN(rinf)) {
      if (x.inf() < 0.0)
      return interval<double,K,E>::NEG_INFTY();
     else
      return interval<double,K,E>::POS_INFTY();
    }
   }

   if (rinf<0)
   {
    rsup=rinf*filib_consts<double>::q_cotm;
    rinf*=filib_consts<double>::q_cotp;
   }
   else
   {
    rsup=rinf*filib_consts<double>::q_cotp;
    rinf*=filib_consts<double>::q_cotm;
   }
  }
  else if (((x.inf()<=0)&(x.sup()>=0))||((x.sup()<0)&(x.sup()>-filib_consts<double>::q_minr))
                          ||((x.inf()>0)&&(x.inf()<filib_consts<double>::q_minr)))
  {
   if ( E )
    return interval<double,K,E>::ENTIRE();
   else
    {
     std::cerr << "filib: cot singularity." << std::endl;
     std::terminate();
    }
  }
  else
  {
   if (x.sup()<0)
   {
    h1=x.inf()*filib_consts<double>::q_pi2u;
    h2=x.sup()*filib_consts<double>::q_pi2d;
   }
   else
   {
    h1=x.inf()*filib_consts<double>::q_pi2d;
    h2=x.sup()*filib_consts<double>::q_pi2u;
   }

   k1=long_int_cast(h1);

   if (k1<0)
    q1=(k1-1)%2;
   else
    q1=k1%2;

   if (q1<0)
    q1+=2;

   k2=long_int_cast(h2);

   if ((k1==k2) || ((q1==0)&&(k1==k2-1)))
   {
    rinf=q_cot<K,E>(x.sup());

    if (rinf>=0)
     rinf*=filib_consts<double>::q_cotm;
    else
     rinf*=filib_consts<double>::q_cotp;

    rsup=q_cot<K,E>(x.inf());

    if (rsup>=0)
     rsup*=filib_consts<double>::q_cotp;
    else
     rsup*=filib_consts<double>::q_cotm;
   }
   else
   {
    if ( E )
     return interval<double,K,E>::ENTIRE();
    else
     {
      std::cerr << "filib: cot called with invalid argument." << std::endl;
      std::terminate();
     }
   }
  }

  return interval<double,K,E>(rinf,rsup);
 }
}
# 43 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/coth.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/coth.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_coth.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_coth.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_epm1.icc" 1 3
# 37 "/usr/local/include/interval/stdfun/point/q_epm1.icc" 3
namespace filib
{
 inline static double q_p1e1(double const & x)
 {
  int j;
  long int n,m;
  double r,r1,r2,q,s;
  double res;


  if (x>0) n=long_int_cast((x*filib_consts<double>::q_exil)+0.5);
  else n=long_int_cast((x*filib_consts<double>::q_exil)-0.5);
  j=n % 32;
  if (j<0) j+=32;
  m=(n-j)/32;
  r1=x-n*filib_consts<double>::q_exl1;
  r2=-(n*filib_consts<double>::q_exl2);


  r=r1+r2;
  q=(((filib_consts<double>::q_exa[4]*r+filib_consts<double>::q_exa[3])*r+filib_consts<double>::q_exa[2])*r+filib_consts<double>::q_exa[1])*r+filib_consts<double>::q_exa[0];
  q=r*r*q;
  q=r1+(r2+q);


  s=filib_consts<double>::q_exld[j]+filib_consts<double>::q_extl[j];
  if (m>=53)
  {
   if (m<1023)
   {
    res=1.0;
    res = ldexp(res,-m);
   }
   else
    res=0.0;
   res=(filib_consts<double>::q_exld[j]+(s*q+(filib_consts<double>::q_extl[j]-res)));
   res = ldexp(res,m);
  }
  else
  {
   if (m<=-8)
   {
    res=(filib_consts<double>::q_exld[j]+(s*q+filib_consts<double>::q_extl[j]));
    res = ldexp(res,m);
    res-=1;
   }
   else
   {
    res=1.0;
    res = ldexp(res,-m);
    res=((filib_consts<double>::q_exld[j]-res)+(filib_consts<double>::q_exld[j]*q+filib_consts<double>::q_extl[j]*(1+q)));
    res = ldexp(res,m);
   }
  }

  return(res);
 }


 inline static double q_p2e1(double const & x)
 {
  double u,v,y,z,q;


  u=static_cast<double>(float_cast(x));
  v=x-u;
  y=u*u*0.5;
  z=v*(x+u)*0.5;


  q=(((((((filib_consts<double>::q_exb[8]*x+filib_consts<double>::q_exb[7])*x+filib_consts<double>::q_exb[6])*x+filib_consts<double>::q_exb[5])
   *x+filib_consts<double>::q_exb[4])*x+filib_consts<double>::q_exb[3])*x+filib_consts<double>::q_exb[2])*x+filib_consts<double>::q_exb[1])*x+filib_consts<double>::q_exb[0];
  q=x*x*x*q;


  if (y>=7.8125e-3)
   return ((u+y)+(q+(v+z)) );
  else
   return (x+(y+(q+z)) );
 }



 inline double q_epm1(double const & x)
 {
  double fabsx,res;

  fabsx = x < 0 ? -x : x;
  if (fabsx<filib_consts<double>::q_ext1)
  {
   res = (filib_consts<double>::q_p2h * x + fabsx) * filib_consts<double>::q_p2mh;
  }
  else
  {
   if (filib_consts<double>::q_ex2a<x)
   {
    std::cerr << "filib: q_coth called with out of range value." << std::endl;
    std::terminate();
   }
   else
   {
    if (x<filib_consts<double>::q_ext3)
    {
     res=-1.0+filib_consts<double>::q_p2mh;
    }
    else
    {
     if (x==0)
      res=x;
     else
     {
      if ((filib_consts<double>::q_ext4<x) && (x<filib_consts<double>::q_ext5))
       res=q_p2e1(x);
      else
       res=q_p1e1(x);
     }
    }
   }
  }
  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/point/q_coth.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_coth(double x)
 {
  double absx, res;
  int sgn;

  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_coth called with NaN value." << std::endl;
    std::terminate();
   }
  }
  else
  {
   if ((x>-filib_consts<double>::q_ctht)&&(x<filib_consts<double>::q_ctht))
   {
    if ( E )
     return fp_traits<double,K>::quiet_NaN();
    else
    {
     std::cerr << "filib: q_coth called with out of range value." << std::endl;
     std::terminate();
    }
   }

    if (x<0) { sgn=-1; absx=-x; }
    else { sgn=1; absx=x; }

    if (absx>22.875) res=sgn;
    else if (absx>=filib_consts<double>::q_ln2h) res=sgn*(1+2/(q_ep1<K,E>(2*absx)-1));
    else res=sgn*(1+2/q_epm1(2*absx));
  }
  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/coth.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> coth(interval<double,K,E> const & x)
 {
  fp_traits<double,K>::reset();

  if ( E )
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();

  double rinf,rsup;

  if (x.sup()<0)
  {
   if (x.isPoint())
   {
    rinf=q_coth<K,E>(x.inf());


     if (E && fp_traits<double,K>::IsNaN(rinf))
      return interval<double,K,E>::NEG_INFTY();
     else
     {
      rsup=rinf*filib_consts<double>::q_cthm;
      rinf*=filib_consts<double>::q_cthp;
     }
   }
   else
   {
    rinf=q_coth<K,E>(x.sup())*filib_consts<double>::q_cthp;
    rsup=q_coth<K,E>(x.inf())*filib_consts<double>::q_cthm;

    if ( E )
    {

     if (fp_traits<double,K>::IsNaN(rinf))
      rinf = fp_traits<double,K>::ninfinity();


     if (fp_traits<double,K>::IsNaN(rsup))
      rsup = -fp_traits<double,K>::max();
    }
   }

   if (rsup>-1)
    rsup=-1.0;
  }
  else if(x.inf()>0)
  {
   if (x.isPoint())
   {
    rinf=q_coth<K,E>(x.inf());


     if (E && fp_traits<double,K>::IsNaN(rinf))
      return interval<double,K,E>::POS_INFTY();
     else
     {
      rsup=rinf*filib_consts<double>::q_cthp;
      rinf*=filib_consts<double>::q_cthm;
     }
   }
   else
   {
    rinf=q_coth<K,E>(x.sup())*filib_consts<double>::q_cthm;
    rsup=q_coth<K,E>(x.inf())*filib_consts<double>::q_cthp;

    if ( E )
    {

     if (fp_traits<double,K>::IsNaN(rsup))
      rsup = fp_traits<double,K>::infinity();

     if (fp_traits<double,K>::IsNaN(rinf))
      rinf = fp_traits<double,K>::max();
    }
   }

   if (rinf<1)
    rinf=1.0;
  }
  else
  {
   if ( E )
    return interval<double,K,E>::ENTIRE();
   else
   {
    std::cerr << "filib: coth called with invalid argument." << std::endl;
    std::terminate();
   }
  }

  return interval<double,K,E>(rinf,rsup);
 }
}
# 44 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/exp.icc" 1 3
# 32 "/usr/local/include/interval/stdfun/interval/exp.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> exp(interval<double,K,E> const & x)
 {
  if ( E )
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();

  double rinf, rsup;

  if (x.isPoint())
  {
   if (x.inf()==0)
    rinf=rsup=1.0;
   else if (x.inf()<=filib_consts<double>::q_mine)
   {
    rinf=0.0;
    rsup=filib_consts<double>::q_minr;
   }
   else
   {
    rinf=q_exp<K,E>(x.inf());
    rsup=rinf*filib_consts<double>::q_exep;
    rinf*=filib_consts<double>::q_exem;
   }
  }
  else
  {
   if (x.inf()<=filib_consts<double>::q_mine)
    rinf=0.0;
   else
    rinf=q_exp<K,E>(x.inf())*filib_consts<double>::q_exem;

   if (x.sup()<=filib_consts<double>::q_mine)
    rsup=filib_consts<double>::q_minr;
   else
    rsup=q_exp<K,E>(x.sup())*filib_consts<double>::q_exep;
  }

  if (rinf<0.0)
   rinf=0.0;
  if ((x.sup()<=0.0) && (rsup>1.0))
   rsup=1.0;
  if ((x.inf()>=0.0) && (rinf<1.0))
   rinf=1.0;

  if ( E )
   if (rinf == fp_traits<double,K>::infinity())
    rinf = fp_traits<double,K>::max();

  return interval<double,K,E>(rinf,rsup);
 }
}
# 45 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/exp10.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/exp10.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_ex10.icc" 1 3
# 35 "/usr/local/include/interval/stdfun/point/q_ex10.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_ex10(double const & x)
 {
  int j;
  long int n,m;
  double r,r1,r2,q,s;
  double res;


  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_ex10 called with NaN value." << std::endl;
    std::terminate();
   }
  }
  else
  {
   if ((-filib_consts<double>::q_ext1<x) && (x<filib_consts<double>::q_ext1))
    res=x+1;
   else
   {
    if (filib_consts<double>::q_extm<x)
    {
     if ( E )
      res = fp_traits<double,K>::infinity();
     else
     {
      std::cerr << "filib: q_ex10 out of range." << std::endl;
      std::terminate();
     }
    }
    else
    {
     if (x<filib_consts<double>::q_extn)
      res=0;
     else
     {

      if (x>0) n=long_int_cast((x*filib_consts<double>::q_e10i)+0.5);
      else n=long_int_cast((x*filib_consts<double>::q_e10i)-0.5);

      j=n % 32;

      if (j<0) j+=32;

      m=(n-j)/32;
      r1=x-n*filib_consts<double>::q_e1l1;
      r2=-(n*filib_consts<double>::q_e1l2);


      r=r1+r2;
      q=(((((filib_consts<double>::q_exd[6]*r+filib_consts<double>::q_exd[5])*r+filib_consts<double>::q_exd[4])*r+filib_consts<double>::q_exd[3])*r+filib_consts<double>::q_exd[2])*r
       +filib_consts<double>::q_exd[1])*r+filib_consts<double>::q_exd[0];
      q=r*q;
      q=r1+(r2+q);


      s=filib_consts<double>::q_exld[j]+filib_consts<double>::q_extl[j];
      res=(filib_consts<double>::q_exld[j]+(filib_consts<double>::q_extl[j]+s*q));
      res = ldexp(res,m);
     }
           }
        }
  }
  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/exp10.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> exp10(interval<double,K,E> const & x)
 {
  if ( E )
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();

  double rinf, rsup;

  if (x.isPoint())
  {
   if ((x.inf()>=0) && (x.inf()<=22) && (long_int_cast(x.inf())==x.inf()))
   {
    rinf=q_ex10<K,E>(x.inf());
    rsup=rinf;
   }
   else if (x.inf()<=filib_consts<double>::q_extn)
   {
    rinf=0.0;
    rsup=filib_consts<double>::q_minr;
   }
   else
   {
    rinf=q_ex10<K,E>(x.inf());
    rsup=rinf*filib_consts<double>::q_e10p;
    rinf*=filib_consts<double>::q_e10m;
   }
  }
  else
  {
   if (x.inf()<=filib_consts<double>::q_extn)
    rinf=0.0;
   else if ((long_int_cast(x.inf())==x.inf()) && (x.inf()>=0) && (x.inf()<=22))
    rinf=q_ex10<K,E>(x.inf());
   else
    rinf=q_ex10<K,E>(x.inf())*filib_consts<double>::q_e10m;

   if (x.sup()<=filib_consts<double>::q_extn)
    rsup=filib_consts<double>::q_minr;
   else if ((long_int_cast(x.sup())==x.sup()) && (x.sup()>=0) && (x.sup()<=22))
    rsup=q_ex10<K,E>(x.sup());
   else
    rsup=q_ex10<K,E>(x.sup())*filib_consts<double>::q_e10p;
  }

  if (rinf<0.0)
   rinf=0.0;
  if ((x.sup()<=0.0) && (rsup>1.0))
   rsup=1.0;
  if ((x.inf()>=0.0) && (rinf<1.0))
   rinf=1.0;

  if ( E )
   if (rinf == fp_traits<double,K>::infinity())
    rinf = fp_traits<double,K>::max();

  return interval<double,K,E>(rinf,rsup);
 }
}
# 46 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/exp2.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/exp2.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_exp2.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_exp2.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_exp2(double const & x)
 {
  int j;
  long int n,m;
  double r,q,s;
  double res;


  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_exp2 called with NaN value." << std::endl;
    std::terminate();
   }
  }
  else
  {
   if ((-filib_consts<double>::q_ext1<x) && (x<filib_consts<double>::q_ext1))
    res=x+1;
   else
   {
    if (1023<x)
    {
     if ( E )
      res = fp_traits<double,K>::infinity();
     else
      {
       std::cerr << "filib: q_exp2 overflow." << std::endl;
       std::terminate();
      }
    }
    else
    {
     if (x<-1022)
      res=0;
     else
     {
      if (long_int_cast(x)==x)
      {
       res=1.0;
       res = ldexp(res,static_cast<long int>(x));
      }
      else
      {

       if (x>0) n=long_int_cast((x*32)+0.5);
       else n=long_int_cast((x*32)-0.5);

       j=n % 32;

       if (j<0) j+=32;

       m=(n-j)/32;
       r=x-n*0.03125;


       q=(((((filib_consts<double>::q_exc[6]*r+filib_consts<double>::q_exc[5])*r+filib_consts<double>::q_exc[4])*r+filib_consts<double>::q_exc[3])*r+filib_consts<double>::q_exc[2])*r
        +filib_consts<double>::q_exc[1])*r+filib_consts<double>::q_exc[0];
       q=r*q;


       s=filib_consts<double>::q_exld[j]+filib_consts<double>::q_extl[j];
       res=(filib_consts<double>::q_exld[j]+(filib_consts<double>::q_extl[j]+s*q));
       res = ldexp(res,m);
      }
     }
    }
   }
  }
  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/exp2.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> exp2(interval<double,K,E> const & x)
 {
  if ( E )
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();

  double rinf,rsup;

  if (x.isPoint())
  {
   if (x.inf()<-1022)
   {
    rinf=0.0;
    rsup=filib_consts<double>::q_minr;
   }
   else if (long_int_cast(x.inf())==x.inf())
    rinf=rsup=q_exp2<K,E>(x.inf());
   else
   {
    rinf=q_exp2<K,E>(x.inf());
    rsup=rinf*filib_consts<double>::q_e2ep;
    rinf*=filib_consts<double>::q_e2em;
   }
  }
  else
  {
   if (x.inf()<-1022)
    rinf=0.0;
   else if (long_int_cast(x.inf())==x.inf())
    rinf=q_exp2<K,E>(x.inf());
   else
    rinf=q_exp2<K,E>(x.inf())*filib_consts<double>::q_e2em;

   if (x.sup()<-1022)
    rsup=filib_consts<double>::q_minr;
   else if (long_int_cast(x.sup())==x.sup())
    rsup=q_exp2<K,E>(x.sup());
   else
    rsup=q_exp2<K,E>(x.sup())*filib_consts<double>::q_e2ep;
  }

  if (rinf<0.0)
   rinf=0.0;
  if ((x.sup()<=0.0) && (rsup>1.0))
   rsup=1.0;
  if ((x.inf()>=0.0) && (rinf<1.0))
   rinf=1.0;

  if ( E )
   if (rinf == fp_traits<double,K>::infinity())
    rinf = fp_traits<double,K>::max();

  return interval<double,K,E>(rinf,rsup);
 }
}
# 47 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/expm1.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/expm1.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_expm.icc" 1 3
# 36 "/usr/local/include/interval/stdfun/point/q_expm.icc" 3
namespace filib
{
 inline static double q_p1ex(double x)
 {
  int j;
  long int n,m;
  double r,r1,r2,q,s;
  double res;


  if (x>0) n=long_int_cast((x*filib_consts<double>::q_exil)+0.5);
  else n=long_int_cast((x*filib_consts<double>::q_exil)-0.5);

  j=n % 32;

  if (j<0) j+=32;

  m=(n-j)/32;
  r1=x-n*filib_consts<double>::q_exl1;
  r2=-(n*filib_consts<double>::q_exl2);


  r=r1+r2;
  q=(((filib_consts<double>::q_exa[4]*r+filib_consts<double>::q_exa[3])*r+filib_consts<double>::q_exa[2])*r+filib_consts<double>::q_exa[1])*r+filib_consts<double>::q_exa[0];
  q=r*r*q;
  q=r1+(r2+q);


  s=filib_consts<double>::q_exld[j]+filib_consts<double>::q_extl[j];
  if (m>=53)
  {
   if (m<1023)
   {
    res=1.0;
    res = ldexp(res,-m);
   }
   else
    res=0.0;
   res=(filib_consts<double>::q_exld[j]+(s*q+(filib_consts<double>::q_extl[j]-res)));
   res = ldexp(res,m);
  }
  else
  {
   if (m<=-8)
   {
    res=(filib_consts<double>::q_exld[j]+(s*q+filib_consts<double>::q_extl[j]));
    res = ldexp(res,m);
    res-=1;
   }
   else
   {
    res=1.0;
    res = ldexp(res,-m);
    res=((filib_consts<double>::q_exld[j]-res)+(filib_consts<double>::q_exld[j]*q+filib_consts<double>::q_extl[j]*(1+q)));
    res = ldexp(res,m);
   }
  }
  return(res);
 }


 inline static double q_p2ex(double x)
 {
  double u,v,y,z,q;


  u=static_cast<double>(float_cast(x));
  v=x-u;
  y=u*u*0.5;
  z=v*(x+u)*0.5;


  q=(((((((filib_consts<double>::q_exb[8]*x+filib_consts<double>::q_exb[7])*x+filib_consts<double>::q_exb[6])*x+filib_consts<double>::q_exb[5])
   *x+filib_consts<double>::q_exb[4])*x+filib_consts<double>::q_exb[3])*x+filib_consts<double>::q_exb[2])*x+filib_consts<double>::q_exb[1])*x+filib_consts<double>::q_exb[0];
  q=x*x*x*q;


  if (y>=7.8125e-3)
   return ((u+y)+(q+(v+z)) );
  else
   return (x+(y+(q+z)) );
 }



 template <rounding_strategy K, interval_mode E >
 double q_expm(double x)
 {
  double fabsx,res;

  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_expm called with NaN value." << std::endl;
    std::terminate();
   }
  }
  else
  {
   if (x<0) fabsx=-x; else fabsx=x;

   if (fabsx<filib_consts<double>::q_ext1)
   {
    res = (filib_consts<double>::q_p2h * x + fabsx) * filib_consts<double>::q_p2mh;
   }
   else
   {
    if (filib_consts<double>::q_ex2a<x)
    {
     if ( E )
      res = fp_traits<double,K>::infinity();
     else
      {
       std::cerr << "filib: expm overflow." << std::endl;
       std::terminate();
      }
    }
    else
    {
     if (x<filib_consts<double>::q_ext3)
     {
      res=-1.0+filib_consts<double>::q_p2mh;
     }
     else
     {
      if (x==0)
       res=x;
      else
      {
       if ((filib_consts<double>::q_ext4<x) && (x<filib_consts<double>::q_ext5))
        res=q_p2ex(x);
       else
        res=q_p1ex(x);
      }
     }
    }
   }
  }

  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/expm1.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> expm1(interval<double,K,E> const & x)
 {
  if ( E )
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();

  double rinf, rsup;

  if (x.isPoint())
  {
   if (x.inf()<0)
   {
    if (x.inf()>-filib_consts<double>::q_minr)
    {
     rinf=x.inf();
     rsup=primitive::succ(x.inf());
    }
    else
    {
     rinf=q_expm<K,E>(x.inf());
     rsup=rinf*filib_consts<double>::q_exmm;
     rinf*=filib_consts<double>::q_exmp;
    }
   }
   else
   {
    if (x.inf()<filib_consts<double>::q_minr)
    {
     rinf=x.inf();
     if (x.inf()==0)
      rsup=0;
     else
      rsup=primitive::succ(x.inf());
    }
    else
    {
     rinf=q_expm<K,E>(x.inf());
     rsup=rinf*filib_consts<double>::q_exmp;
     rinf*=filib_consts<double>::q_exmm;
    }
   }
  }
  else
  {
   if (x.inf()<=0)
   {
    if (x.inf()>-filib_consts<double>::q_minr)
     rinf=x.inf();
    else
     rinf=q_expm<K,E>(x.inf())*filib_consts<double>::q_exmp;
   }
   else
   {
    if (x.inf()<filib_consts<double>::q_minr)
     rinf=x.inf();
    else
     rinf=q_expm<K,E>(x.inf())*filib_consts<double>::q_exmm;
   }

   if (x.sup()<0)
   {
    if (x.sup()>-filib_consts<double>::q_minr)
     rsup= primitive::succ(x.sup());
    else
     rsup=q_expm<K,E>(x.sup())*filib_consts<double>::q_exmm;
   }
   else
   {
    if (x.sup()<filib_consts<double>::q_minr)
     rsup = x.sup() == 0.0 ? 0.0 : primitive::succ(x.sup());
    else
     rsup=q_expm<K,E>(x.sup())*filib_consts<double>::q_exmp;
   }
  }

  if (rinf<-1.0) rinf=-1.0;

  if ( E )
   if (rinf == fp_traits<double,K>::infinity())
    rinf = fp_traits<double,K>::max();

  return interval<double,K,E>(rinf,rsup);
 }
}
# 48 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/log.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/log.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_log.icc" 1 3
# 35 "/usr/local/include/interval/stdfun/point/q_log.icc" 3
namespace filib
{


 template <rounding_strategy K, interval_mode E>
 inline double q_p1lg(int m, double fg, double fk, double y)
 {
  int j;
  double l_lead,l_trail,u,q;
  double v;


  j=cutint((fg-1.0)*128);
  l_lead =m*filib_consts<double>::q_lgld[128]+filib_consts<double>::q_lgld[j];
  l_trail=m*filib_consts<double>::q_lgtl[128]+filib_consts<double>::q_lgtl[j];


  u=(fk+fk)/(y+fg);
  v=u*u;
  q=u*v*(filib_consts<double>::q_lgb[0]+v*filib_consts<double>::q_lgb[1]);


  return(l_lead+(u+(q+l_trail)));
 }



 template <rounding_strategy K, interval_mode E>
 inline double q_p2lg(double fk)
 {
  double g,q,u,v,u1,f1,f2,u2;


  g=1/(2+fk);
  u=2*fk*g;
  v=u*u;


  q=u*v*(filib_consts<double>::q_lgc[0]+v*(filib_consts<double>::q_lgc[1]+v*(filib_consts<double>::q_lgc[2]+v*filib_consts<double>::q_lgc[3])));


  u1=cut24(u);
  f1=cut24(fk);
  f2=fk-f1;
  u2=((2*(fk-u1)-u1*f1)-u1*f2)*g;


  return(u1+(u2+q));
 }

 template <rounding_strategy K, interval_mode E>
 double q_log(double x)
 {
  int m;
  double fg,fk,y,res;

  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {

    std::cerr << "filib: Argument is NaN in q_log." << std::endl;
    std::terminate();
   }
  }

   else {


    if (x<filib_consts<double>::q_minr)
    {
     if ( E )
     {
      if (x > 0.0)
       return fp_traits<double,K>::ninfinity();
      else
       return fp_traits<double,K>::quiet_NaN();
     }
     else
     {

       std::cerr << "filib: Argument is out of range in q_log." << std::endl;
       std::terminate();
     }
    }
     else if (x==1) res=0.0;
     else if ((filib_consts<double>::q_lgt1<x) && (x<filib_consts<double>::q_lgt2))
     {
      fk=x-1;
      res=q_p2lg<K,E>(fk);
     }
     else
     {
      frexpo(x,m);
      m-=1023;

      y=x;
      power2(y,-m);
      fg=cutint(128*y+0.5);
      fg=0.0078125*fg;
      fk=y-fg;

      res=q_p1lg<K,E>(m,fg,fk,y);
     }
   }
  return(res);
 }





 template <rounding_strategy K, interval_mode E>
 double q_lg1p(double x)
 {
  int m;
  double fg,fk,y,t,h,res;

  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {

    std::cerr << "filib: Argument is NaN in q_lg1p." << std::endl;
    std::terminate();
   }
  }
  else {



   if (x<=-1)
   {
    if ( E )
     return fp_traits<double,K>::quiet_NaN();
    else
    {

     std::cerr << "filib: Argument is out of range in q_lg1p." << std::endl;
     std::terminate();
    }
   }
    else if (x==0) res=x;
    else if ((-filib_consts<double>::q_lgt5<x) && (x<filib_consts<double>::q_lgt5)) res=x;

    else if ((filib_consts<double>::q_lgt3<x) && (x<filib_consts<double>::q_lgt4))
    {
     fk=x;
     res=q_p2lg<K,E>(fk);
    }
    else
    {
     t=filib_consts<double>::q_lgt6;
     if (x<t) y=1+x;
     else y=x;
     frexpo(y,m);
     m-=1023;

     power2(y,-m);
     fg=cutint(128*y+0.5);
     fg=0.0078125*fg;

     if (m<=-2)
      fk=y-fg;
     else if ((-1<=m) && (m<=52))
     {
      fk=1.0;
      power2(fk,-m);
      h=x;
      power2(h,-m);
      fk=(fk-fg)+h;
     }
     else
     {
      fk=1.0;
      power2(fk,-m);
      h=x;
      power2(h,-m);
      fk=(h-fg)+fk;
     }

     res=q_p1lg<K,E>(m,fg,fk,y);
    }
  }
  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/log.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> log(interval<double,K,E> const & y)
 {
  interval<double,K,E> x = y;

  if ( E == i_mode_extended )
  {
   interval<double,K,E> LOG_DOMAIN(0.0, fp_traits<double,K>::infinity());
   x = x.intersect(LOG_DOMAIN);
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();
  }
  if ( E == i_mode_extended_flag )
  {
   interval<double,K,E> z = x.uncheckedIntersect(0.0, fp_traits<double,K>::infinity());

   if ( x != z )
    interval<double,K,E>::extended_error_flag = true;

   x = z;
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();
  }

  double rinf,rsup;

  if (x.isPoint())
  {
   rinf=q_log<K,E>(x.inf());

    if (E && fp_traits<double,K>::IsNaN(rinf))
     return interval<double,K,E>::NEG_INFTY();
    else
    {
     if (rinf>=0)
     {
      rsup=rinf*filib_consts<double>::q_logp;
      rinf*=filib_consts<double>::q_logm;
     }
     else
     {
      rsup=rinf*filib_consts<double>::q_logm;
      rinf*=filib_consts<double>::q_logp;
     }
    }
  }
  else
  {
   rinf=q_log<K,E>(x.inf());
   if (rinf>=0)
    rinf*=filib_consts<double>::q_logm;
   else
    rinf*=filib_consts<double>::q_logp;

    if (E && ( x.sup() == fp_traits<double,K>::infinity() ) )
     rsup = fp_traits<double,K>::infinity();
    else
    {
     rsup=q_log<K,E>(x.sup());

     if (rsup>=0)
      rsup*=filib_consts<double>::q_logp;
     else
      rsup*=filib_consts<double>::q_logm;
    }

   if ( E )
   {
    if (fp_traits<double,K>::IsNaN(rinf))
     rinf = fp_traits<double,K>::ninfinity();
    if (fp_traits<double,K>::IsNaN(rsup))
     rsup = fp_traits<double,K>::infinity();
   }
  }

  return interval<double,K,E>(rinf,rsup);
 }
}
# 49 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/log10.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/log10.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_lg10.icc" 1 3
# 32 "/usr/local/include/interval/stdfun/point/q_lg10.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_lg10(double const & x)
 {
  double res;

  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_lg10 called with NaN value." << std::endl;
    std::terminate();
   }
  }
  else
   res=q_log<K,E>(x)*filib_consts<double>::q_l10i;

  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/log10.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> log10(interval<double,K,E> const & y)
 {
  interval<double,K,E> x = y;

  if ( E == i_mode_extended )
  {
   interval<double,K,E> LOG10_DOMAIN(0, fp_traits<double,K>::infinity());
   x = x.intersect(LOG10_DOMAIN);
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();
  }
  if ( E == i_mode_extended_flag )
  {
   interval<double,K,E> z = x.uncheckedIntersect(0,fp_traits<double,K>::infinity());

   if ( z != x )
    interval<double,K,E>::extended_error_flag = true;

   x = z;

   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();
  }

  double rinf, rsup;

  if (x.isPoint())
  {
   rinf=q_lg10<K,E>(x.inf());

    if (E && fp_traits<double,K>::IsNaN(rinf))
     return interval<double,K,E>::NEG_INFTY();
    else
    {
     if (rinf>=0)
     {
      rsup=rinf*filib_consts<double>::q_l10p;
      rinf*=filib_consts<double>::q_l10m;
     }
     else
     {
      rsup=rinf*filib_consts<double>::q_l10m;
      rinf*=filib_consts<double>::q_l10p;
     }
    }
  }
  else
  {
   rinf=q_lg10<K,E>(x.inf());

   if (rinf>=0)
    rinf*=filib_consts<double>::q_l10m;
   else
    rinf*=filib_consts<double>::q_l10p;

    if (E && ( x.sup() == fp_traits<double,K>::infinity() ) )
     rsup = fp_traits<double,K>::infinity();
    else
    {
     rsup=q_lg10<K,E>(x.sup());

     if (rsup>=0)
      rsup*=filib_consts<double>::q_l10p;
     else
      rsup*=filib_consts<double>::q_l10m;
    }

    if ( E )
    {
     if (fp_traits<double,K>::IsNaN(rinf))
      rinf = fp_traits<double,K>::ninfinity();
     if (fp_traits<double,K>::IsNaN(rsup))
      rsup = fp_traits<double,K>::infinity();
    }
  }

  return interval<double,K,E>(rinf,rsup);
 }
}
# 50 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/log1p.icc" 1 3
# 32 "/usr/local/include/interval/stdfun/interval/log1p.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> log1p(interval<double,K,E> const & y)
 {
  interval<double,K,E> x = y;

  if ( E == i_mode_extended)
  {
   interval<double,K,E> LOG1P_DOMAIN(-1, fp_traits<double,K>::infinity());
   x = x.intersect(LOG1P_DOMAIN);

   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();
  }
  if ( E == i_mode_extended_flag )
  {
   interval<double,K,E> z = x.uncheckedIntersect(-1,fp_traits<double,K>::infinity());

   if ( x != z )
    interval<double,K,E>::extended_error_flag = true;

   x = z;

   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();
  }

  double rinf,rsup;

  if (x.isPoint())
  {
   rinf=q_lg1p<K,E>(x.inf());

    if (E && fp_traits<double,K>::IsNaN(rinf))
     return interval<double,K,E>::NEG_INFTY();
    else
    {
     if (rinf>=0)
     {
      rsup=rinf*filib_consts<double>::q_lgpp;
      rinf*=filib_consts<double>::q_lgpm;
     }
     else
     {
      rsup=rinf*filib_consts<double>::q_lgpm;
      rinf*=filib_consts<double>::q_lgpp;
     }
    }
  }
  else
  {
   rinf=q_lg1p<K,E>(x.inf());

   if (rinf>=0)
    rinf*=filib_consts<double>::q_lgpm;
   else
    rinf*=filib_consts<double>::q_lgpp;

    if (E && (x.sup() == fp_traits<double,K>::infinity() ) )
     rsup = fp_traits<double,K>::infinity();
    else
    {
     rsup=q_lg1p<K,E>(x.sup());

     if (rsup>=0)
      rsup*=filib_consts<double>::q_lgpp;
     else
      rsup*=filib_consts<double>::q_lgpm;
    }

   if ( E )
   {
    if (fp_traits<double,K>::IsNaN(rinf))
     rinf = fp_traits<double,K>::ninfinity();
    if (fp_traits<double,K>::IsNaN(rsup))
     rsup = fp_traits<double,K>::infinity();
   }
  }

  return interval<double,K,E>(rinf,rsup);
 }
}
# 51 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/log2.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/log2.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_log2.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_log2.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_log2(double x)
 {
  double res;

  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_log2 called with NaN value." << std::endl;
    std::terminate();
   }
  }
  else
   res=q_log<K,E>(x)*filib_consts<double>::q_l2i;
  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/log2.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >

 interval<double,K,E> log2(interval<double,K,E> const & y)



 {
  interval<double,K,E> x = y;

  if ( E == i_mode_extended)
  {
   interval<double,K,E> LOG2_DOMAIN(0, fp_traits<double,K>::infinity());
   x = x.intersect(LOG2_DOMAIN);
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();
  }
  if ( E == i_mode_extended_flag )
  {
   interval<double,K,E> z = x.uncheckedIntersect(0,fp_traits<double,K>::infinity());

   if ( x != z )
    interval<double,K,E>::extended_error_flag = true;

   x = z;

   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();
  }

  double rinf, rsup;

  if (x.isPoint())
  {
   rinf=q_log2<K,E>(x.inf());

    if (E && fp_traits<double,K>::IsNaN(rinf))
     return interval<double,K,E>::NEG_INFTY();
    else
    {
     if (rinf>=0)
     {
      rsup=rinf*filib_consts<double>::q_lg2p;
      rinf*=filib_consts<double>::q_lg2m;
     }
     else
     {
      rsup=rinf*filib_consts<double>::q_lg2m;
      rinf*=filib_consts<double>::q_lg2p;
     }
    }
  }
  else
  {
   rinf=q_log2<K,E>(x.inf());

   if (rinf>=0)
    rinf*=filib_consts<double>::q_lg2m;
   else
    rinf*=filib_consts<double>::q_lg2p;

    if (E && x.sup() == fp_traits<double,K>::infinity())
     rsup = fp_traits<double,K>::infinity();
    else
    {
     rsup=q_log2<K,E>(x.sup());

     if (rsup>=0)
      rsup*=filib_consts<double>::q_lg2p;
     else
      rsup*=filib_consts<double>::q_lg2m;
    }

     if (E && fp_traits<double,K>::IsNaN(rinf))
      rinf = fp_traits<double,K>::ninfinity();
     if (E && fp_traits<double,K>::IsNaN(rsup))
      rsup = fp_traits<double,K>::infinity();
  }

  return interval<double,K,E>(rinf,rsup);
 }
}
# 52 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/pow.icc" 1 3
# 36 "/usr/local/include/interval/stdfun/interval/pow.icc" 3
namespace filib
{
# 62 "/usr/local/include/interval/stdfun/interval/pow.icc" 3
 template <rounding_strategy K, interval_mode E >
 static double Power (double x, int n, int RndMode )
 {
  int ChangeRndMode;
  double p, z;

  typedef double N;


  if (x == 0.0)
   return n == 0 ? 1.0 : 0.0;

  ChangeRndMode = ( (x < 0.0) && (n % 2 == 1) );

  if (ChangeRndMode)
  {
   z = -x;
   RndMode = -RndMode;
  }
  else
   z = x;

  p = 1.0;

  switch (RndMode)
  {
   case -1 :
    while (n > 0)
    {
     if (n % 2 == 1) {
      p=fp_traits<N,K>::downward_multiplies(p,z,true);
     }

     n = n / 2;

     if (n > 0) {
      z=fp_traits<N,K>::downward_multiplies(z,z,true);
     }
    }
   break;

   case 1 :
    while (n > 0)
    {
     typedef double N;

     if (n % 2 == 1) {
      p=fp_traits<N,K>::upward_multiplies(p,z,true);
     }

     n = n / 2;

     if (n > 0) {
      z=fp_traits<N,K>::upward_multiplies(z,z,true);
     }
    }
   break;
  }

  if (ChangeRndMode)
   return -p;
  else
   return p;
 }
# 143 "/usr/local/include/interval/stdfun/interval/pow.icc" 3
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> power(interval<double,K,E> const & x, int const & n)
 {
  bool invert = false;

  if ( E )
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();

  if (n == 0)
   return(interval<double,K,E>(1.0,1.0));

  if (n == 1)
   return x;

  int m;

  double rinf,rsup;

  if (n > 0)
   m = n;
  else
   m = -n;

  if ( (0.0 < inf(x)) || (m % 2 == 1) )
  {
   rinf = Power<K,E>(inf(x),m,-1);
   rsup = Power<K,E>(sup(x),m,+1);
  }
  else if (0.0 > sup(x))
  {
   rinf = Power<K,E>(sup(x),m,-1);
   rsup = Power<K,E>(inf(x),m,+1);
  }
  else
  {
   rinf = 0.0;
   rsup = Power<K,E>(mag(x),m,+1);
  }

  if (n < 0)
  {
   if (n % 2)
    invert = true;
   else
   {
    if (x.contains(0.0))
    {
     rinf = 0.0;
     rsup = fp_traits<double,K>::infinity();
    }
    else
     invert = true;
   }
  }



  return invert ?
     1.0/interval<double,K,E>(rinf,rsup)
   : interval<double,K,E>(rinf,rsup);
 }

 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> pow(interval<double,K,E> const & x, interval<double,K,E> const & y)
 {
   if (E && (x.isEmpty() || y.isEmpty()))
    return interval<double,K,E>::EMPTY();
   else if ( ! E && ( inf(x) <= 0.0 ) )
   {
    std::cerr << "base is not positive in pow()." << std::endl;
    std::terminate();
   }
   else
    return exp(y * log(x));
 }
}
# 53 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/sin.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/sin.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_sin.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_sin.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_sin(double x)
 {
  double res;
  long int m,n,k;
  double ysq,y,q;


  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
    {
     std::cerr << "filib: q_sin called with NaN value." << std::endl;
     std::terminate();
    }
  }
  else
  {
   if ((x<-filib_consts<double>::q_sint[2])||(x>filib_consts<double>::q_sint[2]))
   {
    if ( E )
     return fp_traits<double,K>::quiet_NaN();
    else
     {
      std::cerr << "filib: q_sin called with invalid argument." << std::endl;
      std::terminate();
     }
   }


   y=x*filib_consts<double>::q_pi2i;
   if (y>0) k=long_int_cast(y+0.5); else k=long_int_cast(y-0.5);

   y=q_rtrg<double>(x,k);
   n=k%4; if(n<0) n+=4; m=n%2;


   ysq=y*y;
   if (m==0)
   {
    if ((-filib_consts<double>::q_sint[3]<y)&&(y<filib_consts<double>::q_sint[3]))
    {
     if (n==0) res=y;
     else res=-y;
    }
    else
    {
     q=ysq*(((((((filib_consts<double>::q_sins[5]*ysq)+filib_consts<double>::q_sins[4])
      *ysq+filib_consts<double>::q_sins[3])*ysq+filib_consts<double>::q_sins[2])*ysq+filib_consts<double>::q_sins[1])*ysq)+filib_consts<double>::q_sins[0]);
     if (n==0)
      res=y+y*q;
     else
      res=-(y+y*q);
    }
   }
   else
   {
    q=ysq*ysq*(((((((filib_consts<double>::q_sinc[5]*ysq)+filib_consts<double>::q_sinc[4])
    *ysq+filib_consts<double>::q_sinc[3])*ysq+filib_consts<double>::q_sinc[2])*ysq+filib_consts<double>::q_sinc[1])*ysq)+filib_consts<double>::q_sinc[0]);

    if (ysq >= filib_consts<double>::q_sint[0])
     res=0.625+(0.375-(0.5*ysq)+q);
    else if (ysq >= filib_consts<double>::q_sint[1])
     res=0.8125+((0.1875-(0.5*ysq))+q);
    else
     res=1.0-(0.5*ysq - q);

    if (n==3) res=-res;
   }
  }
  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/sin.icc" 2 3
# 1 "/usr/local/include/interval/stdfun/point/q_sin1.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_sin1.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_sin1(double x, long int k)
 {
  double res;
  long int m,n;
  double ysq,q;


  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
   {
    std::cerr << "filib: q_sin1h called with NaN value." << std::endl;
    std::terminate();
   }
  }
  else
  {
   if ((x<-filib_consts<double>::q_sint[2])||(x>filib_consts<double>::q_sint[2]))
   {
    if ( E )
     return fp_traits<double,K>::quiet_NaN();
    else
     {
      std::cerr << "filib: q_sin1h called with invalid argument." << std::endl;
      std::terminate();
     }
   }


   n=k%4; if(n<0) n+=4; m=n%2;


   ysq=x*x;
   if (m==0)
   {
    if ((-filib_consts<double>::q_sint[3]<x)&&(x<filib_consts<double>::q_sint[3]))
    {
     if (n==0) res=x;
     else res=-x;
    }
    else
    {
     q=ysq*(((((((filib_consts<double>::q_sins[5]*ysq)+filib_consts<double>::q_sins[4])
      *ysq+filib_consts<double>::q_sins[3])*ysq+filib_consts<double>::q_sins[2])*ysq+filib_consts<double>::q_sins[1])*ysq)+filib_consts<double>::q_sins[0]);
     if (n==0)
      res=x+x*q;
     else
      res=-(x+x*q);
    }
   }
   else
   {
    q=ysq*ysq*(((((((filib_consts<double>::q_sinc[5]*ysq)+filib_consts<double>::q_sinc[4])
     *ysq+filib_consts<double>::q_sinc[3])*ysq+filib_consts<double>::q_sinc[2])*ysq+filib_consts<double>::q_sinc[1])*ysq)+filib_consts<double>::q_sinc[0]);

    if (ysq >= filib_consts<double>::q_sint[0])
     res=0.625+(0.375-(0.5*ysq)+q);
    else if (ysq >= filib_consts<double>::q_sint[1])
     res=0.8125+((0.1875-(0.5*ysq))+q);
    else
     res=1.0-(0.5*ysq - q);
    if (n==3)
     res=-res;
   }
  }

  return(res);
 }
}
# 32 "/usr/local/include/interval/stdfun/interval/sin.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> sin(interval<double,K,E> const & x)
 {
  if ( E )
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();

  double rinf,rsup;
  double erg1,erg2,y1,y2;
  long int k1,k2,q1,q2;

  if (x.isPoint())
  {
   if ((x.inf()<-filib_consts<double>::q_sint[2])||(x.sup()>filib_consts<double>::q_sint[2]))
   {
    rinf=-1.0;
    rsup=1.0;
   }
   else
   {
    if ((x.inf()>=-filib_consts<double>::q_sint[3])&&(x.inf()<0))
    {
     rinf=x.inf();
     rsup=primitive::succ(x.inf());
    }
    else if ((x.inf()>=0)&&(x.inf()<=filib_consts<double>::q_sint[3]))
    {
     rsup=x.inf();

     if (x.inf()==0)
      rinf=0;
     else
      rinf=primitive::pred(x.inf());
    }
    else
    {
     rinf=q_sin<K,E>(x.inf());

     if (rinf<0)
     {
      rsup=rinf*filib_consts<double>::q_sinm;
      rinf*=filib_consts<double>::q_sinp;
     }
     else
     {
      rsup=rinf*filib_consts<double>::q_sinp;
      rinf*=filib_consts<double>::q_sinm;
     }
    }
   }
  }
  else
  {
   if ((x.sup()-x.inf())>=(2.0*filib_consts<double>::q_pi))
   {
    rinf=-1.0;
    rsup=1.0;
   }
   else if ((x.inf()<-filib_consts<double>::q_sint[2])||(x.sup()>filib_consts<double>::q_sint[2]))
   {
    rinf=-1.0;
    rsup=1.0;
   }
   else
   {

    erg1=x.inf()*filib_consts<double>::q_pi2i;

    if (erg1>0) {k1=long_int_cast(erg1+0.5);
     q1=(long_int_cast(erg1))%4; }
    else
    {
     k1=long_int_cast(erg1-0.5);
     q1=((long_int_cast(erg1))-1)%4;
    }

    y1=q_rtrg<double>(x.inf(),k1);


    erg2=x.sup()*filib_consts<double>::q_pi2i;

    if (erg2>0)
    {
     k2=long_int_cast(erg2+0.5);
     q2=(long_int_cast(erg2))%4;
    }
    else
    {
     k2=long_int_cast(erg2-0.5);
     q2=((long_int_cast(erg2))-1)%4;
    }

    y2=q_rtrg<double>(x.sup(),k2);

    if (q1<0)
     q1+=4;
    if (q2<0)
     q2+=4;

    if (q1==q2)
    {
     if ((x.sup()-x.inf())>=filib_consts<double>::q_pi)
     {
      rinf=-1.0;
      rsup=1.0;
     }
     else if ((q1==1) || (q1==2))
     {
      rinf=q_sin1<K,E>(y2,k2);
      if (rinf<0)
       rinf*=filib_consts<double>::q_sinp;
      else
       rinf*=filib_consts<double>::q_sinm;

      rsup=q_sin1<K,E>(y1,k1);

      if (rsup<0)
       rsup*=filib_consts<double>::q_sinm;
      else
       rsup*=filib_consts<double>::q_sinp;
     }
     else if (q1==0)
     {
      if ((x.inf()>0) && (x.inf()<=filib_consts<double>::q_sint[3]))
       rinf=primitive::pred(x.inf());
      else
       rinf=q_sin1<K,E>(y1,k1)*filib_consts<double>::q_sinm;

      if ((x.sup()>0) && (x.sup()<=filib_consts<double>::q_sint[3]))
       rsup=x.sup();
      else
       rsup=q_sin1<K,E>(y2,k2)*filib_consts<double>::q_sinp;
     }
     else
     {
      if ((x.inf()>=-filib_consts<double>::q_sint[3]) && (x.inf()<0))
       rinf=x.inf();
      else
       rinf=q_sin1<K,E>(y1,k1)*filib_consts<double>::q_sinp;

      if ((x.sup()>=-filib_consts<double>::q_sint[3]) && (x.sup()<0))
       rsup=primitive::succ(x.sup());
      else
       rsup=q_sin1<K,E>(y2,k2)*filib_consts<double>::q_sinm;
     }
    }
    else
    {
     if (q1==0)
     {
      if (q2==1)
      {
       if ((x.inf()>0) && (x.inf()<=filib_consts<double>::q_sint[3]))
        rinf=primitive::pred(x.inf());
       else
       {
        erg1=q_sin1<K,E>(y1,k1);
        erg2=q_sin1<K,E>(y2,k2);

        if (erg1<erg2)
         rinf=erg1*filib_consts<double>::q_sinm;
        else
         rinf=erg2*filib_consts<double>::q_sinm;
       }

       rsup=1.0;
      }
      else if (q2==2)
      {
       rinf=q_sin1<K,E>(y2,k2)*filib_consts<double>::q_sinp;
       rsup=1.0;
      }
      else
      {
       rinf=-1.0;
       rsup=1.0;
      }
     }
     else if (q1==1)
     {
      if (q2==0)
      {
       rinf=-1.0;
       erg1=q_sin1<K,E>(y1,k1);
       erg2=q_sin1<K,E>(y2,k2);
       if (erg1>erg2)
        rsup=erg1*filib_consts<double>::q_sinp;
       else
        rsup=erg2*filib_consts<double>::q_sinp;
      }
      else if (q2==2)
      {
       rinf=q_sin1<K,E>(y2,k2)*filib_consts<double>::q_sinp;
       rsup=q_sin1<K,E>(y1,k1)*filib_consts<double>::q_sinp;
      }
      else
      {
       rinf=-1.0;
       rsup=q_sin1<K,E>(y1,k1)*filib_consts<double>::q_sinp;
      }
     }
     else if (q1==2)
     {
      if (q2==0)
      {
       rinf=-1.0;

       if ((x.sup()>0) && (x.sup()<=filib_consts<double>::q_sint[3]))
        rsup=x.sup();
       else
        rsup=q_sin1<K,E>(y2,k2)*filib_consts<double>::q_sinp;
      }
      else if (q2==1)
      {
       rinf=-1.0;
       rsup=1.0;
      }
      else
      {
       rinf=-1.0;

       if ((x.sup()>=-filib_consts<double>::q_sint[3]) && (x.sup()<0))
        rsup=primitive::succ(x.sup());
       else
       {
        erg1=q_sin1<K,E>(y1,k1);
        erg2=q_sin1<K,E>(y2,k2);

        if (erg1>erg2)
         rsup=erg1*filib_consts<double>::q_sinm;
        else
         rsup=erg2*filib_consts<double>::q_sinm;
       }
      }
     }
     else
     {
      if (q2==0)
      {
       if ((x.inf()>=-filib_consts<double>::q_sint[3]) && (x.inf()<0))
        rinf=x.inf();
       else
        rinf=q_sin1<K,E>(y1,k1)*filib_consts<double>::q_sinp;

       if ((x.sup()>0) && (x.sup()<=filib_consts<double>::q_sint[3]))
        rsup=x.sup();
       else
        rsup=q_sin1<K,E>(y2,k2)*filib_consts<double>::q_sinp;
      }
      else if (q2==1)
      {
       if ((x.inf()>=-filib_consts<double>::q_sint[3]) && (x.inf()<0))
        rinf=x.inf();
       else
        rinf=q_sin1<K,E>(y1,k1)*filib_consts<double>::q_sinp;

       rsup=1.0;
      }
      else
      {
       erg1=q_sin1<K,E>(y1,k1);
       erg2=q_sin1<K,E>(y2,k2);

       if (erg1<erg2)
        rinf=erg1*filib_consts<double>::q_sinp;
       else
        rinf=erg2*filib_consts<double>::q_sinp;

       rsup=1.0;
      }
     }
    }
   }
  }

  if (rinf<-1.0)
   rinf=-1.0;
  if (rsup>1.0)
   rsup=1.0;

  return interval<double,K,E>(rinf,rsup);
 }
}
# 54 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/sinh.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/sinh.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_sinh.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_sinh.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_sinh(double x)
 {
  double absx, h;
  int sgn;
  double res;

  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
    {
     std::cerr << "filib: q_sinh called with NaN value." << std::endl;
     std::terminate();
    }
  }
  else
  {
   if (x<0) {sgn=-1; absx=-x;}
   else {sgn=1; absx=x; }

   if (absx>filib_consts<double>::q_ex2a)
   {
    if ( E )
     return sgn*fp_traits<double,K>::infinity();
    else
     {
      std::cerr << "filib: q_sinh called with invalid argument." << std::endl;
      std::terminate();
     }
   }

   if (absx<2.5783798e-8)
    res=x;
   else if (absx>=0.662)
   {
    h=q_ep1<K,E>(absx);
    res=sgn*0.5*(h-1.0/h);
   }
   else
   {
    h=q_epm1(absx);
    res=sgn*0.5*(h+h/(h+1.0));
   }
  }

  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/sinh.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> sinh(interval<double,K,E> const & x)
 {
  if ( E )
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();

  double rinf,rsup;

  if (x.inf()==x.sup())
  {
   if (x.inf()<0)
   {
    if (x.inf()>-filib_consts<double>::q_minr)
    {
     rinf=primitive::pred(x.inf());
     rsup=x.inf();
    }
    else
    {
     rinf=q_sinh<K,E>(x.inf());
     rsup=rinf*filib_consts<double>::q_snhm;
     rinf*=filib_consts<double>::q_snhp;

     if (rsup>x.inf())
      rsup=x.inf();
    }
   }
   else
   {
    if (x.inf()<filib_consts<double>::q_minr)
    {
     rinf=x.inf();

     if (x.inf()==0)
      rsup=0;
     else
      rsup=primitive::succ(x.inf());
    }
    else
    {
     rinf=q_sinh<K,E>(x.inf());
     rsup=rinf*filib_consts<double>::q_snhp;
     rinf*=filib_consts<double>::q_snhm;

     if (rinf<x.inf())
      rinf=x.inf();
    }
   }
  }
  else
  {
   if (x.inf()<0)
   {
    if (x.inf()>-filib_consts<double>::q_minr)
     rinf=primitive::pred(x.inf());
    else
     rinf=q_sinh<K,E>(x.inf())*filib_consts<double>::q_snhp;
   }
   else
   {
    if (x.inf()<filib_consts<double>::q_minr)
     rinf=x.inf();
    else
    {
     rinf=q_sinh<K,E>(x.inf())*filib_consts<double>::q_snhm;

     if (rinf<x.inf())
      rinf=x.inf();
    }
   }

   if (x.sup()<=0)
   {
    if (x.sup()>-filib_consts<double>::q_minr)
     rsup=x.sup();
    else
    {
     rsup=q_sinh<K,E>(x.sup())*filib_consts<double>::q_snhm;

     if (rsup>x.sup())
      rsup=x.sup();
    }
   }
   else
   {
    if (x.sup()<filib_consts<double>::q_minr)
     rsup=primitive::succ(x.sup());
    else
     rsup=q_sinh<K,E>(x.sup())*filib_consts<double>::q_snhp;
   }
  }

  if ( E )
  {
   if (rinf == fp_traits<double,K>::infinity())
    rinf = fp_traits<double,K>::max();
   else if (rsup == fp_traits<double,K>::ninfinity())
    rsup = -fp_traits<double,K>::max();
  }

  return interval<double,K,E>(rinf,rsup);
 }
}
# 55 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/sqr.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/sqr.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> sqr(interval<double,K,E> const & x)
 {
  if ( E )
  {
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();
  }

  double rinf,rsup;

  if (x.isPoint())
  {
   if (x.inf()==0)
    rinf=rsup=0;
   else

    if (!E && fp_traits<double,K>::IsNaN(x.inf()))
    {
     std::cerr << "filib: q_sqr called with NaN value." << std::endl;
     std::terminate();
    }
    else if ( ! E && ((x.inf()<-filib_consts<double>::q_sqra)||(x.inf()>filib_consts<double>::q_sqra )))
    {
     std::cerr << "filib: q_sqr overflow." << std::endl;
     std::terminate();
    }
    else
    {
     typedef double N;

     rinf=fp_traits<N,K>::downward_multiplies(x.inf(),x.inf(),false);
     rsup=fp_traits<N,K>::upward_multiplies(x.inf(),x.inf(),true);
    }
  }
  else
  {
    if (! E && fp_traits<double,K>::IsNaN(x.inf()))
    {
     std::cerr << "filib: sqr called with NaN value." << std::endl;
     std::terminate();
    }
    else if (! E && (fp_traits<double,K>::IsNaN(x.sup() )))
    {
     std::cerr << "filib: sqr called with NaN value." << std::endl;
     std::terminate();
    }
    else
    {
     if (!E && ((x.inf()<-filib_consts<double>::q_sqra)||(x.sup()>filib_consts<double>::q_sqra)))
     {
      std::cerr << "filib: q_sqr overflow." << std::endl;
      std::terminate();
     }
     else
     {
      typedef double N;

      if ( x.inf() == 0 )
      {
       rinf = 0;
       rsup=fp_traits<N,K>::upward_multiplies(x.sup(),x.sup(),true);
      }
      else if ( x.inf() > 0 )
      {
       rinf=fp_traits<N,K>::downward_multiplies(x.inf(),x.inf(),false);
       rsup=fp_traits<N,K>::upward_multiplies(x.sup(),x.sup(),true);
      }
      else if ( x.sup() == 0 )
      {
       rinf = 0;
       rsup=fp_traits<N,K>::upward_multiplies(x.inf(),x.inf(),true);
      }
      else if ( x.sup() < 0 )
      {
       rinf=fp_traits<N,K>::downward_multiplies(x.sup(),x.sup(),false);
       rsup=fp_traits<N,K>::upward_multiplies(x.inf(),x.inf(),true);
      }
      else
      {
       rinf = 0;

       if ( -x.inf() > x.sup() )
        rsup=fp_traits<N,K>::upward_multiplies(x.inf(),x.inf(),true);
       else
        rsup=fp_traits<N,K>::upward_multiplies(x.sup(),x.sup(),true);
      }
     }
    }
  }

  return interval<double,K,E>(rinf,rsup);
 }
}
# 56 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/sqrt.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/sqrt.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_sqrt.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_sqrt.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_sqrt(double const & x)
 {
  double res;

  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
    {
     std::cerr << "filib: q_sqrt called with NaN value." << std::endl;
     std::terminate();
    }
  }
  else
  {
   if (x<0)
   {
    if ( E )
     return fp_traits<double,K>::quiet_NaN();
    else
     {
      std::cerr << "filib: q_sqrt called with invalid argument." << std::endl;
      std::terminate();
     }
   }
   else
    res=std::sqrt(x);
  }

  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/sqrt.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> sqrt(interval<double,K,E> const & y)
 {
  interval<double,K,E> x = y;

  if ( E == i_mode_extended)
  {
   interval<double,K,E> SQRT_DOMAIN(0, fp_traits<double,K>::infinity());
   x = x.intersect(SQRT_DOMAIN);

   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();
  }
  if ( E == i_mode_extended_flag)
  {
   interval<double,K,E> z = x.uncheckedIntersect(0,fp_traits<double,K>::infinity());

   if ( x != z )
    interval<double,K,E>::extended_error_flag = true;

   x = z;

   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();
  }

  double rinf, rsup;

  if (x.isPoint())
  {
   if (x.inf()==0)
    rinf=rsup=0;
   else
   {
    rinf=q_sqrt<K,E>(x.inf());
    rsup=primitive::succ(rinf);
    rinf=primitive::pred(rinf);
   }
  }
  else
  {
    if (E && (x.inf() <= 0))
     rinf = 0;
    if (!E && (x.inf() == 0))
     rinf = 0;
    else
     rinf=primitive::pred(q_sqrt<K,E>(x.inf()));

    rsup = x.sup() == 0 ? 0 : primitive::succ(q_sqrt<K,E>(x.sup()));
  }

  return interval<double,K,E>(rinf,rsup);
 }
}
# 57 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/tan.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/interval/tan.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_tan.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_tan.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_tan(double x)
 {
  double res;
  long int m,n,k;
  double ysq,y,q,s,c;


  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
    {
     std::cerr << "filib: q_tan called with NaN value." << std::endl;
     std::terminate();
    }
  }
  else
  {
   if ((x<-filib_consts<double>::q_sint[2])||(x>filib_consts<double>::q_sint[2]))
   {
    if ( E )
     return fp_traits<double,K>::quiet_NaN();
    else
     {
      std::cerr << "filib: q_tan called with invalid argument." << std::endl;
      std::terminate();
     }
   }


   if(x==0) res=0; else
   {
    y=x*filib_consts<double>::q_pi2i;

    if (y>0) k=long_int_cast(y+0.5); else k=long_int_cast(y-0.5);

    y=q_rtrg<double>(x,k);
    n=k%4; if (n<0) n+=4; m=n%2;


    if ((-filib_consts<double>::q_sint[4]<y)&&(y<filib_consts<double>::q_sint[4]))
     if (m==0) res=y;
     else res=-1/y;
    else
    {
     ysq=y*y;


     q=ysq*(((((((filib_consts<double>::q_sins[5]*ysq)+filib_consts<double>::q_sins[4])
      *ysq+filib_consts<double>::q_sins[3])*ysq+filib_consts<double>::q_sins[2])*ysq+filib_consts<double>::q_sins[1])*ysq)+filib_consts<double>::q_sins[0]);




      s=y+y*q;






     q=ysq*ysq*(((((((filib_consts<double>::q_sinc[5]*ysq)+filib_consts<double>::q_sinc[4])
      *ysq+filib_consts<double>::q_sinc[3])*ysq+filib_consts<double>::q_sinc[2])*ysq+filib_consts<double>::q_sinc[1])*ysq)+filib_consts<double>::q_sinc[0]);

     if (ysq >= filib_consts<double>::q_sint[0])
      c=0.625+(0.375-(0.5*ysq)+q);
     else if (ysq >= filib_consts<double>::q_sint[1])
      c=0.8125+((0.1875-(0.5*ysq))+q);
     else
      c=1.0-(0.5*ysq - q);



     if (m==0) res=s/c;
     else res=-c/s;
    }
   }
  }

  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/interval/tan.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> tan(interval<double,K,E> const & x)
 {
  if ( E )
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();

  double rinf,rsup;
  double h1,h2;
  long int k1,k2,q1;


  if ((x.inf()<-filib_consts<double>::q_sint[2])||(x.sup()>filib_consts<double>::q_sint[2]))
  {
   if ( E )
    return interval<double,K,E>::ENTIRE();
   else
    {
     std::cerr << "filib: tan called with invalid argument." << std::endl;
     std::terminate();
    }
  }
  else
  {
   if (x.isPoint())
   {
    if ((x.inf()>=-filib_consts<double>::q_sint[4])&&(x.inf()<0))
    {
     rinf=primitive::pred(x.inf());
     rsup=x.inf();
    }
    else if ((x.inf()>=0)&&(x.inf()<=filib_consts<double>::q_sint[4]))
    {
     rinf=x.inf();

     if (x.inf()==0)
      rsup=0;
     else
      rsup=primitive::succ(x.inf());
    }
    else
    {
     rinf=q_tan<K,E>(x.inf());

     if (rinf<0)
     {
      rsup=rinf*filib_consts<double>::q_tanm;
      rinf*=filib_consts<double>::q_tanp;
     }
     else
     {
      rsup=rinf*filib_consts<double>::q_tanp;
      rinf*=filib_consts<double>::q_tanm;
     }
    }
   }
   else
   {
    if (x.sup()<0)
    {
     h1=x.inf()*filib_consts<double>::q_pi2u;
     h2=x.sup()*filib_consts<double>::q_pi2d;
    }
    else
    {
     h1=x.inf()*filib_consts<double>::q_pi2d;
     h2=x.sup()*filib_consts<double>::q_pi2u;
    }

    k1=long_int_cast(h1);

    if (k1<0)
     q1=(k1-1)%2;
    else
     q1=k1%2;

    if (q1<0)
     q1+=2;

    k2=long_int_cast(h2);

    if ((k1==k2) || (q1==1)&(k1==k2-1))
    {
     if ((-filib_consts<double>::q_sint[4]<x.inf())&&(x.inf()<0))
      rinf=primitive::pred(x.inf());
     else if ((0<=x.inf())&&(x.inf()<filib_consts<double>::q_sint[4]))
      rinf=x.inf();
     else
     {
      rinf=q_tan<K,E>(x.inf());

      if (rinf>=0)
       rinf*=filib_consts<double>::q_tanm;
      else
       rinf*=filib_consts<double>::q_tanp;
     }

     if ((-filib_consts<double>::q_sint[4]<x.sup())&&(x.sup()<=0))
      rsup=x.sup();
     else if ((0<x.sup())&&(x.sup()<filib_consts<double>::q_sint[4]))
      rsup=primitive::succ(x.sup());
     else
     {
      rsup=q_tan<K,E>(x.sup());

      if (rsup>=0)
       rsup*=filib_consts<double>::q_tanp;
      else
       rsup*=filib_consts<double>::q_tanm;
     }
    }
    else
    {
     if ( E )
      return interval<double,K,E>::ENTIRE();
     {
      std::cerr << "filib: tan invalid argument." << std::endl;
      std::terminate();
     }
    }
   }
  }

  return interval<double,K,E>(rinf,rsup);
 }
}
# 58 "/usr/local/include/interval/filib.hpp" 2 3
# 1 "/usr/local/include/interval/stdfun/interval/tanh.icc" 1 3
# 33 "/usr/local/include/interval/stdfun/interval/tanh.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_tanh.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_tanh.icc" 3
# 1 "/usr/local/include/interval/stdfun/point/q_cth1.icc" 1 3
# 30 "/usr/local/include/interval/stdfun/point/q_cth1.icc" 3
namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_cth1(double const & x)
 {
  double absx, res;
  int sgn;

  if (x<0) { sgn=-1; absx=-x; }
  else { sgn=1; absx=x; }

  if (absx>22.875) res=sgn;
  else if (absx>=filib_consts<double>::q_ln2h) res=sgn*(1+2/(q_ep1<K,E>(2*absx)-1));
  else res=sgn*(1+2/q_epm1(2*absx));

  return(res);
 }
}
# 31 "/usr/local/include/interval/stdfun/point/q_tanh.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 double q_tanh(double x)
 {
  double res;

  if (fp_traits<double,K>::IsNaN(x))
  {
   if ( E )
    return fp_traits<double,K>::quiet_NaN();
   else
    {
     std::cerr << "filib: q_tanh called with NaN value." << std::endl;
     std::terminate();
    }
  }
  else
  {
   if ((-1e-10<x) && (x<1e-10)) res=x;
   else res=1.0/q_cth1<K,E>(x);
  }
  return(res);
 }
}
# 34 "/usr/local/include/interval/stdfun/interval/tanh.icc" 2 3

namespace filib
{
 template <rounding_strategy K, interval_mode E >
 interval<double,K,E> tanh(interval<double,K,E> const & x)
 {
  if ( E )
   if (x.isEmpty())
    return interval<double,K,E>::EMPTY();

  double rinf,rsup;

  if (x.inf()==x.sup())
  {
   if (x.inf()<0)
   {
    if (x.inf()>-filib_consts<double>::q_minr)
    {
     rinf=x.inf();
     rsup=primitive::succ(x.inf());
    }
    else
    {
     rinf=q_tanh<K,E>(x.inf());
     rsup=rinf*filib_consts<double>::q_tnhm;
     rinf*=filib_consts<double>::q_tnhp;

     if (rinf<x.inf())
      rinf=x.inf();
    }
   }
   else
   {
    if (x.inf()<filib_consts<double>::q_minr)
    {
     rsup=x.inf();

     if (x.inf()==0)
      rinf=0;
     else
      rinf=primitive::pred(x.inf());
    }
    else
    {
     rinf=q_tanh<K,E>(x.inf());
     rsup=rinf*filib_consts<double>::q_tnhp;
     rinf*=filib_consts<double>::q_tnhm;

     if (rsup>x.inf())
      rsup=x.inf();
    }
   }
  }
  else
  {
   if (x.inf()<=0)
   {
    if (x.inf()>-filib_consts<double>::q_minr)
     rinf=x.inf();
    else
    {
     rinf=q_tanh<K,E>(x.inf())*filib_consts<double>::q_tnhp;

     if (rinf<x.inf())
      rinf=x.inf();
    }
   }
   else
   {
    if (x.inf()<filib_consts<double>::q_minr)
     rinf=primitive::pred(x.inf());
    else
     rinf=q_tanh<K,E>(x.inf())*filib_consts<double>::q_tnhm;
   }

   if (x.sup()<0)
   {
    if (x.sup()>-filib_consts<double>::q_minr)
     rsup=primitive::succ(x.sup());
    else
     rsup=q_tanh<K,E>(x.sup())*filib_consts<double>::q_tnhm;
   }
   else
   {
    if (x.sup()<filib_consts<double>::q_minr)
     rsup=x.sup();
    else
    {
     rsup=q_tanh<K,E>(x.sup())*filib_consts<double>::q_tnhp;

     if (rsup>x.sup())
      rsup=x.sup();
    }
   }
  }

  if (rsup>1.0)
   rsup=1.0;
  if (rinf<-1.0)
   rinf=-1.0;

  return interval<double,K,E>(rinf,rsup);
 }
}
# 59 "/usr/local/include/interval/filib.hpp" 2 3
# 1226 "/usr/local/include/interval/interval.hpp" 2 3
# 1 "/usr/local/include/interval/interval_fo.hpp" 1 3
# 32 "/usr/local/include/interval/interval_fo.hpp" 3
namespace filib
{

 template <typename ResT, typename ArgT>
 struct unary_virtual_fo : public std::unary_function<ResT,ArgT>
 {
  virtual ~unary_virtual_fo() {}
  virtual ResT operator()(ArgT const &) const = 0;
 };


 template <typename ResT, typename ArgT1, typename ArgT2>
 struct binary_virtual_fo : public std::binary_function<ResT,ArgT1,ArgT2>
 {
  virtual ~binary_virtual_fo() {}
  virtual ResT operator()(ArgT1 const &, ArgT2 const &) const = 0;
 };


 template <typename N, rounding_strategy K, interval_mode E>
 struct unary_plus_fo :
  public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()(interval<N,K,E> const & a) const
  {
   return (+a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct unary_minus_fo :
  public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()(interval<N,K,E> const & a) const
  {
   return (-a);
  }
 };


 template <typename N, rounding_strategy K, interval_mode E>
 struct plus_interval_interval_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return a+b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct plus_interval_argtype_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, N >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, N const & b) const
  {
   return a+b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct plus_argtype_interval_fo
  : public binary_virtual_fo< interval<N,K,E>, N, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (N const & a, interval<N,K,E> const & b) const
  {
   return a+b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct plus_upd_interval_interval_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return a+=b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct plus_upd_interval_interval_copy_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   interval<N,K,E> c = a;
   return c+=b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct plus_upd_interval_argtype_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, N >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, N const & b) const
  {
   return a+=b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct plus_upd_interval_argtype_copy_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, N >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, N const & b) const
  {
   interval<N,K,E> c = a;
   return c+=b;
  }
 };


 template <typename N, rounding_strategy K, interval_mode E>
 struct minus_interval_interval_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return a-b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct minus_interval_argtype_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, N >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, N const & b) const
  {
   return a-b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct minus_argtype_interval_fo
  : public binary_virtual_fo< interval<N,K,E>, N, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (N const & a, interval<N,K,E> const & b) const
  {
   return a-b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct minus_upd_interval_interval_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return a-=b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct minus_upd_interval_interval_copy_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   interval<N,K,E> c = a;
   return c-=b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct minus_upd_interval_argtype_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, N >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, N const & b) const
  {
   return a-=b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct minus_upd_interval_argtype_copy_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, N >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, N const & b) const
  {
   interval<N,K,E> c = a;
   return c-=b;
  }
 };


 template <typename N, rounding_strategy K, interval_mode E>
 struct multiplies_interval_interval_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return a*b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct multiplies_interval_argtype_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, N >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, N const & b) const
  {
   return a*b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct multiplies_argtype_interval_fo
  : public binary_virtual_fo< interval<N,K,E>, N, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (N const & a, interval<N,K,E> const & b) const
  {
   return a*b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct multiplies_upd_interval_interval_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return a*=b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct multiplies_upd_interval_interval_copy_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   interval<N,K,E> c = a;
   return c*=b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct multiplies_upd_interval_argtype_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, N >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, N const & b) const
  {
   return a*=b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct multiplies_upd_interval_argtype_copy_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, N >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, N const & b) const
  {
   interval<N,K,E> c = a;
   return c*=b;
  }
 };


 template <typename N, rounding_strategy K, interval_mode E>
 struct divides_interval_interval_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return a/b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct divides_interval_argtype_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, N >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, N const & b) const
  {
   return a/b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct divides_argtype_interval_fo
  : public binary_virtual_fo< interval<N,K,E>, N, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (N const & a, interval<N,K,E> const & b) const
  {
   return a/b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct divides_upd_interval_interval_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return a/=b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct divides_upd_interval_interval_copy_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   interval<N,K,E> c = a;
   return c/=b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct divides_upd_interval_argtype_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, N >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, N const & b) const
  {
   return a/=b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct divides_upd_interval_argtype_copy_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, N >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, N const & b) const
  {
   interval<N,K,E> c = a;
   return c/=b;
  }
 };


 template <typename N, rounding_strategy K, interval_mode E>
 struct inf_fo : public unary_virtual_fo <N, interval<N,K,E> >
 {
  virtual N operator()
  (interval<N,K,E> const & a) const
  {
   return inf(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct sup_fo : public unary_virtual_fo <N, interval<N,K,E> >
 {
  virtual N operator()
  (interval<N,K,E> const & a) const
  {
   return sup(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct isPoint_fo : public unary_virtual_fo <bool, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a) const
  {
   return isPoint(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct isInfinite_fo : public unary_virtual_fo <bool, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a) const
  {
   return isInfinite(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct isEmpty_fo : public unary_virtual_fo <bool, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a) const
  {
   return isEmpty(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct hasUlpAcc_fo : public binary_virtual_fo <bool, interval<N,K,E>, unsigned int >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, unsigned int const & b) const
  {
   return hasUlpAcc(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct diam_fo : public unary_virtual_fo <N, interval<N,K,E> >
 {
  virtual N operator()
  (interval<N,K,E> const & a) const
  {
   return diam(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct relDiam_fo : public unary_virtual_fo <N, interval<N,K,E> >
 {
  virtual N operator()
  (interval<N,K,E> const & a) const
  {
   return relDiam(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct rad_fo : public unary_virtual_fo <N, interval<N,K,E> >
 {
  virtual N operator()
  (interval<N,K,E> const & a) const
  {
   return rad(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct mag_fo : public unary_virtual_fo <N, interval<N,K,E> >
 {
  virtual N operator()
  (interval<N,K,E> const & a) const
  {
   return mag(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct abs_fo : public unary_virtual_fo <interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return abs(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct imin_fo : public binary_virtual_fo <interval<N,K,E>, interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return imin(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct imax_fo : public binary_virtual_fo <interval<N,K,E>, interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return imax(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct dist_fo : public binary_virtual_fo <N, interval<N,K,E>, interval<N,K,E> >
 {
  virtual N operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return dist(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct mid_fo : public unary_virtual_fo <N, interval<N,K,E> >
 {
  virtual N operator()
  (interval<N,K,E> const & a) const
  {
   return mid(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct mig_fo : public unary_virtual_fo <N, interval<N,K,E> >
 {
  virtual N operator()
  (interval<N,K,E> const & a) const
  {
   return mig(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct blow_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, N >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, N const & b) const
  {
   return blow(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct intersect_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return intersect(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct hull_interval_interval_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return hull(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct hull_argtype_interval_fo
  : public binary_virtual_fo< interval<N,K,E>, N, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (N const & a, interval<N,K,E> const & b) const
  {
   return hull(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct hull_argtype_argtype_fo
  : public binary_virtual_fo< interval<N,K,E>, N, N >
 {
  virtual interval<N,K,E> operator()
  (N const & a, N const & b) const
  {
   return hull<N,K,E>(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct disjoint_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return disjoint(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct in_fo
  : public binary_virtual_fo< bool, N, interval<N,K,E> >
 {
  virtual bool operator()
  (N const & a, interval<N,K,E> const & b) const
  {
   return in(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct interior_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return interior(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct proper_subset_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return proper_subset(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct subset_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return subset(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct smaller_equal_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return a <=b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct proper_superset_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return proper_superset(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct superset_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return superset(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct greater_equal_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return a >=b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct seq_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return seq(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct equality_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return a == b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct sne_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return sne(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct inequality_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return a != b;
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct sge_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return sge(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct sgt_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return sgt(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct sle_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return sle(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct slt_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return slt(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct ceq_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return ceq(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct cne_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return cne(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct cge_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return cge(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct cgt_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return cgt(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct cle_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return cle(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct clt_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return clt(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct peq_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return peq(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct pne_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return pne(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct pge_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return pge(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct pgt_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return pgt(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct ple_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return ple(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct plt_fo
  : public binary_virtual_fo< bool, interval<N,K,E>, interval<N,K,E> >
 {
  virtual bool operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return plt(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct acos_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return acos(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct acosh_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return acosh(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct acot_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return acot(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct acoth_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return acoth(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct asin_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return asin(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct asinh_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return asinh(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct atan_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return atan(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct atanh_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return atanh(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct cos_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return cos(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct cosh_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return cosh(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct cot_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return cot(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct coth_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return coth(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct exp_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return exp(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct exp10_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return exp10(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct exp2_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return exp2(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct expm1_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return expm1(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct log_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return log(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct log10_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return log10(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct log1p_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return log1p(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct log2_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {

   return log2(a);



  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct power_interval_integer_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, int >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, int const & b) const
  {
   return power(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct pow_interval_interval_fo
  : public binary_virtual_fo< interval<N,K,E>, interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a, interval<N,K,E> const & b) const
  {
   return pow(a,b);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct sin_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return sin(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct sinh_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return sinh(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct sqr_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return sqr(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct sqrt_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return sqrt(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct tan_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return tan(a);
  }
 };

 template <typename N, rounding_strategy K, interval_mode E>
 struct tanh_fo
  : public unary_virtual_fo< interval<N,K,E>, interval<N,K,E> >
 {
  virtual interval<N,K,E> operator()
  (interval<N,K,E> const & a) const
  {
   return tanh(a);
  }
 };

 template <typename N>
 struct pred_fo : public unary_virtual_fo<N,N>
 {
  virtual N operator()(N const & a) const
  { return primitive::pred(a); }
 };

 template <typename N>
 struct succ_fo : public unary_virtual_fo<N,N>
 {
  virtual N operator()(N const & a) const
  { return primitive::succ(a); }
 };
}
# 1227 "/usr/local/include/interval/interval.hpp" 2 3
# 48 "/usr/local/include/ibex/ibex_Interval.h" 2 3
# 110 "/usr/local/include/ibex/ibex_Interval.h" 3
namespace ibex {

template<class T> class Affine2Main;

class IntervalVector;
class IntervalMatrix;
class IntervalMatrixArray;
class ExprConstant;
# 127 "/usr/local/include/ibex/ibex_Interval.h" 3
void fpu_round_down();




void fpu_round_up();




void fpu_round_near();




void fpu_round_zero();




double previous_float(double x);




double next_float(double x);
# 175 "/usr/local/include/ibex/ibex_Interval.h" 3
class Interval {
  public:

    Interval();


    Interval(double a, double b);


    Interval(double a);


    bool operator==(const Interval& x) const;


    bool operator!=(const Interval& x) const;


    void set_empty();



    Interval& operator=(const Interval& x);



    template<class T>
    Interval& operator=(const Affine2Main<T>& x);



    Interval& operator=(double x);



    Interval& operator&=(const Interval& x);



    template<class T>
    Interval& operator&=( const Affine2Main<T>& x);



    Interval& operator|=(const Interval& x);



    template<class T>
    Interval& operator|=(const Affine2Main<T>& x);






    Interval& inflate(double rad);




    double lb() const;




    double ub() const;
# 256 "/usr/local/include/ibex/ibex_Interval.h" 3
    double mid() const;






    double rad() const;






    double diam() const;
# 281 "/usr/local/include/ibex/ibex_Interval.h" 3
    double mig() const;






    double mag() const;






    bool is_subset(const Interval& x) const;
# 304 "/usr/local/include/ibex/ibex_Interval.h" 3
    bool is_strict_subset(const Interval& x) const;
# 313 "/usr/local/include/ibex/ibex_Interval.h" 3
    bool is_interior_subset(const Interval& x) const;







    bool is_strict_interior_subset(const Interval& x) const;






    bool is_superset(const Interval& x) const;






    bool is_strict_superset(const Interval& x) const;
# 344 "/usr/local/include/ibex/ibex_Interval.h" 3
    bool contains(const double& d) const;





    bool interior_contains(const double& d) const;




    bool intersects(const Interval &x) const;






    bool overlaps(const Interval &x) const;





    bool is_disjoint(const Interval &x) const;




    bool is_empty() const;







    bool is_degenerated() const;






    bool is_unbounded() const;






    bool is_bisectable() const;







    double rel_distance(const Interval& x) const;




    int complementary(Interval& c1, Interval& c2) const;




    int diff(const Interval& y, Interval& c1, Interval& c2) const;


    Interval operator-() const;


    Interval& operator+=(double d);


    Interval& operator-=(double d);


    Interval& operator*=(double d);


    Interval& operator/=(double d);


    Interval& operator+=(const Interval& x);


    Interval& operator-=(const Interval& x);


    Interval& operator*=(const Interval& x);






    Interval& operator/=(const Interval& x);
# 464 "/usr/local/include/ibex/ibex_Interval.h" 3
    bool div2_inter(const Interval& x, const Interval& y, Interval& out2);




    Interval& div2_inter(const Interval& x, const Interval& y);
# 482 "/usr/local/include/ibex/ibex_Interval.h" 3
    double delta(const Interval& x) const;
# 497 "/usr/local/include/ibex/ibex_Interval.h" 3
    double ratiodelta(const Interval& x) const;
# 506 "/usr/local/include/ibex/ibex_Interval.h" 3
    std::pair<Interval,Interval> bisect(double ratio=0.5) const;


    static const Interval PI;

    static const Interval TWO_PI;

    static const Interval HALF_PI;

    static const Interval EMPTY_SET;

    static const Interval ALL_REALS;

    static const Interval ZERO;

    static const Interval ONE;

    static const Interval POS_REALS;

    static const Interval NEG_REALS;



    typedef Interval SCALAR;
    typedef IntervalVector VECTOR;
    typedef IntervalMatrix MATRIX;
    typedef IntervalMatrixArray MATRIX_ARRAY;




    operator const ExprConstant&() const;
# 557 "/usr/local/include/ibex/ibex_Interval.h" 3
    typedef filib::interval<double,filib::native_switched,filib::i_mode_extended_flag> FI_INTERVAL;

    Interval(const FI_INTERVAL& x);

    Interval& operator=(const FI_INTERVAL& x);

    FI_INTERVAL itv;
# 577 "/usr/local/include/ibex/ibex_Interval.h" 3
};





std::ostream& operator<<(std::ostream& os, const Interval& x);



Interval operator&(const Interval& x1, const Interval& x2);


Interval operator|(const Interval& x1, const Interval& x2);


Interval operator+(const Interval& x, double d);


Interval operator-(const Interval& x, double d);


Interval operator*(const Interval& x, double d);


Interval operator/(const Interval& x, double d);
# 613 "/usr/local/include/ibex/ibex_Interval.h" 3
void div2(const Interval& x, const Interval& y, Interval& out1, Interval& out2);


Interval operator+(double d,const Interval& x);


Interval operator-(double d, const Interval& x);


Interval operator*(double d, const Interval& x);


Interval operator/(double d, const Interval& x);


Interval operator+(const Interval& x1, const Interval& x2);


Interval operator-(const Interval& x1, const Interval& x2);


Interval operator*(const Interval& x1, const Interval& x2);


Interval operator/(const Interval& x1, const Interval& x2);


double distance(const Interval &x1, const Interval &x2);


Interval sqr(const Interval& x);


Interval sqrt(const Interval& x);


Interval pow(const Interval& x, int n);


Interval pow(const Interval& x, double d);


Interval pow(const Interval &x, const Interval &y);


Interval root(const Interval& x, int n);


Interval exp(const Interval& x);


Interval log(const Interval& x);


Interval cos(const Interval& x);


Interval sin(const Interval& x);


Interval tan(const Interval& x);


Interval acos(const Interval& x);


Interval asin(const Interval& x);


Interval atan(const Interval& x);


Interval atan2(const Interval& x, const Interval& y);


Interval cosh(const Interval& x);


Interval sinh(const Interval& x);


Interval tanh(const Interval& x);


Interval acosh(const Interval& x);


Interval asinh(const Interval& x);


Interval atanh(const Interval& x);


Interval abs(const Interval &x);




Interval max(const Interval& x, const Interval& y);




Interval min(const Interval& x, const Interval& y);





Interval sign(const Interval& x);





Interval chi(const Interval& a, const Interval& b, const Interval& c);




Interval integer(const Interval& x);




bool bwd_add(const Interval& y, Interval& x1, Interval& x2);




bool bwd_sub(const Interval& y, Interval& x1, Interval& x2);




bool bwd_mul(const Interval& y, Interval& x1, Interval& x2);




bool bwd_div(const Interval& y, Interval& x1, Interval& x2);




bool bwd_sqr(const Interval& y, Interval& x);




bool bwd_sqrt(const Interval& y, Interval& x);




bool bwd_pow(const Interval& y, int n, Interval& x);




bool bwd_pow(const Interval& y, Interval& x1, Interval& x2);




bool bwd_root(const Interval& y, int n, Interval& x);




bool bwd_exp(const Interval& y, Interval& x);




bool bwd_log(const Interval& y, Interval& x);




bool bwd_cos(const Interval& y, Interval& x);




bool bwd_sin(const Interval& y, Interval& x);




bool bwd_tan(const Interval& y, Interval& x);




bool bwd_acos(const Interval& y, Interval& x);




bool bwd_asin(const Interval& y, Interval& x);




bool bwd_atan(const Interval& y, Interval& x);




bool bwd_atan2(const Interval& y, Interval& x1, Interval& x2);




bool bwd_cosh(const Interval& y, Interval& x);




bool bwd_sinh(const Interval& y, Interval& x);




bool bwd_tanh(const Interval& y, Interval& x);




bool bwd_acosh(const Interval& y, Interval& x);




bool bwd_asinh(const Interval& y, Interval& x);




bool bwd_atanh(const Interval& y, Interval& x);




bool bwd_abs(const Interval& y, Interval& x);




bool bwd_max(const Interval& y, Interval& x1, Interval& x2);




bool bwd_min(const Interval& y, Interval& x1, Interval& x2);




bool bwd_sign(const Interval& y, Interval& x);


bool bwd_chi(const Interval& f, Interval& a, Interval& b, Interval& c);




bool bwd_integer(Interval& x);




bool bwd_imod(Interval& x, Interval& y, const double& p);

}
# 897 "/usr/local/include/ibex/ibex_Interval.h" 3
# 1 "/usr/local/include/ibex/ibex_filib_Interval.h_" 1 3
# 16 "/usr/local/include/ibex/ibex_filib_Interval.h_" 3
# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 44 "/usr/include/c++/7/cassert" 2 3
# 17 "/usr/local/include/ibex/ibex_filib_Interval.h_" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/float.h" 1 3 4
# 18 "/usr/local/include/ibex/ibex_filib_Interval.h_" 2 3

# 1 "/usr/include/c++/7/climits" 1 3
# 39 "/usr/include/c++/7/climits" 3
       
# 40 "/usr/include/c++/7/climits" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 194 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 183 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 184 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 188 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 192 "/usr/include/limits.h" 2 3 4
# 195 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 2 3 4
# 43 "/usr/include/c++/7/climits" 2 3
# 20 "/usr/local/include/ibex/ibex_filib_Interval.h_" 2 3

namespace ibex {

inline void fpu_round_down() {
 filib::fp_traits<double,filib::native_switched>::downward();
}

inline void fpu_round_up() {
 filib::fp_traits<double,filib::native_switched>::upward();
}

inline void fpu_round_near() {
 filib::fp_traits<double,filib::native_switched>::tonearest();
}

inline double previous_float(double x) {
 return filib::primitive::pred(x);
}

inline double next_float(double x) {
 return filib::primitive::succ(x);
}

inline void fpu_round_zero() {
 filib::fp_traits<double,filib::native_switched>::tozero();
}

inline Interval::Interval(const FI_INTERVAL& x) : itv(x) {

}

inline Interval& Interval::operator=(const FI_INTERVAL& x) {
 this->itv = x;
 return *this;
}

inline Interval& Interval::operator+=(double d) {
 if (d==filib::primitive::compose(0,0x7FF,0,0) || d==filib::primitive::compose(1,0x7FF,0,0))
  set_empty();
 else
  itv+=d;
 return *this;
}

inline Interval& Interval::operator-=(double d) {
 if (d==filib::primitive::compose(0,0x7FF,0,0) || d==filib::primitive::compose(1,0x7FF,0,0))
  set_empty();
 else
  itv-=d;
 return *this;

}

inline Interval& Interval::operator*=(double d) {
 if (d==filib::primitive::compose(0,0x7FF,0,0) || d==filib::primitive::compose(1,0x7FF,0,0))
  set_empty();
 else
  *this*=Interval(d);
 return *this;
}

inline Interval& Interval::operator/=(double d) {
 if (d==filib::primitive::compose(0,0x7FF,0,0) || d==filib::primitive::compose(1,0x7FF,0,0))
  set_empty();
 else{
  *this/=Interval(d);
 }
 return *this;
}

inline Interval& Interval::operator+=(const Interval& x) {
 itv+=x.itv;
 return *this;
}

inline Interval& Interval::operator-=(const Interval& x) {
 itv-=x.itv;
 return *this;
}

inline Interval& Interval::operator*=(const Interval& y) {

 FI_INTERVAL r;

 if (is_empty()) return *this;
 if (y.is_empty()) { *this=Interval::EMPTY_SET; return *this; }

 const double& a(lb());
 const double& b(ub());
 const double& c(y.lb());
 const double& d(y.ub());

 if ((a==0 && b==0) || (c==0 && d==0)) { *this=Interval(0.0,0.0); return *this; }

 if (((a<0) && (b>0)) && (c==filib::primitive::compose(1,0x7FF,0,0) || d==filib::primitive::compose(0,0x7FF,0,0))) { *this=Interval(filib::primitive::compose(1,0x7FF,0,0), filib::primitive::compose(0,0x7FF,0,0)); return *this; }

 if (((c<0) && (d>0)) && (a==filib::primitive::compose(1,0x7FF,0,0) || b==filib::primitive::compose(0,0x7FF,0,0))) { *this=Interval(filib::primitive::compose(1,0x7FF,0,0), filib::primitive::compose(0,0x7FF,0,0)); return *this; }


 if (((a==filib::primitive::compose(1,0x7FF,0,0)) && (d==0)) || ((d==filib::primitive::compose(0,0x7FF,0,0)) && (a==0))) {
  if ((b<=0) || (c>=0)) { *this=Interval(0.0, filib::primitive::compose(0,0x7FF,0,0)); return *this; }
  else {
   r = FI_INTERVAL(b)*FI_INTERVAL(c);
   *this=Interval(r.inf(), filib::primitive::compose(0,0x7FF,0,0));
   return *this;
  }
 }


 if (((a==filib::primitive::compose(1,0x7FF,0,0)) && (c==0)) || ((c==filib::primitive::compose(1,0x7FF,0,0)) && (a==0))) {
  if ((b<=0) || (d<=0)) { *this=Interval(filib::primitive::compose(1,0x7FF,0,0), 0.0); return *this; }
  else {
   r = FI_INTERVAL(b)*FI_INTERVAL(d);
   *this=Interval(filib::primitive::compose(1,0x7FF,0,0), r.sup());
   return *this;
  }
 }


 if (((c==filib::primitive::compose(1,0x7FF,0,0)) && (b==0)) || ((b==filib::primitive::compose(0,0x7FF,0,0)) && (c==0))) {
  if ((d<=0) || (a>=0)) { *this=Interval(0.0, filib::primitive::compose(0,0x7FF,0,0)); return *this; }
  else {
   r = FI_INTERVAL(a)*FI_INTERVAL(d);
   *this=Interval(r.inf(), filib::primitive::compose(0,0x7FF,0,0));
   return *this;
  }
 }


 if (((b==filib::primitive::compose(0,0x7FF,0,0)) && (d==0)) || ((d==filib::primitive::compose(0,0x7FF,0,0)) && (b==0))) {
  if ((a>=0) || (c>=0)) { *this=Interval(filib::primitive::compose(1,0x7FF,0,0), 0.0); return *this; }
  else {
   r = FI_INTERVAL(a)*FI_INTERVAL(c);
   *this=Interval(filib::primitive::compose(1,0x7FF,0,0), r.sup());
   return *this;
  }
 }
 *this= itv*y.itv;
 return *this;
}


inline Interval& Interval::operator/=(const Interval& y) {

 if (is_empty()) return *this;
 if (y.is_empty()) { *this=Interval::EMPTY_SET; return *this; }

 const double& a(lb());
 const double& b(ub());
 const double& c(y.lb());
 const double& d(y.ub());

 FI_INTERVAL r;

 if (c==0 && d==0) {
  *this=Interval::EMPTY_SET;
  return *this;
 }

 if (a==0 && b==0) {

  return *this;
 }

 if (c>0 || d<0) {
  *this= itv / y.itv;
  return *this;
 }

 if ((b<=0) && d==0) {
  r = FI_INTERVAL(b) / FI_INTERVAL(c);
  *this=Interval(r.inf(), filib::primitive::compose(0,0x7FF,0,0));
  return *this;
 }

 if (b<=0 && c<0 && d<0) {
  *this=Interval(filib::primitive::compose(1,0x7FF,0,0), filib::primitive::compose(0,0x7FF,0,0));
  return *this;
 }

 if (b<=0 && c==0) {
  r = FI_INTERVAL(b) / FI_INTERVAL(d);
  *this=Interval(filib::primitive::compose(1,0x7FF,0,0), r.sup());
  return *this;
 }

 if (a>=0 && d==0) {
  r = FI_INTERVAL(a) / FI_INTERVAL(c);
  *this=Interval(filib::primitive::compose(1,0x7FF,0,0), r.sup());
  return *this;
 }

 if (a>=0 && c<0 && d>0) {
  *this=Interval(filib::primitive::compose(1,0x7FF,0,0), filib::primitive::compose(0,0x7FF,0,0));
  return *this;
 }

 if (a>=0 && c==0) {
  r = FI_INTERVAL(a) / FI_INTERVAL(d);
  *this=Interval(r.inf(), filib::primitive::compose(0,0x7FF,0,0));
  return *this;
 }

 *this=Interval(filib::primitive::compose(1,0x7FF,0,0), filib::primitive::compose(0,0x7FF,0,0));
 return *this;

}





inline Interval Interval:: operator-() const {
 return -itv;
}

inline Interval& Interval::div2_inter(const Interval& x, const Interval& y) {
 Interval out2;
 div2_inter(x,y,out2);
 return *this |= out2;
}

inline void Interval::set_empty() {
 *this = EMPTY_SET;
}

inline Interval& Interval::operator&=(const Interval& x) {
 itv = itv.intersect(x.itv);
 return *this;
}

inline Interval& Interval::operator|=(const Interval& x) {
 itv=itv.hull(x.itv);
 return *this;
}

inline double Interval::lb() const {
 return itv.inf();
}

inline double Interval::ub() const {
 return itv.sup();
}

inline double Interval::mid() const {
 if (itv.inf()==filib::primitive::compose(1,0x7FF,0,0))
  if (itv.sup()==filib::primitive::compose(0,0x7FF,0,0)) return 0;
  else return -double(1.79769313486231570814527423731704357e+308L);
 else if (itv.sup()==filib::primitive::compose(0,0x7FF,0,0)) return double(1.79769313486231570814527423731704357e+308L);
 else {
  double m=itv.mid();
  if (m<itv.inf()) m=itv.inf();
  else if (m>itv.sup()) m=itv.sup();
  return m;
 }
}

inline bool Interval::is_empty() const {
 return itv.isEmpty();
}

inline bool Interval::is_degenerated() const {
 return is_empty() || itv.isPoint();
}

inline bool Interval::is_unbounded() const {
 if (is_empty()) return false;
 return lb()==filib::primitive::compose(1,0x7FF,0,0) || ub()==filib::primitive::compose(0,0x7FF,0,0);
}


inline double Interval::diam() const {
 return itv.width();
}

inline double Interval::mig() const {
 return itv.mig();
}

inline double Interval::mag() const {
 return itv.mag();
}

inline Interval operator&(const Interval& x1, const Interval& x2) {
 return x1.itv.intersect(x2.itv);
}


inline Interval operator|(const Interval& x1, const Interval& x2) {
 if (x1.is_empty()) return x2;
 if (x2.is_empty()) return x1;
 return x1.itv.hull(x2.itv);
}

inline double hausdorff(const Interval &x1, const Interval &x2) {
 return x1.itv.dist(x2.itv);
}

inline Interval operator+(const Interval& x, double d) {
 if(d==filib::primitive::compose(1,0x7FF,0,0) || d==filib::primitive::compose(0,0x7FF,0,0))
  return Interval::EMPTY_SET;
 else
  return x.itv+d;
}

inline Interval operator-(const Interval& x, double d) {
 if(d==filib::primitive::compose(1,0x7FF,0,0) || d==filib::primitive::compose(0,0x7FF,0,0))
  return Interval::EMPTY_SET;
 else
  return x.itv-d;
}

inline Interval operator*(const Interval& x, double d) {
 if(d==filib::primitive::compose(1,0x7FF,0,0) || d==filib::primitive::compose(0,0x7FF,0,0))
  return Interval::EMPTY_SET;
 else {
  Interval res(d);
  return res*=x;
 }
}

inline Interval operator/(const Interval& x, double d) {
 if(d==filib::primitive::compose(1,0x7FF,0,0) || d==filib::primitive::compose(0,0x7FF,0,0))
  return Interval::EMPTY_SET;
 else{
  Interval res(x);
  return res/=Interval(d);
 }
}

inline Interval operator+(double d,const Interval& x) {
 if(d==filib::primitive::compose(1,0x7FF,0,0) || d==filib::primitive::compose(0,0x7FF,0,0))
  return Interval::EMPTY_SET;
 else
  return d+x.itv;
}

inline Interval operator-(double d, const Interval& x) {
 if(d==filib::primitive::compose(1,0x7FF,0,0) || d==filib::primitive::compose(0,0x7FF,0,0))
  return Interval::EMPTY_SET;
 else
  return d-x.itv;
}

inline Interval operator*(double d, const Interval& x) {
 if(d==filib::primitive::compose(1,0x7FF,0,0) || d==filib::primitive::compose(0,0x7FF,0,0))
  return Interval::EMPTY_SET;
 else {
  Interval res(d);
  return res*=x;
 }
}

inline Interval operator/(double d, const Interval& x) {
 if(d==filib::primitive::compose(1,0x7FF,0,0) || d==filib::primitive::compose(0,0x7FF,0,0))
  return Interval::EMPTY_SET;
 else{
  Interval res(d);
  return res/=x;
 }
}

inline Interval operator+(const Interval& x1, const Interval& x2) {
 return x1.itv+x2.itv;
}

inline Interval operator-(const Interval& x1, const Interval& x2) {
 return x1.itv-x2.itv;
}

inline Interval operator*(const Interval& x1, const Interval& x2) {
 Interval res(x1);
 return res*=x2;
}

inline Interval operator/(const Interval& x1, const Interval& x2) {
 Interval res(x1);
 return res/=Interval(x2);
}

inline Interval sqr(const Interval& x) {
 return filib::sqr(x.itv);
}

inline Interval sqrt(const Interval& x) {
 return filib::sqrt(x.itv);
}

inline Interval pow(const Interval& x, int n) {
 if (n==0)
  return Interval::ONE;
 else if (n<0)
  return 1.0/Interval(filib::power(x.itv,-n));
 else
  return filib::power(x.itv,n);
}

inline Interval pow(const Interval &x, double d) {
 if(d==filib::primitive::compose(1,0x7FF,0,0) || d==filib::primitive::compose(0,0x7FF,0,0))
  return Interval::EMPTY_SET;
 else if (d==0)
  return Interval::ONE;
 else if (d<0)
  return 1.0/pow(x,-d);
 else
  return pow(x,Interval(d));
}

inline Interval pow(const Interval &x, const Interval &y) {
 return filib::pow(x.itv, y.itv);
}



inline Interval root(const Interval& x, int n) {

 if (x.is_empty()) return Interval::EMPTY_SET;
 if (x.lb()==0 && x.ub()==0) return Interval::ZERO;
 if (n==0) return Interval::ONE;
 if (n<0) return 1.0/root(x,-n);
 if (n==1) return x;

 if (n%2==0) {
  return pow(x,Interval::ONE/n);
 } else {
  return pow(x,Interval::ONE/n) |
     (-pow(-x,Interval::ONE/n));
 }

}



inline Interval exp(const Interval& x) {
 return filib::exp(x.itv);
}

inline Interval log(const Interval& x) {
 if (x.ub()<=0)
  return Interval::EMPTY_SET;
 else
  return filib::log(x.itv);
}

inline Interval cos(const Interval& x) {
 return filib::cos(x.itv);
}

inline Interval sin(const Interval& x) {
 return filib::sin(x.itv);
}

inline Interval tan(const Interval& x) {
 return filib::tan(x.itv);
}

inline Interval acos(const Interval& x) {
 return filib::acos(x.itv);
}

inline Interval asin(const Interval& x) {
 return filib::asin(x.itv);
}

inline Interval atan(const Interval& x) {
 return filib::atan(x.itv);
}

inline Interval cosh(const Interval& x) {
 return filib::cosh(x.itv);
}

inline Interval sinh(const Interval& x) {
 return filib::sinh(x.itv);
}

inline Interval tanh(const Interval& x) {
 return filib::tanh(x.itv);
}

inline Interval acosh(const Interval& x) {
 return filib::acosh(x.itv);
}

inline Interval asinh(const Interval& x) {
 return filib::asinh(x.itv);
}

inline Interval atanh(const Interval& x) {
 return filib::atanh(x.itv);
}

inline Interval abs(const Interval &x) {
 return filib::abs(x.itv);
}

inline Interval max(const Interval& x, const Interval& y) {
 return x.itv.imax(y.itv);
}

inline Interval min(const Interval& x, const Interval& y) {
 return x.itv.imin(y.itv);
}

inline Interval integer(const Interval& x) {
 return Interval(std::ceil(x.lb()),std::floor(x.ub()));
}

inline bool bwd_mul(const Interval& y, Interval& x1, Interval& x2) {
 if (y.contains(0)) {
  if (!x2.contains(0))
   if (x1.div2_inter(y,x2).is_empty()) { x2.set_empty(); return false; }
  if (x1.contains(0)) return true;
  if (x2.div2_inter(y,x1).is_empty()) { x1.set_empty(); return false; }
  else return true;
 } else {
  if (x1.div2_inter(y,x2).is_empty()) { x2.set_empty(); return false; }
  if (x2.div2_inter(y,x1).is_empty()) { x1.set_empty(); return false; }
  else return true;
 }

}

inline bool bwd_sqr(const Interval& y, Interval& x) {

 Interval proj=sqrt(y);
 Interval pos_proj= proj & x;
 Interval neg_proj = (-proj) & x;

 x = pos_proj | neg_proj;
 return !x.is_empty();

}

inline bool bwd_pow(const Interval& y, int expon, Interval& x) {
 if (expon % 2 ==0) {
  Interval proj=root(y,expon);
  Interval pos_proj= proj & x;
  Interval neg_proj = (-proj) & x;
  x = pos_proj | neg_proj;
 }
 else {
  x &= root(y, expon);
 }
 return !x.is_empty();
}

inline bool bwd_pow(const Interval& , Interval& , Interval& ) {
 ibex_error("bwd_power(y,x1,x2) (with x1 and x2 intervals) not implemented yet with filib");
 return false;
}
# 579 "/usr/local/include/ibex/ibex_filib_Interval.h_" 3
inline bool bwd_trigo(const Interval& y, Interval& x, int ftype) {

 const int COS=0;
 const int SIN=1;
 const int TAN=2;

 Interval period_0, nb_period;

 switch (ftype) {
 case COS :
  period_0 = acos(y); break;
 case SIN :
  period_0 = asin(y); break;
 case TAN :
  period_0 = atan(y); break;
 default :
  (static_cast <bool> (false) ? void (0) : __assert_fail ("false", "/usr/local/include/ibex/ibex_filib_Interval.h_", 595, __extension__ __PRETTY_FUNCTION__)); break;
 }

 if (period_0.is_empty()) { x.set_empty(); return false; }

 if (x.lb()==filib::primitive::compose(1,0x7FF,0,0) || x.ub()==filib::primitive::compose(0,0x7FF,0,0)) return true;

 switch (ftype) {
 case COS :
  nb_period = x / Interval::PI; break;
 case SIN :
  nb_period = (x+Interval::HALF_PI) / Interval::PI; break;
 case TAN :
  nb_period = (x+Interval::HALF_PI) / Interval::PI; break;
 default :
  (static_cast <bool> (false) ? void (0) : __assert_fail ("false", "/usr/local/include/ibex/ibex_filib_Interval.h_", 610, __extension__ __PRETTY_FUNCTION__)); break;
 }

 if (nb_period.mag() > 0x7fffffff) return true;

 int p1 = ((int) nb_period.lb())-1;
 int p2 = ((int) nb_period.ub());
 Interval tmp1, tmp2;

 bool found = false;
 int i = p1-1;

 switch(ftype) {
 case COS :

  while (++i<=p2 && !found) found = !(tmp1 = (x & (i%2==0? period_0 + i*Interval::PI : (i+1)*Interval::PI - period_0))).is_empty();
  break;
 case SIN :
  while (++i<=p2 && !found) found = !(tmp1 = (x & (i%2==0? period_0 + i*Interval::PI : i*Interval::PI - period_0))).is_empty();
  break;
 case TAN :
  while (++i<=p2 && !found) found = !(tmp1 = (x & (period_0 + i*Interval::PI))).is_empty();
  break;
 }

 if (!found) { x.set_empty(); return false; }
 found = false;
 i=p2+1;

 switch(ftype) {
 case COS :
  while (--i>=p1 && !found) found = !(tmp2 = (x & (i%2==0? period_0 + i*Interval::PI : (i+1)*Interval::PI - period_0))).is_empty();
  break;
 case SIN :
  while (--i>=p1 && !found) found = !(tmp2 = (x & (i%2==0? period_0 + i*Interval::PI : i*Interval::PI - period_0))).is_empty();
  break;
 case TAN :
  while (--i>=p1 && !found) found = !(tmp2 = (x & (period_0 + i*Interval::PI))).is_empty();
  break;
 }

 if (!found) { x.set_empty(); return false; }

 x = tmp1 | tmp2;

 return true;
}


inline bool bwd_cos(const Interval& y, Interval& x) {
 return bwd_trigo(y,x,0);
}

inline bool bwd_sin(const Interval& y, Interval& x) {
 return bwd_trigo(y,x,1);
}

inline bool bwd_tan(const Interval& y, Interval& x) {
 return bwd_trigo(y,x,2);
}

inline bool bwd_cosh(const Interval& y, Interval& x) {

 Interval proj=acosh(y);
 if (proj.is_empty()) return false;
 Interval pos_proj= proj & x;
 Interval neg_proj = (-proj) & x;

 x = pos_proj | neg_proj;

 return !x.is_empty();
}

inline bool bwd_sinh(const Interval& y, Interval& x) {
 x &= asinh(y);
 return !x.is_empty();
}

inline bool bwd_tanh(const Interval& y, Interval& x) {
 x &= atanh(y);
 return !x.is_empty();
}



inline bool bwd_abs(const Interval& y, Interval& x) {
 Interval x1 = x & y;
 Interval x2 = x & (-y);
 x &= x1 | x2;
 return !x.is_empty();
}


}
# 898 "/usr/local/include/ibex/ibex_Interval.h" 2 3
# 910 "/usr/local/include/ibex/ibex_Interval.h" 3
namespace ibex {

namespace {



inline bool is_empty(double x) { return false; }
inline bool is_empty(const Interval& x) { return x.is_empty(); }
# 926 "/usr/local/include/ibex/ibex_Interval.h" 3
inline void set_empty(double x) { }
inline void set_empty(Interval& x) { x.set_empty(); }
# 936 "/usr/local/include/ibex/ibex_Interval.h" 3
}

inline double abs(double x) {return fabs(x);}


inline Interval::Interval() : itv(filib::primitive::compose(1,0x7FF,0,0), filib::primitive::compose(0,0x7FF,0,0)) {

}

inline Interval::Interval(double a, double b) : itv(a,b) {
 if (a==filib::primitive::compose(0,0x7FF,0,0) || b==filib::primitive::compose(1,0x7FF,0,0) || a>b) *this=EMPTY_SET;
}

inline Interval::Interval(double a) : itv(a,a) {
 if (a==filib::primitive::compose(1,0x7FF,0,0) || a==filib::primitive::compose(0,0x7FF,0,0)) *this=EMPTY_SET;
}

inline bool Interval::operator==(const Interval& x) const {
 return (is_empty() && x.is_empty()) || (lb()==x.lb() && ub()==x.ub());
}

inline Interval& Interval::operator=(double x) {
 if (x==filib::primitive::compose(1,0x7FF,0,0) || x==filib::primitive::compose(0,0x7FF,0,0))
  *this=EMPTY_SET;
 else
  itv = x;
 return *this;
}


inline Interval& Interval::operator=(const Interval& x) {
 itv = x.itv;
 return *this;
}

inline Interval& Interval::inflate(double radd) {
 (*this) += Interval(-radd,radd);
 return *this;
}

inline bool Interval::operator!=(const Interval& x) const {
 return !(*this==x);
}

inline double Interval::rad() const {
 if (is_empty()) return 0;
 else if (is_unbounded()) return filib::primitive::compose(0,0x7FF,0,0);
 else {
  double t = mid();
  double t1 =(t-*this).ub();
  double t2= (*this-t).ub();
  return (t1>t2) ? t1 : t2;
 }
}

inline bool Interval::is_bisectable() const {
 if (is_empty()) return false;
 double m=mid();
 return (lb()<m && m<ub());
}


inline double Interval::rel_distance(const Interval& x) const {
   double d=distance(*this,x);
   if (d==filib::primitive::compose(0,0x7FF,0,0)) return 1;
   double D=diam();
   return (D==0 || D==filib::primitive::compose(0,0x7FF,0,0)) ? 0.0 : (d/D);
}

inline double distance(const Interval &x1, const Interval &x2) {

    if (x1.is_empty()) return x2.rad();

    if (x2.is_empty()) return x1.rad();

    if (x1.lb()==filib::primitive::compose(1,0x7FF,0,0)) {
     if (x2.lb()!=filib::primitive::compose(1,0x7FF,0,0))
      return filib::primitive::compose(0,0x7FF,0,0);
     else if (x1.ub()==filib::primitive::compose(0,0x7FF,0,0)) {
      if (x2.ub()==filib::primitive::compose(0,0x7FF,0,0)) return 0.0;
      else return filib::primitive::compose(0,0x7FF,0,0);
     }
     else if (x2.ub()==filib::primitive::compose(0,0x7FF,0,0)) return filib::primitive::compose(0,0x7FF,0,0);
     else return fabs(x1.ub()-x2.ub());
    }
    else if (x1.ub()==filib::primitive::compose(0,0x7FF,0,0)) {
     if (x2.ub()!=filib::primitive::compose(0,0x7FF,0,0))
      return filib::primitive::compose(0,0x7FF,0,0);
     else if (x2.lb()==filib::primitive::compose(1,0x7FF,0,0))
      return filib::primitive::compose(0,0x7FF,0,0);
     else return fabs(x1.lb()-x2.lb());
    }
    else if (x2.is_unbounded())
     return filib::primitive::compose(0,0x7FF,0,0);
    else







     return x1.itv.dist(x2.itv);
# 1047 "/usr/local/include/ibex/ibex_Interval.h" 3
}

inline Interval sign(const Interval& x) {
 return x.ub()<0 ? Interval(-1,-1) : x.lb()>0 ? Interval(1,1) : Interval(-1,1);
}

inline Interval chi(const Interval& a, const Interval& b, const Interval& c){
 if (a.ub()<=0) {
  return b;
 } else if (a.lb()>0) {
  return c;
 } else {
  return b|c;
 }
}

inline Interval atan2(const Interval& y, const Interval& x) {

 if (y.is_empty() || x.is_empty()) return Interval::EMPTY_SET;


 else if (x==Interval::ZERO) {
  if (y.lb()>=0)
   if (y.ub()==0) return Interval::EMPTY_SET;
   else return Interval::HALF_PI;
  else if (y.ub()<=0) return -Interval::HALF_PI;
  else return Interval(-1,1)*Interval::HALF_PI;
 }

 else if (x.lb()>=0) {
  return atan(y/x);
 }
 else if (x.ub()<=0) {
  if (y.lb()>=0)
   return atan(y/x)+Interval::PI;
  else if (y.ub()<0)
   return atan(y/x)-Interval::PI;
  else
   return Interval(-1,1)*Interval::PI;
 } else {
  if (y.lb()>=0)
   return atan(y/x.ub()) | (atan(y/x.lb()) + Interval::PI);
  else if (y.ub()<=0)
   return (atan(y/x.lb())-Interval::PI) | atan(y/x.ub());
  else
   return Interval(-1,1)*Interval::PI;
 }
}

inline bool bwd_add(const Interval& y, Interval& x1, Interval& x2) {
 if ((x1 &= y-x2).is_empty()) { x2.set_empty(); return false; }
 if ((x2 &= y-x1).is_empty()) { x1.set_empty(); return false; }
 return true;
}

inline bool bwd_sub(const Interval& y, Interval& x1, Interval& x2) {
 if ((x1 &= y+x2).is_empty()) { x2.set_empty(); return false; }
 if ((x2 &= x1-y).is_empty()) { x1.set_empty(); return false; }
 return true;
}

inline bool bwd_div(const Interval& y, Interval& x1, Interval& x2) {
 if ((x1 &= y*x2).is_empty()) { x2.set_empty(); return false; }
 Interval tmp=y;
 bwd_mul(x1, tmp, x2);
 if (x2.is_empty()) { x1.set_empty(); return false; }
 return true;
}

inline bool bwd_sqrt(const Interval& y, Interval& x) {
 if (y.is_empty() || y.ub()<0) {
  x.set_empty();
 } else if (y.lb()<0) {
  x &= sqr(Interval(0,y.ub()));
 } else {
  x &= sqr(y);
 }
 return !x.is_empty();
}

inline bool bwd_root(const Interval& y, int n, Interval& x) {
 x &= pow(y,n);
 return !x.is_empty();
}

inline bool bwd_exp(const Interval& y, Interval& x) {
 x &= log(y);
 return !x.is_empty();
}

inline bool bwd_log(const Interval& y, Interval& x) {
 x &= exp(y);
 return !x.is_empty();
}

inline bool bwd_acos(const Interval& y, Interval& x) {
 x &= cos(y);
 return !x.is_empty();
}

inline bool bwd_asin(const Interval& y, Interval& x) {
 x &= sin(y);
 return !x.is_empty();
}

inline bool bwd_atan(const Interval& y, Interval& x) {

 if (y.is_empty()) {
  x.set_empty();
  return false;
 }




 Interval z=y;
 double pi2l=(Interval::PI/2).lb();
 double pi2u=(Interval::PI/2).ub();

 if (z.ub()>=pi2l)
  if (z.lb()>=pi2u)
   x.set_empty();
  else {
   if (z.lb()>-pi2l) {
# 1183 "/usr/local/include/ibex/ibex_Interval.h" 3
    x &= Interval(tan(Interval(z.lb())).lb(),filib::primitive::compose(0,0x7FF,0,0));
   }

  }
 else
  if (z.ub()<=-pi2u)
   x.set_empty();
  else if (z.lb()<-pi2l)

   x &= Interval(filib::primitive::compose(1,0x7FF,0,0),tan(Interval(z.ub())).ub());
  else
   x &= Interval(tan(Interval(z.lb())).lb(),
     tan(Interval(z.ub())).ub());

 return !x.is_empty();
}


inline bool bwd_acosh(const Interval& y, Interval& x) {
 if (y.is_empty() || y.ub()<0.0) {
  x.set_empty(); return false;
 }
 else {
  x &= cosh(Interval(y.lb()<0?0:y.lb(),y.ub()));
  return !x.is_empty();
 }
}

inline bool bwd_asinh(const Interval& y, Interval& x) {
 x &= sinh(y);
 return !x.is_empty();
}

inline bool bwd_atanh(const Interval& y, Interval& x) {
 x &= tanh(y);
 return !x.is_empty();
}

inline bool bwd_max(const Interval& y, Interval& x1, Interval& x2) {

 if (y.is_empty()) {
  x1.set_empty();
  x2.set_empty();
  return false;
 }


 if (x2.lb()>x1.ub() || y.lb()>x1.ub()) {

  if ((x2 &= y).is_empty()) { x1.set_empty(); return false;}
  else return true;
 } else if (x1.lb()>x2.ub() || y.lb()>x2.ub()) {
  if ((x1 &= y).is_empty()) { x2.set_empty(); return false;}
  else return true;
 }


 if (y.ub()<x1.lb() || y.ub()<x2.lb()) {
  x1.set_empty();
  x2.set_empty();
  return false;
 }


 if (x1.ub()>y.ub())
  x1=Interval(x1.lb(),y.ub());
 if (x2.ub()>y.ub())
  x2=Interval(x2.lb(),y.ub());

 return true;
}

inline bool bwd_min(const Interval& y, Interval& x1, Interval& x2) {

 Interval mx1=-x1;
 Interval mx2=-x2;

 if (!bwd_max(-y,mx1,mx2)) {
  x1.set_empty();
  x2.set_empty();
  return false;
 }

 x1=-mx1;
 x2=-mx2;
 return true;
}

inline bool bwd_sign(const Interval& y, Interval& x) {

 if (y.is_empty()) {
  x.set_empty();
  return false;
 }

 if(y.lb()>0)
  x &= Interval::POS_REALS;
 else if(y.ub()<0)
  x &= Interval::NEG_REALS;
 return !x.is_empty();
}



inline bool bwd_atan2(const Interval& theta, Interval& y, Interval& x) {


 Interval theta_xpos = theta & Interval(-1,1)*Interval::HALF_PI;

 Interval theta_xneg_ypos = theta & (Interval::HALF_PI | Interval::PI);

 Interval theta_xneg_yneg = theta & -(Interval::HALF_PI | Interval::PI);

 Interval xres= Interval::EMPTY_SET;
 Interval yres= Interval::EMPTY_SET;

 if (!theta_xpos.is_empty()) {

  Interval xpos=x & Interval::POS_REALS;
  Interval yall=y;

  if (theta_xneg_ypos.is_empty() || theta_xneg_yneg.is_empty()) {
   Interval z=yall/xpos;
   bwd_atan(theta_xpos,z);
   bwd_div(z,yall,xpos);

  }
  xres |= xpos;
  yres |= yall;


  if (theta_xpos.lb()>=Interval::HALF_PI.lb()) {
   xres |= (x & Interval::ZERO);
   yres |= (y & Interval::POS_REALS);
  } else if (theta_xpos.ub()<=-Interval::HALF_PI.lb()) {
   xres |= (x & Interval::ZERO);
   yres |= (y & Interval::NEG_REALS);
  }
 }

 if (!theta_xneg_ypos.is_empty()) {
  Interval xneg=x & Interval::NEG_REALS;
  Interval ypos=y & Interval::POS_REALS;
  Interval z=ypos/xneg;
  bwd_atan(theta_xneg_ypos - Interval::PI,z);
  bwd_div(z,ypos,xneg);
  xres |= xneg;
  yres |= ypos; }

 if (!theta_xneg_yneg.is_empty()) {
  Interval xneg=x & Interval::NEG_REALS;
  Interval yneg=y & Interval::NEG_REALS;
  Interval z=yneg/xneg;
  bwd_atan(theta_xneg_yneg + Interval::PI,z);
  bwd_div(z,yneg,xneg);
  xres |= xneg;
  yres |= yneg;
 }

 x=xres;
 y=yres;

 return !x.is_empty();
}
# 1471 "/usr/local/include/ibex/ibex_Interval.h" 3
inline bool bwd_chi(const Interval& f, Interval& a, Interval& b, Interval& c){
 if (a.ub()<=0) {if ((b &= f).is_empty()) { a.set_empty(); c.set_empty(); return false; } }
 else if (a.lb()>0) {if ((c &= f).is_empty()) { a.set_empty(); b.set_empty(); return false; } }

 if (f.is_disjoint(b)) {
  if ((a &= Interval::POS_REALS).is_empty()) { b.set_empty(); c.set_empty(); return false; }
  if ((c &= f).is_empty()) { a.set_empty(); b.set_empty(); return false; }
 }
 if (f.is_disjoint(c)) {
  if ((a &= Interval::NEG_REALS).is_empty()) { b.set_empty(); c.set_empty(); return false; }
  if ((b &= f).is_empty()) { a.set_empty(); c.set_empty(); return false; }
 }
 return true;
}


inline bool bwd_integer(Interval& x) {
 return !(x = integer(x)).is_empty();
}


inline bool bwd_imod(Interval& x, Interval& y, const double& p) {
    if (p <= 0.)
    {
        ibex_error("Modulo needs a strictly positive period p.");
        return false;
    }
    if (y.diam()>p || x.diam()>p)
        return false;
    Interval r = (x-y)/p;
    Interval ir = integer(r);
    if (ir.is_empty())
    {
        x.set_empty(); y.set_empty();
        return false;
    }
    if (ir.is_degenerated())
        bwd_sub(ir*p,x,y);
    else if (ir.diam()==1.)
    {
        double ir1 = ir.lb();
        double ir2 = ir.ub();
        Interval x1 = x; Interval x2 = x;
        Interval y1 = y; Interval y2 = y;
        bwd_sub(Interval(ir1*p),x1,y1);
        bwd_sub(Interval(ir2*p),x2,y2);
        x = x1 | x2;
        y = y1 | y2;
    }
    else
    {
        ibex_error("Modulo diameter error.");
        return false;
    }

    return true;
}

}
# 16 "/usr/local/include/ibex/ibex_Affine2.h" 2 3
# 1 "/usr/include/c++/7/math.h" 1 3
# 36 "/usr/include/c++/7/math.h" 3
# 1 "/usr/include/c++/7/cmath" 1 3
# 39 "/usr/include/c++/7/cmath" 3
       
# 40 "/usr/include/c++/7/cmath" 3
# 37 "/usr/include/c++/7/math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 17 "/usr/local/include/ibex/ibex_Affine2.h" 2 3
# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 44 "/usr/include/c++/7/cassert" 2 3
# 18 "/usr/local/include/ibex/ibex_Affine2.h" 2 3


# 1 "/usr/local/include/ibex/ibex_Affine2_fAF1.h" 1 3
# 18 "/usr/local/include/ibex/ibex_Affine2_fAF1.h" 3
namespace ibex {
class AF_fAF1 {

 friend class Affine2Main<AF_fAF1>;

private:
# 36 "/usr/local/include/ibex/ibex_Affine2_fAF1.h" 3
 double * _val;
 Interval _err;


public:

 AF_fAF1(double * val, Interval err);


 ~AF_fAF1();

};


inline AF_fAF1::AF_fAF1(double * val, Interval err) :
 _val (val ),
 _err (err) {

}



inline AF_fAF1::~AF_fAF1() {
 if (_val!=__null) delete[] _val;
}



}
# 21 "/usr/local/include/ibex/ibex_Affine2.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Affine2_fAF2.h" 1 3
# 18 "/usr/local/include/ibex/ibex_Affine2_fAF2.h" 3
namespace ibex {
class AF_fAF2 {

 friend class Affine2Main<AF_fAF2>;

private:
# 35 "/usr/local/include/ibex/ibex_Affine2_fAF2.h" 3
 double * _val;
 double _err;





 double twoSum(double a, double b, double *res);




 double twoProd(double a, double b, double *res);
 void Split(double x, int sp, double *x_high, double *x_low);



public:

 AF_fAF2(double * val, double err);


 virtual ~AF_fAF2();

};


inline AF_fAF2::AF_fAF2(double * val, double err) :
 _val (val ),
 _err (err) {

}



inline AF_fAF2::~AF_fAF2() {
 if (_val!=__null) delete[] _val;
}





inline void AF_fAF2::Split(double x, int sp, double *x_high, double *x_low)
{
 unsigned long C = (1UL << sp) + 1;
 double gamma = (C * x);
 double delta = (x - gamma);
 *x_high= (gamma + delta);
 *x_low= (x - *x_high);
}

inline double AF_fAF2::twoProd(double x, double y, double *r_1)
{
 int SHIFT_POW = 27;
 double x_high, x_low;
 double y_high, y_low;
 double t_1;
 double t_2;
 double t_3;
 Split(x, SHIFT_POW, &x_high, &x_low);
 Split(y, SHIFT_POW, &y_high, &y_low);
 *r_1 = (x * y);
 t_1 = (-*r_1 + x_high * y_high);
 t_2 = (t_1 + x_high * y_low );
 t_3 = (t_2 + x_low * y_high);
 return (t_3 + x_low * y_low );
}




inline double AF_fAF2::twoSum(double a, double b, double *res) {
 *res = (a+b);
 double a2 = (*res - b);
 double b2 = (*res - a2);
 double delta_a = (a - a2);
 double delta_b = (b - b2);
 return (delta_a + delta_b);
}



}
# 22 "/usr/local/include/ibex/ibex_Affine2.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Affine2_iAF.h" 1 3
# 18 "/usr/local/include/ibex/ibex_Affine2_iAF.h" 3
namespace ibex {
class AF_iAF {

 friend class Affine2Main<AF_iAF>;

private:
# 36 "/usr/local/include/ibex/ibex_Affine2_iAF.h" 3
 Interval * _val;
 Interval _err;



public:

 AF_iAF(Interval * val, Interval err);


 ~AF_iAF();

};


inline AF_iAF::AF_iAF(Interval * val, Interval err) :
 _val (val ),
 _err (err) {

}

inline AF_iAF::~AF_iAF() {
 if (_val!=__null) delete[] _val;
}



}
# 23 "/usr/local/include/ibex/ibex_Affine2.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Affine2_fAF2_fma.h" 1 3
# 28 "/usr/local/include/ibex/ibex_Affine2_fAF2_fma.h" 3
namespace ibex {
class AF_fAF2_fma {

 friend class Affine2Main<AF_fAF2_fma>;

private:
# 45 "/usr/local/include/ibex/ibex_Affine2_fAF2_fma.h" 3
 double * _val;
 double _err;





 double twoSum(double a, double b, double *res);




 double twoProd(double a, double b, double *res);
 void Split(double x, int sp, double *x_high, double *x_low);



public:

 AF_fAF2_fma(double * val, double err);


 virtual ~AF_fAF2_fma();

};


inline AF_fAF2_fma::AF_fAF2_fma(double * val, double err) :
 _val (val ),
 _err (err) {

}



inline AF_fAF2_fma::~AF_fAF2_fma() {
 if (_val!=__null) delete[] _val;
}




inline double AF_fAF2_fma::twoProd(double x, double y, double *res) {
 *res = x * y;
 return fma(x,y,-(*res));

}



inline double AF_fAF2_fma::twoSum(double a, double b, double *res) {
 *res = (a+b);
 double a2 = (*res - b);
 double b2 = (*res - a2);
 double delta_a = (a - a2);
 double delta_b = (b - b2);
 return (delta_a + delta_b);
}



}
# 24 "/usr/local/include/ibex/ibex_Affine2.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Affine2_sAF.h" 1 3
# 22 "/usr/local/include/ibex/ibex_Affine2_sAF.h" 3
namespace ibex {
class AF_sAF {

 friend class Affine2Main<AF_sAF>;

private:
# 39 "/usr/local/include/ibex/ibex_Affine2_sAF.h" 3
 double * _val;
 double _err;




public:

 AF_sAF(double * val, double err);


 virtual ~AF_sAF();

};


inline AF_sAF::AF_sAF(double * val, double err) :
 _val (val ),
 _err (err) {

}



inline AF_sAF::~AF_sAF() {
 if (_val!=__null) delete[] _val;
}

}
# 25 "/usr/local/include/ibex/ibex_Affine2.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Affine2_No.h" 1 3
# 18 "/usr/local/include/ibex/ibex_Affine2_No.h" 3
namespace ibex {
class AF_No {

 friend class Affine2Main<AF_No>;

private:
# 35 "/usr/local/include/ibex/ibex_Affine2_No.h" 3
 double * _val;
 double _err;



public:

 AF_No(double * val, double err);


 ~AF_No();

};


inline AF_No::AF_No(double * val, double err) :
 _val (val ),
 _err (err) {

}

inline AF_No::~AF_No() {
 if (_val!=__null) delete[] _val;
}



}
# 26 "/usr/local/include/ibex/ibex_Affine2.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Affine2_fAFFullI.h" 1 3
# 18 "/usr/local/include/ibex/ibex_Affine2_fAFFullI.h" 3
# 1 "/usr/include/c++/7/list" 1 3
# 58 "/usr/include/c++/7/list" 3
       
# 59 "/usr/include/c++/7/list" 3




# 1 "/usr/include/c++/7/bits/stl_list.h" 1 3
# 63 "/usr/include/c++/7/bits/stl_list.h" 3
# 1 "/usr/include/c++/7/bits/allocated_ptr.h" 1 3
# 40 "/usr/include/c++/7/bits/allocated_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Alloc>
    struct __allocated_ptr
    {
      using pointer = typename allocator_traits<_Alloc>::pointer;
      using value_type = typename allocator_traits<_Alloc>::value_type;


      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
      : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)
      { }


      template<typename _Ptr,
        typename _Req = _Require<is_same<_Ptr, value_type*>>>
      __allocated_ptr(_Alloc& __a, _Ptr __ptr)
      : _M_alloc(std::__addressof(__a)),
 _M_ptr(pointer_traits<pointer>::pointer_to(*__ptr))
      { }


      __allocated_ptr(__allocated_ptr&& __gd) noexcept
      : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr)
      { __gd._M_ptr = nullptr; }


      ~__allocated_ptr()
      {
 if (_M_ptr != nullptr)
   std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
      }


      __allocated_ptr&
      operator=(std::nullptr_t) noexcept
      {
 _M_ptr = nullptr;
 return *this;
      }


      value_type* get() { return _S_raw_ptr(_M_ptr); }

    private:
      static value_type* _S_raw_ptr(value_type* __ptr) { return __ptr; }

      template<typename _Ptr>
 static auto
 _S_raw_ptr(_Ptr __ptr) -> decltype(_S_raw_ptr(__ptr.operator->()))
 { return _S_raw_ptr(__ptr.operator->()); }

      _Alloc* _M_alloc;
      pointer _M_ptr;
    };


  template<typename _Alloc>
    __allocated_ptr<_Alloc>
    __allocate_guarded(_Alloc& __a)
    {
      return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };
    }


}
# 64 "/usr/include/c++/7/bits/stl_list.h" 2 3
# 1 "/usr/include/c++/7/ext/aligned_buffer.h" 1 3
# 32 "/usr/include/c++/7/ext/aligned_buffer.h" 3
       
# 33 "/usr/include/c++/7/ext/aligned_buffer.h" 3







namespace __gnu_cxx
{




  template<typename _Tp>
    struct __aligned_membuf
    {



      struct _Tp2 { _Tp _M_t; };

      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];

      __aligned_membuf() = default;


      __aligned_membuf(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      { return static_cast<void*>(&_M_storage); }

      const void*
      _M_addr() const noexcept
      { return static_cast<const void*>(&_M_storage); }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };






  template<typename _Tp>
    struct __aligned_buffer
    : std::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>
    {
      typename
 std::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>::type
 _M_storage;

      __aligned_buffer() = default;


      __aligned_buffer(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
      }

      const void*
      _M_addr() const noexcept
      {
        return static_cast<const void*>(&_M_storage);
      }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };

}
# 65 "/usr/include/c++/7/bits/stl_list.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace __detail
  {
 
# 80 "/usr/include/c++/7/bits/stl_list.h" 3
    struct _List_node_base
    {
      _List_node_base* _M_next;
      _List_node_base* _M_prev;

      static void
      swap(_List_node_base& __x, _List_node_base& __y) noexcept;

      void
      _M_transfer(_List_node_base* const __first,
    _List_node_base* const __last) noexcept;

      void
      _M_reverse() noexcept;

      void
      _M_hook(_List_node_base* const __position) noexcept;

      void
      _M_unhook() noexcept;
    };

 
  }




  template<typename _Tp>
    struct _List_node : public __detail::_List_node_base
    {

      __gnu_cxx::__aligned_membuf<_Tp> _M_storage;
      _Tp* _M_valptr() { return _M_storage._M_ptr(); }
      _Tp const* _M_valptr() const { return _M_storage._M_ptr(); }





    };






  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator() noexcept
      : _M_node() { }

      explicit
      _List_iterator(__detail::_List_node_base* __x) noexcept
      : _M_node(__x) { }

      _Self
      _M_const_cast() const noexcept
      { return *this; }


      reference
      operator*() const noexcept
      { return *static_cast<_Node*>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Node*>(_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }


      __detail::_List_node_base* _M_node;
    };






  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator() noexcept
      : _M_node() { }

      explicit
      _List_const_iterator(const __detail::_List_node_base* __x)
      noexcept
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x) noexcept
      : _M_node(__x._M_node) { }

      iterator
      _M_const_cast() const noexcept
      { return iterator(const_cast<__detail::_List_node_base*>(_M_node)); }


      reference
      operator*() const noexcept
      { return *static_cast<_Node*>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Node*>(_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }


      const __detail::_List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y) noexcept
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y) noexcept
    { return __x._M_node != __y._M_node; }

namespace __cxx11 {

  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tp_alloc_traits;
      typedef typename _Tp_alloc_traits::template
 rebind<_List_node<_Tp> >::other _Node_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Node_alloc_type> _Node_alloc_traits;

      static size_t
      _S_distance(const __detail::_List_node_base* __first,
    const __detail::_List_node_base* __last)
      {
 size_t __n = 0;
 while (__first != __last)
   {
     __first = __first->_M_next;
     ++__n;
   }
 return __n;
      }

      struct _List_impl
      : public _Node_alloc_type
      {

 _List_node<size_t> _M_node;




 _List_impl() noexcept
 : _Node_alloc_type(), _M_node()
 { }

 _List_impl(const _Node_alloc_type& __a) noexcept
 : _Node_alloc_type(__a), _M_node()
 { }


 _List_impl(_Node_alloc_type&& __a) noexcept
 : _Node_alloc_type(std::move(__a)), _M_node()
 { }

      };

      _List_impl _M_impl;


      size_t _M_get_size() const { return *_M_impl._M_node._M_valptr(); }

      void _M_set_size(size_t __n) { *_M_impl._M_node._M_valptr() = __n; }

      void _M_inc_size(size_t __n) { *_M_impl._M_node._M_valptr() += __n; }

      void _M_dec_size(size_t __n) { *_M_impl._M_node._M_valptr() -= __n; }

      size_t
      _M_distance(const __detail::_List_node_base* __first,
    const __detail::_List_node_base* __last) const
      { return _S_distance(__first, __last); }


      size_t _M_node_count() const { return *_M_impl._M_node._M_valptr(); }
# 381 "/usr/include/c++/7/bits/stl_list.h" 3
      typename _Node_alloc_traits::pointer
      _M_get_node()
      { return _Node_alloc_traits::allocate(_M_impl, 1); }

      void
      _M_put_node(typename _Node_alloc_traits::pointer __p) noexcept
      { _Node_alloc_traits::deallocate(_M_impl, __p, 1); }

  public:
      typedef _Alloc allocator_type;

      _Node_alloc_type&
      _M_get_Node_allocator() noexcept
      { return _M_impl; }

      const _Node_alloc_type&
      _M_get_Node_allocator() const noexcept
      { return _M_impl; }

      _List_base()
      : _M_impl()
      { _M_init(); }

      _List_base(const _Node_alloc_type& __a) noexcept
      : _M_impl(__a)
      { _M_init(); }


      _List_base(_List_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Node_allocator()))
      { _M_move_nodes(std::move(__x)); }

      _List_base(_List_base&& __x, _Node_alloc_type&& __a)
      : _M_impl(std::move(__a))
      {
 if (__x._M_get_Node_allocator() == _M_get_Node_allocator())
   _M_move_nodes(std::move(__x));
 else
   _M_init();
      }

      void
      _M_move_nodes(_List_base&& __x)
      {
 auto* const __xnode = std::__addressof(__x._M_impl._M_node);
 if (__xnode->_M_next == __xnode)
   _M_init();
 else
   {
     auto* const __node = std::__addressof(_M_impl._M_node);
     __node->_M_next = __xnode->_M_next;
     __node->_M_prev = __xnode->_M_prev;
     __node->_M_next->_M_prev = __node->_M_prev->_M_next = __node;
     _M_set_size(__x._M_get_size());
     __x._M_init();
   }
      }



      ~_List_base() noexcept
      { _M_clear(); }

      void
      _M_clear() noexcept;

      void
      _M_init() noexcept
      {
 this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
 this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
 _M_set_size(0);
      }
    };
# 502 "/usr/include/c++/7/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {
# 514 "/usr/include/c++/7/bits/stl_list.h" 3
      typedef _List_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef typename _Base::_Tp_alloc_traits _Tp_alloc_traits;
      typedef typename _Base::_Node_alloc_type _Node_alloc_type;
      typedef typename _Base::_Node_alloc_traits _Node_alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_traits::pointer pointer;
      typedef typename _Tp_alloc_traits::const_pointer const_pointer;
      typedef typename _Tp_alloc_traits::reference reference;
      typedef typename _Tp_alloc_traits::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;

      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Node_allocator;
# 568 "/usr/include/c++/7/bits/stl_list.h" 3
      template<typename... _Args>
 _Node*
 _M_create_node(_Args&&... __args)
 {
   auto __p = this->_M_get_node();
   auto& __alloc = _M_get_Node_allocator();
   __allocated_ptr<_Node_alloc_type> __guard{__alloc, __p};
   _Node_alloc_traits::construct(__alloc, __p->_M_valptr(),
     std::forward<_Args>(__args)...);
   __guard = nullptr;
   return __p;
 }


    public:






      list()

      noexcept(is_nothrow_default_constructible<_Node_alloc_type>::value)

      : _Base() { }





      explicit
      list(const allocator_type& __a) noexcept
      : _Base(_Node_alloc_type(__a)) { }
# 612 "/usr/include/c++/7/bits/stl_list.h" 3
      explicit
      list(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_default_initialize(__n); }
# 625 "/usr/include/c++/7/bits/stl_list.h" 3
      list(size_type __n, const value_type& __value,
    const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_fill_initialize(__n, __value); }
# 652 "/usr/include/c++/7/bits/stl_list.h" 3
      list(const list& __x)
      : _Base(_Node_alloc_traits::
       _S_select_on_copy(__x._M_get_Node_allocator()))
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }
# 665 "/usr/include/c++/7/bits/stl_list.h" 3
      list(list&& __x) noexcept
      : _Base(std::move(__x)) { }
# 676 "/usr/include/c++/7/bits/stl_list.h" 3
      list(initializer_list<value_type> __l,
    const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_initialize_dispatch(__l.begin(), __l.end(), __false_type()); }

      list(const list& __x, const allocator_type& __a)
      : _Base(_Node_alloc_type(__a))
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }

      list(list&& __x, const allocator_type& __a)
      noexcept(_Node_alloc_traits::_S_always_equal())
      : _Base(std::move(__x), _Node_alloc_type(__a))
      {


 insert(begin(), std::__make_move_if_noexcept_iterator(__x.begin()),
   std::__make_move_if_noexcept_iterator(__x.end()));
      }
# 707 "/usr/include/c++/7/bits/stl_list.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
 : _Base(_Node_alloc_type(__a))
 { _M_initialize_dispatch(__first, __last, __false_type()); }
# 733 "/usr/include/c++/7/bits/stl_list.h" 3
      ~list() = default;
# 744 "/usr/include/c++/7/bits/stl_list.h" 3
      list&
      operator=(const list& __x);
# 758 "/usr/include/c++/7/bits/stl_list.h" 3
      list&
      operator=(list&& __x)
      noexcept(_Node_alloc_traits::_S_nothrow_move())
      {
 constexpr bool __move_storage =
   _Node_alloc_traits::_S_propagate_on_move_assign()
   || _Node_alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 return *this;
      }
# 776 "/usr/include/c++/7/bits/stl_list.h" 3
      list&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
# 794 "/usr/include/c++/7/bits/stl_list.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 811 "/usr/include/c++/7/bits/stl_list.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_dispatch(__first, __last, __false_type()); }
# 835 "/usr/include/c++/7/bits/stl_list.h" 3
      void
      assign(initializer_list<value_type> __l)
      { this->_M_assign_dispatch(__l.begin(), __l.end(), __false_type()); }



      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_Base::_M_get_Node_allocator()); }






      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_node._M_next); }






      iterator
      end() noexcept
      { return iterator(&this->_M_impl._M_node); }






      const_iterator
      end() const noexcept
      { return const_iterator(&this->_M_impl._M_node); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      cend() const noexcept
      { return const_iterator(&this->_M_impl._M_node); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }







      bool
      empty() const noexcept
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const noexcept
      { return this->_M_node_count(); }


      size_type
      max_size() const noexcept
      { return _Node_alloc_traits::max_size(_M_get_Node_allocator()); }
# 984 "/usr/include/c++/7/bits/stl_list.h" 3
      void
      resize(size_type __new_size);
# 997 "/usr/include/c++/7/bits/stl_list.h" 3
      void
      resize(size_type __new_size, const value_type& __x);
# 1019 "/usr/include/c++/7/bits/stl_list.h" 3
      reference
      front() noexcept
      { return *begin(); }





      const_reference
      front() const noexcept
      { return *begin(); }





      reference
      back() noexcept
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const noexcept
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 1066 "/usr/include/c++/7/bits/stl_list.h" 3
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }


      void
      push_front(value_type&& __x)
      { this->_M_insert(begin(), std::move(__x)); }

      template<typename... _Args>



 void

 emplace_front(_Args&&... __args)
 {
   this->_M_insert(begin(), std::forward<_Args>(__args)...);



 }
# 1102 "/usr/include/c++/7/bits/stl_list.h" 3
      void
      pop_front() noexcept
      { this->_M_erase(begin()); }
# 1116 "/usr/include/c++/7/bits/stl_list.h" 3
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }


      void
      push_back(value_type&& __x)
      { this->_M_insert(end(), std::move(__x)); }

      template<typename... _Args>



 void

 emplace_back(_Args&&... __args)
 {
   this->_M_insert(end(), std::forward<_Args>(__args)...);



 }
# 1151 "/usr/include/c++/7/bits/stl_list.h" 3
      void
      pop_back() noexcept
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
# 1168 "/usr/include/c++/7/bits/stl_list.h" 3
      template<typename... _Args>
 iterator
 emplace(const_iterator __position, _Args&&... __args);
# 1183 "/usr/include/c++/7/bits/stl_list.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1213 "/usr/include/c++/7/bits/stl_list.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 1232 "/usr/include/c++/7/bits/stl_list.h" 3
      iterator
      insert(const_iterator __p, initializer_list<value_type> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }
# 1252 "/usr/include/c++/7/bits/stl_list.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x);
# 1291 "/usr/include/c++/7/bits/stl_list.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last);
# 1335 "/usr/include/c++/7/bits/stl_list.h" 3
      iterator

      erase(const_iterator __position) noexcept;
# 1360 "/usr/include/c++/7/bits/stl_list.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last) noexcept



      {
 while (__first != __last)
   __first = erase(__first);
 return __last._M_const_cast();
      }
# 1383 "/usr/include/c++/7/bits/stl_list.h" 3
      void
      swap(list& __x) noexcept
      {
 __detail::_List_node_base::swap(this->_M_impl._M_node,
     __x._M_impl._M_node);

 size_t __xsize = __x._M_get_size();
 __x._M_set_size(this->_M_get_size());
 this->_M_set_size(__xsize);

 _Node_alloc_traits::_S_on_swap(this->_M_get_Node_allocator(),
           __x._M_get_Node_allocator());
      }







      void
      clear() noexcept
      {
 _Base::_M_clear();
 _Base::_M_init();
      }
# 1422 "/usr/include/c++/7/bits/stl_list.h" 3
      void

      splice(const_iterator __position, list&& __x) noexcept



      {
 if (!__x.empty())
   {
     _M_check_equal_allocators(__x);

     this->_M_transfer(__position._M_const_cast(),
         __x.begin(), __x.end());

     this->_M_inc_size(__x._M_get_size());
     __x._M_set_size(0);
   }
      }


      void
      splice(const_iterator __position, list& __x) noexcept
      { splice(__position, std::move(__x)); }
# 1458 "/usr/include/c++/7/bits/stl_list.h" 3
      void
      splice(const_iterator __position, list&& __x, const_iterator __i) noexcept
# 1473 "/usr/include/c++/7/bits/stl_list.h" 3
      {
 iterator __j = __i._M_const_cast();
 ++__j;
 if (__position == __i || __position == __j)
   return;

 if (this != std::__addressof(__x))
   _M_check_equal_allocators(__x);

 this->_M_transfer(__position._M_const_cast(),
     __i._M_const_cast(), __j);

 this->_M_inc_size(1);
 __x._M_dec_size(1);
      }
# 1500 "/usr/include/c++/7/bits/stl_list.h" 3
      void
      splice(const_iterator __position, list& __x, const_iterator __i) noexcept
      { splice(__position, std::move(__x), __i); }
# 1519 "/usr/include/c++/7/bits/stl_list.h" 3
      void
      splice(const_iterator __position, list&& __x, const_iterator __first,
      const_iterator __last) noexcept
# 1539 "/usr/include/c++/7/bits/stl_list.h" 3
      {
 if (__first != __last)
   {
     if (this != std::__addressof(__x))
       _M_check_equal_allocators(__x);

     size_t __n = this->_M_distance(__first._M_node, __last._M_node);
     this->_M_inc_size(__n);
     __x._M_dec_size(__n);

     this->_M_transfer(__position._M_const_cast(),
         __first._M_const_cast(),
         __last._M_const_cast());
   }
      }
# 1569 "/usr/include/c++/7/bits/stl_list.h" 3
      void
      splice(const_iterator __position, list& __x, const_iterator __first,
      const_iterator __last) noexcept
      { splice(__position, std::move(__x), __first, __last); }
# 1586 "/usr/include/c++/7/bits/stl_list.h" 3
      void
      remove(const _Tp& __value);
# 1600 "/usr/include/c++/7/bits/stl_list.h" 3
      template<typename _Predicate>
 void
 remove_if(_Predicate);
# 1614 "/usr/include/c++/7/bits/stl_list.h" 3
      void
      unique();
# 1629 "/usr/include/c++/7/bits/stl_list.h" 3
      template<typename _BinaryPredicate>
 void
 unique(_BinaryPredicate);
# 1643 "/usr/include/c++/7/bits/stl_list.h" 3
      void
      merge(list&& __x);

      void
      merge(list& __x)
      { merge(std::move(__x)); }
# 1668 "/usr/include/c++/7/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
 void
 merge(list&& __x, _StrictWeakOrdering __comp);

      template<typename _StrictWeakOrdering>
 void
 merge(list& __x, _StrictWeakOrdering __comp)
 { merge(std::move(__x), __comp); }
# 1687 "/usr/include/c++/7/bits/stl_list.h" 3
      void
      reverse() noexcept
      { this->_M_impl._M_node._M_reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
 void
 sort(_StrictWeakOrdering);

    protected:






      template<typename _Integer>
 void
 _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
 { _M_fill_initialize(static_cast<size_type>(__n), __x); }


      template<typename _InputIterator>
 void
 _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
 {
   for (; __first != __last; ++__first)

     emplace_back(*__first);



 }



      void
      _M_fill_initialize(size_type __n, const value_type& __x)
      {
 for (; __n; --__n)
   push_back(__x);
      }



      void
      _M_default_initialize(size_type __n)
      {
 for (; __n; --__n)
   emplace_back();
      }


      void
      _M_default_append(size_type __n);
# 1765 "/usr/include/c++/7/bits/stl_list.h" 3
      template<typename _Integer>
 void
 _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
 { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
 void
 _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->_M_transfer(__first._M_node, __last._M_node); }
# 1797 "/usr/include/c++/7/bits/stl_list.h" 3
     template<typename... _Args>
       void
       _M_insert(iterator __position, _Args&&... __args)
       {
  _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
  __tmp->_M_hook(__position._M_node);
  this->_M_inc_size(1);
       }



      void
      _M_erase(iterator __position) noexcept
      {
 this->_M_dec_size(1);
 __position._M_node->_M_unhook();
 _Node* __n = static_cast<_Node*>(__position._M_node);

 _Node_alloc_traits::destroy(_M_get_Node_allocator(), __n->_M_valptr());




 _M_put_node(__n);
      }


      void
      _M_check_equal_allocators(list& __x) noexcept
      {
 if (std::__alloc_neq<typename _Base::_Node_alloc_type>::
     _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))
   __builtin_abort();
      }


      const_iterator
      _M_resize_pos(size_type& __new_size) const;


      void
      _M_move_assign(list&& __x, true_type) noexcept
      {
 this->_M_clear();
 if (__x.empty())
   this->_M_init();
 else
   {
     this->_M_impl._M_node._M_next = __x._M_impl._M_node._M_next;
     this->_M_impl._M_node._M_next->_M_prev = &this->_M_impl._M_node;
     this->_M_impl._M_node._M_prev = __x._M_impl._M_node._M_prev;
     this->_M_impl._M_node._M_prev->_M_next = &this->_M_impl._M_node;
     this->_M_set_size(__x._M_get_size());
     __x._M_init();
   }
 std::__alloc_on_move(this->_M_get_Node_allocator(),
        __x._M_get_Node_allocator());
      }

      void
      _M_move_assign(list&& __x, false_type)
      {
 if (__x._M_get_Node_allocator() == this->_M_get_Node_allocator())
   _M_move_assign(std::move(__x), true_type{});
 else


   _M_assign_dispatch(std::__make_move_if_noexcept_iterator(__x.begin()),
        std::__make_move_if_noexcept_iterator(__x.end()),
        __false_type{});
      }

    };
}
# 1882 "/usr/include/c++/7/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {

      if (__x.size() != __y.size())
 return false;


      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
# 1916 "/usr/include/c++/7/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }







  template<typename _Tp>
    inline ptrdiff_t
    __distance(std::_List_iterator<_Tp> __first,
        std::_List_iterator<_Tp> __last,
        input_iterator_tag __tag)
    {
      typedef std::_List_const_iterator<_Tp> _CIter;
      return std::__distance(_CIter(__first), _CIter(__last), __tag);
    }

  template<typename _Tp>
    inline ptrdiff_t
    __distance(std::_List_const_iterator<_Tp> __first,
        std::_List_const_iterator<_Tp> __last,
        input_iterator_tag)
    {
      typedef std::_List_node<size_t> _Sentinel;
      std::_List_const_iterator<_Tp> __beyond = __last;
      ++__beyond;
      bool __whole = __first == __beyond;
      if (__builtin_constant_p (__whole) && __whole)
 return *static_cast<const _Sentinel*>(__last._M_node)->_M_valptr();

      ptrdiff_t __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }



}
# 64 "/usr/include/c++/7/list" 2 3
# 1 "/usr/include/c++/7/bits/list.tcc" 1 3
# 59 "/usr/include/c++/7/bits/list.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear() noexcept
    {
      typedef _List_node<_Tp> _Node;
      __detail::_List_node_base* __cur = _M_impl._M_node._M_next;
      while (__cur != &_M_impl._M_node)
 {
   _Node* __tmp = static_cast<_Node*>(__cur);
   __cur = __tmp->_M_next;
   _Tp* __val = __tmp->_M_valptr();

   _Node_alloc_traits::destroy(_M_get_Node_allocator(), __val);



   _M_put_node(__tmp);
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename list<_Tp, _Alloc>::iterator
      list<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
 _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
 __tmp->_M_hook(__position._M_const_cast()._M_node);
 this->_M_inc_size(1);
 return iterator(__tmp);
      }


  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->_M_hook(__position._M_const_cast()._M_node);
      this->_M_inc_size(1);
      return iterator(__tmp);
    }


  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(const_iterator __position, size_type __n, const value_type& __x)
    {
      if (__n)
 {
   list __tmp(__n, __x, get_allocator());
   iterator __it = __tmp.begin();
   splice(__position, __tmp);
   return __it;
 }
      return __position._M_const_cast();
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator, typename>
      typename list<_Tp, _Alloc>::iterator
      list<_Tp, _Alloc>::
      insert(const_iterator __position, _InputIterator __first,
      _InputIterator __last)
      {
 list __tmp(__first, __last, get_allocator());
 if (!__tmp.empty())
   {
     iterator __it = __tmp.begin();
     splice(__position, __tmp);
     return __it;
   }
 return __position._M_const_cast();
      }


  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::

    erase(const_iterator __position) noexcept



    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position._M_const_cast());
      return __ret;
    }
# 172 "/usr/include/c++/7/bits/list.tcc" 3
  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::const_iterator
    list<_Tp, _Alloc>::
    _M_resize_pos(size_type& __new_size) const
    {
      const_iterator __i;

      const size_type __len = size();
      if (__new_size < __len)
 {
   if (__new_size <= __len / 2)
     {
       __i = begin();
       std::advance(__i, __new_size);
     }
   else
     {
       __i = end();
       ptrdiff_t __num_erase = __len - __new_size;
       std::advance(__i, -__num_erase);
     }
   __new_size = 0;
   return __i;
 }
      else
 __i = end();





      __new_size -= __len;
      return __i;
    }


  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      size_type __i = 0;
      try
 {
   for (; __i < __n; ++__i)
     emplace_back();
 }
      catch(...)
 {
   for (; __i; --__i)
     pop_back();
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size)
    {
      const_iterator __i = _M_resize_pos(__new_size);
      if (__new_size)
 _M_default_append(__new_size);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, const value_type& __x)
    {
      const_iterator __i = _M_resize_pos(__new_size);
      if (__new_size)
        insert(end(), __new_size, __x);
      else
        erase(__i, end());
    }
# 264 "/usr/include/c++/7/bits/list.tcc" 3
  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != std::__addressof(__x))
 {

   if (_Node_alloc_traits::_S_propagate_on_copy_assign())
     {
              auto& __this_alloc = this->_M_get_Node_allocator();
              auto& __that_alloc = __x._M_get_Node_allocator();
              if (!_Node_alloc_traits::_S_always_equal()
           && __this_alloc != __that_alloc)
         {

    clear();
  }
       std::__alloc_on_copy(__this_alloc, __that_alloc);
            }

   _M_assign_dispatch(__x.begin(), __x.end(), __false_type());
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      iterator __extra = __last;
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     {



       if (std::__addressof(*__first) != std::__addressof(__value))
  _M_erase(__first);
       else
  __extra = __first;
     }
   __first = __next;
 }
      if (__extra != __last)
 _M_erase(__extra);
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::

    merge(list&& __x)



    {


      if (this != std::__addressof(__x))
 {
   _M_check_equal_allocators(__x);

   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   const size_t __orig_size = __x.size();
   try {
     while (__first1 != __last1 && __first2 != __last2)
       if (*__first2 < *__first1)
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);

     this->_M_inc_size(__x._M_get_size());
     __x._M_set_size(0);
   }
   catch(...)
     {
       const size_t __dist = std::distance(__first2, __last2);
       this->_M_inc_size(__orig_size - __dist);
       __x._M_set_size(__dist);
       throw;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::

      merge(list&& __x, _StrictWeakOrdering __comp)



      {


 if (this != std::__addressof(__x))
   {
     _M_check_equal_allocators(__x);

     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     const size_t __orig_size = __x.size();
     try
       {
  while (__first1 != __last1 && __first2 != __last2)
    if (__comp(*__first2, *__first1))
      {
        iterator __next = __first2;
        _M_transfer(__first1, __first2, ++__next);
        __first2 = __next;
      }
    else
      ++__first1;
  if (__first2 != __last2)
    _M_transfer(__last1, __first2, __last2);

  this->_M_inc_size(__x._M_get_size());
  __x._M_set_size(0);
       }
     catch(...)
       {
  const size_t __dist = std::distance(__first2, __last2);
  this->_M_inc_size(__orig_size - __dist);
  __x._M_set_size(__dist);
  throw;
       }
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = __tmp;
        list * __counter;
 try
   {
     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = __tmp;
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = __tmp + 1; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1));
     swap( *(__fill - 1) );
   }
 catch(...)
   {
     this->splice(this->end(), __carry);
     for (int __i = 0; __i < sizeof(__tmp)/sizeof(__tmp[0]); ++__i)
       this->splice(this->end(), __tmp[__i]);
     throw;
   }
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = __tmp;
     list * __counter;
     try
       {
  do
    {
      __carry.splice(__carry.begin(), *this, begin());

      for(__counter = __tmp;
   __counter != __fill && !__counter->empty();
   ++__counter)
        {
   __counter->merge(__carry, __comp);
   __carry.swap(*__counter);
        }
      __carry.swap(*__counter);
      if (__counter == __fill)
        ++__fill;
    }
  while ( !empty() );

  for (__counter = __tmp + 1; __counter != __fill; ++__counter)
    __counter->merge(*(__counter - 1), __comp);
  swap(*(__fill - 1));
       }
     catch(...)
       {
  this->splice(this->end(), __carry);
  for (int __i = 0; __i < sizeof(__tmp)/sizeof(__tmp[0]); ++__i)
    this->splice(this->end(), __tmp[__i]);
  throw;
       }
   }
      }


}
# 65 "/usr/include/c++/7/list" 2 3
# 19 "/usr/local/include/ibex/ibex_Affine2_fAFFullI.h" 2 3

namespace ibex {
  class AF_fAFFullI {


    friend class Affine2Main<AF_fAFFullI>;


    static unsigned long int _counter;

  private:
    static double maTol;

    static unsigned int _noiseNumber;
# 46 "/usr/local/include/ibex/ibex_Affine2_fAFFullI.h" 3
    double _center;
    std::list< std::pair<int, double> > _rays;
    Interval _garbage;


  public:
    AF_fAFFullI (double center, std::list<std::pair<int,double> > rays, Interval garbage);


    virtual ~AF_fAFFullI();

    static void setAffineTolerance (double tol);
    static double getAffineTolerance ();

    static void setAffineNoiseNumber (unsigned int n);
    static unsigned int getAffineNoiseNumber ();
  };

  inline AF_fAFFullI::AF_fAFFullI (double center, std::list<std::pair<int,double> > rays, Interval garbage) :
    _center(center), _rays(rays), _garbage(garbage) {

  }

  inline AF_fAFFullI::~AF_fAFFullI() {
    if (!_rays.empty()) { _rays.clear(); }
  }




}
# 27 "/usr/local/include/ibex/ibex_Affine2.h" 2 3


namespace ibex {

template<class T> class Affine2MainVector;
template<class T> class Affine2MainMatrix;
template<class T> class Affine2MainMatrixArray;
# 43 "/usr/local/include/ibex/ibex_Affine2.h" 3
typedef AF_fAF2 AF_Linear;







typedef AF_fAFFullI AF_Default;

typedef Affine2Main<AF_Default> Affine2;
typedef Affine2Main<AF_Linear> AffineLin;


template<class T=AF_Default>
class Affine2Main {

private:

 static const double AF_COMPAC_Tol;
 static const double AF_EM;
 static const double AF_EC;
 static const double AF_EE;
# 78 "/usr/local/include/ibex/ibex_Affine2.h" 3
 int _n;

 T _elt;







 Affine2Main& saxpy(double alpha, const Affine2Main& y, double beta, double delta,
   bool B1, bool B2, bool B3, bool B4);


public:


 typedef enum {
  AF_SQRT,
  AF_EXP,
  AF_LOG,
  AF_INV,
  AF_COS,
  AF_SIN,
  AF_TAN,
  AF_ABS,
  AF_ACOS,
  AF_ASIN,
  AF_ATAN,
  AF_COSH,
  AF_SINH,
  AF_TANH
 } Affine2_expr;




 Affine2Main();


 explicit Affine2Main(const double d);


 explicit Affine2Main(const Interval& itv);


 Affine2Main(int n, int m, const Interval& itv);


 Affine2Main(const Affine2Main& x);


 virtual ~Affine2Main() { };
# 140 "/usr/local/include/ibex/ibex_Affine2.h" 3
 Affine2Main& linChebyshev(Affine2_expr num, const Interval itv);


 Affine2Main operator-() const;


 Affine2Main& sqr(const Interval itv);


 Affine2Main& power(int n, const Interval itv);


 bool operator==(const Affine2Main& x) const;


 bool operator==(const Interval& x) const;


 bool operator!=(const Affine2Main& x) const;


 bool operator!=(const Interval& x) const ;


 void set_empty();



 Affine2Main& operator=(const Affine2Main& x);



 Affine2Main& operator=(double x);



 Affine2Main& operator=(const Interval& itv);
# 193 "/usr/local/include/ibex/ibex_Affine2.h" 3
 Affine2Main& inflate(double radd);
# 203 "/usr/local/include/ibex/ibex_Affine2.h" 3
 int size() const;




 const Interval itv() const ;




 double val(int i) const;




 double err() const;



 bool is_actif() const;




 bool is_empty() const;




 bool is_degenerated() const;






 bool is_unbounded() const;




 double mid() const;




 void compact(double tol);
 void compact();

 void initialize(double center, std::list<std::pair<int,double> > rays, Interval garbage);


 Affine2Main& operator+=(double d);


 Affine2Main& operator-=(double d);


 Affine2Main& operator*=(double d);


 Affine2Main& operator/=(double d) ;


 Affine2Main& operator+=(const Interval& x);


 Affine2Main& operator-=(const Interval& x);


 Affine2Main& operator*=(const Interval& x);


 Affine2Main& operator/=(const Interval& x);


 Affine2Main& operator+=(const Affine2Main& x);


 Affine2Main& operator-=(const Affine2Main& x);


 Affine2Main& operator*=(const Affine2Main& x);


 Affine2Main& operator/=(const Affine2Main& x);

 typedef Affine2Main<T> SCALAR;
 typedef Affine2MainVector<T> VECTOR;
 typedef Affine2MainMatrix<T> MATRIX;
 typedef Affine2MainMatrixArray<T> MATRIX_ARRAY;

};
# 304 "/usr/local/include/ibex/ibex_Affine2.h" 3
template<class T>
std::ostream& operator<<(std::ostream& os, const Affine2Main<T>& x);



template<class T>
Affine2Main<T> operator+(const Affine2Main<T>& x1, const Affine2Main<T>& x2);


template<class T>
Affine2Main<T> operator+(const Affine2Main<T>& x, double d);


template<class T>
Affine2Main<T> operator+(double d, const Affine2Main<T>& x);


template<class T>
Affine2Main<T> operator+(const Affine2Main<T>& x1, const Interval& x2);


template<class T>
Affine2Main<T> operator+(const Interval& x1, const Affine2Main<T>& x2);


template<class T>
Affine2Main<T> operator-(const Affine2Main<T>& x1, const Affine2Main<T>& x2);


template<class T>
Affine2Main<T> operator-(const Affine2Main<T>& x, double d);


template<class T>
Affine2Main<T> operator-(double d, const Affine2Main<T>& x);


template<class T>
Affine2Main<T> operator-(const Affine2Main<T>& x1, const Interval& x2);


template<class T>
Affine2Main<T> operator-(const Interval& x1, const Affine2Main<T>& x2);


template<class T>
Affine2Main<T> operator*(const Affine2Main<T>& x1, const Affine2Main<T>& x2);


template<class T>
Affine2Main<T> operator*(const Affine2Main<T>& x, double d);


template<class T>
Affine2Main<T> operator*(double d, const Affine2Main<T>& x);


template<class T>
Affine2Main<T> operator*(const Affine2Main<T>& x1, const Interval& x2);


template<class T>
Affine2Main<T> operator*(const Interval& x1, const Affine2Main<T>& x2);


template<class T>
Affine2Main<T> operator/(const Affine2Main<T>& x1, const Affine2Main<T>& x2);


template<class T>
Affine2Main<T> operator/(const Affine2Main<T>& x, double d);


template<class T>
Affine2Main<T> operator/(double d, const Affine2Main<T>& x);


template<class T>
Affine2Main<T> operator/(const Affine2Main<T>& x1, const Interval& x2);


template<class T>
Affine2Main<T> operator/(const Interval& x1, const Affine2Main<T>& x2);



template<class T>
double distance(const Affine2Main<T>& x1, const Affine2Main<T>& x2);


template<class T>
double distance(const Interval &x1, const Affine2Main<T>& x2);


template<class T>
double distance(const Affine2Main<T>& x1, const Interval &x2);



template<class T>
Affine2Main<T> inv(const Affine2Main<T>& x);
template<class T>
Affine2Main<T> inv(const Affine2Main<T>& x, const Interval itv);


template<class T>
Affine2Main<T> sqr(const Affine2Main<T>& x);
template<class T>
Affine2Main<T> sqr(const Affine2Main<T>& x, const Interval itv);


template<class T>
Affine2Main<T> sqrt(const Affine2Main<T>& x);
template<class T>
Affine2Main<T> sqrt(const Affine2Main<T>& x, const Interval itv);


template<class T>
Affine2Main<T> exp(const Affine2Main<T>& x);
template<class T>
Affine2Main<T> exp(const Affine2Main<T>& x, const Interval itv);


template<class T>
Affine2Main<T> log(const Affine2Main<T>& x);
template<class T>
Affine2Main<T> log(const Affine2Main<T>& x, const Interval itv);


template<class T>
Affine2Main<T> pow(const Affine2Main<T>& x, int n);
template<class T>
Affine2Main<T> pow(const Affine2Main<T>& x, int n, const Interval itv);


template<class T>
Affine2Main<T> pow(const Affine2Main<T>& x, double d);
template<class T>
Affine2Main<T> pow(const Affine2Main<T>& x, double d, const Interval itv);


template<class T>
Affine2Main<T> pow(const Affine2Main<T>& x, const Interval &y);
template<class T>
Affine2Main<T> pow(const Affine2Main<T>& x, const Interval &y, const Interval itvx);


template<class T>
Affine2Main<T> pow(const Affine2Main<T>& x, const Affine2Main<T>& y);


template<class T>
Affine2Main<T> root(const Affine2Main<T>& x, int n);
template<class T>
Affine2Main<T> root(const Affine2Main<T>& x, int n, const Interval itv);


template<class T>
Affine2Main<T> cos(const Affine2Main<T>& x);
template<class T>
Affine2Main<T> cos(const Affine2Main<T>& x, const Interval itv);


template<class T>
Affine2Main<T> sin(const Affine2Main<T>& x);
template<class T>
Affine2Main<T> sin(const Affine2Main<T>& x, const Interval itv);


template<class T>
Affine2Main<T> tan(const Affine2Main<T>& x);
template<class T>
Affine2Main<T> tan(const Affine2Main<T>& x, const Interval itv);


template<class T>
Affine2Main<T> acos(const Affine2Main<T>& x);
template<class T>
Affine2Main<T> acos(const Affine2Main<T>& x, const Interval itv);


template<class T>
Affine2Main<T> asin(const Affine2Main<T>& x);
template<class T>
Affine2Main<T> asin(const Affine2Main<T>& x, const Interval itv);


template<class T>
Affine2Main<T> atan(const Affine2Main<T>& x);
template<class T>
Affine2Main<T> atan(const Affine2Main<T>& x, const Interval itv);


template<class T>
Affine2Main<T> cosh(const Affine2Main<T>& x);
template<class T>
Affine2Main<T> cosh(const Affine2Main<T>& x, const Interval itv);


template<class T>
Affine2Main<T> sinh(const Affine2Main<T>& x);
template<class T>
Affine2Main<T> sinh(const Affine2Main<T>& x, const Interval itv);


template<class T>
Affine2Main<T> tanh(const Affine2Main<T>& x);

template<class T>
Affine2Main<T> tanh(const Affine2Main<T>& x, const Interval itv);


template<class T>
Affine2Main<T> abs(const Affine2Main<T>& x);

template<class T>
Affine2Main<T> abs(const Affine2Main<T>& x, const Interval itv);

template<class T>
Interval max(const Affine2Main<T>& x, const Affine2Main<T>& y);
template<class T>
Interval max(const Interval& x, const Affine2Main<T>& y);
template<class T>
Interval max(const Affine2Main<T>& x, const Interval& y);

template<class T>
Interval min(const Affine2Main<T>& x, const Affine2Main<T>& y);
template<class T>
Interval min(const Interval& x, const Affine2Main<T>& y) ;
template<class T>
Interval min(const Affine2Main<T>& x, const Interval& y);




template<class T>
Interval operator&(const Affine2Main<T>& x1, const Affine2Main<T>& x2);
template<class T>
Interval operator&(const Interval& x1, const Affine2Main<T>& x2);
template<class T>
Interval operator&(const Affine2Main<T>& x1, const Interval& x2);



template<class T>
Interval operator|(const Affine2Main<T>& x1, const Affine2Main<T>& x2);
template<class T>
Interval operator|(const Interval& x1, const Affine2Main<T>& x2);
template<class T>
Interval operator|(const Affine2Main<T>& x1, const Interval& x2);






template<class T>
Affine2Main<T> integer(const Affine2Main<T>& x);





template<class T>
Affine2Main<T> sign(const Affine2Main<T>& x);
template<class T>
Affine2Main<T> sign(const Affine2Main<T>& x, const Interval itv);







template<class T>
Affine2Main<T> chi(const Affine2Main<T>& a,const Affine2Main<T>& b,const Affine2Main<T>& c);
template<class T>
Affine2Main<T> chi(const Interval& a,const Affine2Main<T>& b,const Affine2Main<T>& c);
template<class T>
Affine2Main<T> chi(const Interval& a,const Interval& b,const Affine2Main<T>& c);
template<class T>
Affine2Main<T> chi(const Interval& a,const Affine2Main<T>& b,const Interval& c);
template<class T>
Affine2Main<T> chi(const Affine2Main<T>& a,const Interval& b,const Affine2Main<T>& c);
template<class T>
Affine2Main<T> chi(const Affine2Main<T>& a,const Affine2Main<T>& b,const Interval& c);

}







# 1 "/usr/local/include/ibex/ibex_Affine2.h_" 1 3
# 18 "/usr/local/include/ibex/ibex_Affine2.h_" 3
namespace ibex {

template<class T>
inline std::ostream& operator<<(std::ostream& os, const Affine2Main<T>& x) {
 {
  os << x.itv() << " : ";
  if (x.is_actif()) {
   os << x.val(0);
   for (int i = 1; i <= x.size(); i++) {
    os << " + " << x.val(i) << " eps_" << i;
   }
   os << " + " << x.err() << " [-1,1] ";
  } else {
   os << "Affine2Main form not Activate ";
  }
  return os;

 }
}



template<class T>
inline Affine2Main<T>& Affine2Main<T>::linChebyshev(Affine2_expr num, const Interval itv) {


 Interval res_itv;
 switch (num) {
 case AF_SQRT :
  res_itv = sqrt(itv);
  break;
 case AF_EXP :
  res_itv = exp(itv);
  break;
 case AF_LOG :
  res_itv = log(itv);
  break;
 case AF_INV :
  res_itv = 1.0/itv;
  break;
 case AF_COS :
  res_itv = cos(itv);
  break;
 case AF_SIN :
  res_itv = sin(itv);
  break;
 case AF_TAN :
  res_itv = tan(itv);
  break;
 case AF_ABS :
  res_itv = abs(itv);
  break;
 case AF_ACOS :
  res_itv = acos(itv);
  break;
 case AF_ASIN :
  res_itv = asin(itv);
  break;
 case AF_ATAN :
  res_itv = atan(itv);
  break;
 case AF_COSH :
  res_itv = cosh(itv);
  break;
 case AF_SINH :
  res_itv = sinh(itv);
  break;
 case AF_TANH :
  res_itv = tanh(itv);
  break;
 default: {
  ibex_error("Not implemented yet");
  break;
 }
 }


 if (res_itv.is_empty() || res_itv.is_unbounded()) {
  *this = res_itv;
 } else if ((!is_actif())||(itv.diam()<AF_EC)) {
  *this = res_itv;
 } else {


  double alpha, beta, ddelta, t1, t2;
  Interval dmm(0.0), TEMP1(0.0), TEMP2(0.0), band(0.0);

  switch (num) {
# 115 "/usr/local/include/ibex/ibex_Affine2.h_" 3
  case AF_SQRT: {
   Interval itv2;
   if (itv.lb()<0) {
    itv2 = Interval(0.0,itv.ub());
   } else {
    itv2 = itv;
   }
   dmm = sqrt(itv2);
   alpha = dmm.diam()/itv2.diam();


   TEMP1 = dmm.lb()-alpha*Interval(itv2.lb());
   TEMP2 = dmm.ub()-alpha*Interval(itv2.ub());
   if (TEMP1.lb()>TEMP2.lb()) {
    band = Interval(TEMP2.lb(),(1.0/(4*Interval(alpha))).ub());
   } else {
    band = Interval(TEMP1.lb(),(1.0/(4*Interval(alpha))).ub());
   }

   beta = band.mid();
   t1 = (beta -band).ub();
   t2 = (band-beta).ub();
   ddelta = (t1>t2)? t1 : t2;

   saxpy(alpha, Affine2Main<T>(), beta, ddelta, true,false,true,true);
   break;
  }
  case AF_EXP : {

   if (itv.is_unbounded()) {
    *this = res_itv;
   } else {

    dmm = res_itv;
    alpha = dmm.diam()/itv.diam();


    TEMP1 = dmm.lb()-alpha*Interval(itv.lb());
    TEMP2 = dmm.ub()-alpha*Interval(itv.ub());
    if (TEMP1.ub()>TEMP2.ub()) {
     band = Interval((alpha*(1-log(Interval(alpha)))).lb(),TEMP1.ub());
    } else {
     band = Interval((alpha*(1-log(Interval(alpha)))).lb(),TEMP2.ub());
    }

    beta = band.mid();
    t1 = (beta -band).ub();
    t2 = (band-beta).ub();
    ddelta = (t1>t2)? t1 : t2;

    saxpy(alpha, Affine2Main<T>(), beta, ddelta, true,false,true,true);
   }

   break;
  }
  case AF_LOG : {
   dmm = res_itv;
   alpha = dmm.diam()/itv.diam();


   TEMP1 = dmm.lb()-alpha*Interval(itv.lb());
   TEMP2 = dmm.ub()-alpha*Interval(itv.ub());
   if (TEMP1.lb()>TEMP2.lb()) {
    band = Interval(TEMP2.lb(),(-log(Interval(alpha))-1).ub());
   }
   else {
    band = Interval(TEMP1.lb(),(-log(Interval(alpha))-1).ub());
   }

   beta = band.mid();
   t1 = (beta -band).ub();
   t2 = (band -beta).ub();
   ddelta = (t1>t2)? t1 : t2;

   saxpy(alpha, Affine2Main<T>(), beta, ddelta, true,false,true,true);
   break;
  }
  case AF_INV : {
   if (itv.is_unbounded()) {
    *this = res_itv;
   }
   else {
    dmm = (1.0/abs(itv));
    alpha = -(dmm.diam()/itv.diam());


    TEMP1 = (1.0/Interval(abs(itv).lb()))-alpha*Interval(abs(itv).lb());
    TEMP2 = (1.0/Interval(abs(itv).ub()))-alpha*Interval(abs(itv).ub());
    if (TEMP1.ub()>TEMP2.ub()) {
     band = Interval((2*sqrt(-Interval(alpha))).lb(),TEMP1.ub());
    }
    else {
     band = Interval((2*sqrt(-Interval(alpha))).lb(),TEMP2.ub());
    }

    beta = band.mid();
    t1 = (beta -band).ub();
    t2 = (band -beta).ub();
    ddelta = (t1>t2)? t1 : t2;

    if (itv.lb()<0.0) beta = -beta;
    saxpy(alpha, Affine2Main<T>(), beta, ddelta, true,false,true,true);
   }
   break;
  }
  case AF_COSH : {

   dmm = res_itv;
   alpha = ((cosh(Interval(itv.ub()))-cosh(Interval(itv.lb())))/itv.diam()).lb();


   TEMP1 = cosh(Interval(itv.lb()))-alpha*Interval(itv.lb());
   TEMP2 = cosh(Interval(itv.ub()))-alpha*Interval(itv.ub());
   if (TEMP1.ub()>TEMP2.ub()) {

    band = Interval((sqrt(pow(Interval(alpha),2)+1)-alpha*asinh(Interval(alpha))).lb(),TEMP1.ub());
   }
   else {
    band = Interval((sqrt(pow(Interval(alpha),2)+1)-alpha*asinh(Interval(alpha))).lb(),TEMP2.ub());
   }

   beta = band.mid();
   t1 = (beta -band).ub();
   t2 = (band -beta).ub();
   ddelta = (t1>t2)? t1 : t2;

   saxpy(alpha, Affine2Main<T>(), beta, ddelta, true,false,true,true);
   break;
  }
  case AF_ABS : {
   if (0<=itv.lb()) {
    break;
   }
   else if (itv.ub()<=0) {
    *this = (-Affine2Main<T>(*this));
   }
   else {
    dmm = res_itv;
    alpha = ((abs(Interval(itv.ub()))-abs(Interval(itv.lb())))/itv.diam()).ub();

    TEMP1 = dmm.lb()-alpha*Interval(itv.lb());
    TEMP2 = dmm.ub()-alpha*Interval(itv.ub());
    if (TEMP1.ub()>TEMP2.ub()) {

     band = Interval(0.0,TEMP1.ub());
    }
    else {
     band = Interval(0.0,TEMP2.ub());
    }

    beta = band.mid();
    t1 = (beta -band).ub();
    t2 = (band -beta).ub();
    ddelta = (t1>t2)? t1 : t2;

    saxpy(alpha, Affine2Main<T>(), beta, ddelta, true,false,true,true);
   }
   break;
  }


  case AF_TAN :
  case AF_COS :
  case AF_SIN : {
   if (itv.diam()>=Interval::TWO_PI.lb()) {
    *this = Interval(-1,1);
    break;
   }
# 295 "/usr/local/include/ibex/ibex_Affine2.h_" 3
   double x0,xb0,xb1,fxb0,fxb1,c0,c1;

   x0 = 1.0/::sqrt(2.);
   xb0 = (0.5)*(itv.diam()*x0 +itv.lb()+itv.ub());
   xb1 = (0.5)*(itv.diam()*(-x0) +itv.lb()+itv.ub());

   switch (num) {
   case AF_COS :
    fxb0 = ::cos(xb0);
    fxb1 = ::cos(xb1);
    break;
   case AF_SIN :
    fxb0 = ::sin(xb0);
    fxb1 = ::sin(xb1);
    break;
   case AF_TAN :
    fxb0 = ::tan(xb0);
    fxb1 = ::tan(xb1);
    break;
   default:
    ibex_error("Not implemented yet");
    break;
   }

   c0 = (0.5)*(fxb0+fxb1);
   c1 = x0*fxb0-x0*fxb1;

   alpha = 2*c1/(itv.diam());
   beta = c0-c1*((itv.lb()+itv.ub())/(itv.diam()));



   ddelta= 0.0;
   Interval u,nb_period;


   switch (num) {
   case AF_COS :
    ddelta = (abs(cos(Interval(itv.lb()))-(alpha*Interval(itv.lb())+beta))).ub();
    t1 = (abs(cos(Interval(itv.ub()))-(alpha*Interval(itv.ub())+beta))).ub();
    if (t1>ddelta) ddelta= t1;
    u = asin(-Interval(alpha));
    nb_period = (itv+Interval::HALF_PI) / Interval::PI;
    break;
   case AF_SIN :
    ddelta = (abs(sin(Interval(itv.lb()))-(alpha*Interval(itv.lb())+beta))).ub();
    t1 = (abs(sin(Interval(itv.ub()))-(alpha*Interval(itv.ub())+beta))).ub();
    if (t1>ddelta) ddelta= t1;
    u = acos(Interval(alpha));
    nb_period = (itv) / Interval::PI;
    break;
   case AF_TAN :
    ddelta = (abs(tan(Interval(itv.lb()))-(alpha*Interval(itv.lb())+beta))).ub();
    t1 = (abs(tan(Interval(itv.ub()))-(alpha*Interval(itv.ub())+beta))).ub();
    if (t1>ddelta) ddelta= t1;
    u = acos(1/sqrt(Interval(alpha)));
    nb_period = (itv) / Interval::PI;
    break;
   default:
    ibex_error("Not implemented yet");
    break;
   }


   int p1 = ((int) nb_period.lb())-2;
   int p2 = ((int) nb_period.ub())+2;

   int i = p1;
   switch(num) {
   case AF_COS :
    while (i<=p2) {
     TEMP1 = (itv & (i%2==0? (u + i*Interval::PI) : (i*Interval::PI - u)));
     if (!(TEMP1.is_empty())) {
      t1 = (abs(cos(TEMP1)-(alpha*TEMP1+beta))).ub();
      if (t1>ddelta) ddelta= t1;
     }
     i++;
    }
    break;
   case AF_SIN :
    while (i<=p2) {
     TEMP1 = (itv & (i%2==0? (u + i*Interval::PI) : ((i+1)*Interval::PI - u)));
     if (!(TEMP1.is_empty())) {
      t1 = (abs(sin(TEMP1)-(alpha*TEMP1+beta))).ub();
      if (t1>ddelta) ddelta= t1;
     }
     i++;
    }
    break;
   case AF_TAN :
    while (i<=p2) {
     TEMP1 = (itv & ( i*Interval::PI + u));
     if ((!(TEMP1.is_empty()))) {
      t1 = (abs(tan(TEMP1)-(alpha*TEMP1+beta))).ub();
      if (t1>ddelta) ddelta= t1;
     }
     TEMP1 = (itv & ( i*Interval::PI - u ));
     if ((!(TEMP1.is_empty()))) {
      t1 = (abs(tan(TEMP1)-(alpha*TEMP1+beta))).ub();
      if (t1>ddelta) ddelta= t1;
     }
     i++;
    }
    break;
   default:
    ibex_error("Not implemented yet");
    break;
   }

   saxpy(alpha, Affine2Main<T>(), beta, ddelta, true,false,true,true);
   break;
  }



  case AF_ACOS :
  case AF_ASIN :

   if ((itv.lb() < (-1))||(itv.ub() > 1)) {
    linChebyshev(num,(itv & Interval(-1,1)));
    break;
   }
  case AF_TANH :
  case AF_ATAN :

   if (itv.is_unbounded() ) {
    *this = res_itv ;
    break;
   }
  case AF_SINH : {
# 437 "/usr/local/include/ibex/ibex_Affine2.h_" 3
   double x0,xb0,xb1,fxb0,fxb1,c0,c1;

   x0 = 1.0/::sqrt(2.);
   xb0 = (0.5)*(itv.diam()* x0 +itv.lb()+itv.ub());
   xb1 = (0.5)*(itv.diam()*(-x0) +itv.lb()+itv.ub());
   switch (num) {
   case AF_SINH :
    fxb0 = ::sinh(xb0);
    fxb1 = ::sinh(xb1);
    break;
   case AF_TANH :
    fxb0 = ::tanh(xb0);
    fxb1 = ::tanh(xb1);
    break;
   case AF_ATAN :
    fxb0 = ::atan(xb0);
    fxb1 = ::atan(xb1);
    break;
   case AF_ACOS :
    fxb0 = ::acos(xb0);
    fxb1 = ::acos(xb1);
    break;
   case AF_ASIN :
    fxb0 = ::asin(xb0);
    fxb1 = ::asin(xb1);
    break;
   default:
    ibex_error("Not implemented yet");
    break;
   }

   c0 = (0.5)*(fxb0+fxb1);
   c1 = x0*fxb0-x0*fxb1;

   alpha = 2*c1/(itv.diam());
   beta = c0-c1*((itv.lb()+itv.ub())/(itv.diam()));



   ddelta= 0.0;


   switch (num) {
   case AF_SINH :
    ddelta = (abs(sinh(Interval(itv.lb()))-(alpha*Interval(itv.lb())+beta))).ub();
    t1 = (abs(sinh(Interval(itv.ub()))-(alpha*Interval(itv.ub())+beta))).ub();
    if (t1>ddelta) ddelta= t1;

    TEMP2 = acosh(Interval(alpha));
    if (!((TEMP2 & itv).is_empty())) {

     t1 = (abs(sqrt(pow(Interval(alpha),2)-1)-(alpha*TEMP2+beta))).ub();
     if (t1>ddelta) ddelta= t1;
    }
    if (!(((-TEMP2) & itv).is_empty())) {

     t1 = (abs((-sqrt(pow(Interval(alpha),2)-1))-(alpha*(-TEMP2)+beta))).ub();
     if (t1>ddelta) ddelta= t1;
    }
    break;
   case AF_TANH :
    ddelta = (abs(tanh(Interval(itv.lb()))-(alpha*Interval(itv.lb())+beta))).ub();
    t1 = (abs(tanh(Interval(itv.ub()))-(alpha*Interval(itv.ub())+beta))).ub();
    if (t1>ddelta) ddelta= t1;



    TEMP2 = acosh(-2/Interval(alpha) -1);
    if (!((TEMP2 & itv).is_empty())) {
     t1 = (abs(tanh(TEMP2)-(alpha*TEMP2+beta))).ub();
     if (t1>ddelta) ddelta= t1;
    }
    if (!(((-TEMP2) & itv).is_empty())) {
     t1 = (abs(tanh(-TEMP2)-(alpha*(-TEMP2)+beta))).ub();
     if (t1>ddelta) ddelta= t1;
    }
    break;
   case AF_ATAN :
    ddelta = (abs(atan(Interval(itv.lb()))-(alpha*Interval(itv.lb())+beta))).ub();
    t1 = (abs(atan(Interval(itv.ub()))-(alpha*Interval(itv.ub())+beta))).ub();
    if (t1>ddelta) ddelta= t1;


    TEMP2 = sqrt(1/Interval(alpha)-1);
    if (!((TEMP2 & itv).is_empty())) {
     t1 = (abs(atan(TEMP2)-(alpha*TEMP2+beta))).ub();
     if (t1>ddelta) ddelta= t1;
    }
    if (!(((-TEMP2) & itv).is_empty())) {
     t1 = (abs(atan(-TEMP2)-(alpha*(-TEMP2)+beta))).ub();
     if (t1>ddelta) ddelta= t1;
    }
    break;
   case AF_ACOS :
    ddelta = (abs(acos(Interval(itv.lb()))-(alpha*Interval(itv.lb())+beta))).ub();
    t1 = (abs(acos(Interval(itv.ub()))-(alpha*Interval(itv.ub())+beta))).ub();
    if (t1>ddelta) ddelta= t1;


    TEMP2 = sqrt(1-1/(pow(Interval(alpha),2)));
    if (!((TEMP2 & itv).is_empty())) {
     t1 = (abs(acos(TEMP2)-(alpha*TEMP2+beta))).ub();
     if (t1>ddelta) ddelta= t1;
    }
    if (!(((-TEMP2) & itv).is_empty())) {
     t1 = (abs(acos(-TEMP2)-(alpha*(-TEMP2)+beta))).ub();
     if (t1>ddelta) ddelta= t1;
    }
    break;
   case AF_ASIN :
    ddelta = (abs(asin(Interval(itv.lb()))-(alpha*Interval(itv.lb())+beta))).ub();
    t1 = (abs(asin(Interval(itv.ub()))-(alpha*Interval(itv.ub())+beta))).ub();
    if (t1>ddelta) ddelta= t1;


    TEMP2 = sqrt(1/Interval(alpha)-1);
    if (!((TEMP2 & itv).is_empty())) {

     t1 = (abs(asin(TEMP2)-(alpha*TEMP2+beta))).ub();
     if (t1>ddelta) ddelta= t1;
    }
    if (!(((-TEMP2) & itv).is_empty())) {

     t1 = (abs(asin(-TEMP2)-(alpha*(-TEMP2)+beta))).ub();
     if (t1>ddelta) ddelta= t1;
    }
    break;
   default:
    ibex_error("Not implemented yet");
    break;
   }

   saxpy(alpha, Affine2Main<T>(), beta, ddelta, true,false,true,true);
   break;
  }
  default : {
   ibex_error("Not implemented yet");
   break;
  }
  }

 }

 return *this;
}




template<class T>
inline Affine2Main<T>& Affine2Main<T>::power(int n, const Interval itv) {



 if (itv.is_empty()||itv.is_unbounded()) {
  *this = pow(itv,n);
 } else if (!is_actif()) {
  *this = pow(itv,n);
 } else if (itv.diam()< AF_EC) {
  *this = pow(itv,n);
 } else {


  if (n == 0) {
   *this = Interval::ONE;

  } else if (n == 1) {

  } else if (n == 2) {
   sqr(itv);

  } else if (n % 2 == 0) {
# 617 "/usr/local/include/ibex/ibex_Affine2.h_" 3
   double alpha, beta, ddelta, t1, t2;
   Interval dmm(0.0), TEMP1(0.0), TEMP2(0.0), band(0.0);

   dmm = pow(itv, n);
   alpha = ((__builtin_powi(itv.ub(),n)-__builtin_powi(itv.lb(),n))/itv.diam());

   TEMP1 = (dmm.lb()) - alpha * Interval(itv.lb());
   TEMP2 = (dmm.ub()) - alpha * Interval(itv.ub());

   if (TEMP1.ub() > TEMP2.ub()) {
    TEMP2 = Interval(alpha) / n;
    band = Interval(
      ((1 - n) * TEMP2 * (root(TEMP2, n - 1))).lb(),
      TEMP1.ub());
   } else {
    TEMP1 = Interval(alpha) / n;
    band = Interval(
      ((1 - n) * TEMP1 * (root(TEMP1, n - 1))).lb(),
      TEMP2.ub());
   }

   beta = band.mid();
   t1 = (beta - band).ub();
   t2 = (band - beta).ub();
   ddelta = (t1 > t2) ? t1 : t2;

   saxpy(alpha, Affine2Main<T>(), beta, ddelta, true, false, true, true);

  } else {
# 658 "/usr/local/include/ibex/ibex_Affine2.h_" 3
   Interval TEMP1, TEMP2;
   double alpha, beta, ddelta, t1, x0, xb0, xb1, fxb0, fxb1, c0, c1;

   x0 = 1.0 / ::sqrt(2.);
   xb0 = (0.5) * (itv.diam() * ( x0) + itv.lb() + itv.ub());
   xb1 = (0.5) * (itv.diam() * (-x0) + itv.lb() + itv.ub());
   fxb0 = __builtin_powi(xb0, n);
   fxb1 = __builtin_powi(xb1, n);
   c0 = (0.5) * (fxb0 + fxb1);
   c1 = x0 * fxb0 - x0 * fxb1;

   alpha = 2 * c1 / (itv.diam());
   beta = c0 - c1 * ((itv.lb() + itv.ub()) / (itv.diam()));





   ddelta = (abs(
     pow(Interval(itv.lb()), n)
     - (alpha * Interval(itv.lb()) + beta))).ub();
   t1 = (abs(
     pow(Interval(itv.ub()), n)
     - (alpha * Interval(itv.ub()) + beta))).ub();
   if (t1 > ddelta) ddelta= t1 ;

   TEMP2 = pow(Interval(alpha) / n, 1.0 / Interval(n - 1));
   if (!((TEMP2 & itv).is_empty())) {
    t1 = (abs(pow(TEMP2, n) - (alpha * TEMP2 + beta))).ub();
    if (t1 > ddelta) ddelta= t1 ;
   }
   if (!(((-TEMP2) & itv).is_empty())) {
    t1 = (abs(pow(-TEMP2, n) - (alpha * (-TEMP2) + beta))).ub();
    if (t1 > ddelta) ddelta= t1 ;
   }

   saxpy(alpha, Affine2Main<T>(), beta, ddelta, true, false, true, true);
  }

 }

 return *this;
}

template<class T>
inline Affine2Main<T> pow(const Affine2Main<T>& x, int n, const Interval itv) {
 if (n == 0)
  return Affine2Main<T>(1.0);
 else if (n == 1)
  return Affine2Main<T>(x);
 else if (n == 2)
  return sqr(x,itv);
 else if (n<0)
  return inv(Affine2Main<T>(x).power(-n,itv),pow(itv,-n));
 else
  return Affine2Main<T>(x).power(n,itv);
}


template<class T>
inline Affine2Main<T> pow(const Affine2Main<T>& x, double d, const Interval itv) {
 if ( ((int) (d)) == d) {
  return pow(x, (int) (d),itv);
 } else if (d<0) {
  return inv(pow(x,Interval(-d), itv),pow(itv,-d));
 } else {
  return pow(x, Interval(d),itv);
 }
}


template<class T>
inline Affine2Main<T> root(const Affine2Main<T>& x, int n, const Interval itv) {

 if (x.is_empty()) return Affine2Main<T>(Interval::EMPTY_SET);
 else if (n==0) return Affine2Main<T>(Interval::ONE);
 else if (n==1) return x;
 else if (n<0) return inv(root(x,-n,itv),root(itv,-n));
 else if (x.is_degenerated()) return Affine2Main<T>(pow(Interval(x.val(0)),1.0/n));
 else if (n % 2 == 0) return pow(x, Interval::ONE/n,itv);
 else if (0 <= itv.lb()) return pow(x, Interval::ONE/n,itv);
 else if (itv.ub() <= 0) return -pow(-x, Interval::ONE/n,-itv);
 else {




  return Affine2Main<T>( pow(x, Interval::ONE/n,itv)| (-pow(-x,Interval::ONE/n,-itv)));
 }

}



template<class T>
inline Affine2Main<T> sign(const Affine2Main<T>&, const Interval itv) {
 if (itv.lb() > 0) {
  return Affine2Main<T>(1.0);
 } else if (itv.ub() < 0) {
  return Affine2Main<T>(-1.0);
 } else {
  return Affine2Main<T>(Interval(-1.0, 1.0));
 }
}






template<>
inline Affine2Main<AF_No>& Affine2Main<AF_No>::linChebyshev(Affine2_expr num, const Interval itv);

template<>
inline Affine2Main<AF_No>& Affine2Main<AF_No>::power(int n, const Interval itv);
# 1049 "/usr/local/include/ibex/ibex_Affine2.h_" 3
}
# 600 "/usr/local/include/ibex/ibex_Affine2.h" 2 3


namespace ibex {


template<class T> const double Affine2Main<T>::AF_COMPAC_Tol = 1.e-6;
template<class T> const double Affine2Main<T>::AF_EM = __builtin_powi(2.0, -51);
template<class T> const double Affine2Main<T>::AF_EC = __builtin_powi(2.0, -55);
template<class T> const double Affine2Main<T>::AF_EE = 2.0;


template<class T>
inline void Affine2Main<T>::compact(){ compact(AF_COMPAC_Tol); }


template<class T>
inline Interval& Interval::operator&=(const Affine2Main<T>& x) {
 return (*this &= x.itv());
}

template<class T>
inline Interval& Interval::operator|=(const Affine2Main<T>& x) {
 return (*this |= x.itv());
}

template<class T>
inline Interval& Interval::operator=(const Affine2Main<T>& x) {
 return (*this = x.itv());
}

template<class T>
inline Interval operator&(const Affine2Main<T>& x1, const Affine2Main<T>& x2) {
 return ((x1.itv())&(x2.itv()));
}

template<class T>
inline Interval operator&(const Interval& x1, const Affine2Main<T>& x2) {
 return ((x1)&(x2.itv()));
}

template<class T>
inline Interval operator&(const Affine2Main<T>& x1, const Interval& x2) {
 return ((x1.itv())&(x2));
}

template<class T>
inline Interval operator|(const Affine2Main<T>& x1, const Affine2Main<T>& x2) {
 return ((x1.itv())|(x2.itv()));
}

template<class T>
inline Interval operator|(const Interval& x1, const Affine2Main<T>& x2) {
 return ((x1)|(x2.itv()));
}

template<class T>
inline Interval operator|(const Affine2Main<T>& x1, const Interval& x2) {
 return ((x1.itv())|(x2));
}

template<class T>
inline bool Affine2Main<T>::operator==(const Affine2Main<T>& x) const{
 return (this->itv() == x.itv());
}

template<class T>
inline bool Affine2Main<T>::operator==(const Interval& x) const{
 return (this->itv() == x);
}

template<class T>
inline bool Affine2Main<T>::operator!=(const Affine2Main<T>& x) const{
 return (this->itv() != x.itv());
}

template<class T>
inline bool Affine2Main<T>::operator!=(const Interval& x) const {
 return (this->itv() != x);
}

template<class T>
inline void Affine2Main<T>::set_empty(){
 *this = Interval::EMPTY_SET;
}

template<class T>
inline Affine2Main<T>& Affine2Main<T>::inflate(double radd){
 if (fabs(radd)>= filib::primitive::compose(0,0x7FF,0,0)) {
  *this = Interval::ALL_REALS;
 } else {
  saxpy(1.0, Affine2Main<T>(),0.0, radd, false, false, false, true);
 }
 return *this;
}

template<class T>
inline int Affine2Main<T>::size() const{
 return _n;
}


template<class T>
inline bool Affine2Main<T>::is_actif() const{

 return (_n>-1);
}

template<class T>
inline bool Affine2Main<T>::is_empty() const{
 return (_n==-1);
}

template<class T>
inline bool Affine2Main<T>::is_degenerated() const {
 return (itv().diam() < AF_EC);
}

template<class T>
inline bool Affine2Main<T>::is_unbounded() const{
 return ((-1>_n)&&(_n>-5));
}

template<class T>
inline Affine2Main<T>& Affine2Main<T>::operator+=(double d){
 return saxpy(1.0, Affine2Main<T>(), d, 0.0, false, false, true, false);
}

template<class T>
inline Affine2Main<T>& Affine2Main<T>::operator-=(double d){
 return saxpy(1.0, Affine2Main<T>(), (-d), 0.0, false, false, true, false);
}

template<class T>
inline Affine2Main<T>& Affine2Main<T>::operator*=(double d){
 return saxpy(d, Affine2Main<T>(), 0.0, 0.0, true, false, false, false);
}

template<class T>
inline Affine2Main<T>& Affine2Main<T>::operator/=(double d) {
 return *this *= (1.0 / Interval(d)) ;
}

template<class T>
inline Affine2Main<T>& Affine2Main<T>::operator+=(const Interval& x){
 return saxpy(1.0, Affine2Main<T>(), x.mid(), x.rad(), false, false, true, true);
}

template<class T>
inline Affine2Main<T>& Affine2Main<T>::operator-=(const Interval& x){
 return *this += (-x);
}

template<class T>
inline Affine2Main<T>& Affine2Main<T>::operator/=(const Interval& x){
 return *this *= (1.0/x) ;
}

template<class T>
inline Affine2Main<T>& Affine2Main<T>::operator+=(const Affine2Main<T>& x){
 return saxpy(1.0, x, 0.0, 0.0, false, true, false, false);
}

template<class T>
inline Affine2Main<T>& Affine2Main<T>::operator-=(const Affine2Main<T>& x){
 return *this += (-Affine2Main<T>(x));
}

template<class T>
inline Affine2Main<T>& Affine2Main<T>::operator/=(const Affine2Main<T>& x){
 return *this *= (Affine2Main<T>(x).linChebyshev(AF_INV, x.itv()));
}

template<class T>
inline Affine2Main<T> operator+(const Affine2Main<T>& x1, const Affine2Main<T>& x2){
 return Affine2Main<T>(x1) += x2;
}

template<class T>
inline Affine2Main<T> operator+(const Affine2Main<T>& x, double d){
 return Affine2Main<T>(x) += d;
}

template<class T>
inline Affine2Main<T> operator+(double d, const Affine2Main<T>& x){
 return Affine2Main<T>(x) += d;
}

template<class T>
inline Affine2Main<T> operator+(const Affine2Main<T>& x1, const Interval& x2){
 return Affine2Main<T>(x1) += x2;
}

template<class T>
inline Affine2Main<T> operator+(const Interval& x1, const Affine2Main<T>& x2){
 return Affine2Main<T>(x2) += x1;
}

template<class T>
inline Affine2Main<T> operator-(const Affine2Main<T>& x1, const Affine2Main<T>& x2){
 return Affine2Main<T>(x1) += (-x2);
}

template<class T>
inline Affine2Main<T> operator-(const Affine2Main<T>& x, double d){
 return Affine2Main<T>(x) -= d;
}

template<class T>
inline Affine2Main<T> operator-(double d, const Affine2Main<T>& x){
 Affine2Main<T> res = (-x);
 return res += d;
}

template<class T>
inline Affine2Main<T> operator-(const Affine2Main<T>& x1, const Interval& x2) {
 return Affine2Main<T>(x1) -= x2;
}

template<class T>
inline Affine2Main<T> operator-(const Interval& x1, const Affine2Main<T>& x2) {
 Affine2Main<T> res = (- x2);
 return res += x1;
}

template<class T>
inline Affine2Main<T> operator*(const Affine2Main<T>& x1, const Affine2Main<T>& x2) {
 return Affine2Main<T>(x1) *= x2;
}

template<class T>
inline Affine2Main<T> operator*(const Affine2Main<T>& x, double d){
 return Affine2Main<T>(x) *= d;
}

template<class T>
inline Affine2Main<T> operator*(double d, const Affine2Main<T>& x){
 return Affine2Main<T>(x) *= d;
}

template<class T>
inline Affine2Main<T> operator*(const Affine2Main<T>& x1, const Interval& x2){
 return Affine2Main<T>(x1) *= x2;
}

template<class T>
inline Affine2Main<T> operator*(const Interval& x1, const Affine2Main<T>& x2){
 return Affine2Main<T>(x2) *= x1;
}

template<class T>
inline Affine2Main<T> operator/(const Affine2Main<T>& x1, const Affine2Main<T>& x2){
 return Affine2Main<T>(x1) /= x2;
}

template<class T>
inline Affine2Main<T> operator/(const Affine2Main<T>& x, double d){
 return Affine2Main<T>(x) /= d;
}

template<class T>
inline Affine2Main<T> operator/(double d, const Affine2Main<T>& x){
 return Affine2Main<T>(d) *= (Affine2Main<T>(x).linChebyshev(Affine2Main<T>::AF_INV,x.itv()));
}

template<class T>
inline Affine2Main<T> operator/(const Affine2Main<T>& x1, const Interval& x2){
 return Affine2Main<T>(x1) /= x2;
}

template<class T>
inline Affine2Main<T> operator/(const Interval& x1, const Affine2Main<T>& x2){
 return Affine2Main<T>(x1) *= (Affine2Main<T>(x2).linChebyshev(Affine2Main<T>::AF_INV,x2.itv()));
}

template<class T>
inline double distance(const Affine2Main<T> &x1, const Affine2Main<T> &x2){
 return distance(x1.itv(), x2.itv());
}

template<class T>
inline double distance(const Interval &x1, const Affine2Main<T> &x2){
 return distance(x1, x2.itv());
}

template<class T>
inline double distance(const Affine2Main<T> &x1, const Interval &x2){
 return distance(x1.itv(), x2);
}

template<class T>
inline Affine2Main<T> inv(const Affine2Main<T>& x){
 return inv(x,x.itv());
}

template<class T>
inline Affine2Main<T> inv(const Affine2Main<T>& x, const Interval itv){
 return Affine2Main<T>(x).linChebyshev(Affine2Main<T>::AF_INV, itv);
}

template<class T>
inline Affine2Main<T> sqr(const Affine2Main<T>& x){
 return Affine2Main<T>(x).sqr(x.itv());
}
template<class T>
inline Affine2Main<T> sqr(const Affine2Main<T>& x, const Interval itv){
 return Affine2Main<T>(x).sqr(itv);
}

template<class T>
inline Affine2Main<T> sqrt(const Affine2Main<T>& x){
 return sqrt(x,x.itv());
}

template<class T>
inline Affine2Main<T> sqrt(const Affine2Main<T>& x, const Interval itv){
 return Affine2Main<T>(x).linChebyshev(Affine2Main<T>::AF_SQRT,itv);
}

template<class T>
inline Affine2Main<T> exp(const Affine2Main<T>& x){
 return exp(x,x.itv());
}

template<class T>
inline Affine2Main<T> exp(const Affine2Main<T>& x, const Interval itv){
 return Affine2Main<T>(x).linChebyshev(Affine2Main<T>::AF_EXP,itv);
}

template<class T>
inline Affine2Main<T> log(const Affine2Main<T>& x){
 return log(x,x.itv());
}

template<class T>
inline Affine2Main<T> log(const Affine2Main<T>& x, const Interval itv){
 return Affine2Main<T>(x).linChebyshev(Affine2Main<T>::AF_LOG,itv);
}

template<class T>
inline Affine2Main<T> pow(const Affine2Main<T>& x, int n) {
 return pow(x,n,x.itv());
}

template<class T>
inline Affine2Main<T> pow(const Affine2Main<T>& x, double d){
 return pow(x,d,x.itv());
}

template<class T>
inline Affine2Main<T> pow(const Affine2Main<T> &x, const Interval &y){

 return pow(x,y,x.itv());
}

template<class T>
inline Affine2Main<T> pow(const Affine2Main<T> &x, const Interval &y, const Interval itvx){

 return (y * Affine2Main<T>(x).linChebyshev(Affine2Main<T>::AF_LOG, itvx)).linChebyshev(Affine2Main<T>::AF_EXP, (y*log(itvx)));
}

template<class T>
inline Affine2Main<T> pow(const Affine2Main<T> &x, const Affine2Main<T> &y){
 return pow(x, y.itv());
}

template<class T>
inline Affine2Main<T> root(const Affine2Main<T>& x, int n) {
 return root(x,n,x.itv());
}

template<class T>
inline Affine2Main<T> cos(const Affine2Main<T>& x){
 return cos(x,x.itv());
}

template<class T>
inline Affine2Main<T> cos(const Affine2Main<T>& x, const Interval itv){
 return Affine2Main<T>(x).linChebyshev(Affine2Main<T>::AF_COS, itv);
}

template<class T>
inline Affine2Main<T> sin(const Affine2Main<T>& x){
 return sin(x,x.itv());
}

template<class T>
inline Affine2Main<T> sin(const Affine2Main<T>& x, const Interval itv){
 return Affine2Main<T>(x).linChebyshev(Affine2Main<T>::AF_SIN,itv);
}

template<class T>
inline Affine2Main<T> tan(const Affine2Main<T>& x){
 return tan(x,x.itv());
}

template<class T>
inline Affine2Main<T> tan(const Affine2Main<T>& x, const Interval itv){
 return Affine2Main<T>(x).linChebyshev(Affine2Main<T>::AF_TAN,itv);
}

template<class T>
inline Affine2Main<T> acos(const Affine2Main<T>& x){
 return acos(x,x.itv());
}

template<class T>
inline Affine2Main<T> acos(const Affine2Main<T>& x, const Interval itv){
 return Affine2Main<T>(x).linChebyshev(Affine2Main<T>::AF_ACOS, itv);
}

template<class T>
inline Affine2Main<T> asin(const Affine2Main<T>& x){
 return asin(x,x.itv());
}

template<class T>
inline Affine2Main<T> asin(const Affine2Main<T>& x, const Interval itv){
 return Affine2Main<T>(x).linChebyshev(Affine2Main<T>::AF_ASIN, itv);
}

template<class T>
inline Affine2Main<T> atan(const Affine2Main<T>& x){
 return atan(x,x.itv());
}

template<class T>
inline Affine2Main<T> atan(const Affine2Main<T>& x, const Interval itv){
 return Affine2Main<T>(x).linChebyshev(Affine2Main<T>::AF_ATAN, itv);
}

template<class T>
inline Affine2Main<T> cosh(const Affine2Main<T>& x){
 return cosh(x,x.itv());
}

template<class T>
inline Affine2Main<T> cosh(const Affine2Main<T>& x, const Interval itv){
 return Affine2Main<T>(x).linChebyshev(Affine2Main<T>::AF_COSH, itv);
}

template<class T>
inline Affine2Main<T> sinh(const Affine2Main<T>& x){
 return sinh(x,x.itv());
}

template<class T>
inline Affine2Main<T> sinh(const Affine2Main<T>& x, const Interval itv){
 return Affine2Main<T>(x).linChebyshev(Affine2Main<T>::AF_SINH, itv);
}

template<class T>
inline Affine2Main<T> tanh(const Affine2Main<T>& x){
 return tanh(x,x.itv());
}

template<class T>
inline Affine2Main<T> tanh(const Affine2Main<T>& x, const Interval itv){
 return Affine2Main<T>(x).linChebyshev(Affine2Main<T>::AF_TANH, itv);
}

template<class T>
inline Affine2Main<T> abs(const Affine2Main<T> &x){
 return abs(x,x.itv());
}

template<class T>
inline Affine2Main<T> abs(const Affine2Main<T> &x, const Interval itv){
 return Affine2Main<T>(x).linChebyshev(Affine2Main<T>::AF_ABS, itv);
}

template<class T>
inline Interval max(const Affine2Main<T>& x, const Affine2Main<T>& y) {
 return max(x.itv(), y.itv());
}

template<class T>
inline Interval max(const Interval& x, const Affine2Main<T>& y) {
 return max(x, y.itv());
}

template<class T>
inline Interval max(const Affine2Main<T>& x, const Interval& y) {
 return max(x.itv(), y);
}

template<class T>
inline Interval min(const Affine2Main<T>& x, const Affine2Main<T>& y) {
 return min(x.itv(), y.itv());
}

template<class T>
inline Interval min(const Interval& x, const Affine2Main<T>& y) {
 return min(x, y.itv());
}

template<class T>
inline Interval min(const Affine2Main<T>& x, const Interval& y) {
 return min(x.itv(), y);
}

template<class T>
inline Affine2Main<T> integer(const Affine2Main<T>& x){
 Interval tmp= x.itv();
 if ((tmp.lb()==(int) tmp.lb())&&(tmp.ub()==(int) tmp.ub())) {
  return Affine2Main<T>(x);
 } else {
  return Affine2Main<T>(integer(tmp));
 }
}

template<class T>
inline Affine2Main<T> sign(const Affine2Main<T>& x) {
 return sign(x, x.itv());
}


template<class T>
inline Affine2Main<T> chi(const Affine2Main<T>& a,const Affine2Main<T>& b,const Affine2Main<T>& c) {
 return chi(a.itv(),b,c);
}
template<class T>
inline Affine2Main<T> chi(const Interval& a,const Interval& b,const Affine2Main<T>& c) {
 return chi(a,Affine2Main<T>(b),c);
}
template<class T>
inline Affine2Main<T> chi(const Interval& a,const Affine2Main<T>& b,const Interval& c) {
 return chi(a,b,Affine2Main<T>(c));
}
template<class T>
inline Affine2Main<T> chi(const Affine2Main<T>& a,const Interval& b,const Affine2Main<T>& c) {
 return chi(a.itv(),Affine2Main<T>(b),c);
}
template<class T>
inline Affine2Main<T> chi(const Affine2Main<T>& a,const Affine2Main<T>& b,const Interval& c){
 return chi(a.itv(),b,Affine2Main<T>(c));
}
template<class T>
inline Affine2Main<T> chi(const Interval& a,const Affine2Main<T>& b,const Affine2Main<T>& c){
 if (a.ub()<=0) {
  return Affine2Main<T>(b);
 } else if (a.lb()>0) {
  return Affine2Main<T>(c);
 } else {
  return Affine2Main<T>(b|c);
 }
}


}
# 3 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Affine2Domain.h" 1 3
# 16 "/usr/local/include/ibex/ibex_Affine2Domain.h" 3
# 1 "/usr/local/include/ibex/ibex_Affine2MatrixArray.h" 1 3
# 15 "/usr/local/include/ibex/ibex_Affine2MatrixArray.h" 3
# 1 "/usr/local/include/ibex/ibex_IntervalMatrixArray.h" 1 3
# 16 "/usr/local/include/ibex/ibex_IntervalMatrixArray.h" 3
# 1 "/usr/local/include/ibex/ibex_IntervalMatrix.h" 1 3
# 15 "/usr/local/include/ibex/ibex_IntervalMatrix.h" 3
# 1 "/usr/local/include/ibex/ibex_IntervalVector.h" 1 3
# 15 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 44 "/usr/include/c++/7/cassert" 2 3
# 16 "/usr/local/include/ibex/ibex_IntervalVector.h" 2 3



# 1 "/usr/local/include/ibex/ibex_InvalidIntervalVectorOp.h" 1 3
# 17 "/usr/local/include/ibex/ibex_InvalidIntervalVectorOp.h" 3
namespace ibex {







class InvalidIntervalVectorOp : public Exception {
public:


 InvalidIntervalVectorOp(const std::string& msg1) : msg(msg1) { }



 std::string message() { return msg; }

private:
 std::string msg;
};


}
# 20 "/usr/local/include/ibex/ibex_IntervalVector.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Vector.h" 1 3
# 14 "/usr/local/include/ibex/ibex_Vector.h" 3
# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 44 "/usr/include/c++/7/cassert" 2 3
# 15 "/usr/local/include/ibex/ibex_Vector.h" 2 3


namespace ibex {

class Matrix;
class ExprConstant;







class Vector {
public:






 Vector(int n);
# 45 "/usr/local/include/ibex/ibex_Vector.h" 3
 Vector(int n, double x);




 Vector(const Vector& x);







 Vector(int n, double x[]);




 virtual ~Vector();







 const double& operator[](int i) const;







 double& operator[](int i);







 void resize(int n2);






 Vector subvector(int start_index, int end_index) const;







 void put(int start_index, const Vector& subvec);






 Vector& operator=(const Vector& x);




 bool operator==(const Vector& x) const;




 bool operator!=(const Vector& x) const;




 int size() const;




 double max() const;




 double min() const;




 double norm() const;




 Vector& operator+=(const Vector& x2);




 Vector& operator-=(const Vector& x2);




 Vector& operator*=(double d);




 static Vector zeros(int n);




 static Vector ones(int n);




 operator const ExprConstant&() const;

private:
 friend class Matrix;

 Vector() : n(0), vec(__null) { }

 int n;
 double *vec;
};







Vector operator-(const Vector& x);




Vector operator+(const Vector& x1, const Vector& x2);




Vector operator-(const Vector& x1, const Vector& x2);




double operator*(const Vector& x1, const Vector& x2);




Matrix outer_product(const Vector& x1, const Vector& x2);







Vector hadamard_product(const Vector& x, const Vector& y);




Vector operator*(double d, const Vector& x);




Vector abs(const Vector& x);




std::ostream& operator<<(std::ostream& os, const Vector& x);







namespace {





inline bool is_empty(const Vector& v) { return false; }
# 255 "/usr/local/include/ibex/ibex_Vector.h" 3
inline void set_empty(Vector& v) { }
# 264 "/usr/local/include/ibex/ibex_Vector.h" 3
}

}

# 1 "/usr/local/include/ibex/ibex_LinearArith.h_" 1 3
# 15 "/usr/local/include/ibex/ibex_LinearArith.h_" 3
namespace ibex {

class Vector;
class Matrix;
class Interval;
class IntervalVector;
class IntervalMatrix;
template<class T> class Affine2Main;
template<class T> class Affine2MainVector;
template<class T> class Affine2MainMatrix;



double abs(double x) ;
Interval abs(const Interval& x);
Vector abs(const Vector& v);
IntervalVector abs(const IntervalVector& v);
Matrix abs(const Matrix& m);
IntervalMatrix abs(const IntervalMatrix& m);
template<class T> inline Affine2Main<T> abs(const Affine2Main<T>& x) ;
template<class T> inline Affine2MainVector<T> abs(const Affine2MainVector<T>& v);
template<class T> inline Affine2MainMatrix<T> abs(const Affine2MainMatrix<T>& m);


namespace {



bool is_empty(double x) ;
bool is_empty(const Interval& x) ;
bool is_empty(const Vector& v);
bool is_empty(const IntervalVector& v);
bool is_empty(const Matrix& m);
bool is_empty(const IntervalMatrix& m);
template<class T> inline bool is_empty(const Affine2Main<T>& x);
template<class T> inline bool is_empty(const Affine2MainVector<T>& v);
template<class T> inline bool is_empty(const Affine2MainMatrix<T>& m);



void set_empty(double x) ;
void set_empty(Interval& x);
void set_empty(Vector& v);
void set_empty(IntervalVector& v);
void set_empty(Matrix& m);
void set_empty(IntervalMatrix& m);
template<class T> inline void set_empty(Affine2Main<T>& x) ;
template<class T> inline void set_empty(Affine2MainVector<T>& v);
template<class T> inline void set_empty(Affine2MainMatrix<T>& m);



template<typename V>
inline V minusV(const V& v) {
 const int n=v.size();

 V y(n);

 if (is_empty(v)) { set_empty(y); return y; }

 for (int i=0; i<n; i++) {
  y[i]= (-v[i]);
 }
 return y;
}

template<typename V1, typename V2>
inline V1& set_addV(V1& v1, const V2& v2) {
 (static_cast <bool> (v1.size()==v2.size()) ? void (0) : __assert_fail ("v1.size()==v2.size()", "/usr/local/include/ibex/ibex_LinearArith.h_", 83, __extension__ __PRETTY_FUNCTION__));

 if (is_empty(v1) || is_empty(v2)) { set_empty(v1); return v1; }

 for (int i=0; i<v1.size(); i++)
  v1[i]+=v2[i];

 return v1;
}

template<typename V1, typename V2>
inline V1& set_subV(V1& v1, const V2& v2) {
 (static_cast <bool> (v1.size()==v2.size()) ? void (0) : __assert_fail ("v1.size()==v2.size()", "/usr/local/include/ibex/ibex_LinearArith.h_", 95, __extension__ __PRETTY_FUNCTION__));

 if (is_empty(v1) || is_empty(v2)) { set_empty(v1); return v1; }

 for (int i=0; i<v1.size(); i++)
  v1[i]-=v2[i];

 return v1;
}

template<typename M>
inline M minusM(const M& m) {
 M res(m.nb_rows(),m.nb_cols());

 if (is_empty(m)) { set_empty(res); return res; }

 for (int i=0; i<m.nb_rows(); i++)
  res[i]= (-m[i]);

 return res;
}

template<typename M1, typename M2>
inline M1& set_addM(M1& m1, const M2& m2) {
 (static_cast <bool> (m1.nb_rows()==m2.nb_rows()) ? void (0) : __assert_fail ("m1.nb_rows()==m2.nb_rows()", "/usr/local/include/ibex/ibex_LinearArith.h_", 119, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (m1.nb_cols()==m2.nb_cols()) ? void (0) : __assert_fail ("m1.nb_cols()==m2.nb_cols()", "/usr/local/include/ibex/ibex_LinearArith.h_", 120, __extension__ __PRETTY_FUNCTION__));

 if (is_empty(m1) || is_empty(m2)) { set_empty(m1); return m1; }

 for (int i=0; i<m1.nb_rows(); i++)
  m1[i]+=m2[i];

 return m1;
}

template<typename M1, typename M2>
inline M1& set_subM(M1& m1, const M2& m2) {
 (static_cast <bool> (m1.nb_rows()==m2.nb_rows()) ? void (0) : __assert_fail ("m1.nb_rows()==m2.nb_rows()", "/usr/local/include/ibex/ibex_LinearArith.h_", 132, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (m1.nb_cols()==m2.nb_cols()) ? void (0) : __assert_fail ("m1.nb_cols()==m2.nb_cols()", "/usr/local/include/ibex/ibex_LinearArith.h_", 133, __extension__ __PRETTY_FUNCTION__));

 if (is_empty(m1) || is_empty(m2)) { set_empty(m1); return m1; }

 for (int i=0; i<m1.nb_rows(); i++)
  m1[i]-=m2[i];

 return m1;
}

template<typename S, class V>
inline V& set_mulSV(const S& x, V& v) {

 if (is_empty(x) || is_empty(v)) { set_empty(v); return v; }

 for (int i=0; i<v.size(); i++)
  v[i]*=x;
 return v;
}

template<typename S, class M>
inline M& set_mulSM(const S& x, M& m) {

 if (is_empty(x) || is_empty(m)) { set_empty(m); return m; }

 for (int i=0; i<m.nb_rows(); i++)
  m[i]*=x;
 return m;
}

template<class Vin1, class Vin2, class S>
inline S mulVV(const Vin1& v1, const Vin2& v2) {
 (static_cast <bool> (v1.size()==v2.size()) ? void (0) : __assert_fail ("v1.size()==v2.size()", "/usr/local/include/ibex/ibex_LinearArith.h_", 165, __extension__ __PRETTY_FUNCTION__));

 const int n=v1.size();
 S y=0;

 if (is_empty(v1) || is_empty(v2)) {
  set_empty(y);
  return y;
 }

 for (int i=0; i<n; i++) {
  y+=v1[i]*v2[i];
 }
 return y;
}

template<class Vin1, class Vin2, class M>
inline M outer_prod(const Vin1& v1, const Vin2& v2) {

 M y(v1.size(),v2.size());

 if (is_empty(v1) || is_empty(v2)) {
  set_empty(y);
  return y;
 }

 for (int i=0; i<v1.size(); i++) {
  for (int j=0; j<v2.size(); j++) {
   y[i][j]=v1[i]*v2[j];
  }
 }
 return y;
}

template<class Vin1, class Vin2, class Vout>
inline Vout hadamard_prod(const Vin1& v1, const Vin2& v2) {

 (static_cast <bool> (v1.size()==v2.size()) ? void (0) : __assert_fail ("v1.size()==v2.size()", "/usr/local/include/ibex/ibex_LinearArith.h_", 202, __extension__ __PRETTY_FUNCTION__));
 Vout y(v1.size());

 if (is_empty(v1) || is_empty(v2)) {
  set_empty(y);
  return y;
 }

 for (int i=0; i<v1.size(); i++) {
   y[i]=v1[i]*v2[i];
 }
 return y;
}

template<class M, class Vin, class Vout>
inline Vout mulMV(const M& m, const Vin& v) {
 (static_cast <bool> (m.nb_cols()==v.size()) ? void (0) : __assert_fail ("m.nb_cols()==v.size()", "/usr/local/include/ibex/ibex_LinearArith.h_", 218, __extension__ __PRETTY_FUNCTION__));

 if (is_empty(m) || is_empty(v)) {
  Vout res(m.nb_rows());
  set_empty(res);
  return res;
 }

 Vout y(m.nb_rows());

 for (int i=0; i<m.nb_rows(); i++)
  y[i]=m[i]*v;

 return y;
}

template<class Vin, class M, class Vout>
inline Vout mulVM(const Vin& v, const M& m) {
 (static_cast <bool> (m.nb_rows()==v.size()) ? void (0) : __assert_fail ("m.nb_rows()==v.size()", "/usr/local/include/ibex/ibex_LinearArith.h_", 236, __extension__ __PRETTY_FUNCTION__));

 if (is_empty(m) || is_empty(v)) {
  Vout res(m.nb_cols());
  set_empty(res);
  return res;
 }

 Vout y(m.nb_cols());

 for (int j=0; j<m.nb_cols(); j++) {
  y[j]=0;
  for (int i=0; i<m.nb_rows(); i++) {
   y[j]+=m[i][j]*v[i];
  }
 }

 return y;
}

template<class Min1, class Min2, class Mout>
inline Mout mulMM(const Min1& m1, const Min2& m2) {
 (static_cast <bool> (m1.nb_cols()==m2.nb_rows()) ? void (0) : __assert_fail ("m1.nb_cols()==m2.nb_rows()", "/usr/local/include/ibex/ibex_LinearArith.h_", 258, __extension__ __PRETTY_FUNCTION__));

 Mout m3(m1.nb_rows(),m2.nb_cols());

 if (is_empty(m1) || is_empty(m2)) { set_empty(m3); return m3; }

 for (int i=0; i<m1.nb_rows(); i++) {
  for (int j=0; j<m2.nb_cols(); j++) {
   m3[i][j]=0;
   for (int k=0; k<m1.nb_cols(); k++)
    m3[i][j]+=m1[i][k]*m2[k][j];
  }
 }
 return m3;
}

template<typename V>
inline V absV(const V& v) {
 V res(v.size());

 if (is_empty(v)) { set_empty(res); return res; }

 for (int i=0; i<v.size(); i++)
  res[i]=abs(v[i]);

 return res;
}

template<typename M>
inline M absM(const M& m) {
 M res(m.nb_rows(),m.nb_cols());

 if (is_empty(m)) { set_empty(res); return res; }

 for (int i=0; i<m.nb_rows(); i++)
  res[i]=abs(m[i]);

 return res;
}

}



}
# 269 "/usr/local/include/ibex/ibex_Vector.h" 2 3

namespace ibex {



inline const double& Vector::operator[](int i) const {
 (static_cast <bool> (i>=0 && i<n) ? void (0) : __assert_fail ("i>=0 && i<n", "/usr/local/include/ibex/ibex_Vector.h", 275, __extension__ __PRETTY_FUNCTION__));
 return vec[i];
}

inline double& Vector::operator[](int i) {
 (static_cast <bool> (i>=0 && i<n) ? void (0) : __assert_fail ("i>=0 && i<n", "/usr/local/include/ibex/ibex_Vector.h", 280, __extension__ __PRETTY_FUNCTION__));
 return vec[i];
}


inline bool Vector::operator!=(const Vector& x) const {
 return !(*this==x);
}

inline int Vector::size() const {
 return n;
}

inline Vector Vector::zeros(int n) {
 return Vector(n,0.0);
}

inline Vector Vector::ones(int n) {
 return Vector(n,1.0);
}

inline Vector operator-(const Vector& x) {
 return minusV(x);
}

inline Vector& Vector::operator+=(const Vector& x) {
 return set_addV<Vector,Vector>(*this,x);
}

inline Vector& Vector::operator-=(const Vector& x) {
 return set_subV<Vector,Vector>(*this,x);
}

inline Vector& Vector::operator*=(double x) {
 return set_mulSV<double,Vector>(x,*this);
}

inline Vector operator+(const Vector& m1, const Vector& m2) {
 return Vector(m1)+=m2;
}

inline Vector operator-(const Vector& m1, const Vector& m2) {
 return Vector(m1)-=m2;
}

inline Vector operator*(double x, const Vector& v) {
 return Vector(v)*=x;
}

inline Vector hadamard_product(const Vector& v1, const Vector& v2) {
 return hadamard_prod<Vector,Vector,Vector>(v1,v2);
}

inline Vector abs(const Vector& v) {
 return absV(v);
}

inline double operator*(const Vector& v1, const Vector& v2) {
 return mulVV<Vector,Vector,double>(v1,v2);
}



}
# 21 "/usr/local/include/ibex/ibex_IntervalVector.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Matrix.h" 1 3
# 18 "/usr/local/include/ibex/ibex_Matrix.h" 3
namespace ibex {

class MatrixArray;






class Matrix {

public:



 Matrix(int nb_rows, int nb_cols);





 Matrix(int nb_rows, int nb_cols, double x);




 Matrix(const Matrix& m);
# 58 "/usr/local/include/ibex/ibex_Matrix.h" 3
 Matrix(int m, int n, double x[]);




 ~Matrix();




 Matrix& operator=(const Matrix& x);





 bool operator==(const Matrix& m) const;




 bool operator!=(const Matrix& m) const;




 void resize(int nb_rows, int nb_cols);




 int nb_cols() const;




 int nb_rows() const;






 Vector& operator[](int i);






 const Vector& operator[](int i) const;




 Matrix submatrix(int row_start_index, int row_end_index, int col_start_index, int col_end_index) const;




 Matrix transpose() const;






 Vector& row(int i);






 const Vector& row(int i) const;




 Vector col(int i) const;




 void set_row(int row, const Vector& v);




 void set_col(int col, const Vector& v);




 void put(int row_start_index, int col_start_index, const Matrix& M);





 void put(int row_start_index, int col_start_index, const Vector& v, bool row_vec);




    Matrix& operator+=(const Matrix& m);




    Matrix& operator-=(const Matrix& m);




    Matrix& operator*=(double a);




    Matrix& operator*=(const Matrix& m);




    static Matrix eye(int n);




    static Matrix zeros(int n);




    static Matrix zeros(int m, int n);




    static Matrix ones(int n);




    static Matrix ones(int m, int n);




    operator const ExprConstant&() const;

private:
 friend class MatrixArray;

 Matrix();

 int _nb_rows;
 int _nb_cols;
 Vector* M;
};







Matrix operator-(const Matrix& m);




Matrix operator+(const Matrix& m1, const Matrix& m2);




Matrix operator-(const Matrix& m1, const Matrix& m2);




Matrix operator*(double d, const Matrix& m);




Matrix operator*(const Matrix& m1, const Matrix& m2);




Vector operator*(const Matrix& m, const Vector& x);




Vector operator*(const Vector& x, const Matrix& m);




Matrix abs(const Matrix& x);




std::ostream& operator<<(std::ostream& os, const Matrix&);






namespace {







inline bool is_empty(const Matrix& m) { return false; }
# 293 "/usr/local/include/ibex/ibex_Matrix.h" 3
inline void set_empty(Matrix& m) { }





}

}



namespace ibex {


inline bool Matrix::operator!=(const Matrix& m) const {
 return !(*this==m);
}

inline int Matrix::nb_cols() const {
 return _nb_cols;
}

inline int Matrix::nb_rows() const {
 return _nb_rows;
}

inline Vector& Matrix::operator[](int i) {
 (static_cast <bool> (i>=0 && i<nb_rows()) ? void (0) : __assert_fail ("i>=0 && i<nb_rows()", "/usr/local/include/ibex/ibex_Matrix.h", 321, __extension__ __PRETTY_FUNCTION__));
 return M[i];
}

inline const Vector& Matrix::operator[](int i) const {
 (static_cast <bool> (i>=0 && i<nb_rows()) ? void (0) : __assert_fail ("i>=0 && i<nb_rows()", "/usr/local/include/ibex/ibex_Matrix.h", 326, __extension__ __PRETTY_FUNCTION__));
 return M[i];
}

inline Vector& Matrix::row(int i) {
 (static_cast <bool> (i>=0 && i<nb_rows()) ? void (0) : __assert_fail ("i>=0 && i<nb_rows()", "/usr/local/include/ibex/ibex_Matrix.h", 331, __extension__ __PRETTY_FUNCTION__));
 return M[i];
}

inline const Vector& Matrix::row(int i) const {
 (static_cast <bool> (i>=0 && i<nb_rows()) ? void (0) : __assert_fail ("i>=0 && i<nb_rows()", "/usr/local/include/ibex/ibex_Matrix.h", 336, __extension__ __PRETTY_FUNCTION__));
 return M[i];
}

inline void Matrix::set_row(int row1, const Vector& v1) {
 (static_cast <bool> (row1>=0 && row1<nb_rows()) ? void (0) : __assert_fail ("row1>=0 && row1<nb_rows()", "/usr/local/include/ibex/ibex_Matrix.h", 341, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (nb_cols()==v1.size()) ? void (0) : __assert_fail ("nb_cols()==v1.size()", "/usr/local/include/ibex/ibex_Matrix.h", 342, __extension__ __PRETTY_FUNCTION__));
 M[row1]=v1;
}

inline Matrix Matrix::eye(int n) {
 Matrix M(n,n);
 for (int i=0; i<n; i++)
  for (int j=0; j<n; j++)
   M[i][j]=i==j ? 1.0 : 0.0;
 return M;
}

inline Matrix Matrix::zeros(int n) {
 return Matrix(n,n,0.0);
}

inline Matrix Matrix::zeros(int m, int n) {
 return Matrix(m,n,0.0);
}

inline Matrix Matrix::ones(int n){
 return Matrix(n,n,1.0);
}

inline Matrix Matrix::ones(int m, int n) {
 return Matrix(m,n,1.0);
}

inline Matrix outer_product(const Vector& v1, const Vector& v2) {
 return outer_prod<Vector,Vector,Matrix>(v1,v2);
}

inline Matrix& Matrix::operator+=(const Matrix& m) {
 return set_addM<Matrix,Matrix>(*this,m);
}

inline Matrix& Matrix::operator-=(const Matrix& m) {
 return set_subM<Matrix,Matrix>(*this,m);
}

inline Matrix& Matrix::operator*=(double x) {
 return set_mulSM<double,Matrix>(x,*this);
}

inline Matrix& Matrix::operator*=(const Matrix& m) {
 return *this=(*this*m);
}

inline Matrix operator+(const Matrix& m1, const Matrix& m2) {
 return Matrix(m1)+=m2;
}

inline Matrix operator-(const Matrix& m) {
 return minusM(m);
}

inline Matrix operator-(const Matrix& m1, const Matrix& m2) {
 return Matrix(m1)-=m2;
}

inline Matrix operator*(double x, const Matrix& m) {
 return Matrix(m)*=x;
}

inline Matrix operator*(const Matrix& m1, const Matrix& m2) {
 return mulMM<Matrix,Matrix,Matrix>(m1,m2);
}

inline Vector operator*(const Matrix& m, const Vector& v) {
 return mulMV<Matrix,Vector,Vector>(m,v);
}

inline Vector operator*(const Vector& v, const Matrix& m) {
 return mulVM<Vector,Matrix,Vector>(v,m);
}

inline Matrix abs(const Matrix& m) {
 return absM(m);
}

}
# 22 "/usr/local/include/ibex/ibex_IntervalVector.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Array.h" 1 3
# 16 "/usr/local/include/ibex/ibex_Array.h" 3
# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 44 "/usr/include/c++/7/cassert" 2 3
# 17 "/usr/local/include/ibex/ibex_Array.h" 2 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 18 "/usr/local/include/ibex/ibex_Array.h" 2 3

namespace ibex {
# 30 "/usr/local/include/ibex/ibex_Array.h" 3
template<class T>
class Array {
public:





 Array();






 Array(int n);




 void resize(int n);




 void add(T& obj);




 void set_ref(int i, T& obj);




 Array(T** array, int n);






 Array(const std::vector<T*>&);




 Array(T& x);




 Array(T& x1, T& x2);




 Array(T& x1, T& x2, T& x3);





 Array(T& x1, T& x2, T& x3, T& x4);





 Array(T& x1, T& x2, T& x3, T& x4, T& x5);





 Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6);




 Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7);




 Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8);




 Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9);




 Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10);




 Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11);




 Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12);




 Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12, T& x13);




 Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12, T& x13, T& x14);




 Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12, T& x13, T& x14, T& x15);




 Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12, T& x13, T& x14, T& x15, T& x16);




 Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12, T& x13, T& x14, T& x15, T& x16, T& x17);




 Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12, T& x13, T& x14, T& x15, T& x16, T& x17, T& x18);




 Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12, T& x13, T& x14, T& x15, T& x16, T& x17, T& x18, T& x19);




 Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12, T& x13, T& x14, T& x15, T& x16, T& x17, T& x18, T& x19, T& x20);





 Array(const Array&);




 ~Array();




 bool is_empty() const;




 int size() const;




 T& operator[](int i);





 T& operator[](int i) const;





 void clear();

protected:
 int _nb;


 T** array;
private:
 T& operator=(const Array<T>&);
};




template<class T>
Array<T>::Array() : _nb(0), array(__null) {

}

template<class T>
Array<T>::Array(int n) : _nb(n), array(new T*[n]) {
 (static_cast <bool> (n>=0) ? void (0) : __assert_fail ("n>=0", "/usr/local/include/ibex/ibex_Array.h", 234, __extension__ __PRETTY_FUNCTION__));
 for (int i=0; i<_nb; i++) {
  array[i] = __null;
 }
}

template<class T>
void Array<T>::resize(int n) {
 (static_cast <bool> (n>=0) ? void (0) : __assert_fail ("n>=0", "/usr/local/include/ibex/ibex_Array.h", 242, __extension__ __PRETTY_FUNCTION__));
 T** new_array=new T*[n];
 int i=0;
 for (; i<_nb; i++) {
  if (i<n) new_array[i] = array[i];
  else if (array[i]) delete array[i];
 }
 for (; i<n; i++) {
  new_array[i]=__null;
 }
 if (array) delete[] array;
 array=new_array;
 _nb=n;
}

template<class T>
void Array<T>::set_ref(int i, T& obj) {
 (static_cast <bool> (i>=0 && i<_nb) ? void (0) : __assert_fail ("i>=0 && i<_nb", "/usr/local/include/ibex/ibex_Array.h", 259, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (!array[i]) ? void (0) : __assert_fail ("!array[i]", "/usr/local/include/ibex/ibex_Array.h", 260, __extension__ __PRETTY_FUNCTION__));

 array[i]=&obj;
}

template<class T>
void Array<T>::add(T& obj) {
 resize(size()+1);
 set_ref(size()-1,obj);
}

template<class T>
Array<T>::Array(T** a, int n) : _nb(n), array(new T*[n]) {
 (static_cast <bool> (n>=0) ? void (0) : __assert_fail ("n>=0", "/usr/local/include/ibex/ibex_Array.h", 273, __extension__ __PRETTY_FUNCTION__));
 for (int i=0; i<_nb; i++) {
  array[i] = a[i];
 }
}

template<class T>
Array<T>::Array(const std::vector<T*>& vec) : _nb(vec.size()), array(new T*[vec.size()]) {

 (static_cast <bool> (vec.size()>0) ? void (0) : __assert_fail ("vec.size()>0", "/usr/local/include/ibex/ibex_Array.h", 282, __extension__ __PRETTY_FUNCTION__));
 int i=0;
 for (typename std::vector<T*>::const_iterator it=vec.begin(); it!=vec.end(); it++) {
  array[i++] = *it;
 }
}

template<class T>
Array<T>::Array(T& x) : _nb(1), array(new T*[1]) {
 array[0] = &x;
}

template<class T>
Array<T>::Array(T& x1, T& x2) : _nb(2), array(new T*[2]) {
 array[0] = &x1;
 array[1] = &x2;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3) : _nb(3), array(new T*[3]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3, T& x4) : _nb(4), array(new T*[4]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
 array[3] = &x4;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3, T& x4, T& x5) : _nb(5), array(new T*[5]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
 array[3] = &x4;
 array[4] = &x5;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6) : _nb(6), array(new T*[6]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
 array[3] = &x4;
 array[4] = &x5;
 array[5] = &x6;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7) : _nb(7), array(new T*[7]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
 array[3] = &x4;
 array[4] = &x5;
 array[5] = &x6;
 array[6] = &x7;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8) : _nb(8), array(new T*[8]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
 array[3] = &x4;
 array[4] = &x5;
 array[5] = &x6;
 array[6] = &x7;
 array[7] = &x8;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9) : _nb(9), array(new T*[9]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
 array[3] = &x4;
 array[4] = &x5;
 array[5] = &x6;
 array[6] = &x7;
 array[7] = &x8;
 array[8] = &x9;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10) : _nb(10), array(new T*[10]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
 array[3] = &x4;
 array[4] = &x5;
 array[5] = &x6;
 array[6] = &x7;
 array[7] = &x8;
 array[8] = &x9;
 array[9] = &x10;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11) : _nb(11), array(new T*[11]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
 array[3] = &x4;
 array[4] = &x5;
 array[5] = &x6;
 array[6] = &x7;
 array[7] = &x8;
 array[8] = &x9;
 array[9] = &x10;
 array[10] = &x11;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12) : _nb(12), array(new T*[12]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
 array[3] = &x4;
 array[4] = &x5;
 array[5] = &x6;
 array[6] = &x7;
 array[7] = &x8;
 array[8] = &x9;
 array[9] = &x10;
 array[10] = &x11;
 array[11] = &x12;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12, T& x13) : _nb(13), array(new T*[13]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
 array[3] = &x4;
 array[4] = &x5;
 array[5] = &x6;
 array[6] = &x7;
 array[7] = &x8;
 array[8] = &x9;
 array[9] = &x10;
 array[10] = &x11;
 array[11] = &x12;
 array[12] = &x13;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12, T& x13, T& x14) : _nb(14), array(new T*[14]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
 array[3] = &x4;
 array[4] = &x5;
 array[5] = &x6;
 array[6] = &x7;
 array[7] = &x8;
 array[8] = &x9;
 array[9] = &x10;
 array[10] = &x11;
 array[11] = &x12;
 array[12] = &x13;
 array[13] = &x14;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12, T& x13, T& x14, T& x15) : _nb(15), array(new T*[15]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
 array[3] = &x4;
 array[4] = &x5;
 array[5] = &x6;
 array[6] = &x7;
 array[7] = &x8;
 array[8] = &x9;
 array[9] = &x10;
 array[10] = &x11;
 array[11] = &x12;
 array[12] = &x13;
 array[13] = &x14;
 array[14] = &x15;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12, T& x13, T& x14, T& x15, T& x16) : _nb(16), array(new T*[16]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
 array[3] = &x4;
 array[4] = &x5;
 array[5] = &x6;
 array[6] = &x7;
 array[7] = &x8;
 array[8] = &x9;
 array[9] = &x10;
 array[10] = &x11;
 array[11] = &x12;
 array[12] = &x13;
 array[13] = &x14;
 array[14] = &x15;
 array[15] = &x16;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12, T& x13, T& x14, T& x15, T& x16, T& x17) : _nb(17), array(new T*[17]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
 array[3] = &x4;
 array[4] = &x5;
 array[5] = &x6;
 array[6] = &x7;
 array[7] = &x8;
 array[8] = &x9;
 array[9] = &x10;
 array[10] = &x11;
 array[11] = &x12;
 array[12] = &x13;
 array[13] = &x14;
 array[14] = &x15;
 array[15] = &x16;
 array[16] = &x17;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12, T& x13, T& x14, T& x15, T& x16, T& x17, T& x18) : _nb(18), array(new T*[18]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
 array[3] = &x4;
 array[4] = &x5;
 array[5] = &x6;
 array[6] = &x7;
 array[7] = &x8;
 array[8] = &x9;
 array[9] = &x10;
 array[10] = &x11;
 array[11] = &x12;
 array[12] = &x13;
 array[13] = &x14;
 array[14] = &x15;
 array[15] = &x16;
 array[16] = &x17;
 array[17] = &x18;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12, T& x13, T& x14, T& x15, T& x16, T& x17, T& x18, T& x19) : _nb(19), array(new T*[19]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
 array[3] = &x4;
 array[4] = &x5;
 array[5] = &x6;
 array[6] = &x7;
 array[7] = &x8;
 array[8] = &x9;
 array[9] = &x10;
 array[10] = &x11;
 array[11] = &x12;
 array[12] = &x13;
 array[13] = &x14;
 array[14] = &x15;
 array[15] = &x16;
 array[16] = &x17;
 array[17] = &x18;
 array[18] = &x19;
}

template<class T>
Array<T>::Array(T& x1, T& x2, T& x3, T& x4, T& x5, T& x6, T& x7, T& x8, T& x9, T& x10, T& x11, T& x12, T& x13, T& x14, T& x15, T& x16, T& x17, T& x18, T& x19, T& x20) : _nb(20), array(new T*[20]) {
 array[0] = &x1;
 array[1] = &x2;
 array[2] = &x3;
 array[3] = &x4;
 array[4] = &x5;
 array[5] = &x6;
 array[6] = &x7;
 array[7] = &x8;
 array[8] = &x9;
 array[9] = &x10;
 array[10] = &x11;
 array[11] = &x12;
 array[12] = &x13;
 array[13] = &x14;
 array[14] = &x15;
 array[15] = &x16;
 array[16] = &x17;
 array[17] = &x18;
 array[18] = &x19;
 array[19] = &x20;
}

template<class T>
Array<T>::Array(const Array<T>& a) : _nb(a.size()), array(new T*[a.size()]) {
 for (int i=0; i<_nb; i++) {
  array[i] = &a[i];
 }
}

template<class T>
Array<T>::~Array() {
 delete[] array;
}

template<class T>
bool Array<T>::is_empty() const {
 return _nb==0;
}

template<class T>
int Array<T>::size() const {
 return _nb;
}

template<class T>
T& Array<T>::operator[](int i) {
 (static_cast <bool> (i>=0 && i<_nb) ? void (0) : __assert_fail ("i>=0 && i<_nb", "/usr/local/include/ibex/ibex_Array.h", 603, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (array[i]) ? void (0) : __assert_fail ("array[i]", "/usr/local/include/ibex/ibex_Array.h", 604, __extension__ __PRETTY_FUNCTION__));

 return *array[i];
}

template<class T>
T& Array<T>::operator[](int i) const {
 (static_cast <bool> (i>=0 && i<_nb) ? void (0) : __assert_fail ("i>=0 && i<_nb", "/usr/local/include/ibex/ibex_Array.h", 611, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (array[i]) ? void (0) : __assert_fail ("array[i]", "/usr/local/include/ibex/ibex_Array.h", 612, __extension__ __PRETTY_FUNCTION__));

 return *array[i];
}

template<class T>
void Array<T>::clear() {
 for (int i=0; i<_nb; i++) {
  array[i] = __null;
 }
}
}
# 23 "/usr/local/include/ibex/ibex_IntervalVector.h" 2 3

namespace ibex {

class IntervalMatrix;
template<class T> class Affine2MainVector;
# 38 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
class IntervalVector {

public:






 explicit IntervalVector(int n);
# 56 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
 IntervalVector(int n, const Interval& x);




 IntervalVector(const IntervalVector& x);
 template<class T>
 explicit IntervalVector(const Affine2MainVector<T>& x);







 IntervalVector(int n, double bounds[][2]);





 IntervalVector(const Vector& x);
# 87 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
 static IntervalVector empty(int n);




 virtual ~IntervalVector();







 const Interval& operator[](int i) const;







 Interval& operator[](int i);






 void set_empty();






 void clear();






 void init(const Interval& x);






 IntervalVector& inflate(double rad);
# 146 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
 void resize(int n2);







 IntervalVector subvector(int start_index, int end_index) const;
# 164 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
 void put(int start_index, const IntervalVector& subvec);







 IntervalVector& operator=(const IntervalVector& x);

 template<class T>
 IntervalVector& operator=(const Affine2MainVector<T>& x);







 IntervalVector& operator&=(const IntervalVector& x);







 IntervalVector& operator|=(const IntervalVector& x);




 IntervalVector operator&(const IntervalVector& x) const;




 IntervalVector operator|(const IntervalVector& x) const;




 bool operator==(const IntervalVector& x) const;




 bool operator!=(const IntervalVector& x) const;




 int size() const;





 Vector lb() const;





 Vector ub() const;





 Vector mid() const;





 Vector mig() const;





 Vector mag() const;




 bool is_empty() const;







 bool is_flat() const;






 bool is_unbounded() const;
# 277 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
 bool is_subset(const IntervalVector& x) const;
# 288 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
 bool is_strict_subset(const IntervalVector& x) const;
# 299 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
 bool is_interior_subset(const IntervalVector& x) const;
# 310 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
 bool is_strict_interior_subset(const IntervalVector& x) const;
# 321 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
 bool is_superset(const IntervalVector& x) const;
# 332 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
 bool is_strict_superset(const IntervalVector& x) const;







 bool contains(const Vector& x) const;







 bool interior_contains(const Vector& x) const;







 bool intersects(const IntervalVector& x) const;







 bool overlaps(const IntervalVector& x) const;







 bool is_disjoint(const IntervalVector& x) const;




 bool is_zero() const;






 bool is_bisectable() const;




 Vector rad() const;




 Vector diam() const;







 int extr_diam_index(bool min) const;





 void sort_indices(bool min, int tab[]) const;






 double max_diam() const;






 double min_diam() const;
# 433 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
 double volume() const;






 double perimeter() const;






 double maxdelta(const IntervalVector&);
# 457 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
 double rel_distance(const IntervalVector& x) const;
# 472 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
 int diff(const IntervalVector& y, IntervalVector*& result) const;
# 488 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
 int complementary(IntervalVector*& result) const;
# 502 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
 std::pair<IntervalVector,IntervalVector> bisect(int i, double ratio=0.5) const;






 Vector random(int seed) const;
 Vector random() const;




 IntervalVector& operator+=(const Vector& x2);




 IntervalVector& operator+=(const IntervalVector& x2);




 IntervalVector& operator-=(const Vector& x2);




 IntervalVector& operator-=(const IntervalVector& x2);




 IntervalVector& operator*=(double d);




 IntervalVector& operator*=(const Interval& x1);




 operator const ExprConstant&() const;

private:
 friend class IntervalMatrix;
 template<class T> friend class Affine2MainVector;

 IntervalVector() : n(0), vec(__null) { }

 int n;
 Interval *vec;
};
# 569 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
double distance(const IntervalVector& x1, const IntervalVector& x2);




IntervalVector operator-(const IntervalVector& x);





IntervalVector operator+(const Vector& x1, const IntervalVector& x2);




IntervalVector operator+(const IntervalVector& x1, const Vector& x2);




IntervalVector operator+(const IntervalVector& x1, const IntervalVector& x2);




IntervalVector operator-(const Vector& x1, const IntervalVector& x2);





IntervalVector operator-(const IntervalVector& x1, const Vector& x2);




IntervalVector operator-(const IntervalVector& x1, const IntervalVector& x2);




Interval operator*(const Vector& x1, const IntervalVector& x2);




Interval operator*(const IntervalVector& x1, const Vector& x2);




Interval operator*(const IntervalVector& x1, const IntervalVector& x2);




IntervalVector operator*(double d, const IntervalVector& x);




IntervalVector operator*(const Interval& x1, const Vector& x2);




IntervalVector operator*(const Interval& x1, const IntervalVector& x2);







IntervalVector hadamard_product(const IntervalVector& x, const Vector& y);







IntervalVector hadamard_product(const Vector& x, const IntervalVector& y);







IntervalVector hadamard_product(const IntervalVector& x, const IntervalVector& y);




IntervalVector abs(const IntervalVector& x);






bool bwd_add(const IntervalVector& y, IntervalVector& x1, IntervalVector& x2);






bool bwd_sub(const IntervalVector& y, IntervalVector& x1, IntervalVector& x2);






bool bwd_mul(const IntervalVector& y, Interval& x1, IntervalVector& x2);






bool bwd_mul(const Interval& y, IntervalVector& x1, IntervalVector& x2);




std::ostream& operator<<(std::ostream& os, const IntervalVector& x);




IntervalVector cart_prod(const IntervalVector& x, const IntervalVector& y);







namespace {






inline bool is_empty(const IntervalVector& v) { return v.is_empty(); }
# 730 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
inline void set_empty(IntervalVector& v) { v.set_empty(); }






}

}



namespace ibex {

inline IntervalVector IntervalVector::empty(int n) {
 return IntervalVector(n, Interval::EMPTY_SET);
}

inline IntervalVector::~IntervalVector() {
 delete[] vec;
}

inline void IntervalVector::set_empty() {
 (*this)[0]=Interval::EMPTY_SET;
}

inline const Interval& IntervalVector::operator[](int i) const {
 (static_cast <bool> (i>=0 && i<n) ? void (0) : __assert_fail ("i>=0 && i<n", "/usr/local/include/ibex/ibex_IntervalVector.h", 758, __extension__ __PRETTY_FUNCTION__));
 return vec[i];
}

inline Interval& IntervalVector::operator[](int i) {
 (static_cast <bool> (i>=0 && i<n) ? void (0) : __assert_fail ("i>=0 && i<n", "/usr/local/include/ibex/ibex_IntervalVector.h", 763, __extension__ __PRETTY_FUNCTION__));
 return vec[i];
}

inline void IntervalVector::clear() {
 init(0);
}

inline IntervalVector IntervalVector::operator&(const IntervalVector& x) const {
 return IntervalVector(*this) &= x;
}

inline IntervalVector IntervalVector::operator|(const IntervalVector& x) const {
 return IntervalVector(*this) |= x;
}

inline bool IntervalVector::operator!=(const IntervalVector& x) const {
 return !(*this==x);
}
# 796 "/usr/local/include/ibex/ibex_IntervalVector.h" 3
inline int IntervalVector::size() const {
 return n;
}

inline bool IntervalVector::is_empty() const {
 return (*this)[0].is_empty();
}

inline double IntervalVector::max_diam() const {
 return (*this)[extr_diam_index(false)].diam();
}

inline double IntervalVector::min_diam() const {
 return (*this)[extr_diam_index(true)].diam();
}

inline IntervalVector cart_prod(const IntervalVector& x, const IntervalVector& y) {
 IntervalVector z(x.size()+y.size());
 z.put(0,x);
 z.put(x.size(),y);
 return z;
}

inline IntervalVector& IntervalVector::operator+=(const Vector& x) {
 return set_addV<IntervalVector,Vector>(*this,x);
}

inline IntervalVector& IntervalVector::operator+=(const IntervalVector& x) {
 return set_addV<IntervalVector,IntervalVector>(*this,x);
}

inline IntervalVector& IntervalVector::operator-=(const Vector& x) {
 return set_subV<IntervalVector,Vector>(*this,x);
}

inline IntervalVector& IntervalVector::operator-=(const IntervalVector& x) {
 return set_subV<IntervalVector,IntervalVector>(*this,x);
}

inline IntervalVector& IntervalVector::operator*=(double x) {
 return set_mulSV<double,IntervalVector>(x,*this);
}

inline IntervalVector& IntervalVector::operator*=(const Interval& x) {
 return set_mulSV<Interval,IntervalVector>(x,*this);
}

inline IntervalVector operator-(const IntervalVector& x) {
 return minusV(x);
}

inline IntervalVector operator+(const IntervalVector& m1, const Vector& m2) {
 return IntervalVector(m1)+=m2;
}

inline IntervalVector operator+(const Vector& m1, const IntervalVector& m2) {
 return IntervalVector(m1)+=m2;
}

inline IntervalVector operator+(const IntervalVector& m1, const IntervalVector& m2) {
 return IntervalVector(m1)+=m2;
}

inline IntervalVector operator-(const IntervalVector& m1, const Vector& m2) {
 return IntervalVector(m1)-=m2;
}

inline IntervalVector operator-(const Vector& m1, const IntervalVector& m2) {
 return IntervalVector(m1)-=m2;
}

inline IntervalVector operator-(const IntervalVector& m1, const IntervalVector& m2) {
 return IntervalVector(m1)-=m2;
}

inline IntervalVector operator*(double x, const IntervalVector& v) {
 return IntervalVector(v)*=x;
}

inline IntervalVector operator*(const Interval& x, const Vector& v) {
 return IntervalVector(v)*=x;
}

inline IntervalVector operator*(const Interval& x, const IntervalVector& v) {
 return IntervalVector(v)*=x;
}

inline Interval operator*(const Vector& v1, const IntervalVector& v2) {
 return mulVV<Vector,IntervalVector,Interval>(v1,v2);
}

inline Interval operator*(const IntervalVector& v1, const Vector& v2) {
 return mulVV<IntervalVector,Vector,Interval>(v1,v2);
}

inline Interval operator*(const IntervalVector& v1, const IntervalVector& v2) {
 return mulVV<IntervalVector,IntervalVector,Interval>(v1,v2);
}

inline IntervalVector hadamard_product(const Vector& v1, const IntervalVector& v2) {
 return hadamard_prod<Vector,IntervalVector,IntervalVector>(v1,v2);
}

inline IntervalVector hadamard_product(const IntervalVector& v1, const Vector& v2) {
 return hadamard_prod<IntervalVector,Vector,IntervalVector>(v1,v2);
}

inline IntervalVector hadamard_product(const IntervalVector& v1, const IntervalVector& v2) {
 return hadamard_prod<IntervalVector,IntervalVector,IntervalVector>(v1,v2);
}

inline IntervalVector operator*(const Matrix& m, const IntervalVector& v) {
 return mulMV<Matrix,IntervalVector,IntervalVector>(m,v);
}

inline IntervalVector operator*(const IntervalVector& v, const Matrix& m) {
 return mulVM<IntervalVector,Matrix,IntervalVector>(v,m);
}

inline IntervalVector abs(const IntervalVector& v) {
 return absV(v);
}


}
# 16 "/usr/local/include/ibex/ibex_IntervalMatrix.h" 2 3




namespace ibex {

class IntervalMatrixArray;
template <class T> class Affine2MainMatrix;






class IntervalMatrix {

public:



 IntervalMatrix(int nb_rows, int nb_cols);





 IntervalMatrix(int nb_rows, int nb_cols, const Interval& x);




 IntervalMatrix(const IntervalMatrix& m);




 IntervalMatrix(const Matrix& m);
# 66 "/usr/local/include/ibex/ibex_IntervalMatrix.h" 3
 IntervalMatrix(int m, int n, double x[][2]);




 ~IntervalMatrix();
# 81 "/usr/local/include/ibex/ibex_IntervalMatrix.h" 3
 static IntervalMatrix empty(int m, int n);




 IntervalMatrix& operator=(const IntervalMatrix& x);




 template<class T>
 IntervalMatrix& operator=(const Affine2MainMatrix<T>& m);






 IntervalMatrix& operator&=(const IntervalMatrix& x);




 void clear();






 void init(const Interval& x);







 bool operator==(const IntervalMatrix& m) const;




 bool operator!=(const IntervalMatrix& m) const;




 void resize(int nb_rows, int nb_cols);




 int nb_cols() const;




 int nb_rows() const;





 Matrix lb() const;





 Matrix ub() const;





 Matrix mid() const;





 Matrix mig() const;





 Matrix mag() const;




 bool is_empty() const;






 IntervalVector& operator[](int i);






 const IntervalVector& operator[](int i) const;






 void set_empty();




 bool is_zero() const;
# 211 "/usr/local/include/ibex/ibex_IntervalMatrix.h" 3
 bool is_subset(const IntervalMatrix& x) const;
# 222 "/usr/local/include/ibex/ibex_IntervalMatrix.h" 3
 bool is_strict_subset(const IntervalMatrix& x) const;
# 233 "/usr/local/include/ibex/ibex_IntervalMatrix.h" 3
 bool is_interior_subset(const IntervalMatrix& x) const;
# 244 "/usr/local/include/ibex/ibex_IntervalMatrix.h" 3
 bool is_strict_interior_subset(const IntervalMatrix& x) const;
# 255 "/usr/local/include/ibex/ibex_IntervalMatrix.h" 3
 bool is_superset(const IntervalMatrix& x) const;
# 266 "/usr/local/include/ibex/ibex_IntervalMatrix.h" 3
 bool is_strict_superset(const IntervalMatrix& x) const;







 bool contains(const Matrix& x) const;







 bool interior_contains(const Matrix& x) const;







 bool intersects(const IntervalMatrix& x) const;







 bool overlaps(const IntervalMatrix& x) const;







 bool is_disjoint(const IntervalMatrix& x) const;







 IntervalMatrix submatrix(int row_start_index, int row_end_index, int col_start_index, int col_end_index) const;





 IntervalMatrix transpose() const;







 IntervalVector& row(int i);







 const IntervalVector& row(int i) const;





 IntervalVector col(int i) const;





 IntervalMatrix rows(int start_index, int end_index);





 IntervalMatrix cols(int start_index, int end_index);





 void set_row(int row, const IntervalVector& v);





 void set_col(int col, const IntervalVector& v);





 void put(int row_start_index, int col_start_index, const Matrix& M);





 void put(int row_start_index, int col_start_index, const IntervalMatrix& M);






 void put(int row_start_index, int col_start_index, const Vector& V, bool row_vec);






 void put(int row_start_index, int col_start_index, const IntervalVector& V, bool row_vec);






 Matrix random(int seed) const;
 Matrix random() const;




    IntervalMatrix& operator+=(const Matrix& m);




    IntervalMatrix& operator+=(const IntervalMatrix& m);




    IntervalMatrix& operator-=(const Matrix& m);




    IntervalMatrix& operator-=(const IntervalMatrix& m);






 IntervalMatrix& inflate(double rad);




    IntervalMatrix& operator*=(double x);




    IntervalMatrix& operator*=(const Interval& x);




    IntervalMatrix& operator*=(const Matrix& m);




    IntervalMatrix& operator*=(const IntervalMatrix& m);




    operator const ExprConstant&() const;

private:
 friend class IntervalMatrixArray;

 IntervalMatrix();

 int _nb_rows;
 int _nb_cols;
 IntervalVector* M;
};







IntervalMatrix operator-(const IntervalMatrix& m);




IntervalMatrix operator+(const IntervalMatrix& m1, const Matrix& m2);




IntervalMatrix operator+(const Matrix& m1, const IntervalMatrix& m2);




IntervalMatrix operator+(const IntervalMatrix& m1, const IntervalMatrix& m2);




IntervalMatrix operator-(const IntervalMatrix& m1, const Matrix& m2);




IntervalMatrix operator-(const Matrix& m1, const IntervalMatrix& m2);




IntervalMatrix operator-(const IntervalMatrix& m1, const IntervalMatrix& m2);




IntervalMatrix operator*(double d, const IntervalMatrix& m);




IntervalMatrix operator*(const Interval& x, const Matrix& m);




IntervalMatrix operator*(const Interval& x, const IntervalMatrix& m);




IntervalVector operator*(const IntervalMatrix& m, const Vector& x);




IntervalVector operator*(const Matrix& m, const IntervalVector& x);




IntervalVector operator*(const IntervalMatrix& m, const IntervalVector& x);




IntervalVector operator*(const Vector& x, const IntervalMatrix& m);




IntervalVector operator*(const IntervalVector& x, const Matrix& m);




IntervalVector operator*(const IntervalVector& x, const IntervalMatrix& m);




IntervalMatrix operator*(const IntervalMatrix& m1, const Matrix& m2);




IntervalMatrix operator*(const Matrix& m1, const IntervalMatrix& m2);




IntervalMatrix operator*(const IntervalMatrix& m1, const IntervalMatrix& m2);




IntervalMatrix outer_product(const IntervalVector& x1, const Vector& x2);




IntervalMatrix outer_product(const Vector& x1, const IntervalVector& x2);




IntervalMatrix outer_product(const IntervalVector& x1, const IntervalVector& x2);




IntervalMatrix abs(const IntervalMatrix& m);






bool bwd_add(const IntervalMatrix& y, IntervalMatrix& x1, IntervalMatrix& x2);






bool bwd_sub(const IntervalMatrix& y, IntervalMatrix& x1, IntervalMatrix& x2);






bool bwd_mul(const IntervalMatrix& y, Interval& x1, IntervalMatrix& x2);
# 610 "/usr/local/include/ibex/ibex_IntervalMatrix.h" 3
bool bwd_mul(const IntervalVector& y, IntervalMatrix& x1, IntervalVector& x2, double ratio);
# 619 "/usr/local/include/ibex/ibex_IntervalMatrix.h" 3
bool bwd_mul(const IntervalVector& y, IntervalVector& x1, IntervalMatrix& x2, double ratio);
# 628 "/usr/local/include/ibex/ibex_IntervalMatrix.h" 3
bool bwd_mul(const IntervalMatrix& y, IntervalMatrix& x1, IntervalMatrix& x2, double ratio);




std::ostream& operator<<(std::ostream& os, const IntervalMatrix&);





namespace {
# 648 "/usr/local/include/ibex/ibex_IntervalMatrix.h" 3
inline bool is_empty(const IntervalMatrix& m) { return m.is_empty(); }
# 660 "/usr/local/include/ibex/ibex_IntervalMatrix.h" 3
inline void set_empty(IntervalMatrix& m) { m.set_empty(); }




}

}



namespace ibex {

inline IntervalMatrix IntervalMatrix::empty(int m, int n) {
 return IntervalMatrix(m, n, Interval::EMPTY_SET);
}

inline bool IntervalMatrix::operator!=(const IntervalMatrix& m) const {
 return !(*this==m);
}

inline int IntervalMatrix::nb_cols() const {
 return _nb_cols;
}

inline int IntervalMatrix::nb_rows() const {
 return _nb_rows;
}

inline IntervalVector& IntervalMatrix::operator[](int i) {
 (static_cast <bool> (i>=0 && i<nb_rows()) ? void (0) : __assert_fail ("i>=0 && i<nb_rows()", "/usr/local/include/ibex/ibex_IntervalMatrix.h", 690, __extension__ __PRETTY_FUNCTION__));
 return M[i];
}

inline const IntervalVector& IntervalMatrix::operator[](int i) const {
 (static_cast <bool> (i>=0 && i<nb_rows()) ? void (0) : __assert_fail ("i>=0 && i<nb_rows()", "/usr/local/include/ibex/ibex_IntervalMatrix.h", 695, __extension__ __PRETTY_FUNCTION__));
 return M[i];
}

inline void IntervalMatrix::clear() {
 init(0);
}

inline void IntervalMatrix::set_empty() {
 (*this)[0].set_empty();
}

inline IntervalVector& IntervalMatrix::row(int i) {
 (static_cast <bool> (i>=0 && i<nb_rows()) ? void (0) : __assert_fail ("i>=0 && i<nb_rows()", "/usr/local/include/ibex/ibex_IntervalMatrix.h", 708, __extension__ __PRETTY_FUNCTION__));
 return M[i];
}

inline const IntervalVector& IntervalMatrix::row(int i) const {
 (static_cast <bool> (i>=0 && i<nb_rows()) ? void (0) : __assert_fail ("i>=0 && i<nb_rows()", "/usr/local/include/ibex/ibex_IntervalMatrix.h", 713, __extension__ __PRETTY_FUNCTION__));
 return M[i];
}

inline IntervalMatrix IntervalMatrix::rows(int start_index, int end_index) {
 return submatrix(start_index, end_index, 0, nb_cols()-1);
}

inline IntervalMatrix IntervalMatrix::cols(int start_index, int end_index) {
 return submatrix(0, nb_rows()-1, start_index, end_index);
}

inline void IntervalMatrix::set_row(int row1, const IntervalVector& v1) {
 (static_cast <bool> (row1>=0 && row1<nb_rows()) ? void (0) : __assert_fail ("row1>=0 && row1<nb_rows()", "/usr/local/include/ibex/ibex_IntervalMatrix.h", 726, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (nb_cols()==v1.size()) ? void (0) : __assert_fail ("nb_cols()==v1.size()", "/usr/local/include/ibex/ibex_IntervalMatrix.h", 727, __extension__ __PRETTY_FUNCTION__));
 M[row1]=v1;
}

inline bool IntervalMatrix::is_empty() const {
 return (*this)[0].is_empty();
}

inline IntervalMatrix& IntervalMatrix::operator+=(const Matrix& m) {
 return set_addM<IntervalMatrix,Matrix>(*this,m);
}

inline IntervalMatrix& IntervalMatrix::operator+=(const IntervalMatrix& m) {
 return set_addM<IntervalMatrix,IntervalMatrix>(*this,m);
}

inline IntervalMatrix& IntervalMatrix::operator-=(const Matrix& m) {
 return set_subM<IntervalMatrix,Matrix>(*this,m);
}

inline IntervalMatrix& IntervalMatrix::operator-=(const IntervalMatrix& m) {
 return set_subM<IntervalMatrix,IntervalMatrix>(*this,m);
}

inline IntervalMatrix& IntervalMatrix::operator*=(double x) {
 return set_mulSM<double,IntervalMatrix>(x,*this);
}

inline IntervalMatrix& IntervalMatrix::operator*=(const Interval& x) {
 return set_mulSM<Interval,IntervalMatrix>(x,*this);
}

inline IntervalMatrix& IntervalMatrix::operator*=(const Matrix& m) {
 return *this=(*this*m);
}

inline IntervalMatrix& IntervalMatrix::operator*=(const IntervalMatrix& m) {
 return *this=(*this*m);
}

inline IntervalMatrix operator-(const IntervalMatrix& m) {
 return minusM(m);
}

inline IntervalMatrix operator+(const IntervalMatrix& m1, const Matrix& m2) {
 return IntervalMatrix(m1)+=m2;
}

inline IntervalMatrix operator+(const Matrix& m1, const IntervalMatrix& m2) {
 return IntervalMatrix(m1)+=m2;
}

inline IntervalMatrix operator+(const IntervalMatrix& m1, const IntervalMatrix& m2) {
 return IntervalMatrix(m1)+=m2;
}

inline IntervalMatrix operator-(const IntervalMatrix& m1, const Matrix& m2) {
 return IntervalMatrix(m1)-=m2;
}

inline IntervalMatrix operator-(const Matrix& m1, const IntervalMatrix& m2) {
 return IntervalMatrix(m1)-=m2;
}

inline IntervalMatrix operator-(const IntervalMatrix& m1, const IntervalMatrix& m2) {
 return IntervalMatrix(m1)-=m2;
}

inline IntervalMatrix operator*(double x, const IntervalMatrix& m) {
 return IntervalMatrix(m)*=x;
}

inline IntervalMatrix operator*(const Interval& x, const Matrix& m) {
 return IntervalMatrix(m)*=x;
}

inline IntervalMatrix operator*(const Interval& x, const IntervalMatrix& m) {
 return IntervalMatrix(m)*=x;
}

inline IntervalMatrix outer_product(const Vector& v1, const IntervalVector& v2) {
 return outer_prod<Vector,IntervalVector,IntervalMatrix>(v1,v2);
}

inline IntervalMatrix outer_product(const IntervalVector& v1, const Vector& v2) {
 return outer_prod<IntervalVector,Vector,IntervalMatrix>(v1,v2);
}

inline IntervalMatrix outer_product(const IntervalVector& v1, const IntervalVector& v2) {
 return outer_prod<IntervalVector,IntervalVector,IntervalMatrix>(v1,v2);
}

inline IntervalVector operator*(const IntervalMatrix& m, const Vector& v) {
 return mulMV<IntervalMatrix,Vector,IntervalVector>(m,v);
}

inline IntervalVector operator*(const IntervalMatrix& m, const IntervalVector& v) {
 return mulMV<IntervalMatrix,IntervalVector,IntervalVector>(m,v);
}

inline IntervalVector operator*(const Vector& v, const IntervalMatrix& m) {
 return mulVM<Vector,IntervalMatrix,IntervalVector>(v,m);
}

inline IntervalVector operator*(const IntervalVector& v, const IntervalMatrix& m) {
 return mulVM<IntervalVector,IntervalMatrix,IntervalVector>(v,m);
}

inline IntervalMatrix operator*(const Matrix& m1, const IntervalMatrix& m2) {
 return mulMM<Matrix,IntervalMatrix,IntervalMatrix>(m1,m2);
}

inline IntervalMatrix operator*(const IntervalMatrix& m1, const Matrix& m2) {
 return mulMM<IntervalMatrix,Matrix,IntervalMatrix>(m1,m2);
}

inline IntervalMatrix operator*(const IntervalMatrix& m1, const IntervalMatrix& m2) {
 return mulMM<IntervalMatrix,IntervalMatrix,IntervalMatrix>(m1,m2);
}

inline IntervalMatrix abs(const IntervalMatrix& m) {
 return absM(m);
}






}
# 17 "/usr/local/include/ibex/ibex_IntervalMatrixArray.h" 2 3
# 1 "/usr/local/include/ibex/ibex_MatrixArray.h" 1 3
# 18 "/usr/local/include/ibex/ibex_MatrixArray.h" 3
namespace ibex {






class MatrixArray {

public:



 MatrixArray(int size, int nb_rows, int nb_cols);





 MatrixArray(int size, int nb_rows, int nb_cols, double x);




 MatrixArray(const MatrixArray& m);
# 63 "/usr/local/include/ibex/ibex_MatrixArray.h" 3
 ~MatrixArray();




 MatrixArray& operator=(const MatrixArray& x);




 bool operator==(const MatrixArray& m) const;




 bool operator!=(const MatrixArray& m);




 int size() const;




 int nb_rows() const;




 int nb_cols() const;






 Matrix& operator[](int i);






 const Matrix& operator[](int i) const;

private:
 Matrix* array;
 int n;
};
# 122 "/usr/local/include/ibex/ibex_MatrixArray.h" 3
std::ostream& operator<<(std::ostream& os, const MatrixArray&);





inline int MatrixArray::size() const {
 return n;
}

inline int MatrixArray::nb_rows() const {
 (static_cast <bool> (n>0) ? void (0) : __assert_fail ("n>0", "/usr/local/include/ibex/ibex_MatrixArray.h", 133, __extension__ __PRETTY_FUNCTION__));
 return array[0].nb_rows();
}

inline int MatrixArray::nb_cols() const {
 (static_cast <bool> (n>0) ? void (0) : __assert_fail ("n>0", "/usr/local/include/ibex/ibex_MatrixArray.h", 138, __extension__ __PRETTY_FUNCTION__));
 return array[0].nb_cols();
}

inline Matrix& MatrixArray::operator[](int i) {
 return array[i];
}

inline const Matrix& MatrixArray::operator[](int i) const {
 return array[i];
}

}
# 18 "/usr/local/include/ibex/ibex_IntervalMatrixArray.h" 2 3

namespace ibex {






class IntervalMatrixArray {

public:



 IntervalMatrixArray(int n, int nb_rows, int nb_cols);




 IntervalMatrixArray(const IntervalMatrixArray& a);




 IntervalMatrixArray& operator=(const IntervalMatrixArray& a);






 IntervalMatrixArray& operator&=(const IntervalMatrixArray& x);




 bool operator==(const IntervalMatrixArray& m) const;





 void init(const Interval& x);






 void set_empty();




 ~IntervalMatrixArray();




 int size() const;




 int nb_rows() const;




 int nb_cols() const;




 bool is_empty() const;





 IntervalMatrix& operator[](int i);




 const IntervalMatrix& operator[](int i) const;
# 114 "/usr/local/include/ibex/ibex_IntervalMatrixArray.h" 3
 bool is_subset(const IntervalMatrixArray& x) const;
# 125 "/usr/local/include/ibex/ibex_IntervalMatrixArray.h" 3
 bool is_strict_subset(const IntervalMatrixArray& x) const;
# 136 "/usr/local/include/ibex/ibex_IntervalMatrixArray.h" 3
 bool is_interior_subset(const IntervalMatrixArray& x) const;
# 147 "/usr/local/include/ibex/ibex_IntervalMatrixArray.h" 3
 bool is_strict_interior_subset(const IntervalMatrixArray& x) const;
# 158 "/usr/local/include/ibex/ibex_IntervalMatrixArray.h" 3
 bool is_superset(const IntervalMatrixArray& x) const;
# 169 "/usr/local/include/ibex/ibex_IntervalMatrixArray.h" 3
 bool is_strict_superset(const IntervalMatrixArray& x) const;







 bool contains(const MatrixArray& x) const;







 bool interior_contains(const MatrixArray& x) const;







 bool intersects(const IntervalMatrixArray& x) const;







 bool overlaps(const IntervalMatrixArray& x) const;







 bool is_disjoint(const IntervalMatrixArray& x) const;


private:
 IntervalMatrix* array;
 int n;
};
# 224 "/usr/local/include/ibex/ibex_IntervalMatrixArray.h" 3
std::ostream& operator<<(std::ostream& os, const IntervalMatrixArray&);





inline int IntervalMatrixArray::size() const {
 return n;
}

inline int IntervalMatrixArray::nb_rows() const {
 (static_cast <bool> (n>0) ? void (0) : __assert_fail ("n>0", "/usr/local/include/ibex/ibex_IntervalMatrixArray.h", 235, __extension__ __PRETTY_FUNCTION__));
 return array[0].nb_rows();
}

inline int IntervalMatrixArray::nb_cols() const {
 (static_cast <bool> (n>0) ? void (0) : __assert_fail ("n>0", "/usr/local/include/ibex/ibex_IntervalMatrixArray.h", 240, __extension__ __PRETTY_FUNCTION__));
 return array[0].nb_cols();
}

inline IntervalMatrix& IntervalMatrixArray::operator[](int i) {
 return array[i];
}

inline const IntervalMatrix& IntervalMatrixArray::operator[](int i) const {
 return array[i];
}

inline void IntervalMatrixArray::set_empty() {
 (*this)[0].set_empty();
}

inline bool IntervalMatrixArray::is_empty() const {
 return (*this)[0].is_empty();
}

}
# 16 "/usr/local/include/ibex/ibex_Affine2MatrixArray.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Affine2Matrix.h" 1 3
# 17 "/usr/local/include/ibex/ibex_Affine2Matrix.h" 3
# 1 "/usr/local/include/ibex/ibex_Affine2Vector.h" 1 3
# 14 "/usr/local/include/ibex/ibex_Affine2Vector.h" 3
# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 44 "/usr/include/c++/7/cassert" 2 3
# 15 "/usr/local/include/ibex/ibex_Affine2Vector.h" 2 3
# 23 "/usr/local/include/ibex/ibex_Affine2Vector.h" 3
namespace ibex {

template<class T> class Affine2MainMatrix;
# 37 "/usr/local/include/ibex/ibex_Affine2Vector.h" 3
typedef Affine2MainVector<AF_Default> Affine2Vector;
typedef Affine2MainVector<AF_Linear> AffineLinVector;

template<class T=AF_Default>
class Affine2MainVector {


private:
 friend class Affine2MainMatrix<T>;

 Affine2MainVector() : _n(0), _vec(__null) { }

 int _n;
 Affine2Main<T> *_vec;

public:




 explicit Affine2MainVector(int n);
# 66 "/usr/local/include/ibex/ibex_Affine2Vector.h" 3
 Affine2MainVector(int n, const Interval& x, bool b =false);






 Affine2MainVector(int n, const Affine2Main<T>& x);
# 84 "/usr/local/include/ibex/ibex_Affine2Vector.h" 3
 Affine2MainVector(const Affine2MainVector& x);
# 94 "/usr/local/include/ibex/ibex_Affine2Vector.h" 3
 Affine2MainVector(int n, double bounds[][2], bool b =false);







 explicit Affine2MainVector(const IntervalVector& x, bool b =false);





 explicit Affine2MainVector(const Vector& x);
# 118 "/usr/local/include/ibex/ibex_Affine2Vector.h" 3
 static Affine2MainVector empty(int n);




 virtual ~Affine2MainVector();







 const Affine2Main<T>& operator[](int i) const;







 Affine2Main<T>& operator[](int i);






 void set_empty();






 void clear();




 void compact(double tol);
 void compact();
# 168 "/usr/local/include/ibex/ibex_Affine2Vector.h" 3
 void init(const Interval& x, bool b =false);






 void init(const Affine2Main<T>& x);






 Affine2MainVector& inflate(double rad);
# 192 "/usr/local/include/ibex/ibex_Affine2Vector.h" 3
 void resize(int n2);







 Affine2MainVector subvector(int start_index, int end_index) const;
# 210 "/usr/local/include/ibex/ibex_Affine2Vector.h" 3
 void put(int start_index, const Affine2MainVector& subvec);







 Affine2MainVector& operator=(const Affine2MainVector& x);
 Affine2MainVector& operator=(const IntervalVector& x);




 bool operator==(const Affine2MainVector& x) const;
 bool operator==(const IntervalVector& x) const;




 bool operator!=(const IntervalVector& x) const;
 bool operator!=(const Affine2MainVector& x) const;






 IntervalVector itv() const;




 int size() const;




 bool is_empty() const;






 bool is_unbounded() const;




 Affine2MainVector& operator+=(const Vector& x2);




 Affine2MainVector& operator+=(const IntervalVector& x2);
 Affine2MainVector& operator+=(const Affine2MainVector& x2);




 Affine2MainVector& operator-=(const Vector& x2);




 Affine2MainVector& operator-=(const IntervalVector& x2);
 Affine2MainVector& operator-=(const Affine2MainVector& x2);




 Affine2MainVector& operator*=(double d);




 Affine2MainVector& operator*=(const Interval& x1);
 Affine2MainVector& operator*=(const Affine2Main<T>& x1);


};
# 300 "/usr/local/include/ibex/ibex_Affine2Vector.h" 3
template<class T>
IntervalVector operator&(const Affine2MainVector<T>& x, const Affine2MainVector<T>& y);
template<class T>
IntervalVector operator&(const IntervalVector& x, const Affine2MainVector<T>& y);
template<class T>
IntervalVector operator&(const Affine2MainVector<T>& x, const IntervalVector& y);




template<class T>
IntervalVector operator|(const Affine2MainVector<T>& x, const Affine2MainVector<T>& y);
template<class T>
IntervalVector operator|(const IntervalVector& x, const Affine2MainVector<T>& y);
template<class T>
IntervalVector operator|(const Affine2MainVector<T>& x, const IntervalVector& y);




template<class T>
Affine2MainVector<T> operator-(const Affine2MainVector<T>& x);





template<class T>
Affine2MainVector<T> operator+(const Vector& x1, const Affine2MainVector<T>& x2);




template<class T>
Affine2MainVector<T> operator+(const Affine2MainVector<T>& x1, const Vector& x2);




template<class T>
Affine2MainVector<T> operator+(const Affine2MainVector<T>& x1, const IntervalVector& x2);
template<class T>
Affine2MainVector<T> operator+(const IntervalVector& x1, const Affine2MainVector<T>& x2);
template<class T>
Affine2MainVector<T> operator+(const Affine2MainVector<T>& x1, const Affine2MainVector<T>& x2);




template<class T>
Affine2MainVector<T> operator-(const Vector& x1, const Affine2MainVector<T>& x2);





template<class T>
Affine2MainVector<T> operator-(const Affine2MainVector<T>& x1, const Vector& x2);




template<class T>
Affine2MainVector<T> operator-(const Affine2MainVector<T>& x1, const IntervalVector& x2);
template<class T>
Affine2MainVector<T> operator-(const IntervalVector& x1, const Affine2MainVector<T>& x2);
template<class T>
Affine2MainVector<T> operator-(const Affine2MainVector<T>& x1, const Affine2MainVector<T>& x2);




template<class T>
Affine2Main<T> operator*(const Vector& x1, const Affine2MainVector<T>& x2);




template<class T>
Affine2Main<T> operator*(const Affine2MainVector<T>& x1, const Vector& x2);




template<class T>
Affine2Main<T> operator*(const Affine2MainVector<T>& x1, const IntervalVector& x2);
template<class T>
Affine2Main<T> operator*(const IntervalVector& x1, const Affine2MainVector<T>& x2);
template<class T>
Affine2Main<T> operator*(const Affine2MainVector<T>& x1, const Affine2MainVector<T>& x2);




template<class T>
Affine2MainVector<T> operator*(double d, const Affine2MainVector<T>& x);




template<class T>
Affine2MainVector<T> operator*(const Affine2Main<T>& x1, const Vector& x2);




template<class T>
Affine2MainVector<T> operator*(const Affine2Main<T>& x1, const Affine2MainVector<T>& x2);
template<class T>
Affine2MainVector<T> operator*(const Interval& x1, const Affine2MainVector<T>& x2);




template<class T>
Affine2MainVector<T> abs(const Affine2MainVector<T>& x);




template<class T>
std::ostream& operator<<(std::ostream& os, const Affine2MainVector<T>& x);





template<class T>
Affine2MainVector<T> cart_prod(const Affine2MainVector<T>& x, const Affine2MainVector<T>& y);






namespace {
# 445 "/usr/local/include/ibex/ibex_Affine2Vector.h" 3
template<class T> inline bool is_empty(const Affine2Main<T>& x) { return x.is_empty(); }
template<class T> inline bool is_empty(const Affine2MainVector<T>& v) { return v.is_empty(); }
# 457 "/usr/local/include/ibex/ibex_Affine2Vector.h" 3
template<class T> inline void set_empty(Affine2Main<T>& x) { x.set_empty(); }
template<class T> inline void set_empty(Affine2MainVector<T>& v) { v.set_empty(); }


}

}


# 1 "/usr/local/include/ibex/ibex_Affine2Vector.h_" 1 3
# 15 "/usr/local/include/ibex/ibex_Affine2Vector.h_" 3
# 1 "/usr/local/include/ibex/ibex_TemplateVector.h_" 1 3
# 18 "/usr/local/include/ibex/ibex_TemplateVector.h_" 3
# 1 "/usr/local/include/ibex/ibex_Affine2Vector.h" 1 3
# 19 "/usr/local/include/ibex/ibex_TemplateVector.h_" 2 3
# 1 "/usr/local/include/ibex/ibex_Random.h" 1 3
# 53 "/usr/local/include/ibex/ibex_Random.h" 3
namespace ibex {

 class RNG {

 public:

  static bool srand();
  static bool srand(unsigned long s);
  static uint32_t rand();
  static double rand(double a, double b){return a+((double)(b-a)*RNG::rand())/(4294967295U);}

 private:
  static uint32_t x,y,z;
 };
}
# 20 "/usr/local/include/ibex/ibex_TemplateVector.h_" 2 3

# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 44 "/usr/include/c++/7/cassert" 2 3
# 22 "/usr/local/include/ibex/ibex_TemplateVector.h_" 2 3
# 1 "/usr/include/c++/7/sstream" 1 3
# 36 "/usr/include/c++/7/sstream" 3
       
# 37 "/usr/include/c++/7/sstream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {
# 64 "/usr/include/c++/7/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
      struct __xfer_bufptrs;
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 99 "/usr/include/c++/7/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 112 "/usr/include/c++/7/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }


      basic_stringbuf(const basic_stringbuf&) = delete;

      basic_stringbuf(basic_stringbuf&& __rhs)
      : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this))
      { __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0); }



      basic_stringbuf&
      operator=(const basic_stringbuf&) = delete;

      basic_stringbuf&
      operator=(basic_stringbuf&& __rhs)
      {
 __xfer_bufptrs __st{__rhs, this};
 const __streambuf_type& __base = __rhs;
 __streambuf_type::operator=(__base);
 this->pubimbue(__rhs.getloc());
 _M_mode = __rhs._M_mode;
 _M_string = std::move(__rhs._M_string);
 __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0);
 return *this;
      }

      void
      swap(basic_stringbuf& __rhs)
      {
 __xfer_bufptrs __l_st{*this, std::__addressof(__rhs)};
 __xfer_bufptrs __r_st{__rhs, this};
 __streambuf_type& __base = __rhs;
 __streambuf_type::swap(__base);
 __rhs.pubimbue(this->pubimbue(__rhs.getloc()));
 std::swap(_M_mode, __rhs._M_mode);
 std::swap(_M_string, __rhs._M_string);
      }
# 165 "/usr/include/c++/7/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 189 "/usr/include/c++/7/sstream" 3
      void
      str(const __string_type& __s)
      {


 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 242 "/usr/include/c++/7/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);

    private:




      struct __xfer_bufptrs
      {
 __xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)
 : _M_to{__to}, _M_goff{-1, -1, -1}, _M_poff{-1, -1, -1}
 {
   const _CharT* const __str = __from._M_string.data();
   const _CharT* __end = nullptr;
   if (__from.eback())
     {
       _M_goff[0] = __from.eback() - __str;
       _M_goff[1] = __from.gptr() - __str;
       _M_goff[2] = __from.egptr() - __str;
       __end = __from.egptr();
     }
   if (__from.pbase())
     {
       _M_poff[0] = __from.pbase() - __str;
       _M_poff[1] = __from.pptr() - __from.pbase();
       _M_poff[2] = __from.epptr() - __str;
       if (__from.pptr() > __end)
  __end = __from.pptr();
     }


   if (__end)
     {


       auto& __mut_from = const_cast<basic_stringbuf&>(__from);
       __mut_from._M_string._M_length(__end - __str);
     }
 }

 ~__xfer_bufptrs()
 {
   char_type* __str = const_cast<char_type*>(_M_to->_M_string.data());
   if (_M_goff[0] != -1)
     _M_to->setg(__str+_M_goff[0], __str+_M_goff[1], __str+_M_goff[2]);
   if (_M_poff[0] != -1)
     _M_to->_M_pbump(__str+_M_poff[0], __str+_M_poff[2], _M_poff[1]);
 }

 basic_stringbuf* _M_to;
 off_type _M_goff[3];
 off_type _M_poff[3];
      };
# 356 "/usr/include/c++/7/sstream" 3
      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)
      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)),
      _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string))
      { }

    };
# 379 "/usr/include/c++/7/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 415 "/usr/include/c++/7/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 433 "/usr/include/c++/7/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }


      basic_istringstream(const basic_istringstream&) = delete;

      basic_istringstream(basic_istringstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __istream_type::set_rdbuf(&_M_stringbuf); }



      basic_istringstream&
      operator=(const basic_istringstream&) = delete;

      basic_istringstream&
      operator=(basic_istringstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_istringstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 484 "/usr/include/c++/7/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 523 "/usr/include/c++/7/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 559 "/usr/include/c++/7/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 577 "/usr/include/c++/7/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }


      basic_ostringstream(const basic_ostringstream&) = delete;

      basic_ostringstream(basic_ostringstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __ostream_type::set_rdbuf(&_M_stringbuf); }



      basic_ostringstream&
      operator=(const basic_ostringstream&) = delete;

      basic_ostringstream&
      operator=(basic_ostringstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_ostringstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 628 "/usr/include/c++/7/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 667 "/usr/include/c++/7/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 702 "/usr/include/c++/7/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 718 "/usr/include/c++/7/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }


      basic_stringstream(const basic_stringstream&) = delete;

      basic_stringstream(basic_stringstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __iostream_type::set_rdbuf(&_M_stringbuf); }



      basic_stringstream&
      operator=(const basic_stringstream&) = delete;

      basic_stringstream&
      operator=(basic_stringstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_stringstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 769 "/usr/include/c++/7/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };



  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
  basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
  basic_istringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
  basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
  basic_stringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


}

}

# 1 "/usr/include/c++/7/bits/sstream.tcc" 1 3
# 37 "/usr/include/c++/7/bits/sstream.tcc" 3
       
# 38 "/usr/include/c++/7/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();


      if ((this->epptr() - this->pbase()) < __capacity)
 {

   char_type* __base = const_cast<char_type*>(_M_string.data());
   _M_pbump(__base, __base + __capacity, this->pptr() - this->pbase());
   if (_M_mode & ios_base::in)
     {
       const __size_type __nget = this->gptr() - this->eback();
       const __size_type __eget = this->egptr() - this->eback();
       this->setg(__base, __base + __nget, __base + __eget + 1);
     }
   *this->pptr() = traits_type::to_char_type(__c);
   this->pbump(1);
   return __c;
 }


      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 129 "/usr/include/c++/7/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
# 827 "/usr/include/c++/7/sstream" 2 3
# 23 "/usr/local/include/ibex/ibex_TemplateVector.h_" 2 3




namespace ibex {

namespace {


template<class V>
inline V& _inflate(V& v, double rad1) {
 if (v.is_empty()) return v;
 Interval r(-rad1,rad1);



 for (int i=0; i<v.size(); i++)
  v[i]+=r;
 return v;
}

template<class V>
inline V _subvector(const V& v, int start_index, int end_index) {
 (static_cast <bool> (!is_empty(v)) ? void (0) : __assert_fail ("!is_empty(v)", "/usr/local/include/ibex/ibex_TemplateVector.h_", 46, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (end_index>=0 && start_index>=0) ? void (0) : __assert_fail ("end_index>=0 && start_index>=0", "/usr/local/include/ibex/ibex_TemplateVector.h_", 47, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (end_index<v.size() && start_index<=end_index) ? void (0) : __assert_fail ("end_index<v.size() && start_index<=end_index", "/usr/local/include/ibex/ibex_TemplateVector.h_", 48, __extension__ __PRETTY_FUNCTION__));


 V v2(end_index-start_index+1);
 int j=0;
 for (int i=start_index; i<=end_index; i++) {
  v2[j++]=v[i];
 }
 return v2;
}

template<class V>
inline void _put(V& v, int start_index, const V& subvec) {
 (static_cast <bool> (!is_empty(v)) ? void (0) : __assert_fail ("!is_empty(v)", "/usr/local/include/ibex/ibex_TemplateVector.h_", 61, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (!is_empty(subvec)) ? void (0) : __assert_fail ("!is_empty(subvec)", "/usr/local/include/ibex/ibex_TemplateVector.h_", 62, __extension__ __PRETTY_FUNCTION__));
 int end_index=start_index+subvec.size()-1;
 (static_cast <bool> (start_index>=0 && end_index<v.size()) ? void (0) : __assert_fail ("start_index>=0 && end_index<v.size()", "/usr/local/include/ibex/ibex_TemplateVector.h_", 64, __extension__ __PRETTY_FUNCTION__));

 int j=0;
 for (int i=start_index; i<=end_index; i++) {
  v[i]=subvec[j++];
 }
}

template<class V1,class V2>
V1& _assignV(V1& v, const V2& x) {
 (static_cast <bool> (v.size()==x.size()) ? void (0) : __assert_fail ("v.size()==x.size()", "/usr/local/include/ibex/ibex_TemplateVector.h_", 74, __extension__ __PRETTY_FUNCTION__));

 if (is_empty(x))
  set_empty(v);
 else



  for (int i=0; i<v.size(); i++)
   v[i]=x[i];

 return v;
}

template<class V1,class V2>
bool _equalsV(const V1& v, const V2& x) {
 if (v.size()!=x.size()) return false;
 if (is_empty(v) || is_empty(x)) return is_empty(v) && is_empty(x);
 for (int i=0; i<v.size(); i++)
  if (v[i]!=(x[i])) return false;
 return true;
}


template<class V>
Vector _lb(const V& v) {
 (static_cast <bool> (!v.is_empty()) ? void (0) : __assert_fail ("!v.is_empty()", "/usr/local/include/ibex/ibex_TemplateVector.h_", 100, __extension__ __PRETTY_FUNCTION__));

 Vector l(v.size());
 for (int i=0; i<v.size(); i++) {
  l[i]=v[i].lb();
 }
 return l;
}

template<class V>
Vector _ub(const V& v) {
 (static_cast <bool> (!v.is_empty()) ? void (0) : __assert_fail ("!v.is_empty()", "/usr/local/include/ibex/ibex_TemplateVector.h_", 111, __extension__ __PRETTY_FUNCTION__));

 Vector u(v.size());
 for (int i=0; i<v.size(); i++) {
  u[i]=v[i].ub();
 }
 return u;
}

template<class V>
Vector _mid(const V& v) {
 (static_cast <bool> (!v.is_empty()) ? void (0) : __assert_fail ("!v.is_empty()", "/usr/local/include/ibex/ibex_TemplateVector.h_", 122, __extension__ __PRETTY_FUNCTION__));

 Vector mV(v.size());
 for (int i=0; i<v.size(); i++) {
  mV[i]=v[i].mid();
 }
 return mV;
}

template<class V>
Vector _mig(const V& v) {
 (static_cast <bool> (!v.is_empty()) ? void (0) : __assert_fail ("!v.is_empty()", "/usr/local/include/ibex/ibex_TemplateVector.h_", 133, __extension__ __PRETTY_FUNCTION__));

 Vector res(v.size());
 for (int i=0; i<v.size(); i++) {
  res[i]=v[i].mig();
 }
 return res;
}

template<class V>
Vector _mag(const V& v) {
 (static_cast <bool> (!v.is_empty()) ? void (0) : __assert_fail ("!v.is_empty()", "/usr/local/include/ibex/ibex_TemplateVector.h_", 144, __extension__ __PRETTY_FUNCTION__));

 Vector res(v.size());
 for (int i=0; i<v.size(); i++) {
  res[i]=v[i].mag();
 }
 return res;
}

template<class V>
bool _is_flat(const V& v) {
 if (v.is_empty()) return true;
 for (int i=0; i<v.size(); i++)
  if (v[i].is_degenerated())
   return true;
 return false;
}

template<class V>
bool _is_unbounded(const V& v) {
 if (v.is_empty()) return false;
 for (int i=0; i<v.size(); i++)
  if (v[i].is_unbounded()) return true;
 return false;
}

template<class V>
bool _is_zero(const V& v) {
 for (int i=0; i<v.size(); i++)
  if (v[i]!=Interval::ZERO) return false;
 return true;
}

template<class V>
bool _is_bisectable(const V& v) {
 for (int i=0; i<v.size(); i++)
  if (v[i].is_bisectable()) return true;
 return false;
}

template<class V>
Vector _rad(const V& v) {
 Vector r(v.size());
 for (int i=0; i<v.size(); i++)
  r[i]=v[i].rad();
 return r;
}

template<class V>
Vector _diam(const V& v) {
 Vector d(v.size());
 for (int i=0; i<v.size(); i++)
  d[i]=v[i].diam();
 return d;
}

template<class V>
int _extr_diam_index(const V& v, bool min) {
 double d=min? filib::primitive::compose(0,0x7FF,0,0) : -1;
 int selectedIndex=-1;
 bool unbounded=false;
 if (v.is_empty()) throw InvalidIntervalVectorOp("Diameter of an empty IntervalVector is undefined");
 int i;

 for (i=0; i<v.size(); i++) {
  if (v[i].is_unbounded()) {
   unbounded=true;
   if (!min) break;
  } else {
   double w=v[i].diam();
   if (min? w<d : w>d) {
    selectedIndex=i;
    d=w;
   }
  }
 }

 if (min && selectedIndex==-1) {
  (static_cast <bool> (unbounded) ? void (0) : __assert_fail ("unbounded", "/usr/local/include/ibex/ibex_TemplateVector.h_", 222, __extension__ __PRETTY_FUNCTION__));

  i=0;
 }



 if (unbounded && (!min || selectedIndex==-1)) {
  double pt = min? filib::primitive::compose(1,0x7FF,0,0) : filib::primitive::compose(0,0x7FF,0,0);
  selectedIndex=i;
  for (; i<v.size(); i++) {
   if (v[i].lb()==filib::primitive::compose(1,0x7FF,0,0)) {
    if (v[i].ub()==filib::primitive::compose(0,0x7FF,0,0)) {
     if (!min) {
      selectedIndex=i;
      break;
     }
    }
    if ((min && (-v[i].ub() > pt)) || (!min && (-v[i].ub() < pt))) {
     selectedIndex=i;
     pt=-v[i].ub();
    }
   } else if (v[i].ub()==filib::primitive::compose(0,0x7FF,0,0)) {
    if ((min && (v[i].lb() > pt)) || (!min && (v[i].lb() < pt))) {
     selectedIndex=i;
     pt=v[i].lb();
    }
   }
  }
 }

 return selectedIndex;
}

template<class V>
std::ostream& _displayV(std::ostream& os, const V& x) {
 if (is_empty(x)) return os << "empty vector";

 os << "(";
 for (int i=0; i<x.size(); i++)
  os << x[i] << (i<x.size()-1? " ; " : "");
 os << ")";
 return os;
}

template<class V>
double _volume(const V& v) {
 if (v[0].is_unbounded()) return filib::primitive::compose(0,0x7FF,0,0);
 if (v[0].is_degenerated()) return 0;
 double vol=::log((v[0]).diam());
 for (int i=1; i<v.size(); i++) {
  if (v[i].is_unbounded()) return filib::primitive::compose(0,0x7FF,0,0);
  if (v[i].is_degenerated()) return 0;
  vol+=::log((v[i]).diam());
 }
 return ::exp(vol);
}

template<class V>
double _perimeter(const V& v) {
 if (v[0].is_unbounded()) return filib::primitive::compose(0,0x7FF,0,0);
 double per=(v[0]).diam();
 for (int i=1; i<v.size(); i++) {
  if (v[i].is_unbounded()) return filib::primitive::compose(0,0x7FF,0,0);
  per+=(v[i]).diam();
 }
 return per;
}

template<class V1, class V2>
double _rel_distance(const V1& v, const V2& x) {
 double max = v[0].rel_distance(x[0]);
 for (int i=1; i<v.size(); i++) {
  double cand = v[i].rel_distance(x[i]);
  if (max<cand) max = cand;
 }
 return max;
}

template<class V>
std::pair<IntervalVector,IntervalVector> _bisect(const V& v, int i, double ratio) {
 (static_cast <bool> (0<ratio && ratio<1.0) ? void (0) : __assert_fail ("0<ratio && ratio<1.0", "/usr/local/include/ibex/ibex_TemplateVector.h_", 303, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (0<=i && i<v.size()) ? void (0) : __assert_fail ("0<=i && i<v.size()", "/usr/local/include/ibex/ibex_TemplateVector.h_", 304, __extension__ __PRETTY_FUNCTION__));

 if (!v[i].is_bisectable()) {
  std::ostringstream oss;
  oss << "Unable to bisect " << v;
  throw InvalidIntervalVectorOp(oss.str());
 }
 IntervalVector left(v);
 IntervalVector right(v);

 std::pair<Interval,Interval> p=v[i].bisect(ratio);

 left[i] = p.first;
 right[i] = p.second;

 return std::pair<IntervalVector,IntervalVector>(left,right);
}

template<class V,class T>
Vector _random(const V& v,int seed) {
 (static_cast <bool> (!v.is_empty()) ? void (0) : __assert_fail ("!v.is_empty()", "/usr/local/include/ibex/ibex_TemplateVector.h_", 324, __extension__ __PRETTY_FUNCTION__));
 RNG::srand(seed);
 Vector b(v.size());
 for (int i=0; i<v.size(); i++) {
  const T& xi=v[i];

   double p;

  if (xi.lb()==filib::primitive::compose(1,0x7FF,0,0))
   if (xi.ub()==filib::primitive::compose(0,0x7FF,0,0))
    p=RNG::rand();
   else
    p=xi.ub()-RNG::rand();
  else
   if (xi.ub()==filib::primitive::compose(0,0x7FF,0,0))
    p=xi.lb()+RNG::rand();
   else {


    p = RNG::rand(xi.lb(), xi.ub());
   }


  if (p<xi.lb()) p=xi.lb();
  else if (p>xi.ub()) p=xi.ub();
  b[i]=p;
 }
 return b;
}


template<class V,class T>
Vector _random(const V& v) {
 (static_cast <bool> (!v.is_empty()) ? void (0) : __assert_fail ("!v.is_empty()", "/usr/local/include/ibex/ibex_TemplateVector.h_", 357, __extension__ __PRETTY_FUNCTION__));
 Vector b(v.size());
 for (int i=0; i<v.size(); i++) {
  const T& xi=v[i];

   double p;

  if (xi.lb()==filib::primitive::compose(1,0x7FF,0,0))
   if (xi.ub()==filib::primitive::compose(0,0x7FF,0,0))
    p=RNG::rand();
   else
    p=xi.ub()-RNG::rand();
  else
   if (xi.ub()==filib::primitive::compose(0,0x7FF,0,0))
    p=xi.lb()+RNG::rand();
   else {


    p = RNG::rand(xi.lb(), xi.ub());
   }


  if (p<xi.lb()) p=xi.lb();
  else if (p>xi.ub()) p=xi.ub();
  b[i]=p;
 }
 return b;
}


}

}
# 16 "/usr/local/include/ibex/ibex_Affine2Vector.h_" 2 3

namespace ibex {

template<class T>
IntervalVector& IntervalVector::operator=(const Affine2MainVector<T>& x) {
 resize(x.size());
 for (int i = 0; i < size(); i++){
  vec[i] = x[i].itv();
 }
 return *this;
}

template<class T>
IntervalVector::IntervalVector(const Affine2MainVector<T>& x) : n(x.size()), vec(new Interval[x.size()]) {
 for (int i=0; i<n; i++) vec[i]=x[i].itv();
}


template<class T>
Affine2MainVector<T>::Affine2MainVector(int n) :
  _n(n),
  _vec(new Affine2Main<T>[n]) {
 (static_cast <bool> (n>=1) ? void (0) : __assert_fail ("n>=1", "/usr/local/include/ibex/ibex_Affine2Vector.h_", 38, __extension__ __PRETTY_FUNCTION__));
 for (int i = 0; i < n; i++){
  _vec[i] = Affine2Main<T>();
 }
}

template<class T>
Affine2MainVector<T>::Affine2MainVector(int n, const Interval& x, bool b) :
  _n(n),
  _vec(new Affine2Main<T>[n]) {
 (static_cast <bool> (n>=1) ? void (0) : __assert_fail ("n>=1", "/usr/local/include/ibex/ibex_Affine2Vector.h_", 48, __extension__ __PRETTY_FUNCTION__));
 if (!b) {
  for (int i = 0; i < n; i++) {
   _vec[i] = Affine2Main<T>(x);
  }
 } else {
  for (int i = 0; i < n; i++) {
   _vec[i] = Affine2Main<T>(n, i + 1, x);
  }
 }
}

template<class T>
Affine2MainVector<T>::Affine2MainVector(int n, const Affine2Main<T>& x) :
  _n(n),
  _vec(new Affine2Main<T>[n]) {
 (static_cast <bool> (n>=1) ? void (0) : __assert_fail ("n>=1", "/usr/local/include/ibex/ibex_Affine2Vector.h_", 64, __extension__ __PRETTY_FUNCTION__));
 for (int i = 0; i < n; i++) {
  _vec[i] = x;
 }
}


template<class T>
Affine2MainVector<T>::Affine2MainVector(const Affine2MainVector<T>& x) :
  _n(x.size()),
  _vec(new Affine2Main<T>[x.size()]) {

 for (int i = 0; i < _n; i++){
  _vec[i] = Affine2Main<T>(x[i]);
 }

}

template<class T>
Affine2MainVector<T>::Affine2MainVector(int n, double bounds[][2], bool b) :
  _n(n),
  _vec(new Affine2Main<T>[n]) {
 if (bounds == 0){
  for (int i = 0; i < n; i++){
   _vec[i] = Affine2Main<T>( 0.0);
  }
 }
 else {
  if (!b) {
   for (int i = 0; i < n; i++){
    _vec[i] = Affine2Main<T>(Interval(bounds[i][0], bounds[i][1]));
   }
  } else {
   for (int i = 0; i < n; i++){
    _vec[i] = Affine2Main<T>(n, i + 1, Interval(bounds[i][0], bounds[i][1]));
   }
  }
 }
}


template<class T>
Affine2MainVector<T>::Affine2MainVector(const IntervalVector& x, bool b) :
  _n(x.size()),
  _vec(new Affine2Main<T>[x.size()]) {
 if (!b) {
  for (int i = 0; i < x.size(); i++) {
   _vec[i] = Affine2Main<T>(x[i]);
  }
 } else {
  for (int i = 0; i < x.size(); i++) {
   _vec[i] = Affine2Main<T>(x.size(), i + 1, x[i]);
  }
 }
}

template<class T>
Affine2MainVector<T>::Affine2MainVector(const Vector& x) :
  _n(x.size()),
  _vec(new Affine2Main<T>[x.size()]) {
 for (int i = 0; i < _n; i++){
  _vec[i] = Affine2Main<T>(x[i]);
 }
}

template<class T>
void Affine2MainVector<T>::init(const Interval& x, bool b) {
 if (!b) {
  for (int i = 0; i < size(); i++) {
   (*this)[i] = Affine2Main<T>(x);
  }
 } else {
  for (int i = 0; i < size(); i++) {
   (*this)[i] = Affine2Main<T>(size(),i+1,x);
  }
 }
}
template<class T>
void Affine2MainVector<T>::init(const Affine2Main<T>& x) {
 for (int i = 0; i < size(); i++) {
  (*this)[i] = x;
 }
}

template<class T>
void Affine2MainVector<T>::resize(int n) {
 (static_cast <bool> (n>=1) ? void (0) : __assert_fail ("n>=1", "/usr/local/include/ibex/ibex_Affine2Vector.h_", 150, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> ((_vec==__null && _n==0) || (size()!=0 && _vec!=__null)) ? void (0) : __assert_fail ("(_vec==NULL && _n==0) || (size()!=0 && _vec!=NULL)", "/usr/local/include/ibex/ibex_Affine2Vector.h_", 151, __extension__ __PRETTY_FUNCTION__));

 if (n==size()) return;

 Affine2Main<T>* newVec=new Affine2Main<T>[n];
 int i=0;
 for (; i<size() && i<n; i++){
  newVec[i]=_vec[i];
 }
 for (; i<n; i++){
  newVec[i]= Affine2Main<T>();
 }
 if (_vec!=__null) {
  delete[] _vec;
 }
 _n = n;
 _vec = newVec;
}

template<class T>
IntervalVector operator&(const Affine2MainVector<T>& y,const IntervalVector& x) {

 if (y.size()!=x.size()) throw InvalidIntervalVectorOp("Cannot intersect Affine2MainVector<T>es with different dimensions");

 if (y.is_empty()||x.is_empty())
  return IntervalVector::empty(y.size());

 IntervalVector res(y.size());
 for (int i=0; i<y.size(); i++) {
  res [i] = y[i] & x[i];
  if (res[i].is_empty()) {
   res.set_empty();
   return res;
  }
 }
 return res;
}
template<class T>
IntervalVector operator&(const Affine2MainVector<T>& y,const Affine2MainVector<T>& x) {

 if (y.size()!=x.size()) throw InvalidIntervalVectorOp("Cannot intersect Affine2MainVector<T>es with different dimensions");

 if (y.is_empty()||x.is_empty())
  return IntervalVector::empty(y.size());

 IntervalVector res(y.size());
 for (int i=0; i<y.size(); i++) {
  res [i] = y[i] & x[i];
  if (res[i].is_empty()) {
   res.set_empty();
   return res;
  }
 }
 return res;
}
template<class T>
IntervalVector operator|(const Affine2MainVector<T>& y,const IntervalVector& x) {

 if (y.size()!=x.size()) throw InvalidIntervalVectorOp("Cannot make the hull of Affine2MainVector<T>es with different dimensions");

 if (y.is_empty()&&x.is_empty())
  return IntervalVector::empty(y.size());

 IntervalVector res(y.size());
 for (int i=0; i<y.size(); i++) {
  res [i] = y[i] | x[i];
 }
 return res;
}
template<class T>
IntervalVector operator|(const Affine2MainVector<T>& y,const Affine2MainVector<T>& x) {

 if (y.size()!=x.size()) throw InvalidIntervalVectorOp("Cannot make the hull of Affine2MainVector<T>es with different dimensions");

 if (y.is_empty()&&x.is_empty())
  return IntervalVector::empty(y.size());

 IntervalVector res(y.size());
 for (int i=0; i<y.size(); i++) {
  res [i] = y[i] | x[i];
 }
 return res;
}


template<class T>
IntervalVector Affine2MainVector<T>::itv() const {
 (static_cast <bool> (!is_empty()) ? void (0) : __assert_fail ("!is_empty()", "/usr/local/include/ibex/ibex_Affine2Vector.h_", 238, __extension__ __PRETTY_FUNCTION__));
 IntervalVector intv(_n);
 for (int i = 0; i < _n; i++) {
  intv[i] = (*this)[i].itv();
 }
 return intv;
}



template<class T>
Affine2Main<T> operator*(const Vector& v1, const Affine2MainVector<T>& v2) {
 (static_cast <bool> (v1.size()==v2.size()) ? void (0) : __assert_fail ("v1.size()==v2.size()", "/usr/local/include/ibex/ibex_Affine2Vector.h_", 250, __extension__ __PRETTY_FUNCTION__));

 int n=v1.size();
 Affine2Main<T> y(0);

 if (v2.is_empty()) {
  y.set_empty();
  return y;
 }

 for (int i=0; i<n; i++) {
  y+=v1[i]*v2[i];
 }
 return y;
}

template<class T>
Affine2Main<T> operator*(const Affine2MainVector<T>& v1, const Vector& v2) {
 (static_cast <bool> (v1.size()==v2.size()) ? void (0) : __assert_fail ("v1.size()==v2.size()", "/usr/local/include/ibex/ibex_Affine2Vector.h_", 268, __extension__ __PRETTY_FUNCTION__));

 int n=v1.size();
 Affine2Main<T> y(0);

 if (v1.is_empty()) {
  y.set_empty();
  return y;
 }

 for (int i=0; i<n; i++) {
  y+=v1[i]*v2[i];
 }
 return y;
}


template<class T>
Affine2Main<T> operator*(const IntervalVector& x1, const Affine2MainVector<T>& x2){
 return x2*x1;
}

template<class T>
Affine2Main<T> operator*(const Affine2MainVector<T>& v1, const IntervalVector& v2) {
 (static_cast <bool> (v1.size()==v2.size()) ? void (0) : __assert_fail ("v1.size()==v2.size()", "/usr/local/include/ibex/ibex_Affine2Vector.h_", 292, __extension__ __PRETTY_FUNCTION__));

 int n=v1.size();
 Affine2Main<T> y(0);

 if (v1.is_empty() || v2.is_empty()) {
  y.set_empty();
  return y;
 }

 for (int i=0; i<n; i++) {
  y+=v1[i] * v2[i];
 }
 return y;
}

template<class T>
Affine2Main<T> operator*(const Affine2MainVector<T>& v1, const Affine2MainVector<T>& v2) {
 (static_cast <bool> (v1.size()==v2.size()) ? void (0) : __assert_fail ("v1.size()==v2.size()", "/usr/local/include/ibex/ibex_Affine2Vector.h_", 310, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (v1.size()==v2.size()) ? void (0) : __assert_fail ("v1.size()==v2.size()", "/usr/local/include/ibex/ibex_Affine2Vector.h_", 311, __extension__ __PRETTY_FUNCTION__));

 int n=v1.size();
 Affine2Main<T> y(0);

 if (v1.is_empty() || v2.is_empty()) {
  y.set_empty();
  return y;
 }

 for (int i=0; i<n; i++) {
  y+=v1[i] * v2[i];
 }
 return y;
}

template<class T>
Affine2MainVector<T> operator*(const Affine2Main<T>& x1, const Vector& x2) {
 Affine2MainVector<T> res(x2.size(),x1);
 for (int i=0; i<x2.size(); i++) {
  res[i] *= x2[i];
 }
 return res;
}

template<class T>
Affine2MainVector<T>& Affine2MainVector<T>::inflate(double rad1) { return _inflate(*this,rad1); }
template<class T>
Affine2MainVector<T> Affine2MainVector<T>::subvector(int start_index, int end_index) const { return _subvector(*this,start_index,end_index); }
template<class T>
void Affine2MainVector<T>::put(int start_index, const Affine2MainVector<T>& subvec) { _put(*this, start_index, subvec); }
template<class T>
Affine2MainVector<T>& Affine2MainVector<T>::operator=(const Affine2MainVector<T>& x) { resize(x.size());
                                                                                  return _assignV(*this,x); }
template<class T>
Affine2MainVector<T>& Affine2MainVector<T>::operator=(const IntervalVector& x) { return _assignV(*this,x); }
template<class T>
bool Affine2MainVector<T>::operator==(const Affine2MainVector<T>& x) const { return _equalsV(*this,x); }
template<class T>
bool Affine2MainVector<T>::operator==(const IntervalVector& x) const { return _equalsV(*this,x); }







template<class T>
bool Affine2MainVector<T>::is_unbounded() const { return _is_unbounded(*this); }
# 369 "/usr/local/include/ibex/ibex_Affine2Vector.h_" 3
template<class T>
std::ostream& operator<<(std::ostream& os, const Affine2MainVector<T>& x) { return _displayV(os,x); }
# 383 "/usr/local/include/ibex/ibex_Affine2Vector.h_" 3
}
# 467 "/usr/local/include/ibex/ibex_Affine2Vector.h" 2 3

namespace ibex {


template<class T>
inline Affine2MainVector<T> Affine2MainVector<T>::empty(int n) {
 return Affine2MainVector<T>(n, Interval::EMPTY_SET);
}

template<class T>
inline Affine2MainVector<T>::~Affine2MainVector<T>() {
 delete[] _vec;
}

template<class T>
inline void Affine2MainVector<T>::set_empty() {
 (*this)[0] = Interval::EMPTY_SET;
}

template<class T>
inline const Affine2Main<T>& Affine2MainVector<T>::operator[](int i) const {
 (static_cast <bool> (i>=0 && i<_n) ? void (0) : __assert_fail ("i>=0 && i<_n", "/usr/local/include/ibex/ibex_Affine2Vector.h", 488, __extension__ __PRETTY_FUNCTION__));
 return _vec[i];
}

template<class T>
inline Affine2Main<T>& Affine2MainVector<T>::operator[](int i) {
 (static_cast <bool> (i>=0 && i<_n) ? void (0) : __assert_fail ("i>=0 && i<_n", "/usr/local/include/ibex/ibex_Affine2Vector.h", 494, __extension__ __PRETTY_FUNCTION__));
 return _vec[i];
}

template<class T>
inline void Affine2MainVector<T>::clear() {
 init(0);
}

template<class T>
inline bool Affine2MainVector<T>::operator!=(const IntervalVector& x) const {
 return !(*this==x);
}
template<class T>
inline bool Affine2MainVector<T>::operator!=(const Affine2MainVector<T>& x) const {
 return !(*this==x);
}

template<class T>
inline int Affine2MainVector<T>::size() const {
 return _n;
}

template<class T>
inline bool Affine2MainVector<T>::is_empty() const {
 return (*this)[0].is_empty();
}

template<class T>
inline IntervalVector operator&(const IntervalVector& x, const Affine2MainVector<T>& y) {
 return (y & x);
}

template<class T>
inline IntervalVector operator|(const IntervalVector& x, const Affine2MainVector<T>& y) {
 return (y | x);
}

template<class T>
inline Affine2MainVector<T> cart_prod(const Affine2MainVector<T>& x, const Affine2MainVector<T>& y) {
 Affine2MainVector<T> z(x.size()+y.size());
 z.put(0,x);
 z.put(x.size(),y);
 return z;
}


template<class T>
inline void Affine2MainVector<T>::compact(double tol) {
 (static_cast <bool> (!is_empty()) ? void (0) : __assert_fail ("!is_empty()", "/usr/local/include/ibex/ibex_Affine2Vector.h", 543, __extension__ __PRETTY_FUNCTION__));
 for (int i = 0; i < _n; i++) { _vec[i].compact(tol); }
}

template<class T>
inline void Affine2MainVector<T>::compact() {
 (static_cast <bool> (!is_empty()) ? void (0) : __assert_fail ("!is_empty()", "/usr/local/include/ibex/ibex_Affine2Vector.h", 549, __extension__ __PRETTY_FUNCTION__));
 for (int i = 0; i < _n; i++) { _vec[i].compact(); }
}



template<class T>
inline Affine2MainVector<T> operator-(const Affine2MainVector<T>& x) {
 return minusV(x);
}


template<class T>
Affine2MainVector<T>& Affine2MainVector<T>::operator+=(const Vector& x2) {
 return set_addV<Affine2MainVector<T>,Vector>(*this,x2);
}

template<class T>
inline Affine2MainVector<T>& Affine2MainVector<T>::operator+=(const IntervalVector& x2) {
 return set_addV<Affine2MainVector<T>,IntervalVector>(*this,x2);
}

template<class T>
inline Affine2MainVector<T>& Affine2MainVector<T>::operator+=(const Affine2MainVector<T>& x2) {
 return set_addV<Affine2MainVector<T>,Affine2MainVector<T> >(*this,x2);
}

template<class T>
inline Affine2MainVector<T>& Affine2MainVector<T>::operator-=(const Vector& x2) {
 return set_subV<Affine2MainVector<T>,Vector>(*this,x2);
}

template<class T>
inline Affine2MainVector<T>& Affine2MainVector<T>::operator-=(const IntervalVector& x2) {
 return set_subV<Affine2MainVector<T>,IntervalVector>(*this,x2);
}

template<class T>
inline Affine2MainVector<T>& Affine2MainVector<T>::operator-=(const Affine2MainVector<T>& x2) {
 return set_subV<Affine2MainVector<T>,Affine2MainVector<T> >(*this,x2);
}

template<class T>
inline Affine2MainVector<T>& Affine2MainVector<T>::operator*=(double d) {
 return set_mulSV<double,Affine2MainVector<T> >(d,*this);
}

template<class T>
inline Affine2MainVector<T>& Affine2MainVector<T>::operator*=(const Interval& x1) {
 return set_mulSV<Interval,Affine2MainVector<T> >(x1,*this);
}

template<class T>
inline Affine2MainVector<T>& Affine2MainVector<T>::operator*=(const Affine2Main<T>& x1) {
 return set_mulSV<Affine2Main<T>,Affine2MainVector<T> >(x1,*this);
}

template<class T>
inline Affine2MainVector<T> abs( const Affine2MainVector<T>& x) {
 return absV(x);
}


template<class T>
inline Affine2MainVector<T> operator+(const Vector& x1, const Affine2MainVector<T>& x2) {
 return Affine2MainVector<T>(x2)+=x1;
}

template<class T>
inline Affine2MainVector<T> operator+(const Affine2MainVector<T>& x1, const Vector& x2) {
 return Affine2MainVector<T>(x1)+=x2;
}

template<class T>
inline Affine2MainVector<T> operator+(const IntervalVector& x1, const Affine2MainVector<T>& x2) {
 return x2 + x1;
}

template<class T>
inline Affine2MainVector<T> operator+(const Affine2MainVector<T>& x1, const IntervalVector& x2) {
 return Affine2MainVector<T>(x1)+=x2;
}

template<class T>
Affine2MainVector<T> operator+(const Affine2MainVector<T>& x1, const Affine2MainVector<T>& x2) {
 return Affine2MainVector<T>(x1)+=x2;
}


template<class T>
inline Affine2MainVector<T> operator-(const Vector& x1, const Affine2MainVector<T>& x2) {
 Affine2MainVector<T> res(x2.size());
 res = (-x2);
 return res += x1;
}

template<class T>
inline Affine2MainVector<T> operator-(const Affine2MainVector<T>& x1, const Vector& x2) {
 return Affine2MainVector<T>(x1)-=x2;
}

template<class T>
inline Affine2MainVector<T> operator-(const Affine2MainVector<T>& x1, const IntervalVector& x2) {
 return Affine2MainVector<T>(x1)-=x2;
}

template<class T>
inline Affine2MainVector<T> operator-(const IntervalVector& x1, const Affine2MainVector<T>& x2) {
 Affine2MainVector<T> res(x2.size());
 res = (-x2);
 return res += x1;
}
template<class T>
inline Affine2MainVector<T> operator-(const Affine2MainVector<T>& x1, const Affine2MainVector<T>& x2) {
 return Affine2MainVector<T>(x1) += (-x2);
}

template<class T>
inline Affine2MainVector<T> operator*(double d, const Affine2MainVector<T>& x) {
 return Affine2MainVector<T>(x)*=d;
}

template<class T>
inline Affine2MainVector<T> operator*(const Affine2Main<T>& x1, const Affine2MainVector<T>& x2) {
 return Affine2MainVector<T>(x2)*=x1;
}

template<class T>
inline Affine2MainVector<T> operator*(const Interval& x1, const Affine2MainVector<T>& x2) {
 return Affine2MainVector<T>(x2)*=x1;
}

template<class T>
inline Affine2MainVector<T> operator*(const IntervalMatrix& m, const Affine2MainVector<T>& x) {
 return mulMV<IntervalMatrix,Affine2MainVector<T>,Affine2MainVector<T> >(m,x);
}

template<class T>
inline Affine2MainVector<T> operator*(const Affine2MainVector<T>& x, const Matrix& m) {
 return mulVM<Affine2MainVector<T>,Matrix,Affine2MainVector<T> >(x,m);
}


template<class T>
inline Affine2MainVector<T> operator*(const Affine2MainVector<T>& x, const IntervalMatrix& m) {
 return mulVM<Affine2MainVector<T>,IntervalMatrix,Affine2MainVector<T> >(x,m);
}



}
# 18 "/usr/local/include/ibex/ibex_Affine2Matrix.h" 2 3

namespace ibex {

template<class T> class Affine2MainMatrixArray;
# 30 "/usr/local/include/ibex/ibex_Affine2Matrix.h" 3
typedef Affine2MainMatrix<AF_Default> Affine2Matrix;
typedef Affine2MainMatrix<AF_Linear> AffineLinMatrix;

template<class T=AF_Default>
class Affine2MainMatrix {

private:
 friend class Affine2MainMatrixArray<T>;

 Affine2MainMatrix();

 int _nb_rows;
 int _nb_cols;
 Affine2MainVector<T>* _M;

public:



 Affine2MainMatrix(int nb_rows, int nb_cols);





 Affine2MainMatrix(int nb_rows, int nb_cols, const Affine2Main<T>& x);





 explicit Affine2MainMatrix(const IntervalMatrix& m);




 Affine2MainMatrix(const Affine2MainMatrix& x);





 explicit Affine2MainMatrix(const Matrix& m);
# 86 "/usr/local/include/ibex/ibex_Affine2Matrix.h" 3
 Affine2MainMatrix(int m, int n, double x[][2]);




 ~Affine2MainMatrix();
# 101 "/usr/local/include/ibex/ibex_Affine2Matrix.h" 3
 static Affine2MainMatrix empty(int m, int n);




 Affine2MainMatrix& operator=(const Affine2MainMatrix& x);
 Affine2MainMatrix& operator=(const IntervalMatrix& x);





 void clear();






 void init(const Affine2Main<T>& x);
 void init(const Interval& x);







 bool operator==(const Affine2MainMatrix& m) const;
 bool operator==(const IntervalMatrix& m) const;




 bool operator!=(const Affine2MainMatrix& m) const;
 bool operator!=(const IntervalMatrix& m) const;






 IntervalMatrix itv() const;




 void resize(int nb_rows, int nb_cols);




 int nb_cols() const;




 int nb_rows() const;




 bool is_empty() const;






 Affine2MainVector<T>& operator[](int i);






 const Affine2MainVector<T>& operator[](int i) const;






 void set_empty();




 Affine2MainMatrix submatrix(int row_start_index, int row_end_index, int col_start_index, int col_end_index);




 Affine2MainMatrix transpose() const;






 Affine2MainVector<T>& row(int i);






 const Affine2MainVector<T>& row(int i) const;




 Affine2MainVector<T> col(int i) const;




 Affine2MainMatrix rows(int start_index, int end_index);




 Affine2MainMatrix cols(int start_index, int end_index);




 void set_row(int row, const Affine2MainVector<T>& v);





 void set_col(int col, const Affine2MainVector<T>& v);





    Affine2MainMatrix& operator+=(const Matrix& m);




    Affine2MainMatrix& operator+=(const Affine2MainMatrix& m);
    Affine2MainMatrix& operator+=(const IntervalMatrix& m);




    Affine2MainMatrix& operator-=(const Matrix& m);




    Affine2MainMatrix& operator-=(const Affine2MainMatrix& m);
    Affine2MainMatrix& operator-=(const IntervalMatrix& m);






 Affine2MainMatrix& inflate(double rad);




    Affine2MainMatrix& operator*=(double x);




    Affine2MainMatrix& operator*=(const Affine2Main<T>& x);
    Affine2MainMatrix& operator*=(const Interval& x);




    Affine2MainMatrix& operator*=(const Matrix& m);




    Affine2MainMatrix& operator*=(const Affine2MainMatrix& m);
    Affine2MainMatrix& operator*=(const IntervalMatrix& m);


};







template<class T>
IntervalMatrix operator&(const Affine2MainMatrix<T>& x, const Affine2MainMatrix<T>& y);
template<class T>
IntervalMatrix operator&(const IntervalMatrix& x, const Affine2MainMatrix<T>& y);
template<class T>
IntervalMatrix operator&(const Affine2MainMatrix<T>& x, const IntervalMatrix& y);




template<class T>
IntervalMatrix operator|(const Affine2MainMatrix<T>& x, const Affine2MainMatrix<T>& y);
template<class T>
IntervalMatrix operator|(const IntervalMatrix& x, const Affine2MainMatrix<T>& y);
template<class T>
IntervalMatrix operator|(const Affine2MainMatrix<T>& x, const IntervalMatrix& y);




template<class T>
Affine2MainMatrix<T> operator-(const Affine2MainMatrix<T>& m);




template<class T>
Affine2MainMatrix<T> operator+(const Affine2MainMatrix<T>& m1, const Matrix& m2);




template<class T>
Affine2MainMatrix<T> operator+(const Matrix& m1, const Affine2MainMatrix<T>& m2);




template<class T>
Affine2MainMatrix<T> operator+(const Affine2MainMatrix<T>& m1, const Affine2MainMatrix<T>& m2);
template<class T>
Affine2MainMatrix<T> operator+(const Affine2MainMatrix<T>& m1, const IntervalMatrix& m2);
template<class T>
Affine2MainMatrix<T> operator+(const IntervalMatrix& m1, const Affine2MainMatrix<T>& m2);




template<class T>
Affine2MainMatrix<T> operator-(const Affine2MainMatrix<T>& m1, const Matrix& m2);




template<class T>
Affine2MainMatrix<T> operator-(const Matrix& m1, const Affine2MainMatrix<T>& m2);




template<class T>
Affine2MainMatrix<T> operator-(const Affine2MainMatrix<T>& m1, const Affine2MainMatrix<T>& m2);
template<class T>
Affine2MainMatrix<T> operator-(const Affine2MainMatrix<T>& m1, const IntervalMatrix& m2);
template<class T>
Affine2MainMatrix<T> operator-(const IntervalMatrix& m1, const Affine2MainMatrix<T>& m2);




template<class T>
Affine2MainMatrix<T> operator*(double d, const Affine2MainMatrix<T>& m);




template<class T>
Affine2MainMatrix<T> operator*(const Affine2Main<T>& x, const Matrix& m);




template<class T>
Affine2MainMatrix<T> operator*(const Affine2Main<T>& x, const Affine2MainMatrix<T>& m);
template<class T>
Affine2MainMatrix<T> operator*(const Interval& x, const Affine2MainMatrix<T>& m);
template<class T>
Affine2MainMatrix<T> operator*(const Affine2Main<T>& x, const IntervalMatrix& m);





template<class T>
Affine2MainVector<T> operator*(const Affine2MainMatrix<T>& m, const Vector& x);




template<class T>
Affine2MainVector<T> operator*(const Matrix& m, const Affine2MainVector<T>& x);




template<class T>
Affine2MainVector<T> operator*(const Affine2MainMatrix<T>& m, const Affine2MainVector<T>& x);
template<class T>
Affine2MainVector<T> operator*(const Affine2MainMatrix<T>& m, const IntervalVector& x);
template<class T>
Affine2MainVector<T> operator*(const IntervalMatrix& m, const Affine2MainVector<T>& x);




template<class T>
Affine2MainVector<T> operator*(const Vector& x, const Affine2MainMatrix<T>& m);




template<class T>
Affine2MainVector<T> operator*(const Affine2MainVector<T>& x, const Matrix& m);




template<class T>
Affine2MainVector<T> operator*(const Affine2MainVector<T>& x, const Affine2MainMatrix<T>& m);
template<class T>
Affine2MainVector<T> operator*(const Affine2MainVector<T>& x, const IntervalMatrix& m);
template<class T>
Affine2MainVector<T> operator*(const IntervalVector& x, const Affine2MainMatrix<T>& m);




template<class T>
Affine2MainMatrix<T> operator*(const Affine2MainMatrix<T>& m1, const Matrix& m2);




template<class T>
Affine2MainMatrix<T> operator*(const Matrix& m1, const Affine2MainMatrix<T>& m2);




template<class T>
Affine2MainMatrix<T> operator*(const Affine2MainMatrix<T>& m1, const Affine2MainMatrix<T>& m2);
template<class T>
Affine2MainMatrix<T> operator*(const Affine2MainMatrix<T>& m1, const IntervalMatrix& m2);
template<class T>
Affine2MainMatrix<T> operator*(const IntervalMatrix& m1, const Affine2MainMatrix<T>& m2);




template<class T>
Affine2MainMatrix<T> outer_product(const Affine2MainVector<T>& x1, const Vector& x2);




template<class T>
Affine2MainMatrix<T> outer_product(const Vector& x1, const Affine2MainVector<T>& x2);




template<class T>
Affine2MainMatrix<T> outer_product(const Affine2MainVector<T>& x1, const Affine2MainVector<T>& x2);
template<class T>
Affine2MainMatrix<T> outer_product(const Affine2MainVector<T>& x1, const IntervalVector& x2);
template<class T>
Affine2MainMatrix<T> outer_product(const IntervalVector& x1, const Affine2MainVector<T>& x2);




template<class T>
Affine2MainMatrix<T> abs(const Affine2MainMatrix<T>& m);





template<class T>
std::ostream& operator<<(std::ostream& os, const Affine2MainMatrix<T>&);







namespace {
# 506 "/usr/local/include/ibex/ibex_Affine2Matrix.h" 3
template<class T> inline bool is_empty(const Affine2MainMatrix<T>& m) { return m.is_empty(); }
# 518 "/usr/local/include/ibex/ibex_Affine2Matrix.h" 3
template<class T> inline void set_empty(Affine2MainMatrix<T>& m) { m.set_empty(); }

}

}


# 1 "/usr/local/include/ibex/ibex_Affine2Matrix.h_" 1 3
# 15 "/usr/local/include/ibex/ibex_Affine2Matrix.h_" 3
# 1 "/usr/local/include/ibex/ibex_TemplateMatrix.h_" 1 3
# 19 "/usr/local/include/ibex/ibex_TemplateMatrix.h_" 3
# 1 "/usr/local/include/ibex/ibex_Affine2Matrix.h" 1 3
# 20 "/usr/local/include/ibex/ibex_TemplateMatrix.h_" 2 3


# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 44 "/usr/include/c++/7/cassert" 2 3
# 23 "/usr/local/include/ibex/ibex_TemplateMatrix.h_" 2 3

namespace ibex {

namespace {


template<class V1,class V2>
bool _is_subsetM(const V1& v, const V2& x) {
 if (v.is_empty()) return true;
 for (int i=0; i<v.nb_rows(); i++)
  if (!v[i].is_subset(x[i])) return false;
 return true;
}

template<class V1,class V2>
bool _is_strict_subsetM(const V1& v, const V2& x) {
 if (v.is_empty() && !x.is_empty()) return true;
 if (x.is_empty()) return false;
 for (int i=0; i<v.nb_rows(); i++)
  if (!v[i].is_strict_subset(x[i])) return false;
 return true;
}

template<class M>
inline M _submatrix(const M& m, int row_start_index, int row_end_index, int col_start_index, int col_end_index) {
 (static_cast <bool> (row_start_index>=0 && row_start_index<m.nb_rows()) ? void (0) : __assert_fail ("row_start_index>=0 && row_start_index<m.nb_rows()", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 48, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (row_end_index>=0 && row_end_index<m.nb_rows()) ? void (0) : __assert_fail ("row_end_index>=0 && row_end_index<m.nb_rows()", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 49, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (row_start_index<=row_end_index) ? void (0) : __assert_fail ("row_start_index<=row_end_index", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 50, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (col_start_index>=0 && col_start_index<m.nb_cols()) ? void (0) : __assert_fail ("col_start_index>=0 && col_start_index<m.nb_cols()", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 51, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (col_end_index>=0 && col_end_index<m.nb_cols()) ? void (0) : __assert_fail ("col_end_index>=0 && col_end_index<m.nb_cols()", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 52, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (col_start_index<=col_end_index) ? void (0) : __assert_fail ("col_start_index<=col_end_index", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 53, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (!is_empty(m)) ? void (0) : __assert_fail ("!is_empty(m)", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 54, __extension__ __PRETTY_FUNCTION__));

 M sub(row_end_index-row_start_index+1, col_end_index-col_start_index+1);


 int i2=0;
 for (int i=row_start_index; i<=row_end_index; i++, i2++) {
  int j2=0;
  for (int j=col_start_index; j<=col_end_index; j++,j2++)
   sub[i2][j2] = m[i][j];
 }
 return sub;
}


template<class M1, class M2>
inline void _put(M1& m, int row_start_index, int col_start_index, const M2& sub) {
 (static_cast <bool> (row_start_index>=0) ? void (0) : __assert_fail ("row_start_index>=0", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 71, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (row_start_index+sub.nb_rows()<=m.nb_rows()) ? void (0) : __assert_fail ("row_start_index+sub.nb_rows()<=m.nb_rows()", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 72, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (col_start_index>=0) ? void (0) : __assert_fail ("col_start_index>=0", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 73, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (col_start_index+sub.nb_cols()<=m.nb_cols()) ? void (0) : __assert_fail ("col_start_index+sub.nb_cols()<=m.nb_cols()", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 74, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (!is_empty(m)) ? void (0) : __assert_fail ("!is_empty(m)", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 75, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (!is_empty(sub)) ? void (0) : __assert_fail ("!is_empty(sub)", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 76, __extension__ __PRETTY_FUNCTION__));

 int i=row_start_index;
 for (int i2=0; i2<sub.nb_rows(); i++,i2++) {
  int j=col_start_index;
  for (int j2=0; j2<sub.nb_cols(); j++,j2++)
   m[i][j] = sub[i2][j2];
 }
}

template<class M, class V>
inline void _put(M& m, int row_start_index, int col_start_index, const V& v, bool row_vec) {
 (static_cast <bool> (row_start_index>=0) ? void (0) : __assert_fail ("row_start_index>=0", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 88, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (row_vec || row_start_index+v.size()<=m.nb_rows()) ? void (0) : __assert_fail ("row_vec || row_start_index+v.size()<=m.nb_rows()", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 89, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (col_start_index>=0) ? void (0) : __assert_fail ("col_start_index>=0", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 90, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (!row_vec || col_start_index+v.size()<=m.nb_cols()) ? void (0) : __assert_fail ("!row_vec || col_start_index+v.size()<=m.nb_cols()", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 91, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (!is_empty(m)) ? void (0) : __assert_fail ("!is_empty(m)", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 92, __extension__ __PRETTY_FUNCTION__));


 int i=row_start_index;
 int j=col_start_index;
 for (int k=0; k<v.size(); k++) {
  m[i][j]=v[k];
  if (row_vec) j++;
  else i++;
 }
}


template<class M>
inline M _transpose(const M& m) {
 (static_cast <bool> (!is_empty(m)) ? void (0) : __assert_fail ("!is_empty(m)", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 107, __extension__ __PRETTY_FUNCTION__));

 M m2(m.nb_cols(), m.nb_rows());

 for (int i=0; i<m.nb_rows(); i++) {
  for (int j=0; j<m.nb_cols(); j++) {
   m2[j][i]=m[i][j];
  }
 }
 return m2;
}

template<class M,class V>
inline V _col(const M& m, int j) {
 (static_cast <bool> (!is_empty(m)) ? void (0) : __assert_fail ("!is_empty(m)", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 121, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (j>=0 && j<m.nb_cols()) ? void (0) : __assert_fail ("j>=0 && j<m.nb_cols()", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 122, __extension__ __PRETTY_FUNCTION__));

 V res(m.nb_rows());
 for (int i=0; i<m.nb_rows(); i++)
  res[i]=m[i][j];
 return res;
}

template<class M,class V>
inline void _set_col(M& m, int col1, const V& v) {
 (static_cast <bool> (!is_empty(m)) ? void (0) : __assert_fail ("!is_empty(m)", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 132, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (col1>=0 && col1<m.nb_cols()) ? void (0) : __assert_fail ("col1>=0 && col1<m.nb_cols()", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 133, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (m.nb_rows()==v.size()) ? void (0) : __assert_fail ("m.nb_rows()==v.size()", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 134, __extension__ __PRETTY_FUNCTION__));

 for (int i=0; i<m.nb_rows(); i++)
  m[i][col1]=v[i];
}


template<class M1,class M2>
M1& _assignM(M1& m1, const M2& m2) {
 (static_cast <bool> (m1.nb_rows()==m2.nb_rows() && m1.nb_cols()==m2.nb_cols()) ? void (0) : __assert_fail ("m1.nb_rows()==m2.nb_rows() && m1.nb_cols()==m2.nb_cols()", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 143, __extension__ __PRETTY_FUNCTION__));


 if (is_empty(m2))
  set_empty(m1);
 else
  for (int i=0; i<m1.nb_rows(); i++)
   m1.set_row(i,m2[i]);

 return m1;
}

template<class M1,class M2>
bool _equalsM(M1& m1, const M2& m2) {
 if (m1.nb_rows()!=m2.nb_rows()) return false;
 if (m1.nb_cols()!=m2.nb_cols()) return false;

 if (is_empty(m1)) return is_empty(m2);
 if (is_empty(m2)) return is_empty(m1);

 for (int i=0; i<m1.nb_rows(); i++) {
  if (m1.row(i)!=m2.row(i)) return false;
 }
 return true;
}

template<class M>
inline std::ostream& _displayM(std::ostream& os, const M& m) {
 if (is_empty(m)) { return os << "empty matrix"; }
 os << "(";
 for (int i=0; i<m.nb_rows(); i++) {
  os << "(";
  for (int j=0; j<m.nb_cols(); j++) {
   os << m[i][j];
   if (j<m.nb_cols()-1) os << " ; ";
  }
  os << ")";
  if (i<m.nb_rows()-1) os << std::endl;
 }
 os << ")";
 return os;
}

template<class M,class V>
Matrix _randomM(const M& m) {
 (static_cast <bool> (!m.is_empty()) ? void (0) : __assert_fail ("!m.is_empty()", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 188, __extension__ __PRETTY_FUNCTION__));

 Matrix mm(m.nb_rows(), m.nb_cols());
 for (int i=0; i<m.nb_rows(); i++) {
  const V& vi=m[i];
  mm[i] = vi.random();
 }
 return mm;
}

template<class M,class V>
Matrix _randomM(const M& m, int seed) {
 (static_cast <bool> (!m.is_empty()) ? void (0) : __assert_fail ("!m.is_empty()", "/usr/local/include/ibex/ibex_TemplateMatrix.h_", 200, __extension__ __PRETTY_FUNCTION__));

 Matrix mm(m.nb_rows(), m.nb_cols());
 for (int i=0; i<m.nb_rows(); i++) {
  const V& vi=m[i];
  mm[i] = vi.random(seed);
 }
 return mm;
}

}

}
# 16 "/usr/local/include/ibex/ibex_Affine2Matrix.h_" 2 3

namespace ibex {


template<class T>
IntervalMatrix& IntervalMatrix::operator=(const Affine2MainMatrix<T>& x) {
 resize(x.nb_rows(), x.nb_cols());
 for (int i=0; i<nb_rows(); i++)
  (*this)[i] = x[i];
 return *this;
}

template<class T>
Affine2MainMatrix<T>::Affine2MainMatrix() : _nb_rows(0), _nb_cols(0), _M(__null) {

}

template<class T>
Affine2MainMatrix<T>::Affine2MainMatrix(int nb_rows1, int nb_cols1) : _nb_rows(nb_rows1), _nb_cols(nb_cols1) {
 (static_cast <bool> (nb_rows1>0) ? void (0) : __assert_fail ("nb_rows1>0", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 35, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (nb_cols1>0) ? void (0) : __assert_fail ("nb_cols1>0", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 36, __extension__ __PRETTY_FUNCTION__));

 _M = new Affine2MainVector<T>[_nb_rows];
 for (int i=0; i<_nb_rows; i++) {
  _M[i].resize(_nb_cols);
 }
}

template<class T>
Affine2MainMatrix<T>::Affine2MainMatrix(int nb_rows1, int nb_cols1, const Affine2Main<T>& x) : _nb_rows(nb_rows1), _nb_cols(nb_cols1) {
 (static_cast <bool> (nb_rows1>0) ? void (0) : __assert_fail ("nb_rows1>0", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 46, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (nb_cols1>0) ? void (0) : __assert_fail ("nb_cols1>0", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 47, __extension__ __PRETTY_FUNCTION__));

 _M = new Affine2MainVector<T>[_nb_rows];
 for (int i=0; i<_nb_rows; i++) {
  _M[i].resize(_nb_cols);
  for (int j=0; j<_nb_cols; j++) _M[i]._vec[j]=x;
 }
}



template<class T>
Affine2MainMatrix<T>::Affine2MainMatrix(int m, int n, double bounds[][2]) : _nb_rows(m), _nb_cols(n) {
 (static_cast <bool> (m>0) ? void (0) : __assert_fail ("m>0", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 60, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (n>0) ? void (0) : __assert_fail ("n>0", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 61, __extension__ __PRETTY_FUNCTION__));
  int k=0;
  _M = new Affine2MainVector<T>[_nb_rows];
  for (int i=0; i<_nb_rows; i++) {
   _M[i].resize(_nb_cols);
   for (int j=0; j<_nb_cols; j++) {
    _M[i]._vec[j]=Affine2Main<T>(Interval(bounds[k][0],bounds[k][1]));
    k++;
   }
  }
}

template<class T>
Affine2MainMatrix<T>::Affine2MainMatrix(const Affine2MainMatrix<T>& m) : _nb_rows(m.nb_rows()), _nb_cols(m.nb_cols()){
 _M = new Affine2MainVector<T>[_nb_rows];

 for (int i=0; i<_nb_rows; i++) {
  _M[i].resize(_nb_cols);
  for (int j=0; j<_nb_cols; j++) _M[i]._vec[j]=Affine2Main<T>(m[i][j]);
 }

}


template<class T>
Affine2MainMatrix<T>::Affine2MainMatrix(const IntervalMatrix& m) : _nb_rows(m.nb_rows()), _nb_cols(m.nb_cols()){
 _M = new Affine2MainVector<T>[_nb_rows];
 int k=0;
 for (int i=0; i<_nb_rows; i++) {
  _M[i].resize(_nb_cols);
  for (int j=0; j<_nb_cols; j++) {
   _M[i]._vec[j]=Affine2Main<T>(m[i][j]);
   k++;
  }
 }
}


template<class T>
Affine2MainMatrix<T>::Affine2MainMatrix(const Matrix& m) : _nb_rows(m.nb_rows()), _nb_cols(m.nb_cols()){
 _M = new Affine2MainVector<T>[_nb_rows];
 for (int i=0; i<_nb_rows; i++) {
  _M[i].resize(_nb_cols);
  for (int j=0; j<_nb_cols; j++) {
   _M[i]._vec[j]=Affine2Main<T>(m[i][j]);
  }
 }
}

template<class T>
Affine2MainMatrix<T>::~Affine2MainMatrix() {
 if (_M!=__null) delete[] _M;
}

template<class T>
Affine2MainMatrix<T>& Affine2MainMatrix<T>::operator=(const Affine2MainMatrix<T>& x) {

 return _assignM(*this,x);
}

template<class T>
Affine2MainMatrix<T>& Affine2MainMatrix<T>::operator=(const IntervalMatrix& x) {

 return _assignM(*this,x);
}

template<class T>
IntervalMatrix Affine2MainMatrix<T>::itv() const {
 (static_cast <bool> (!is_empty()) ? void (0) : __assert_fail ("!is_empty()", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 129, __extension__ __PRETTY_FUNCTION__));
 IntervalMatrix intm(nb_rows(),nb_cols());
 for (int i = 0; i < nb_rows(); i++) {
  for (int j =0; j < nb_cols();j++){
   intm[i][j] = (*this)[i][j].itv();
  }
 }
 return intm;
}


template<class T>
void Affine2MainMatrix<T>::init(const Affine2Main<T>& x) {
 for (int i=0; i<nb_rows(); i++)
  (*this)[i].init(x);
}

template<class T>
void Affine2MainMatrix<T>::init(const Interval& x) {
 for (int i=0; i<nb_rows(); i++) {
  for (int j = 0; i < nb_cols(); i++) {
   (*this)[i][j] = Affine2Main<T>(x);
  }
 }
}

template<class T>
bool Affine2MainMatrix<T>::operator==(const Affine2MainMatrix<T>& m) const {
 return _equalsM(*this,m);
}

template<class T>
bool Affine2MainMatrix<T>::operator==(const IntervalMatrix& m) const {
 return _equalsM(*this,m);
}

template<class T>
void Affine2MainMatrix<T>::resize(int nb_rows1, int nb_cols1) {
 (static_cast <bool> (nb_rows1>0) ? void (0) : __assert_fail ("nb_rows1>0", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 167, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (nb_cols1>0) ? void (0) : __assert_fail ("nb_cols1>0", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 168, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> ((_M==__null && _nb_rows==0) || (_nb_rows!=0 && _M!=__null)) ? void (0) : __assert_fail ("(_M==NULL && _nb_rows==0) || (_nb_rows!=0 && _M!=NULL)", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 169, __extension__ __PRETTY_FUNCTION__));

 if (nb_rows1==_nb_rows && nb_cols1==_nb_cols) return;

 Affine2MainVector<T>* M2;

 if (nb_rows1!=_nb_rows)
  M2 = new Affine2MainVector<T>[nb_rows1];
 else
  M2 = _M;

 for (int i=0; i<nb_rows1; i++) {
  M2[i].resize(nb_cols1);
  if (i<_nb_rows) {
   int min_cols=nb_cols1<_nb_cols?nb_cols1:_nb_cols;
   for (int j=0; j<min_cols; j++)
    M2[i][j]=_M[i][j];
  }
 }

 if (_M!=__null && nb_rows1!=_nb_rows) delete[] _M;

 _M = M2;
 _nb_rows = nb_rows1;
 _nb_cols = nb_cols1;
}

template<class T>
Affine2MainMatrix<T> Affine2MainMatrix<T>::submatrix(int row_start_index, int row_end_index, int col_start_index, int col_end_index) {
 return _submatrix(*this,row_start_index,row_end_index,col_start_index,col_end_index);
}

template<class T>
Affine2MainMatrix<T> Affine2MainMatrix<T>::transpose() const {
 return _transpose(*this);
}

template<class T>
Affine2MainVector<T> Affine2MainMatrix<T>::col(int j) const {

 {
  (static_cast <bool> (!is_empty()) ? void (0) : __assert_fail ("!is_empty()", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 210, __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (j>=0 && j<nb_cols()) ? void (0) : __assert_fail ("j>=0 && j<nb_cols()", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 211, __extension__ __PRETTY_FUNCTION__));

  Affine2MainVector<T> res(nb_rows());
  for (int i=0; i<nb_rows(); i++)
   res[i]=_M[i][j];
  return res;
 }
}

template<class T>
void Affine2MainMatrix<T>::set_col(int col1, const Affine2MainVector<T>& v) {
 _set_col(*this,col1,v);
}

template<class T>
Affine2MainMatrix<T>& Affine2MainMatrix<T>::inflate(double rad) {

 if (is_empty())
  return *this;

 Interval r(-rad, rad);
 for (int i = 0; i < nb_rows(); i++)
  for (int j = 0; j < nb_cols(); j++)
   (*this)[i][j] += r;
 return *this;
}

template<class T>
IntervalMatrix operator&(const Affine2MainMatrix<T>& x, const Affine2MainMatrix<T>& y) {
 (static_cast <bool> (x.nb_rows()==y.nb_rows()) ? void (0) : __assert_fail ("x.nb_rows()==y.nb_rows()", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 240, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (x.nb_cols()==y.nb_cols()) ? void (0) : __assert_fail ("x.nb_cols()==y.nb_cols()", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 241, __extension__ __PRETTY_FUNCTION__));

 if (y.is_empty()||x.is_empty())
  return IntervalMatrix::empty(x.nb_rows(),x.nb_cols());

 IntervalMatrix res(x.nb_rows(),x.nb_cols());
 for (int i=0; i<x.nb_rows(); i++) {
  res [i] = x[i] & y[i];
  if (res[i].is_empty()) {
   res.set_empty();
   return res;
  }
 }
 return res;
}

template<class T>
IntervalMatrix operator&(const Affine2MainMatrix<T>& x, const IntervalMatrix& y) {
 (static_cast <bool> (x.nb_rows()==y.nb_rows()) ? void (0) : __assert_fail ("x.nb_rows()==y.nb_rows()", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 259, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (x.nb_cols()==y.nb_cols()) ? void (0) : __assert_fail ("x.nb_cols()==y.nb_cols()", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 260, __extension__ __PRETTY_FUNCTION__));

 if (y.is_empty()||x.is_empty())
  return IntervalMatrix::empty(x.nb_rows(),x.nb_cols());

 IntervalMatrix res(x.nb_rows(),x.nb_cols());
 for (int i=0; i<x.nb_rows(); i++) {
  res [i] = x[i] & y[i];
  if (res[i].is_empty()) {
   res.set_empty();
   return res;
  }
 }
 return res;
}

template<class T>
IntervalMatrix operator|(const Affine2MainMatrix<T>& x, const Affine2MainMatrix<T>& y) {
 (static_cast <bool> (x.nb_rows()==y.nb_rows()) ? void (0) : __assert_fail ("x.nb_rows()==y.nb_rows()", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 278, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (x.nb_cols()==y.nb_cols()) ? void (0) : __assert_fail ("x.nb_cols()==y.nb_cols()", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 279, __extension__ __PRETTY_FUNCTION__));

 if (y.is_empty()&&x.is_empty())
  return IntervalMatrix::empty(x.nb_rows(),x.nb_cols());

 IntervalMatrix res(x.nb_rows(),x.nb_cols());
 for (int i=0; i<x.nb_rows(); i++) {
  res [i] = x[i] | y[i];
  if (res[i].is_empty()) {
   res.set_empty();
   return res;
  }
 }
 return res;
}

template<class T>
IntervalMatrix operator|(const Affine2MainMatrix<T>& x, const IntervalMatrix& y) {
 (static_cast <bool> (x.nb_rows()==y.nb_rows()) ? void (0) : __assert_fail ("x.nb_rows()==y.nb_rows()", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 297, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (x.nb_cols()==y.nb_cols()) ? void (0) : __assert_fail ("x.nb_cols()==y.nb_cols()", "/usr/local/include/ibex/ibex_Affine2Matrix.h_", 298, __extension__ __PRETTY_FUNCTION__));

 if (y.is_empty()&&x.is_empty())
  return IntervalMatrix::empty(x.nb_rows(),x.nb_cols());

 IntervalMatrix res(x.nb_rows(),x.nb_cols());
 for (int i=0; i<x.nb_rows(); i++) {
  res [i] = x[i] | y[i];
  if (res[i].is_empty()) {
   res.set_empty();
   return res;
  }
 }
 return res;
}


template<class T>
Affine2MainMatrix<T> operator*(const Affine2Main<T>& x, const Matrix& m) {
 if (x.is_empty()) {
  return Affine2MainMatrix<T>::empty(m.nb_rows(),m.nb_cols());
 }
 Affine2MainMatrix<T> res(m.nb_rows(),m.nb_cols(),x);
 for (int i=0; i<m.nb_rows(); i++) {
  for (int j= 0;j<m.nb_cols();j++){
  res[i][j] *= m[i][j];
  }
 }
 return res;
}

template<class T>
Affine2MainMatrix<T> operator*(const Affine2Main<T>& x, const IntervalMatrix& m) {
 if (x.is_empty()||m.is_empty()) {
  return Affine2MainMatrix<T>::empty(m.nb_rows(),m.nb_cols());
 }
 Affine2MainMatrix<T> res(m.nb_rows(),m.nb_cols(),x);
 for (int i=0; i<m.nb_rows(); i++) {
  for (int j= 0;j<m.nb_cols();j++){
  res[i][j] *= m[i][j];
  }
 }
 return res;
}

template<class T>
std::ostream& operator<<(std::ostream& os, const Affine2MainMatrix<T>& m) {
 return _displayM(os, m);
}


}
# 526 "/usr/local/include/ibex/ibex_Affine2Matrix.h" 2 3

namespace ibex {

template<class T>
inline Affine2MainMatrix<T> Affine2MainMatrix<T>::empty(int m, int n) {
 Affine2MainMatrix<T> res(m, n);
 res.set_empty();
 return res;
}

template<class T>
inline bool Affine2MainMatrix<T>::operator!=(const Affine2MainMatrix<T>& m) const {
 return !(*this==m);
}
template<class T>
inline bool Affine2MainMatrix<T>::operator!=(const IntervalMatrix& m) const {
 return !(*this==m);
}

template<class T>
inline int Affine2MainMatrix<T>::nb_cols() const {
 return _nb_cols;
}

template<class T>
inline int Affine2MainMatrix<T>::nb_rows() const {
 return _nb_rows;
}

template<class T>
inline Affine2MainVector<T>& Affine2MainMatrix<T>::operator[](int i) {
 (static_cast <bool> (i>=0 && i<nb_rows()) ? void (0) : __assert_fail ("i>=0 && i<nb_rows()", "/usr/local/include/ibex/ibex_Affine2Matrix.h", 557, __extension__ __PRETTY_FUNCTION__));
 return _M[i];
}

template<class T>
inline const Affine2MainVector<T>& Affine2MainMatrix<T>::operator[](int i) const {
 (static_cast <bool> (i>=0 && i<nb_rows()) ? void (0) : __assert_fail ("i>=0 && i<nb_rows()", "/usr/local/include/ibex/ibex_Affine2Matrix.h", 563, __extension__ __PRETTY_FUNCTION__));
 return _M[i];
}

template<class T>
inline void Affine2MainMatrix<T>::clear() {
 init(0);
}

template<class T>
inline void Affine2MainMatrix<T>::set_empty() {
 (*this)[0].set_empty();
}

template<class T>
inline Affine2MainVector<T>& Affine2MainMatrix<T>::row(int i) {
 (static_cast <bool> (i>=0 && i<nb_rows()) ? void (0) : __assert_fail ("i>=0 && i<nb_rows()", "/usr/local/include/ibex/ibex_Affine2Matrix.h", 579, __extension__ __PRETTY_FUNCTION__));
 return _M[i];
}

template<class T>
inline const Affine2MainVector<T>& Affine2MainMatrix<T>::row(int i) const {
 (static_cast <bool> (i>=0 && i<nb_rows()) ? void (0) : __assert_fail ("i>=0 && i<nb_rows()", "/usr/local/include/ibex/ibex_Affine2Matrix.h", 585, __extension__ __PRETTY_FUNCTION__));
 return _M[i];
}

template<class T>
inline Affine2MainMatrix<T> Affine2MainMatrix<T>::rows(int start_index, int end_index) {
 return submatrix(start_index, end_index, 0, nb_cols()-1);
}

template<class T>
inline Affine2MainMatrix<T> Affine2MainMatrix<T>::cols(int start_index, int end_index) {
 return submatrix(0, nb_rows()-1, start_index, end_index);
}

template<class T>
inline void Affine2MainMatrix<T>::set_row(int row1, const Affine2MainVector<T>& v1) {
 (static_cast <bool> (row1>=0 && row1<nb_rows()) ? void (0) : __assert_fail ("row1>=0 && row1<nb_rows()", "/usr/local/include/ibex/ibex_Affine2Matrix.h", 601, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (nb_cols()==v1.size()) ? void (0) : __assert_fail ("nb_cols()==v1.size()", "/usr/local/include/ibex/ibex_Affine2Matrix.h", 602, __extension__ __PRETTY_FUNCTION__));
 _M[row1]=v1;
}


template<class T>
inline bool Affine2MainMatrix<T>::is_empty() const {
 return (*this)[0].is_empty();
}



template<class T>
inline IntervalMatrix operator|(const IntervalMatrix& x, const Affine2MainMatrix<T>& y) {
   return (y | x );
}

template<class T>
inline IntervalMatrix operator&(const IntervalMatrix& x, const Affine2MainMatrix<T>& y) {
   return (y & x);
}


template<class T>
inline Affine2MainMatrix<T> operator+(const Affine2MainMatrix<T>& m1, const Matrix& m2) {
 return Affine2MainMatrix<T>(m1)+=m2;
}

template<class T>
inline Affine2MainMatrix<T> operator+(const Matrix& m1, const Affine2MainMatrix<T>& m2) {
  return Affine2MainMatrix<T>(m2)+=m1;
}

template<class T>
inline Affine2MainMatrix<T> operator+(const Affine2MainMatrix<T>& m1, const Affine2MainMatrix<T>& m2){
   return Affine2MainMatrix<T>(m1)+=m2;
}
template<class T>
inline Affine2MainMatrix<T> operator+(const Affine2MainMatrix<T>& m1, const IntervalMatrix& m2){
   return Affine2MainMatrix<T>(m1)+=m2;
}
template<class T>
inline Affine2MainMatrix<T> operator+(const IntervalMatrix& m1, const Affine2MainMatrix<T>& m2){
   return Affine2MainMatrix<T>(m2)+=m1;
}

template<class T>
inline Affine2MainMatrix<T> operator-(const Matrix& m1, const Affine2MainMatrix<T>& m2){
  Affine2MainMatrix<T> res(m2.nb_rows(),m2.nb_cols());
  res = (-m2);
   return res+=m1;
}

template<class T>
inline Affine2MainMatrix<T> operator-(const Affine2MainMatrix<T>& m1, const Affine2MainMatrix<T>& m2){
  return Affine2MainMatrix<T>(m1) += (-m2);
}
template<class T>
inline Affine2MainMatrix<T> operator-(const Affine2MainMatrix<T>& m1, const IntervalMatrix& m2){
   return Affine2MainMatrix<T>(m1)-=m2;
}
template<class T>
inline Affine2MainMatrix<T> operator-(const IntervalMatrix& m1, const Affine2MainMatrix<T>& m2){
  Affine2MainMatrix<T> res(m2.nb_rows(),m2.nb_cols());
  res = (-m2);
  return res+=m1;
}

template<class T>
inline Affine2MainMatrix<T> operator-(const Affine2MainMatrix<T>& m1, const Matrix& m2) {
 return Affine2MainMatrix<T>(m1)-=m2;
}

template<class T>
inline Affine2MainMatrix<T> operator*(double d, const Affine2MainMatrix<T>& m){
   return Affine2MainMatrix<T>(m)*=d;
}

template<class T>
inline Affine2MainMatrix<T> operator*(const Affine2Main<T>& x, const Affine2MainMatrix<T>& m){
   return Affine2MainMatrix<T>(m)*=x;
}
template<class T>
inline Affine2MainMatrix<T> operator*(const Interval& x, const Affine2MainMatrix<T>& m){
   return Affine2MainMatrix<T>(m)*=x;
}

template<class T>
inline Affine2MainMatrix<T>& Affine2MainMatrix<T>::operator*=(const Matrix& m) {
 return (*this)=(*this)*m;
}

template<class T>
inline Affine2MainMatrix<T>& Affine2MainMatrix<T>::operator*=(const Affine2MainMatrix<T>& m) {
 return (*this)=(*this)*m;
}

template<class T>
inline Affine2MainMatrix<T>& Affine2MainMatrix<T>::operator*=(const IntervalMatrix& m) {
 return (*this)=(*this)*m;
}



template<class T>
inline Affine2MainMatrix<T> operator-(const Affine2MainMatrix<T>& m) {
 return minusM(m);
}

template<class T>
inline Affine2MainMatrix<T>& Affine2MainMatrix<T>::operator+=(const Matrix& m) {
 return set_addM<Affine2MainMatrix<T>,Matrix>(*this,m);
}

template<class T>
inline Affine2MainMatrix<T>& Affine2MainMatrix<T>::operator+=(const Affine2MainMatrix<T>& m) {
 return set_addM<Affine2MainMatrix<T>,Affine2MainMatrix<T> >(*this,m);
}

template<class T>
inline Affine2MainMatrix<T>& Affine2MainMatrix<T>::operator+=(const IntervalMatrix& m) {
 return set_addM<Affine2MainMatrix<T>,IntervalMatrix>(*this,m);
}

template<class T>
inline Affine2MainMatrix<T>& Affine2MainMatrix<T>::operator-=(const Matrix& m) {
 return set_subM<Affine2MainMatrix<T>,Matrix>(*this,m);
}

template<class T>
inline Affine2MainMatrix<T>& Affine2MainMatrix<T>::operator-=(const Affine2MainMatrix<T>& m) {
 return set_subM<Affine2MainMatrix<T>,Affine2MainMatrix<T> >(*this,m);
}

template<class T>
inline Affine2MainMatrix<T>& Affine2MainMatrix<T>::operator-=(const IntervalMatrix& m) {
 return set_subM<Affine2MainMatrix<T>,IntervalMatrix>(*this,m);
}

template<class T>
inline Affine2MainMatrix<T>& Affine2MainMatrix<T>::operator*=(double x) {
 return set_mulSM<double,Affine2MainMatrix<T> >(x,*this);
}

template<class T>
inline Affine2MainMatrix<T>& Affine2MainMatrix<T>::operator*=(const Affine2Main<T>& x) {
 return set_mulSM<Affine2Main<T>,Affine2MainMatrix<T> >(x,*this);
}

template<class T>
inline Affine2MainMatrix<T>& Affine2MainMatrix<T>::operator*=(const Interval& x) {
 return set_mulSM<Interval,Affine2MainMatrix<T> >(x,*this);
}

template<class T>
inline Affine2MainVector<T> operator*(const Affine2MainMatrix<T>& m, const Vector& x) {
 return mulMV<Affine2MainMatrix<T>,Vector,Affine2MainVector<T> >(m,x);
}

template<class T>
inline Affine2MainVector<T> operator*(const Matrix& m, const Affine2MainVector<T>& x) {
 return mulMV<Matrix,Affine2MainVector<T>,Affine2MainVector<T> >(m,x);
}

template<class T>
inline Affine2MainVector<T> operator*(const Affine2MainMatrix<T>& m, const Affine2MainVector<T>& x) {
 return mulMV<Affine2MainMatrix<T>,Affine2MainVector<T>,Affine2MainVector<T> >(m,x);
}

template<class T>
inline Affine2MainVector<T> operator*(const Affine2MainMatrix<T>& m, const IntervalVector& x) {
 return mulMV<Affine2MainMatrix<T>,IntervalVector,Affine2MainVector<T> >(m,x);
}

template<class T>
inline Affine2MainVector<T> operator*(const Vector& x, const Affine2MainMatrix<T>& m) {
 return mulVM<Vector,Affine2MainMatrix<T>,Affine2MainVector<T> >(x,m);
}

template<class T>
inline Affine2MainVector<T> operator*(const Affine2MainVector<T>& x, const Affine2MainMatrix<T>& m) {
 return mulVM<Affine2MainVector<T>,Affine2MainMatrix<T>,Affine2MainVector<T> >(x,m);
}

template<class T>
inline Affine2MainVector<T> operator*(const IntervalVector& x, const Affine2MainMatrix<T>& m) {
 return mulVM<IntervalVector,Affine2MainMatrix<T>,Affine2MainVector<T> >(x,m);
}

template<class T>
inline Affine2MainMatrix<T> operator*(const Affine2MainMatrix<T>& m1, const Matrix& m2) {
 return mulMM<Affine2MainMatrix<T>,Matrix,Affine2MainMatrix<T> >(m1,m2);
}

template<class T>
inline Affine2MainMatrix<T> operator*(const Matrix& m1, const Affine2MainMatrix<T>& m2) {
 return mulMM<Matrix,Affine2MainMatrix<T>,Affine2MainMatrix<T> >(m1,m2);
}

template<class T>
inline Affine2MainMatrix<T> operator*(const Affine2MainMatrix<T>& m1, const Affine2MainMatrix<T>& m2) {
 return mulMM<Affine2MainMatrix<T>,Affine2MainMatrix<T>,Affine2MainMatrix<T> >(m1,m2);
}

template<class T>
inline Affine2MainMatrix<T> operator*(const Affine2MainMatrix<T>& m1, const IntervalMatrix& m2) {
 return mulMM<Affine2MainMatrix<T>,IntervalMatrix,Affine2MainMatrix<T> >(m1,m2);
}

template<class T>
inline Affine2MainMatrix<T> operator*(const IntervalMatrix& m1, const Affine2MainMatrix<T>& m2) {
 return mulMM<IntervalMatrix,Affine2MainMatrix<T>,Affine2MainMatrix<T> >(m1,m2);
}

template<class T>
inline Affine2MainMatrix<T> outer_product(const Affine2MainVector<T>& x1, const Vector& x2) {
 return outer_prod<Affine2MainVector<T>,Vector,Affine2MainMatrix<T> >(x1,x2);
}

template<class T>
inline Affine2MainMatrix<T> outer_product(const Vector& x1, const Affine2MainVector<T>& x2) {
 return outer_prod<Vector,Affine2MainVector<T>,Affine2MainMatrix<T> >(x1,x2);
}

template<class T>
inline Affine2MainMatrix<T> outer_product(const Affine2MainVector<T>& x1, const Affine2MainVector<T>& x2) {
 return outer_prod<Affine2MainVector<T>,Affine2MainVector<T>,Affine2MainMatrix<T> >(x1,x2);
}

template<class T>
inline Affine2MainMatrix<T> outer_product(const Affine2MainVector<T>& x1, const IntervalVector& x2) {
 return outer_prod<Affine2MainVector<T>,IntervalVector,Affine2MainMatrix<T> >(x1,x2);
}

template<class T>
inline Affine2MainMatrix<T> outer_product(const IntervalVector& x1, const Affine2MainVector<T>& x2) {
 return outer_prod<IntervalVector,Affine2MainVector<T>,Affine2MainMatrix<T> >(x1,x2);
}

template<class T>
inline Affine2MainMatrix<T> abs(const Affine2MainMatrix<T>& m) {
 return absM(m);
}



}
# 17 "/usr/local/include/ibex/ibex_Affine2MatrixArray.h" 2 3

namespace ibex {






typedef Affine2MainMatrixArray<AF_Default> Affine2MatrixArray;
typedef Affine2MainMatrixArray<AF_Linear> AffineLinMatrixArray;

template<class T=AF_Default>
class Affine2MainMatrixArray {


private:
 Affine2MainMatrix<T>* _array;
 int _n;

public:



 Affine2MainMatrixArray(int n, int nb_rows, int nb_cols);




 Affine2MainMatrixArray(const Affine2MainMatrixArray<T>& a);







 Affine2MainMatrixArray<T>& operator=(const Affine2MainMatrixArray<T>& a);
 Affine2MainMatrixArray<T>& operator=(const IntervalMatrixArray& a);





 bool operator==(const Affine2MainMatrixArray<T>& m) const;
 bool operator==(const IntervalMatrixArray& m) const;





 void init(const Affine2Main<T>& x);
 void init(const Interval& x);






 void set_empty();




 ~Affine2MainMatrixArray();




 IntervalMatrixArray itv() const;




 int size() const;




 int nb_rows() const;




 int nb_cols() const;




 bool is_empty() const;





 Affine2MainMatrix<T>& operator[](int i);




 const Affine2MainMatrix<T>& operator[](int i) const;

};
# 129 "/usr/local/include/ibex/ibex_Affine2MatrixArray.h" 3
template<class T>
IntervalMatrixArray operator&(const Affine2MainMatrixArray<T>& x1, const Affine2MainMatrixArray<T>& x2);
template<class T>
IntervalMatrixArray operator&(const Affine2MainMatrixArray<T>& x1, const IntervalMatrixArray& x2);
template<class T>
IntervalMatrixArray operator&(const IntervalMatrixArray& x1, const Affine2MainMatrixArray<T>& x2);




template<class T>
std::ostream& operator<<(std::ostream& os, const Affine2MainMatrixArray<T>&);


}
# 1 "/usr/local/include/ibex/ibex_Affine2MatrixArray.h_" 1 3
# 11 "/usr/local/include/ibex/ibex_Affine2MatrixArray.h_" 3
# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 44 "/usr/include/c++/7/cassert" 2 3
# 12 "/usr/local/include/ibex/ibex_Affine2MatrixArray.h_" 2 3

namespace ibex {

template<class T>
Affine2MainMatrixArray<T>::Affine2MainMatrixArray(int n1, int nb_rows1, int nb_cols1) : _n(n1) {
 (static_cast <bool> (n1>0) ? void (0) : __assert_fail ("n1>0", "/usr/local/include/ibex/ibex_Affine2MatrixArray.h_", 17, __extension__ __PRETTY_FUNCTION__));

 _array = new Affine2MainMatrix<T>[n1];
 for (int i=0; i<n1; i++)
  _array[i].resize(nb_rows1,nb_cols1);
}

template<class T>
Affine2MainMatrixArray<T>::Affine2MainMatrixArray(const Affine2MainMatrixArray<T>& a) : _n(a.size()) {
 _array = new Affine2MainMatrix<T>[_n];
 for (int i=0; i<_n; i++) {
  _array[i] = Affine2MainMatrix<T>(a[i]);
 }
}
# 40 "/usr/local/include/ibex/ibex_Affine2MatrixArray.h_" 3
template<class T>
Affine2MainMatrixArray<T>& Affine2MainMatrixArray<T>::operator=(const Affine2MainMatrixArray<T>& a) {
 if (size()!=a.size()) {
  delete[] _array;
  _array = new Affine2MainMatrix<T>[a.size()];
  _n = a.size();
 }

 for (int i=0; i<a.size(); i++) {
  _array[i]=a[i];
 }
 return *this;
}
template<class T>
Affine2MainMatrixArray<T>& Affine2MainMatrixArray<T>::operator=(const IntervalMatrixArray& a) {
 if (size()!=a.size()) {
  delete[] _array;
  _array = new Affine2MainMatrix<T>[a.size()];
  _n = a.size();
 }

 for (int i=0; i<a.size(); i++) {
  _array[i] = a[i];
 }
 return *this;
}


template<class T>
bool Affine2MainMatrixArray<T>::operator==(const Affine2MainMatrixArray<T>& x) const {
 if (_n!=x.size()) return false;
 for (int i=0; i<_n; i++)
  if ((*this)[i]!=(x[i])) return false;
 return true;
}

template<class T>
bool Affine2MainMatrixArray<T>::operator==(const IntervalMatrixArray& x) const {
 if (_n!=x.size()) return false;
 for (int i=0; i<_n; i++)
  if ((*this)[i]!=(x[i])) return false;
 return true;
}

template<class T>
void Affine2MainMatrixArray<T>::init(const Affine2Main<T>& x) {
 for (int i=0; i<size(); i++)
  (*this)[i].init(x);
}
template<class T>
void Affine2MainMatrixArray<T>::init(const Interval& x) {
 for (int i=0; i<size(); i++)
  (*this)[i].init(x);
}



template<class T>
IntervalMatrixArray Affine2MainMatrixArray<T>::itv() const {
 (static_cast <bool> (!is_empty()) ? void (0) : __assert_fail ("!is_empty()", "/usr/local/include/ibex/ibex_Affine2MatrixArray.h_", 99, __extension__ __PRETTY_FUNCTION__));
 IntervalMatrixArray intm(size(),nb_rows(),nb_cols());
 for (int k = 0; k < size();k++) {
  for (int i = 0; i < nb_rows(); i++) {
   for (int j =0; j < nb_cols();j++){
    intm[k][i][j] = (*this)[k][i][j].itv();
   }
  }
 }
 return intm;
}

template<class T>
Affine2MainMatrixArray<T>::~Affine2MainMatrixArray() {
 delete[] _array;
}


template<class T>
IntervalMatrixArray operator&(const Affine2MainMatrixArray<T>& x1, const Affine2MainMatrixArray<T>& x2) {
 (static_cast <bool> (x1.size()==x2.size()) ? void (0) : __assert_fail ("x1.size()==x2.size()", "/usr/local/include/ibex/ibex_Affine2MatrixArray.h_", 119, __extension__ __PRETTY_FUNCTION__));
 IntervalMatrixArray res (x1.size(),x1.nb_rows(),x1.nb_cols());
 for (int i=0; i<x1.size(); i++) {
  res[i] = x1[i] & x2[i];
 }
 return res;
}
template<class T>
IntervalMatrixArray operator&(const Affine2MainMatrixArray<T>& x1, const IntervalMatrixArray& x2) {
 (static_cast <bool> (x1.size()==x2.size()) ? void (0) : __assert_fail ("x1.size()==x2.size()", "/usr/local/include/ibex/ibex_Affine2MatrixArray.h_", 128, __extension__ __PRETTY_FUNCTION__));
 IntervalMatrixArray res (x1.size(),x1.nb_rows(),x1.nb_cols());
 for (int i=0; i<x1.size(); i++) {
  res[i] = x1[i] & x2[i];
 }
 return res;
}


template<class T>
std::ostream& operator<<(std::ostream& os, const Affine2MainMatrixArray<T>& a) {
 for (int i=0; i<a.size(); i++) {
  os << a[i] << std::endl;
 }
 return os;
}

}
# 145 "/usr/local/include/ibex/ibex_Affine2MatrixArray.h" 2 3



namespace ibex {

template<class T>
inline int Affine2MainMatrixArray<T>::size() const {
 return _n;
}

template<class T>
inline int Affine2MainMatrixArray<T>::nb_rows() const {
 (static_cast <bool> (_n>0) ? void (0) : __assert_fail ("_n>0", "/usr/local/include/ibex/ibex_Affine2MatrixArray.h", 157, __extension__ __PRETTY_FUNCTION__));
 return _array[0].nb_rows();
}

template<class T>
inline int Affine2MainMatrixArray<T>::nb_cols() const {
 (static_cast <bool> (_n>0) ? void (0) : __assert_fail ("_n>0", "/usr/local/include/ibex/ibex_Affine2MatrixArray.h", 163, __extension__ __PRETTY_FUNCTION__));
 return _array[0].nb_cols();
}

template<class T>
inline Affine2MainMatrix<T>& Affine2MainMatrixArray<T>::operator[](int i) {
 return _array[i];
}


template<class T>
inline const Affine2MainMatrix<T>& Affine2MainMatrixArray<T>::operator[](int i) const {
 return _array[i];
}

template<class T>
inline void Affine2MainMatrixArray<T>::set_empty() {
 (*this)[0].set_empty();
}

template<class T>
inline bool Affine2MainMatrixArray<T>::is_empty() const {
 return (*this)[0].is_empty();
}

template<class T>
inline IntervalMatrixArray operator&(const IntervalMatrixArray& x1, const Affine2MainMatrixArray<T>& x2) {
 return (x2 & x1);
}


}
# 17 "/usr/local/include/ibex/ibex_Affine2Domain.h" 2 3
# 1 "/usr/local/include/ibex/ibex_TemplateDomain.h" 1 3
# 15 "/usr/local/include/ibex/ibex_TemplateDomain.h" 3
# 1 "/usr/local/include/ibex/ibex_Dim.h" 1 3
# 17 "/usr/local/include/ibex/ibex_Dim.h" 3
# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 44 "/usr/include/c++/7/cassert" 2 3
# 18 "/usr/local/include/ibex/ibex_Dim.h" 2 3


namespace ibex {
# 41 "/usr/local/include/ibex/ibex_Dim.h" 3
class Dim {
public:


 Dim();


 static Dim scalar();


 static Dim row_vec(int n);


 static Dim col_vec(int n);


 static Dim matrix(int m, int n);


 static Dim matrix_array(int k, int m, int n);


 typedef enum { SCALAR, ROW_VECTOR, COL_VECTOR, MATRIX, MATRIX_ARRAY } Type;


 Type type() const;


 inline int size() const;


 bool is_scalar() const;


 bool is_vector() const;


 bool is_matrix() const;






 int vec_size() const;


 bool operator==(const Dim& d) const;


 bool operator!=(const Dim& d) const;







 Dim transpose_dim() const;







 Dim index_dim() const;






 int max_index() const;
# 128 "/usr/local/include/ibex/ibex_Dim.h" 3
 int dim1;




 int dim2;




 int dim3;


 Dim(int dim1, int dim2, int dim3);
# 152 "/usr/local/include/ibex/ibex_Dim.h" 3
 bool cst_vec;

};
# 173 "/usr/local/include/ibex/ibex_Dim.h" 3
Dim add_dim(Dim& l, Dim& r);




Dim mul_dim(const Dim& l, const Dim& r);




Dim vec_dim(const Array<const Dim>& comp, bool in_a_row);





inline Dim::Dim() : dim1(1), dim2(1), dim3(1), cst_vec(false) {

}

inline Dim Dim::scalar() {
 return Dim(1,1,1);
}

inline Dim Dim::row_vec(int n) {
 if (n==1) return Dim::scalar();
 else return Dim(1,1,n);
}

inline Dim Dim::col_vec(int n) {
 if (n==1) return Dim::scalar();
 else return Dim(1,n,1);
}

inline Dim Dim::matrix(int m, int n) {
 if (m==1) return Dim::row_vec(n);
 else if (n==1) return Dim::col_vec(m);
 else return Dim(1,m,n);
}

inline Dim Dim::matrix_array(int k, int m, int n) {
 if (k==1) return Dim::matrix(m,n);
 else return Dim(k,m,n);
}

inline Dim::Type Dim::type() const {
 if (dim1==1)
  if (dim2==1)
   if (dim3==1) return SCALAR;
   else return ROW_VECTOR;
  else
   if (dim3==1) return COL_VECTOR;
   else return MATRIX;
 else
  return MATRIX_ARRAY;
}

inline int Dim::size() const {
 return dim1*dim2*dim3;
}

inline bool Dim::is_scalar() const {
 return type()==SCALAR;
}

inline bool Dim::is_vector() const {
 Type t=type();
 return t==COL_VECTOR || t==ROW_VECTOR;
}

inline bool Dim::is_matrix() const {
 Type t=type();
 return t==MATRIX;
}

inline int Dim::vec_size() const {
 (static_cast <bool> (is_vector()) ? void (0) : __assert_fail ("is_vector()", "/usr/local/include/ibex/ibex_Dim.h", 249, __extension__ __PRETTY_FUNCTION__));
 return dim2==1? dim3 : dim2;
}

inline bool Dim::operator==(const Dim& d) const {
 return dim1==d.dim1 && dim2==d.dim2 && dim3==d.dim3;
}

inline bool Dim::operator!=(const Dim& d) const {
 return !(*this==d);
}



std::ostream& operator<<(std::ostream&, const Dim&);

}
# 16 "/usr/local/include/ibex/ibex_TemplateDomain.h" 2 3

namespace ibex {
# 32 "/usr/local/include/ibex/ibex_TemplateDomain.h" 3
template<class D>
class TemplateDomain {
public:




 const Dim dim;




 const bool is_reference;





 explicit TemplateDomain(const Dim& dim1);






 explicit TemplateDomain(typename D::SCALAR& itv);






 explicit TemplateDomain(typename D::VECTOR& v1, bool in_row);






 explicit TemplateDomain(typename D::MATRIX& m1);






 explicit TemplateDomain(typename D::MATRIX_ARRAY& ma1);







 TemplateDomain(const TemplateDomain<D>& d, bool is_reference1=false);






 TemplateDomain operator[](int index);






 const TemplateDomain operator[](int index) const;




 ~TemplateDomain();




 TemplateDomain& operator=(const TemplateDomain<D>& d);




 TemplateDomain& operator&=(const TemplateDomain<D>& d);




 bool operator==(const TemplateDomain<D>& d) const;




 bool operator!=(const TemplateDomain<D>& d) const;




 typename D::SCALAR& i();




 typename D::VECTOR& v();




 typename D::MATRIX& m();




 typename D::MATRIX_ARRAY& ma();




 const typename D::SCALAR& i() const;




 const typename D::VECTOR& v() const;




 const typename D::MATRIX& m() const;




 inline const typename D::MATRIX_ARRAY& ma() const;




 bool is_empty() const;




 void set_empty();




 void clear();

private:

 TemplateDomain();

 void build();

 void* domain;
};







template<class D>
std::ostream& operator<<(std::ostream& os,const TemplateDomain<D>&);




template<class D>
void load(Array<TemplateDomain<D> >& domains, const typename D::VECTOR& box, int nb_used=-1, int* used=__null);




template<class D>
void load(typename D::VECTOR& box, const Array<const TemplateDomain<D> >& domains, int nb_used=-1, int* used=__null);




template<class D>
inline void load(typename D::VECTOR& box, const Array<TemplateDomain<D> >& domains, int nb_used=-1, int* used=__null) {
 load(box, (const Array<const TemplateDomain<D> >&) domains, nb_used, used);
}




template<class D>
void load(Array<TemplateDomain<D> >& x, const Array<const TemplateDomain<D> >& y, int nb_used=-1, int* used=__null);




template<class D>
void load(Array<TemplateDomain<D> >& x, const Array<TemplateDomain<D> >& y, int nb_used=-1, int* used=__null);


template<class D>
TemplateDomain<D> operator+(const TemplateDomain<D>& d1, const TemplateDomain<D>& d2);

template<class D>
TemplateDomain<D> operator*(const TemplateDomain<D>& d1, const TemplateDomain<D>& d2);

template<class D>
TemplateDomain<D> operator-(const TemplateDomain<D>& d1, const TemplateDomain<D>& d2);

template<class D>
TemplateDomain<D> operator/(const TemplateDomain<D>& d1, const TemplateDomain<D>& d2);

template<class D>
TemplateDomain<D> max(const TemplateDomain<D>& d1, const TemplateDomain<D>& d2);

template<class D>
TemplateDomain<D> min(const TemplateDomain<D>& d1, const TemplateDomain<D>& d2);

template<class D>
TemplateDomain<D> atan2(const TemplateDomain<D>& d1, const TemplateDomain<D>& d2);

template<class D>
TemplateDomain<D> operator-(const TemplateDomain<D>& d1);

template<class D>
TemplateDomain<D> transpose(const TemplateDomain<D>& d1);

template<class D>
TemplateDomain<D> sign(const TemplateDomain<D>& d1);

template<class D>
TemplateDomain<D> abs(const TemplateDomain<D>& d);

template<class D>
TemplateDomain<D> pow(const TemplateDomain<D>& d, int p);

template<class D>
TemplateDomain<D> pow(const TemplateDomain<D>& d, const TemplateDomain<D>& p);

template<class D>
TemplateDomain<D> sqr(const TemplateDomain<D>& d);

template<class D>
TemplateDomain<D> sqrt(const TemplateDomain<D>& d);

template<class D>
TemplateDomain<D> exp(const TemplateDomain<D>& d);

template<class D>
TemplateDomain<D> log(const TemplateDomain<D>& d);

template<class D>
TemplateDomain<D> cos(const TemplateDomain<D>& d);

template<class D>
TemplateDomain<D> sin(const TemplateDomain<D>& d);

template<class D>
TemplateDomain<D> tan(const TemplateDomain<D>& d);

template<class D>
TemplateDomain<D> acos(const TemplateDomain<D>& d);

template<class D>
TemplateDomain<D> asin(const TemplateDomain<D>& d);

template<class D>
TemplateDomain<D> atan(const TemplateDomain<D>& d);

template<class D>
TemplateDomain<D> cosh(const TemplateDomain<D>& d);

template<class D>
TemplateDomain<D> sinh(const TemplateDomain<D>& d);

template<class D>
TemplateDomain<D> tanh(const TemplateDomain<D>& d);

template<class D>
TemplateDomain<D> acosh(const TemplateDomain<D>& d);

template<class D>
TemplateDomain<D> asinh(const TemplateDomain<D>& d);

template<class D>
TemplateDomain<D> atanh(const TemplateDomain<D>& d);






template<class D>
inline TemplateDomain<D>::TemplateDomain(const Dim& dim1) : dim(dim1), is_reference(false) {
 build();
}

template<class D>
inline TemplateDomain<D>::TemplateDomain(typename D::SCALAR& itv) : dim(), is_reference(true) {
 domain = &itv;
}

template<class D>
inline TemplateDomain<D>::TemplateDomain(typename D::VECTOR& v1, bool in_row) : dim(in_row? Dim::row_vec(v1.size()) : Dim::col_vec(v1.size())), is_reference(true) {
 domain = &v1;
}

template<class D>
inline TemplateDomain<D>::TemplateDomain(typename D::MATRIX& m1) : dim(Dim::matrix(m1.nb_rows(),m1.nb_cols())), is_reference(true) {
 domain = &m1;
}

template<class D>
inline TemplateDomain<D>::TemplateDomain(typename D::MATRIX_ARRAY& ma1) : dim(Dim::matrix_array(ma1.size(),ma1.nb_rows(),ma1.nb_cols())), is_reference(true) {
 domain = &ma1;
}

template<class D>
inline TemplateDomain<D>::TemplateDomain(const TemplateDomain<D>& d, bool is_reference1) : dim(d.dim), is_reference(is_reference1) {
 if (is_reference1) {
  domain = d.domain;
 } else {
  switch (dim.type()) {
  case Dim::SCALAR: domain = new typename D::SCALAR(d.i()); break;
  case Dim::ROW_VECTOR:
  case Dim::COL_VECTOR: domain = new typename D::VECTOR(d.v()); break;
  case Dim::MATRIX: domain = new typename D::MATRIX(d.m()); break;
  case Dim::MATRIX_ARRAY: domain = new typename D::MATRIX_ARRAY(d.ma()); break;
  }
 }
}

template<class D>
inline TemplateDomain<D>::TemplateDomain() : dim(), is_reference(false), domain(__null) {

}

template<class D>
TemplateDomain<D> TemplateDomain<D>::operator[](int ii) {
 switch(dim.type()) {
 case Dim::SCALAR: (static_cast <bool> (ii==0) ? void (0) : __assert_fail ("ii==0", "/usr/local/include/ibex/ibex_TemplateDomain.h", 373, __extension__ __PRETTY_FUNCTION__)); return TemplateDomain<D>(this->i());
 case Dim::ROW_VECTOR:
 case Dim::COL_VECTOR: return TemplateDomain<D>(v()[ii]);
 case Dim::MATRIX: return TemplateDomain<D>(m()[ii],true);
 case Dim::MATRIX_ARRAY:
 default: return TemplateDomain<D>(ma()[ii]);
 }
}

template<class D>
const TemplateDomain<D> TemplateDomain<D>::operator[](int ii) const {
 return ((TemplateDomain<D>&) *this)[ii];
}

template<class D>
TemplateDomain<D>::~TemplateDomain() {
 if (!is_reference) {
  switch(dim.type()) {
  case Dim::SCALAR: delete &i(); break;
  case Dim::ROW_VECTOR:
  case Dim::COL_VECTOR: delete &v(); break;
  case Dim::MATRIX: delete &m(); break;
  case Dim::MATRIX_ARRAY: delete &ma(); break;
  }
 }
}

template<class D>
TemplateDomain<D>& TemplateDomain<D>::operator=(const TemplateDomain<D>& d) {
 (static_cast <bool> ((*this).dim==d.dim) ? void (0) : __assert_fail ("(*this).dim==d.dim", "/usr/local/include/ibex/ibex_TemplateDomain.h", 402, __extension__ __PRETTY_FUNCTION__));
 switch((*this).dim.type()) {
 case Dim::SCALAR: i()=d.i(); break;
 case Dim::ROW_VECTOR:
 case Dim::COL_VECTOR: v()=d.v(); break;
 case Dim::MATRIX: m()=d.m(); break;
 case Dim::MATRIX_ARRAY: ma()=d.ma(); break;
 }
 return *this;
}

template<class D>
TemplateDomain<D>& TemplateDomain<D>::operator&=(const TemplateDomain<D>& d) {
 (static_cast <bool> ((*this).dim==d.dim) ? void (0) : __assert_fail ("(*this).dim==d.dim", "/usr/local/include/ibex/ibex_TemplateDomain.h", 415, __extension__ __PRETTY_FUNCTION__));
 switch((*this).dim.type()) {
 case Dim::SCALAR: i()&=d.i(); break;
 case Dim::ROW_VECTOR:
 case Dim::COL_VECTOR: v()&=d.v(); break;
 case Dim::MATRIX: m()&=d.m(); break;
 case Dim::MATRIX_ARRAY: ma()&=d.ma(); break;
 }
 return *this;
}

template<class D>
bool TemplateDomain<D>::operator==(const TemplateDomain<D>& d) const {
 if (dim!=d.dim) return false;
 switch(dim.type()) {
 case Dim::SCALAR: return i()==d.i();
 case Dim::ROW_VECTOR:
 case Dim::COL_VECTOR: return v()==d.v();
 case Dim::MATRIX: return m()==d.m();
 case Dim::MATRIX_ARRAY: return ma()==d.ma();
 default: (static_cast <bool> (false) ? void (0) : __assert_fail ("false", "/usr/local/include/ibex/ibex_TemplateDomain.h", 435, __extension__ __PRETTY_FUNCTION__)); return false;
 }
}

template<class D>
inline bool TemplateDomain<D>::operator!=(const TemplateDomain<D>& d) const {
 return !(*this==d);
}

template<class D>
inline typename D::SCALAR& TemplateDomain<D>::i() {
 (static_cast <bool> (domain) ? void (0) : __assert_fail ("domain", "/usr/local/include/ibex/ibex_TemplateDomain.h", 446, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (dim.is_scalar()) ? void (0) : __assert_fail ("dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 447, __extension__ __PRETTY_FUNCTION__));
 return *(typename D::SCALAR*) domain;
}

template<class D>
inline typename D::VECTOR& TemplateDomain<D>::v() {
 (static_cast <bool> (domain) ? void (0) : __assert_fail ("domain", "/usr/local/include/ibex/ibex_TemplateDomain.h", 453, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (dim.is_vector()) ? void (0) : __assert_fail ("dim.is_vector()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 454, __extension__ __PRETTY_FUNCTION__));
 return *(typename D::VECTOR*) domain;
}

template<class D>
inline typename D::MATRIX& TemplateDomain<D>::m() {
 (static_cast <bool> (domain) ? void (0) : __assert_fail ("domain", "/usr/local/include/ibex/ibex_TemplateDomain.h", 460, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (dim.type()==Dim::MATRIX) ? void (0) : __assert_fail ("dim.type()==Dim::MATRIX", "/usr/local/include/ibex/ibex_TemplateDomain.h", 461, __extension__ __PRETTY_FUNCTION__));
 return *(typename D::MATRIX*) domain;
}

template<class D>
inline typename D::MATRIX_ARRAY& TemplateDomain<D>::ma() {
 (static_cast <bool> (domain) ? void (0) : __assert_fail ("domain", "/usr/local/include/ibex/ibex_TemplateDomain.h", 467, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (dim.type()==Dim::MATRIX_ARRAY) ? void (0) : __assert_fail ("dim.type()==Dim::MATRIX_ARRAY", "/usr/local/include/ibex/ibex_TemplateDomain.h", 468, __extension__ __PRETTY_FUNCTION__));
 return *(typename D::MATRIX_ARRAY*) domain;
}

template<class D>
inline const typename D::SCALAR& TemplateDomain<D>::i() const {
 (static_cast <bool> (domain) ? void (0) : __assert_fail ("domain", "/usr/local/include/ibex/ibex_TemplateDomain.h", 474, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (dim.is_scalar()) ? void (0) : __assert_fail ("dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 475, __extension__ __PRETTY_FUNCTION__));
 return *(typename D::SCALAR*) domain;
}

template<class D>
inline const typename D::VECTOR& TemplateDomain<D>::v() const {
 (static_cast <bool> (domain) ? void (0) : __assert_fail ("domain", "/usr/local/include/ibex/ibex_TemplateDomain.h", 481, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (dim.is_vector()) ? void (0) : __assert_fail ("dim.is_vector()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 482, __extension__ __PRETTY_FUNCTION__));
 return *(typename D::VECTOR*) domain;
}

template<class D>
inline const typename D::MATRIX& TemplateDomain<D>::m() const {
 (static_cast <bool> (domain) ? void (0) : __assert_fail ("domain", "/usr/local/include/ibex/ibex_TemplateDomain.h", 488, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (dim.type()==Dim::MATRIX) ? void (0) : __assert_fail ("dim.type()==Dim::MATRIX", "/usr/local/include/ibex/ibex_TemplateDomain.h", 489, __extension__ __PRETTY_FUNCTION__));
 return *(typename D::MATRIX*) domain;
}

template<class D>
inline const typename D::MATRIX_ARRAY& TemplateDomain<D>::ma() const {
 (static_cast <bool> (domain) ? void (0) : __assert_fail ("domain", "/usr/local/include/ibex/ibex_TemplateDomain.h", 495, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (dim.type()==Dim::MATRIX_ARRAY) ? void (0) : __assert_fail ("dim.type()==Dim::MATRIX_ARRAY", "/usr/local/include/ibex/ibex_TemplateDomain.h", 496, __extension__ __PRETTY_FUNCTION__));
 return *(typename D::MATRIX_ARRAY*) domain;
}


template<class D>
void TemplateDomain<D>::build() {
 switch(dim.type()) {
 case Dim::SCALAR: domain = new typename D::SCALAR(); break;
 case Dim::ROW_VECTOR: domain = new typename D::VECTOR(dim.dim3); break;
 case Dim::COL_VECTOR: domain = new typename D::VECTOR(dim.dim2); break;
 case Dim::MATRIX: domain = new typename D::MATRIX(dim.dim2,dim.dim3); break;
 case Dim::MATRIX_ARRAY: domain = new typename D::MATRIX_ARRAY(dim.dim1,dim.dim2,dim.dim3); break;
 }
}

template<class D>
bool TemplateDomain<D>::is_empty() const {
 switch (dim.type()) {
  case Dim::SCALAR: return i().is_empty(); break;
  case Dim::ROW_VECTOR:
  case Dim::COL_VECTOR: return v().is_empty(); break;
  case Dim::MATRIX: return m().is_empty(); break;
  case Dim::MATRIX_ARRAY: return ma().is_empty(); break;
  }
 (static_cast <bool> (false) ? void (0) : __assert_fail ("false", "/usr/local/include/ibex/ibex_TemplateDomain.h", 521, __extension__ __PRETTY_FUNCTION__));
 return false;
}

template<class D>
void TemplateDomain<D>::set_empty() {
 switch (dim.type()) {
  case Dim::SCALAR: i().set_empty(); break;
  case Dim::ROW_VECTOR:
  case Dim::COL_VECTOR: v().set_empty(); break;
  case Dim::MATRIX: m().set_empty(); break;
  case Dim::MATRIX_ARRAY: ma().set_empty(); break;
  }
}

template<class D>
void TemplateDomain<D>::clear() {
 switch (dim.type()) {
 case Dim::SCALAR: i()=0; break;
 case Dim::ROW_VECTOR:
 case Dim::COL_VECTOR: v().clear(); break;
 case Dim::MATRIX: m().clear(); break;
 case Dim::MATRIX_ARRAY: for (int i=0; i<dim.dim1; i++) ma()[i].clear(); break;
 }
}

template<class D>
std::ostream& operator<<(std::ostream& os,const TemplateDomain<D>& d) {
 switch (d.dim.type()) {
  case Dim::SCALAR: os << d.i(); break;
  case Dim::ROW_VECTOR:
  case Dim::COL_VECTOR: os << d.v(); break;
  case Dim::MATRIX: os << d.m(); break;
  case Dim::MATRIX_ARRAY: os << d.ma(); break;
  }
 return os;
}

template<class D>
void load(Array<TemplateDomain<D> >& d, const typename D::VECTOR& x, int nb_used, int* used) {
 int i=0;
 int u=0;

 for (int s=0; (nb_used==-1 || u<nb_used) && s<d.size(); s++) {

  const Dim& dim=d[s].dim;

  if (nb_used!=-1 && used[u]>=i+dim.size()) {
   i+=dim.size();
   continue;
  }



  switch (dim.type()) {
  case Dim::SCALAR:
   if (nb_used==-1 || i==used[u]) {
    d[s].i()=x[i];
    u++;
    if (u==nb_used) return;
   }
   i++;
   break;
  case Dim::ROW_VECTOR:
  case Dim::COL_VECTOR:
  {
   typename D::VECTOR& v=d[s].v();
   for (int j=0; j<dim.vec_size(); j++) {
    if (nb_used==-1 || i==used[u]) {
     v[j]=x[i];
     u++;
     if (u==nb_used) return;
    }
    i++;
   }
  }
  break;

  case Dim::MATRIX:
  {
   typename D::MATRIX& M=d[s].m();
   for (int k=0; k<dim.dim2; k++)
    for (int j=0; j<dim.dim3; j++) {
     if (nb_used==-1 || i==used[u]) {
      M[k][j]=x[i];
      u++;
      if (u==nb_used) return;
     }
     i++;
    }
  }
  break;
  case Dim::MATRIX_ARRAY:
  {
   typename D::MATRIX_ARRAY& A=d[s].ma();
   for (int l=0; l<dim.dim1; l++)
    for (int k=0; k<dim.dim2; k++)
     for (int j=0; j<dim.dim3; j++) {
      if (nb_used==-1 || i==used[u]) {
       A[l][k][j]=x[i];
       u++;
       if (u==nb_used) return;
      }
      i++;
     }
  }
  break;
  }
 }
 (static_cast <bool> (nb_used==-1 || u==nb_used) ? void (0) : __assert_fail ("nb_used==-1 || u==nb_used", "/usr/local/include/ibex/ibex_TemplateDomain.h", 630, __extension__ __PRETTY_FUNCTION__));
}


template<class D>
void load(typename D::VECTOR& x, const Array<const TemplateDomain<D> >& d, int nb_used, int* used) {
 int i=0;
 int u=0;

 for (int s=0; (nb_used==-1 || u<nb_used) && s<d.size(); s++) {

  const Dim& dim=d[s].dim;

  if (nb_used!=-1 && used[u]>=i+dim.size()) {
   i+=dim.size();
   continue;
  }



  switch (dim.type()) {
  case Dim::SCALAR:
   if (nb_used==-1 || i==used[u]) {
    x[i]=d[s].i();
    u++;
    if (u==nb_used) return;
   }
   i++;
   break;
  case Dim::ROW_VECTOR:
  case Dim::COL_VECTOR:
  {
   const typename D::VECTOR& v=d[s].v();
   for (int j=0; j<dim.vec_size(); j++) {
    if (nb_used==-1 || i==used[u]) {
     x[i]=v[j];
     u++;
     if (u==nb_used) return;
    }
    i++;
   }
  }
  break;

  case Dim::MATRIX:
  {
   const typename D::MATRIX& M=d[s].m();
   for (int k=0; k<dim.dim2; k++)
    for (int j=0; j<dim.dim3; j++) {
     if (nb_used==-1 || i==used[u]) {
      x[i]=M[k][j];
      u++;
      if (u==nb_used) return;
     }
     i++;
    }
  }
  break;
  case Dim::MATRIX_ARRAY:
  {
   const typename D::MATRIX_ARRAY& A=d[s].ma();
   for (int l=0; l<dim.dim1; l++)
    for (int k=0; k<dim.dim2; k++)
     for (int j=0; j<dim.dim3; j++) {
      if (nb_used==-1 || i==used[u]) {
       x[i]=A[l][k][j];
       u++;
       if (u==nb_used) return;
      }
      i++;
     }
  }
  break;
  }
 }
 (static_cast <bool> (nb_used==-1 || u==nb_used) ? void (0) : __assert_fail ("nb_used==-1 || u==nb_used", "/usr/local/include/ibex/ibex_TemplateDomain.h", 705, __extension__ __PRETTY_FUNCTION__));
}

template<class D>
void load(Array<TemplateDomain<D> >& x, const Array<const TemplateDomain<D> >& y, int nb_used, int* used) {
 (static_cast <bool> (x.size()==y.size()) ? void (0) : __assert_fail ("x.size()==y.size()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 710, __extension__ __PRETTY_FUNCTION__));
 if (nb_used==-1)
  for (int s=0; s<x.size(); s++)
   x[s]=y[s];
 else {

  int i=0;
  int u=0;

  for (int s=0; u<nb_used && s<y.size(); s++) {

   const Dim& dim=y[s].dim;

   if (used[u]>=i+dim.size()) {
    i+=dim.size();
    continue;
   }



   switch (dim.type()) {
   case Dim::SCALAR:
    if (i==used[u]) {
     x[s]=y[s];
     u++;
     if (u==nb_used) return;
    }
    i++;
    break;
   case Dim::ROW_VECTOR:
   {


    for (int j=0; j<dim.dim3; j++) {
     if (i==used[u]) {
      x[s][j]=y[s][j];
      u++;
      if (u==nb_used) return;
     }
     i++;
    }
   }
   break;
   case Dim::COL_VECTOR:
   {


    for (int j=0; j<dim.dim2; j++) {
     if (i==used[u]) {
      x[s][j]=y[s][j];
      u++;
      if (u==nb_used) return;
     }
     i++;
    }
   }
   break;

   case Dim::MATRIX:
   {
    for (int k=0; k<dim.dim2; k++)
     for (int j=0; j<dim.dim3; j++) {
      if (i==used[u]) {
       x[s][k][j]=y[s][k][j];
       u++;
       if (u==nb_used) return;
      }
      i++;
     }
   }
   break;
   case Dim::MATRIX_ARRAY:
   {
    for (int l=0; l<dim.dim1; l++)
     for (int k=0; k<dim.dim2; k++)
      for (int j=0; j<dim.dim3; j++) {


       if (i==used[u]) {
        x[s][l][k][j]=y[s][l][k][j];
        u++;
        if (u==nb_used) return;
       }
       i++;
      }
   }
   break;
   }
  }
  (static_cast <bool> (nb_used==-1 || u==nb_used) ? void (0) : __assert_fail ("nb_used==-1 || u==nb_used", "/usr/local/include/ibex/ibex_TemplateDomain.h", 799, __extension__ __PRETTY_FUNCTION__));
 }





}

template<class D>
void load(Array<TemplateDomain<D> >& x, const Array<TemplateDomain<D> >& y, int nb_used, int* used) {
 load(x,(const Array<const TemplateDomain<D> >&) y, nb_used,used);
}

template<class D>
TemplateDomain<D> operator+(const TemplateDomain<D>& d1, const TemplateDomain<D>& d2) {
 const Dim& dim=d1.dim;
 (static_cast <bool> (d2.dim==dim) ? void (0) : __assert_fail ("d2.dim==dim", "/usr/local/include/ibex/ibex_TemplateDomain.h", 816, __extension__ __PRETTY_FUNCTION__));
 TemplateDomain<D> d(dim);

 switch(dim.type()) {
 case Dim::SCALAR: d.i()=d1.i()+d2.i(); break;
 case Dim::ROW_VECTOR:
 case Dim::COL_VECTOR: d.v()=d1.v()+d2.v(); break;
 case Dim::MATRIX: d.m()=d1.m()+d2.m(); break;
 case Dim::MATRIX_ARRAY: (static_cast <bool> (false) ? void (0) : __assert_fail ("false", "/usr/local/include/ibex/ibex_TemplateDomain.h", 824, __extension__ __PRETTY_FUNCTION__)); break;
 }
 return d;
}

template<class D>
TemplateDomain<D> operator*(const TemplateDomain<D>& d1, const TemplateDomain<D>& d2) {

 TemplateDomain<D> d(mul_dim(d1.dim,d2.dim));

 if (d1.dim.is_scalar()) {
  switch(d2.dim.type()) {
  case Dim::SCALAR: d.i()=d1.i()*d2.i(); break;
  case Dim::ROW_VECTOR:
  case Dim::COL_VECTOR: d.v()=d1.i()*d2.v(); break;
  case Dim::MATRIX: d.m()=d1.i()*d2.m(); break;
  default: (static_cast <bool> (false) ? void (0) : __assert_fail ("false", "/usr/local/include/ibex/ibex_TemplateDomain.h", 840, __extension__ __PRETTY_FUNCTION__)); break;
  }
 } else if (d1.dim.type()==Dim::ROW_VECTOR) {
  switch(d2.dim.type()) {
  case Dim::COL_VECTOR: d.i()=d1.v()*d2.v(); break;
  case Dim::MATRIX: d.v()=d1.v()*d2.m(); break;
  default: (static_cast <bool> (false) ? void (0) : __assert_fail ("false", "/usr/local/include/ibex/ibex_TemplateDomain.h", 846, __extension__ __PRETTY_FUNCTION__)); break;
  }
 } else if (d1.dim.type()==Dim::COL_VECTOR) {
  switch(d2.dim.type()) {
  case Dim::SCALAR: d.v()=d2.i()*d1.v(); break;
  case Dim::ROW_VECTOR: d.m()=outer_product(d1.v(),d2.v()); break;
  default: (static_cast <bool> (false) ? void (0) : __assert_fail ("false", "/usr/local/include/ibex/ibex_TemplateDomain.h", 852, __extension__ __PRETTY_FUNCTION__)); break;
  }
 } else {
  switch(d2.dim.type()) {
  case Dim::COL_VECTOR: d.v()=d1.m()*d2.v(); break;
  case Dim::MATRIX: d.m()=d1.m()*d2.m(); break;
  default: (static_cast <bool> (false) ? void (0) : __assert_fail ("false", "/usr/local/include/ibex/ibex_TemplateDomain.h", 858, __extension__ __PRETTY_FUNCTION__)); break;
  }
 }

 return d;
}

template<class D>
TemplateDomain<D> operator-(const TemplateDomain<D>& d1, const TemplateDomain<D>& d2) {
 const Dim& dim=d1.dim;
 (static_cast <bool> (d2.dim==dim) ? void (0) : __assert_fail ("d2.dim==dim", "/usr/local/include/ibex/ibex_TemplateDomain.h", 868, __extension__ __PRETTY_FUNCTION__));
 TemplateDomain<D> d(dim);

 switch(dim.type()) {
 case Dim::SCALAR: d.i()=d1.i()-d2.i(); break;
 case Dim::ROW_VECTOR:
 case Dim::COL_VECTOR: d.v()=d1.v()-d2.v(); break;
 case Dim::MATRIX: d.m()=d1.m()-d2.m(); break;
 case Dim::MATRIX_ARRAY: (static_cast <bool> (false) ? void (0) : __assert_fail ("false", "/usr/local/include/ibex/ibex_TemplateDomain.h", 876, __extension__ __PRETTY_FUNCTION__)); break;
 }
 return d;
}

template<class D>
TemplateDomain<D> operator-(const TemplateDomain<D>& d1) {
 TemplateDomain<D> d(d1.dim);

 switch(d.dim.type()) {
 case Dim::SCALAR: d.i()=-d1.i(); break;
 case Dim::ROW_VECTOR:
 case Dim::COL_VECTOR: d.v()=-d1.v(); break;
 case Dim::MATRIX: d.m()=-d1.m(); break;
 case Dim::MATRIX_ARRAY: (static_cast <bool> (false) ? void (0) : __assert_fail ("false", "/usr/local/include/ibex/ibex_TemplateDomain.h", 890, __extension__ __PRETTY_FUNCTION__)); break;
 }
 return d;
}

template<class D>
TemplateDomain<D> transpose(const TemplateDomain<D>& d1) {
 TemplateDomain<D> d(Dim(d1.dim.dim1,d1.dim.dim3,d1.dim.dim2));

 switch(d.dim.type()) {
 case Dim::SCALAR: d.i()=d1.i(); break;
 case Dim::ROW_VECTOR:
 case Dim::COL_VECTOR: d.v()=d1.v(); break;
 case Dim::MATRIX: d.m()=d1.m().transpose(); break;
 case Dim::MATRIX_ARRAY: (static_cast <bool> (false) ? void (0) : __assert_fail ("false", "/usr/local/include/ibex/ibex_TemplateDomain.h", 904, __extension__ __PRETTY_FUNCTION__)); break;
 }
 return d;
}

template<class D>
TemplateDomain<D> pow(const TemplateDomain<D>& d1, int i) {
 (static_cast <bool> (d1.dim.is_scalar()) ? void (0) : __assert_fail ("d1.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 911, __extension__ __PRETTY_FUNCTION__));

 TemplateDomain<D> d(Dim::scalar());
 d.i()=pow(d1.i(),i);

 return d;
}
template<class D>
TemplateDomain<D> pow(const TemplateDomain<D>& d1, const TemplateDomain<D>& p) {
 (static_cast <bool> (d1.dim.is_scalar() && p.dim.is_scalar()) ? void (0) : __assert_fail ("d1.dim.is_scalar() && p.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 920, __extension__ __PRETTY_FUNCTION__));

 TemplateDomain<D> d(Dim::scalar());

 typename D::SCALAR expon=p.i();


 if (expon.is_degenerated()) {
  double x=expon.mid();
  if (floor(x)==x) {
   d.i()=pow(d1.i(),(int) x);
   return d;
  }
 }

 d.i()=pow(d1.i(),expon);
 return d;
}
# 953 "/usr/local/include/ibex/ibex_TemplateDomain.h" 3
template<class D>
TemplateDomain<D> operator/(const TemplateDomain<D>& d1, const TemplateDomain<D>& d2) { (static_cast <bool> (d1.dim.is_scalar() && d2.dim.is_scalar()) ? void (0) : __assert_fail ("d1.dim.is_scalar() && d2.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 954, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d3(Dim::scalar()); d3.i()=operator/(d1.i(),d2.i()); return d3;; }
template<class D>
TemplateDomain<D> max(const TemplateDomain<D>& d1, const TemplateDomain<D>& d2) { (static_cast <bool> (d1.dim.is_scalar() && d2.dim.is_scalar()) ? void (0) : __assert_fail ("d1.dim.is_scalar() && d2.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 956, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d3(Dim::scalar()); d3.i()=max(d1.i(),d2.i()); return d3;; }
template<class D>
TemplateDomain<D> min(const TemplateDomain<D>& d1, const TemplateDomain<D>& d2) { (static_cast <bool> (d1.dim.is_scalar() && d2.dim.is_scalar()) ? void (0) : __assert_fail ("d1.dim.is_scalar() && d2.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 958, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d3(Dim::scalar()); d3.i()=min(d1.i(),d2.i()); return d3;; }
template<class D>
TemplateDomain<D> atan2(const TemplateDomain<D>& d1, const TemplateDomain<D>& d2) { (static_cast <bool> (d1.dim.is_scalar() && d2.dim.is_scalar()) ? void (0) : __assert_fail ("d1.dim.is_scalar() && d2.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 960, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d3(Dim::scalar()); d3.i()=atan2(d1.i(),d2.i()); return d3;; }

template<class D>
TemplateDomain<D> sign(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 963, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=sign(d.i()); return d2;; }
template<class D>
TemplateDomain<D> abs(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 965, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=abs(d.i()); return d2;; }
template<class D>
TemplateDomain<D> sqr(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 967, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=sqr(d.i()); return d2;; }
template<class D>
TemplateDomain<D> sqrt(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 969, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=sqrt(d.i()); return d2;; }
template<class D>
TemplateDomain<D> exp(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 971, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=exp(d.i()); return d2;; }
template<class D>
TemplateDomain<D> log(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 973, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=log(d.i()); return d2;; }
template<class D>
TemplateDomain<D> cos(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 975, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=cos(d.i()); return d2;; }
template<class D>
TemplateDomain<D> sin(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 977, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=sin(d.i()); return d2;; }
template<class D>
TemplateDomain<D> tan(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 979, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=tan(d.i()); return d2;; }
template<class D>
TemplateDomain<D> acos(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 981, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=acos(d.i()); return d2;; }
template<class D>
TemplateDomain<D> asin(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 983, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=asin(d.i()); return d2;; }
template<class D>
TemplateDomain<D> atan(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 985, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=atan(d.i()); return d2;; }
template<class D>
TemplateDomain<D> cosh(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 987, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=cosh(d.i()); return d2;; }
template<class D>
TemplateDomain<D> sinh(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 989, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=sinh(d.i()); return d2;; }
template<class D>
TemplateDomain<D> tanh(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 991, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=tanh(d.i()); return d2;; }
template<class D>
TemplateDomain<D> acosh(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 993, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=acosh(d.i()); return d2;; }
template<class D>
TemplateDomain<D> asinh(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 995, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=asinh(d.i()); return d2;; }
template<class D>
TemplateDomain<D> atanh(const TemplateDomain<D>& d) { (static_cast <bool> (d.dim.is_scalar()) ? void (0) : __assert_fail ("d.dim.is_scalar()", "/usr/local/include/ibex/ibex_TemplateDomain.h", 997, __extension__ __PRETTY_FUNCTION__)); TemplateDomain<D> d2(Dim::scalar()); d2.i()=atanh(d.i()); return d2;; }



}
# 18 "/usr/local/include/ibex/ibex_Affine2Domain.h" 2 3

namespace ibex {
# 35 "/usr/local/include/ibex/ibex_Affine2Domain.h" 3
typedef TemplateDomain<Affine2> Affine2Domain;
typedef TemplateDomain<AffineLin> AffineLinDomain;


template<>
inline TemplateDomain<Affine2>& TemplateDomain<Affine2>::operator&=(const TemplateDomain<Affine2>& ) {

        throw std::logic_error("intersection is forbidden with affine forms");
}


template<>
inline TemplateDomain<Affine2> atan2(const TemplateDomain<Affine2>& d1, const TemplateDomain<Affine2>& ) {

 not_implemented("atan2 with affine forms");
 return d1;
}

template<>
inline TemplateDomain<Affine2> acosh(const TemplateDomain<Affine2>& d) {

 not_implemented("acosh with affine forms");
 return d;
}

template<>
inline TemplateDomain<Affine2> asinh(const TemplateDomain<Affine2>& d) {

 not_implemented("asinh with affine forms");
 return d;
}


template<>
inline TemplateDomain<Affine2> atanh(const TemplateDomain<Affine2>& d) {

 not_implemented("atanh with affine forms");
 return d;
}


template<>
inline TemplateDomain<AffineLin>& TemplateDomain<AffineLin>::operator&=(const TemplateDomain<AffineLin>& ) {

        throw std::logic_error("intersection is forbidden with affine forms");
}


template<>
inline TemplateDomain<AffineLin> atan2(const TemplateDomain<AffineLin>& d1, const TemplateDomain<AffineLin>& ) {

 not_implemented("atan2 with affine forms");
 return d1;
}

template<>
inline TemplateDomain<AffineLin> acosh(const TemplateDomain<AffineLin>& d) {

 not_implemented("acosh with affine forms");
 return d;
}

template<>
inline TemplateDomain<AffineLin> asinh(const TemplateDomain<AffineLin>& d) {

 not_implemented("asinh with affine forms");
 return d;
}


template<>
inline TemplateDomain<AffineLin> atanh(const TemplateDomain<AffineLin>& d) {

 not_implemented("atanh with affine forms");
 return d;
}

}
# 4 "/usr/local/include/ibex/ibex.h" 2 3
# 15 "/usr/local/include/ibex/ibex.h" 3
# 1 "/usr/local/include/ibex/ibex_DimException.h" 1 3
# 16 "/usr/local/include/ibex/ibex_DimException.h" 3
namespace ibex {







class DimException : public Exception {
public:

 DimException(std::string message1) : msg(message1) { }



 std::string message() { return msg; }

private:
 std::string msg;
};

}
# 16 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Domain.h" 1 3
# 18 "/usr/local/include/ibex/ibex_Domain.h" 3
namespace ibex {
# 34 "/usr/local/include/ibex/ibex_Domain.h" 3
typedef TemplateDomain<Interval> Domain;

}
# 17 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_InnerArith.h" 1 3
# 17 "/usr/local/include/ibex/ibex_InnerArith.h" 3
namespace ibex {
# 27 "/usr/local/include/ibex/ibex_InnerArith.h" 3
Interval iadd(const Interval& x, const Interval& y);






Interval isub(const Interval& x, const Interval& y);






Interval imul(const Interval& x, const Interval& y);






Interval idiv(const Interval& x, const Interval& y);






Interval imax(const Interval& x, const Interval& y);






Interval imin(const Interval& x, const Interval& y);






Interval isqr(const Interval& x);






Interval iminus(const Interval& x);






Interval ilog(const Interval& x);






Interval iexp(const Interval& x);






Interval iacos(const Interval& x);






Interval iasin(const Interval& x);






Interval iatan(const Interval& x);
# 141 "/usr/local/include/ibex/ibex_InnerArith.h" 3
bool ibwd_add(const Interval& z, Interval& x, Interval& y, const Interval &xin=Interval::EMPTY_SET, const Interval& yin=Interval::EMPTY_SET);






bool ibwd_sub(const Interval& z, Interval& x, Interval& y, const Interval &xin=Interval::EMPTY_SET, const Interval& yin=Interval::EMPTY_SET);






bool ibwd_mul(const Interval& z, Interval& x, Interval& y, const Interval &xin=Interval::EMPTY_SET, const Interval& yin=Interval::EMPTY_SET);






bool ibwd_div(const Interval& z, Interval& x, Interval& y, const Interval &xin=Interval::EMPTY_SET, const Interval& yin=Interval::EMPTY_SET);






bool ibwd_max(const Interval& z, Interval& x, Interval& y, const Interval &xin=Interval::EMPTY_SET, const Interval& yin=Interval::EMPTY_SET);






bool ibwd_min(const Interval& z, Interval& x, Interval& y, const Interval &xin=Interval::EMPTY_SET, const Interval& yin=Interval::EMPTY_SET);
# 197 "/usr/local/include/ibex/ibex_InnerArith.h" 3
bool ibwd_sqr(const Interval& y, Interval& x, const Interval& xin=Interval::EMPTY_SET);







bool ibwd_minus(const Interval& y, Interval& x);







bool ibwd_abs(const Interval& y, Interval& x, const Interval& xin=Interval::EMPTY_SET);






bool ibwd_pow(const Interval& y, Interval& x, int p, const Interval &xin=Interval::EMPTY_SET);






bool ibwd_exp(const Interval& y, Interval& x);






bool ibwd_log(const Interval& y, Interval& x);







bool ibwd_cos(const Interval& y, Interval& x, const Interval &xin=Interval::EMPTY_SET);







bool ibwd_sin(const Interval& y, Interval& x, const Interval &xin=Interval::EMPTY_SET);







bool ibwd_tan(const Interval& y, Interval& x, const Interval &xin=Interval::EMPTY_SET);






bool ibwd_sqrt(const Interval& y, Interval& x);
# 275 "/usr/local/include/ibex/ibex_InnerArith.h" 3
inline Interval iminus(const Interval& x) {
 return -x;
}


inline Interval imax(const Interval& x, const Interval& y) {

 return max(x,y);
}

inline Interval imin(const Interval& x, const Interval& y) {

 return min(x,y);
}

inline bool ibwd_minus(const Interval& y, Interval& x) {
 return !(x&=iminus(y)).is_empty();
}

inline bool ibwd_exp(const Interval& y, Interval& x) {
 return !(x&=ilog(y)).is_empty();
}

inline bool ibwd_log(const Interval& y, Interval& x) {
 return !(x&=iexp(y)).is_empty();
}

inline bool ibwd_sqrt(const Interval& y, Interval& x) {
 return !(x&=isqr(y & Interval::POS_REALS)).is_empty();
}

}
# 18 "/usr/local/include/ibex/ibex.h" 2 3
# 26 "/usr/local/include/ibex/ibex.h" 3
# 1 "/usr/local/include/ibex/ibex_Tube.h" 1 3
# 27 "/usr/local/include/ibex/ibex.h" 2 3

# 1 "/usr/local/include/ibex/ibex_Bsc.h" 1 3
# 14 "/usr/local/include/ibex/ibex_Bsc.h" 3
# 1 "/usr/local/include/ibex/ibex_Cell.h" 1 3
# 15 "/usr/local/include/ibex/ibex_Cell.h" 3
# 1 "/usr/local/include/ibex/ibex_Backtrackable.h" 1 3
# 16 "/usr/local/include/ibex/ibex_Backtrackable.h" 3
namespace ibex {
# 32 "/usr/local/include/ibex/ibex_Backtrackable.h" 3
class Backtrackable {
public:







 Backtrackable() { }




 virtual std::pair<Backtrackable*,Backtrackable*> down()=0;




 virtual ~Backtrackable() { }
};

}
# 16 "/usr/local/include/ibex/ibex_Cell.h" 2 3
# 1 "/usr/local/include/ibex/ibex_SymbolMap.h" 1 3
# 15 "/usr/local/include/ibex/ibex_SymbolMap.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 16 "/usr/local/include/ibex/ibex_SymbolMap.h" 2 3
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4

extern "C" {




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 42 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 88 "/usr/include/string.h" 3 4
}
# 98 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 121 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 203 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 223 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 250 "/usr/include/string.h" 3 4
}
# 260 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 272 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 300 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 327 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 368 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) throw ();
# 420 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, locale_t __l) throw ();



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 66 "/usr/include/strings.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 94 "/usr/include/strings.h" 3 4
}
# 104 "/usr/include/strings.h" 3 4
extern int ffs (int __i) throw () __attribute__ ((__const__));





extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 432 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 498 "/usr/include/string.h" 3 4
}
# 17 "/usr/local/include/ibex/ibex_SymbolMap.h" 2 3

# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 44 "/usr/include/c++/7/cassert" 2 3
# 19 "/usr/local/include/ibex/ibex_SymbolMap.h" 2 3


namespace ibex {

struct hash_string {






 unsigned long operator()(const char *str) const {

  unsigned long hash = 0;
  int c;

  while ((c = *str++))
   hash = c + (hash << 6) + (hash << 16) - hash;

  return hash;
 }
};

struct equal_string {
 bool operator() (const char* s1, const char* s2) const {
  return strcmp (s1, s2) == 0;
 }
};

}


# 1 "/usr/include/c++/7/ciso646" 1 3
# 35 "/usr/include/c++/7/ciso646" 3
       
# 36 "/usr/include/c++/7/ciso646" 3
# 52 "/usr/local/include/ibex/ibex_SymbolMap.h" 2 3




# 1 "/usr/include/c++/7/tr1/unordered_map" 1 3
# 32 "/usr/include/c++/7/tr1/unordered_map" 3
       
# 33 "/usr/include/c++/7/tr1/unordered_map" 3






# 1 "/usr/include/c++/7/tr1/type_traits" 1 3
# 32 "/usr/include/c++/7/tr1/type_traits" 3
       
# 33 "/usr/include/c++/7/tr1/type_traits" 3



namespace std __attribute__ ((__visibility__ ("default")))
{
namespace tr1
{







  struct __sfinae_types
  {
    typedef char __one;
    typedef struct { char __arr[2]; } __two;
  };
# 70 "/usr/include/c++/7/tr1/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static const _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
    };


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<typename _Tp, _Tp __v>
    const _Tp integral_constant<_Tp, __v>::value;


  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };
  template<> struct __is_void_helper<void> : public integral_constant<bool, true> { };




  template<typename _Tp>
    struct is_void
    : public integral_constant<bool, (__is_void_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };
  template<> struct __is_integral_helper<bool> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<char> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<signed char> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned char> : public integral_constant<bool, true> { };

  template<> struct __is_integral_helper<wchar_t> : public integral_constant<bool, true> { };

  template<> struct __is_integral_helper<short> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned short> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<int> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned int> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<long> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned long> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<long long> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned long long> : public integral_constant<bool, true> { };


  template<typename _Tp>
    struct is_integral
    : public integral_constant<bool, (__is_integral_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };
  template<> struct __is_floating_point_helper<float> : public integral_constant<bool, true> { };
  template<> struct __is_floating_point_helper<double> : public integral_constant<bool, true> { };
  template<> struct __is_floating_point_helper<long double> : public integral_constant<bool, true> { };


  template<typename _Tp>
    struct is_floating_point
    : public integral_constant<bool, (__is_floating_point_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };
  template<typename _Tp> struct __is_pointer_helper<_Tp*> : public integral_constant<bool, true> { };


  template<typename _Tp>
    struct is_pointer
    : public integral_constant<bool, (__is_pointer_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };


  template<typename _Tp>
    struct is_reference;


  template<typename _Tp>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };
  template<typename _Tp, typename _Cp> struct __is_member_object_pointer_helper<_Tp _Cp::*> : public integral_constant<bool, !is_function<_Tp>::value> { };



  template<typename _Tp>
    struct is_member_object_pointer
    : public integral_constant<bool, (__is_member_object_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };
  template<typename _Tp, typename _Cp> struct __is_member_function_pointer_helper<_Tp _Cp::*> : public integral_constant<bool, is_function<_Tp>::value> { };



  template<typename _Tp>
    struct is_member_function_pointer
    : public integral_constant<bool, (__is_member_function_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...)>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......)>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile>
    : public true_type { };




  template<typename _Tp>
    struct is_arithmetic
    : public integral_constant<bool, (is_integral<_Tp>::value
          || is_floating_point<_Tp>::value)>
    { };


  template<typename _Tp>
    struct is_fundamental
    : public integral_constant<bool, (is_arithmetic<_Tp>::value
          || is_void<_Tp>::value)>
    { };


  template<typename _Tp>
    struct is_object
    : public integral_constant<bool, !(is_function<_Tp>::value
           || is_reference<_Tp>::value
           || is_void<_Tp>::value)>
    { };


  template<typename _Tp>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public integral_constant<bool, (is_arithmetic<_Tp>::value
          || is_enum<_Tp>::value
          || is_pointer<_Tp>::value
          || is_member_pointer<_Tp>::value)>
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };


  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };
  template<typename _Tp, typename _Cp> struct __is_member_pointer_helper<_Tp _Cp::*> : public integral_constant<bool, true> { };

  template<typename _Tp>
  struct is_member_pointer
    : public integral_constant<bool, (__is_member_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };



  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };


  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };


  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };


  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint = 0>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };




  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };




  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };




  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };

  template<typename>
    struct remove_reference;


  template<typename _Tp>
    struct add_pointer
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename>
    struct is_reference
    : public false_type { };

  template<typename _Tp>
    struct is_reference<_Tp&>
    : public true_type { };

  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp) || is_void<_Tp>::value>
    { };

  template<typename _Tp>
    struct has_trivial_constructor
    : public integral_constant<bool, is_pod<_Tp>::value>
    { };

  template<typename _Tp>
    struct has_trivial_copy
    : public integral_constant<bool, is_pod<_Tp>::value>
    { };

  template<typename _Tp>
    struct has_trivial_assign
    : public integral_constant<bool, is_pod<_Tp>::value>
    { };

  template<typename _Tp>
    struct has_trivial_destructor
    : public integral_constant<bool, is_pod<_Tp>::value>
    { };

  template<typename _Tp>
    struct has_nothrow_constructor
    : public integral_constant<bool, is_pod<_Tp>::value>
    { };

  template<typename _Tp>
    struct has_nothrow_copy
    : public integral_constant<bool, is_pod<_Tp>::value>
    { };

  template<typename _Tp>
    struct has_nothrow_assign
    : public integral_constant<bool, is_pod<_Tp>::value>
    { };

  template<typename>
    struct __is_signed_helper
    : public false_type { };
  template<> struct __is_signed_helper<signed char> : public integral_constant<bool, true> { };
  template<> struct __is_signed_helper<short> : public integral_constant<bool, true> { };
  template<> struct __is_signed_helper<int> : public integral_constant<bool, true> { };
  template<> struct __is_signed_helper<long> : public integral_constant<bool, true> { };
  template<> struct __is_signed_helper<long long> : public integral_constant<bool, true> { };

  template<typename _Tp>
    struct is_signed
    : public integral_constant<bool, (__is_signed_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_unsigned_helper
    : public false_type { };
  template<> struct __is_unsigned_helper<unsigned char> : public integral_constant<bool, true> { };
  template<> struct __is_unsigned_helper<unsigned short> : public integral_constant<bool, true> { };
  template<> struct __is_unsigned_helper<unsigned int> : public integral_constant<bool, true> { };
  template<> struct __is_unsigned_helper<unsigned long> : public integral_constant<bool, true> { };
  template<> struct __is_unsigned_helper<unsigned long long> : public integral_constant<bool, true> { };

  template<typename _Tp>
    struct is_unsigned
    : public integral_constant<bool, (__is_unsigned_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename _Base, typename _Derived>
    struct __is_base_of_helper
    {
      typedef typename remove_cv<_Base>::type _NoCv_Base;
      typedef typename remove_cv<_Derived>::type _NoCv_Derived;
      static const bool __value = (is_same<_Base, _Derived>::value
       || (__is_base_of(_Base, _Derived)
           && !is_same<_NoCv_Base,
                       _NoCv_Derived>::value));
    };

  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool,
          __is_base_of_helper<_Base, _Derived>::__value>
    { };

  template<typename _From, typename _To>
    struct __is_convertible_simple
    : public __sfinae_types
    {
    private:
      static __one __test(_To);
      static __two __test(...);
      static _From __makeFrom();

    public:
      static const bool __value = sizeof(__test(__makeFrom())) == 1;
    };

  template<typename _Tp>
    struct add_reference;

  template<typename _Tp>
    struct __is_int_or_cref
    {
      typedef typename remove_reference<_Tp>::type __rr_Tp;
      static const bool __value = (is_integral<_Tp>::value
       || (is_integral<__rr_Tp>::value
           && is_const<__rr_Tp>::value
           && !is_volatile<__rr_Tp>::value));
    };

  template<typename _From, typename _To,
    bool = (is_void<_From>::value || is_void<_To>::value
     || is_function<_To>::value || is_array<_To>::value

     || (is_floating_point<typename
         remove_reference<_From>::type>::value
         && __is_int_or_cref<_To>::__value))>
    struct __is_convertible_helper
    {

      static const bool __value = (__is_convertible_simple<typename
       add_reference<_From>::type, _To>::__value);
    };

  template<typename _From, typename _To>
    struct __is_convertible_helper<_From, _To, true>
    { static const bool __value = (is_void<_To>::value
       || (__is_int_or_cref<_To>::__value
           && !is_void<_From>::value)); };

  template<typename _From, typename _To>
    struct is_convertible
    : public integral_constant<bool,
          __is_convertible_helper<_From, _To>::__value>
    { };


  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };


  template<typename _Tp, bool = (is_void<_Tp>::value
     || is_reference<_Tp>::value)>
    struct __add_reference_helper
    { typedef _Tp& type; };

  template<typename _Tp>
    struct __add_reference_helper<_Tp, true>
    { typedef _Tp type; };

  template<typename _Tp>
    struct add_reference
    : public __add_reference_helper<_Tp>
    { };


  template<std::size_t _Len, std::size_t _Align>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };
# 683 "/usr/include/c++/7/tr1/type_traits" 3

}
}
# 40 "/usr/include/c++/7/tr1/unordered_map" 2 3
# 1 "/usr/include/c++/7/tr1/functional_hash.h" 1 3
# 33 "/usr/include/c++/7/tr1/functional_hash.h" 3
       
# 34 "/usr/include/c++/7/tr1/functional_hash.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{
namespace tr1
{





  template<typename _Tp>
    struct hash : public std::unary_function<_Tp, size_t>
    {
      size_t
      operator()(_Tp __val) const;
    };


  template<typename _Tp>
    struct hash<_Tp*> : public std::unary_function<_Tp*, size_t>
    {
      size_t
      operator()(_Tp* __p) const
      { return reinterpret_cast<size_t>(__p); }
    };
# 67 "/usr/include/c++/7/tr1/functional_hash.h" 3
  template<> inline size_t hash<bool>::operator()(bool __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<char>::operator()(char __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<signed char>::operator()(signed char __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<unsigned char>::operator()(unsigned char __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<wchar_t>::operator()(wchar_t __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<short>::operator()(short __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<int>::operator()(int __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<long>::operator()(long __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<long long>::operator()(long long __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<unsigned short>::operator()(unsigned short __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<unsigned int>::operator()(unsigned int __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<unsigned long>::operator()(unsigned long __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<unsigned long long>::operator()(unsigned long long __val) const { return static_cast<size_t>(__val); };
# 91 "/usr/include/c++/7/tr1/functional_hash.h" 3
  template<size_t>
    struct _Fnv_hash_base
    {
      template<typename _Tp>
        static size_t
        hash(const _Tp* __ptr, size_t __clength)
        {
   size_t __result = 0;
   const char* __cptr = reinterpret_cast<const char*>(__ptr);
   for (; __clength; --__clength)
     __result = (__result * 131) + *__cptr++;
   return __result;
 }
    };

  template<>
    struct _Fnv_hash_base<4>
    {
      template<typename _Tp>
        static size_t
        hash(const _Tp* __ptr, size_t __clength)
        {
   size_t __result = static_cast<size_t>(2166136261UL);
   const char* __cptr = reinterpret_cast<const char*>(__ptr);
   for (; __clength; --__clength)
     {
       __result ^= static_cast<size_t>(*__cptr++);
       __result *= static_cast<size_t>(16777619UL);
     }
   return __result;
 }
    };

  template<>
    struct _Fnv_hash_base<8>
    {
      template<typename _Tp>
        static size_t
        hash(const _Tp* __ptr, size_t __clength)
        {
   size_t __result
     = static_cast<size_t>(14695981039346656037ULL);
   const char* __cptr = reinterpret_cast<const char*>(__ptr);
   for (; __clength; --__clength)
     {
       __result ^= static_cast<size_t>(*__cptr++);
       __result *= static_cast<size_t>(1099511628211ULL);
     }
   return __result;
 }
    };

  struct _Fnv_hash
  : public _Fnv_hash_base<sizeof(size_t)>
  {
    using _Fnv_hash_base<sizeof(size_t)>::hash;

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }
  };


  template<>
    inline size_t
    hash<float>::operator()(float __val) const
    {

      return __val != 0.0f ? std::tr1::_Fnv_hash::hash(__val) : 0;
    }


  template<>
    inline size_t
    hash<double>::operator()(double __val) const
    {

      return __val != 0.0 ? std::tr1::_Fnv_hash::hash(__val) : 0;
    }


  template<>
    __attribute__ ((__pure__)) size_t
    hash<long double>::operator()(long double __val) const;


  template<>
    __attribute__ ((__pure__)) size_t
    hash<string>::operator()(string) const;

  template<>
    __attribute__ ((__pure__)) size_t
    hash<const string&>::operator()(const string&) const;


  template<>
    __attribute__ ((__pure__)) size_t
    hash<wstring>::operator()(wstring) const;

  template<>
    __attribute__ ((__pure__)) size_t
    hash<const wstring&>::operator()(const wstring&) const;



}
}
# 41 "/usr/include/c++/7/tr1/unordered_map" 2 3
# 1 "/usr/include/c++/7/tr1/hashtable.h" 1 3
# 34 "/usr/include/c++/7/tr1/hashtable.h" 3
       
# 35 "/usr/include/c++/7/tr1/hashtable.h" 3

# 1 "/usr/include/c++/7/tr1/hashtable_policy.h" 1 3
# 31 "/usr/include/c++/7/tr1/hashtable_policy.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
namespace tr1
{
namespace __detail
{




  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::input_iterator_tag)
    { return 0; }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::forward_iterator_tag)
    { return std::distance(__first, __last); }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last)
    {
      typedef typename std::iterator_traits<_Iterator>::iterator_category _Tag;
      return __distance_fw(__first, __last, _Tag());
    }
# 68 "/usr/include/c++/7/tr1/hashtable_policy.h" 3
  template<typename _Value, bool __cache_hash_code>
    struct _Hash_node;

  template<typename _Value>
    struct _Hash_node<_Value, true>
    {
      _Value _M_v;
      std::size_t _M_hash_code;
      _Hash_node* _M_next;
    };

  template<typename _Value>
    struct _Hash_node<_Value, false>
    {
      _Value _M_v;
      _Hash_node* _M_next;
    };



  template<typename _Value, bool __cache>
    struct _Node_iterator_base
    {
      _Node_iterator_base(_Hash_node<_Value, __cache>* __p)
      : _M_cur(__p) { }

      void
      _M_incr()
      { _M_cur = _M_cur->_M_next; }

      _Hash_node<_Value, __cache>* _M_cur;
    };

  template<typename _Value, bool __cache>
    inline bool
    operator==(const _Node_iterator_base<_Value, __cache>& __x,
        const _Node_iterator_base<_Value, __cache>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Value, bool __cache>
    inline bool
    operator!=(const _Node_iterator_base<_Value, __cache>& __x,
        const _Node_iterator_base<_Value, __cache>& __y)
    { return __x._M_cur != __y._M_cur; }

  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
      typedef _Value value_type;
      typedef typename
      __gnu_cxx::__conditional_type<__constant_iterators,
        const _Value*, _Value*>::__type
                                                       pointer;
      typedef typename
      __gnu_cxx::__conditional_type<__constant_iterators,
        const _Value&, _Value&>::__type
                                                       reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Node_iterator()
      : _Node_iterator_base<_Value, __cache>(0) { }

      explicit
      _Node_iterator(_Hash_node<_Value, __cache>* __p)
      : _Node_iterator_base<_Value, __cache>(__p) { }

      reference
      operator*() const
      { return this->_M_cur->_M_v; }

      pointer
      operator->() const
      { return std::__addressof(this->_M_cur->_M_v); }

      _Node_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Node_iterator
      operator++(int)
      {
 _Node_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };

  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_const_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
      typedef _Value value_type;
      typedef const _Value* pointer;
      typedef const _Value& reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Node_const_iterator()
      : _Node_iterator_base<_Value, __cache>(0) { }

      explicit
      _Node_const_iterator(_Hash_node<_Value, __cache>* __p)
      : _Node_iterator_base<_Value, __cache>(__p) { }

      _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,
      __cache>& __x)
      : _Node_iterator_base<_Value, __cache>(__x._M_cur) { }

      reference
      operator*() const
      { return this->_M_cur->_M_v; }

      pointer
      operator->() const
      { return std::__addressof(this->_M_cur->_M_v); }

      _Node_const_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Node_const_iterator
      operator++(int)
      {
 _Node_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };

  template<typename _Value, bool __cache>
    struct _Hashtable_iterator_base
    {
      _Hashtable_iterator_base(_Hash_node<_Value, __cache>* __node,
          _Hash_node<_Value, __cache>** __bucket)
      : _M_cur_node(__node), _M_cur_bucket(__bucket) { }

      void
      _M_incr()
      {
 _M_cur_node = _M_cur_node->_M_next;
 if (!_M_cur_node)
   _M_incr_bucket();
      }

      void
      _M_incr_bucket();

      _Hash_node<_Value, __cache>* _M_cur_node;
      _Hash_node<_Value, __cache>** _M_cur_bucket;
    };



  template<typename _Value, bool __cache>
    void
    _Hashtable_iterator_base<_Value, __cache>::
    _M_incr_bucket()
    {
      ++_M_cur_bucket;


      while (!*_M_cur_bucket)
 ++_M_cur_bucket;
      _M_cur_node = *_M_cur_bucket;
    }

  template<typename _Value, bool __cache>
    inline bool
    operator==(const _Hashtable_iterator_base<_Value, __cache>& __x,
        const _Hashtable_iterator_base<_Value, __cache>& __y)
    { return __x._M_cur_node == __y._M_cur_node; }

  template<typename _Value, bool __cache>
    inline bool
    operator!=(const _Hashtable_iterator_base<_Value, __cache>& __x,
        const _Hashtable_iterator_base<_Value, __cache>& __y)
    { return __x._M_cur_node != __y._M_cur_node; }

  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Hashtable_iterator
    : public _Hashtable_iterator_base<_Value, __cache>
    {
      typedef _Value value_type;
      typedef typename
      __gnu_cxx::__conditional_type<__constant_iterators,
        const _Value*, _Value*>::__type
                                                       pointer;
      typedef typename
      __gnu_cxx::__conditional_type<__constant_iterators,
        const _Value&, _Value&>::__type
                                                       reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Hashtable_iterator()
      : _Hashtable_iterator_base<_Value, __cache>(0, 0) { }

      _Hashtable_iterator(_Hash_node<_Value, __cache>* __p,
     _Hash_node<_Value, __cache>** __b)
      : _Hashtable_iterator_base<_Value, __cache>(__p, __b) { }

      explicit
      _Hashtable_iterator(_Hash_node<_Value, __cache>** __b)
      : _Hashtable_iterator_base<_Value, __cache>(*__b, __b) { }

      reference
      operator*() const
      { return this->_M_cur_node->_M_v; }

      pointer
      operator->() const
      { return std::__addressof(this->_M_cur_node->_M_v); }

      _Hashtable_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Hashtable_iterator
      operator++(int)
      {
 _Hashtable_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };

  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Hashtable_const_iterator
    : public _Hashtable_iterator_base<_Value, __cache>
    {
      typedef _Value value_type;
      typedef const _Value* pointer;
      typedef const _Value& reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Hashtable_const_iterator()
      : _Hashtable_iterator_base<_Value, __cache>(0, 0) { }

      _Hashtable_const_iterator(_Hash_node<_Value, __cache>* __p,
    _Hash_node<_Value, __cache>** __b)
      : _Hashtable_iterator_base<_Value, __cache>(__p, __b) { }

      explicit
      _Hashtable_const_iterator(_Hash_node<_Value, __cache>** __b)
      : _Hashtable_iterator_base<_Value, __cache>(*__b, __b) { }

      _Hashtable_const_iterator(const _Hashtable_iterator<_Value,
    __constant_iterators, __cache>& __x)
      : _Hashtable_iterator_base<_Value, __cache>(__x._M_cur_node,
        __x._M_cur_bucket) { }

      reference
      operator*() const
      { return this->_M_cur_node->_M_v; }

      pointer
      operator->() const
      { return std::__addressof(this->_M_cur_node->_M_v); }

      _Hashtable_const_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Hashtable_const_iterator
      operator++(int)
      {
 _Hashtable_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };







  struct _Mod_range_hashing
  {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type
    operator()(first_argument_type __num, second_argument_type __den) const
    { return __num % __den; }
  };






  struct _Default_ranged_hash { };



  struct _Prime_rehash_policy
  {
    _Prime_rehash_policy(float __z = 1.0)
    : _M_max_load_factor(__z), _M_growth_factor(2.f), _M_next_resize(0) { }

    float
    max_load_factor() const
    { return _M_max_load_factor; }


    std::size_t
    _M_next_bkt(std::size_t __n) const;


    std::size_t
    _M_bkt_for_elements(std::size_t __n) const;





    std::pair<bool, std::size_t>
    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
     std::size_t __n_ins) const;

    enum { _S_n_primes = sizeof(unsigned long) != 8 ? 256 : 256 + 48 };

    float _M_max_load_factor;
    float _M_growth_factor;
    mutable std::size_t _M_next_resize;
  };

  extern const unsigned long __prime_list[];





  inline std::size_t
  _Prime_rehash_policy::
  _M_next_bkt(std::size_t __n) const
  {



    const unsigned long* __p
      = std::lower_bound(__prime_list, __prime_list + _S_n_primes - 1, __n);
    _M_next_resize =
      static_cast<std::size_t>(__builtin_ceil(*__p * _M_max_load_factor));
    return *__p;
  }



  inline std::size_t
  _Prime_rehash_policy::
  _M_bkt_for_elements(std::size_t __n) const
  {
    const float __min_bkts = __n / _M_max_load_factor;
    return _M_next_bkt(__builtin_ceil(__min_bkts));
  }
# 452 "/usr/include/c++/7/tr1/hashtable_policy.h" 3
  inline std::pair<bool, std::size_t>
  _Prime_rehash_policy::
  _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
   std::size_t __n_ins) const
  {
    if (__n_elt + __n_ins > _M_next_resize)
      {
 float __min_bkts = ((float(__n_ins) + float(__n_elt))
       / _M_max_load_factor);
 if (__min_bkts > __n_bkt)
   {
     __min_bkts = std::max(__min_bkts, _M_growth_factor * __n_bkt);
     return std::make_pair(true,
      _M_next_bkt(__builtin_ceil(__min_bkts)));
   }
 else
   {
     _M_next_resize = static_cast<std::size_t>
       (__builtin_ceil(__n_bkt * _M_max_load_factor));
     return std::make_pair(false, 0);
   }
      }
    else
      return std::make_pair(false, 0);
  }
# 492 "/usr/include/c++/7/tr1/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _Ex, bool __unique,
    typename _Hashtable>
    struct _Map_base { };

  template<typename _Key, typename _Pair, typename _Hashtable>
    struct _Map_base<_Key, _Pair, std::_Select1st<_Pair>, false, _Hashtable>
    {
      typedef typename _Pair::second_type mapped_type;
    };

  template<typename _Key, typename _Pair, typename _Hashtable>
    struct _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>
    {
      typedef typename _Pair::second_type mapped_type;

      mapped_type&
      operator[](const _Key& __k);
    };

  template<typename _Key, typename _Pair, typename _Hashtable>
    typename _Map_base<_Key, _Pair, std::_Select1st<_Pair>,
         true, _Hashtable>::mapped_type&
    _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::
    operator[](const _Key& __k)
    {
      _Hashtable* __h = static_cast<_Hashtable*>(this);
      typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code,
          __h->_M_bucket_count);

      typename _Hashtable::_Node* __p =
 __h->_M_find_node(__h->_M_buckets[__n], __k, __code);
      if (!__p)
 return __h->_M_insert_bucket(std::make_pair(__k, mapped_type()),
         __n, __code)->second;
      return (__p->_M_v).second;
    }



  template<typename _RehashPolicy, typename _Hashtable>
    struct _Rehash_base { };

  template<typename _Hashtable>
    struct _Rehash_base<_Prime_rehash_policy, _Hashtable>
    {
      float
      max_load_factor() const
      {
 const _Hashtable* __this = static_cast<const _Hashtable*>(this);
 return __this->__rehash_policy().max_load_factor();
      }

      void
      max_load_factor(float __z)
      {
 _Hashtable* __this = static_cast<_Hashtable*>(this);
 __this->__rehash_policy(_Prime_rehash_policy(__z));
      }
    };
# 565 "/usr/include/c++/7/tr1/hashtable_policy.h" 3
  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    bool __cache_hash_code>
    struct _Hash_code_base;



  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,
      _Hash, false>
    {
    protected:
      _Hash_code_base(const _ExtractKey& __ex, const _Equal& __eq,
        const _H1&, const _H2&, const _Hash& __h)
      : _M_extract(__ex), _M_eq(__eq), _M_ranged_hash(__h) { }

      typedef void* _Hash_code_type;

      _Hash_code_type
      _M_hash_code(const _Key& __key) const
      { return 0; }

      std::size_t
      _M_bucket_index(const _Key& __k, _Hash_code_type,
        std::size_t __n) const
      { return _M_ranged_hash(__k, __n); }

      std::size_t
      _M_bucket_index(const _Hash_node<_Value, false>* __p,
        std::size_t __n) const
      { return _M_ranged_hash(_M_extract(__p->_M_v), __n); }

      bool
      _M_compare(const _Key& __k, _Hash_code_type,
   _Hash_node<_Value, false>* __n) const
      { return _M_eq(__k, _M_extract(__n->_M_v)); }

      void
      _M_store_code(_Hash_node<_Value, false>*, _Hash_code_type) const
      { }

      void
      _M_copy_code(_Hash_node<_Value, false>*,
     const _Hash_node<_Value, false>*) const
      { }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract, __x._M_extract);
 std::swap(_M_eq, __x._M_eq);
 std::swap(_M_ranged_hash, __x._M_ranged_hash);
      }

    protected:
      _ExtractKey _M_extract;
      _Equal _M_eq;
      _Hash _M_ranged_hash;
    };
# 636 "/usr/include/c++/7/tr1/hashtable_policy.h" 3
  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,
      _Hash, true>;




  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,
      _Default_ranged_hash, false>
    {
      typedef _H1 hasher;

      hasher
      hash_function() const
      { return _M_h1; }

    protected:
      _Hash_code_base(const _ExtractKey& __ex, const _Equal& __eq,
        const _H1& __h1, const _H2& __h2,
        const _Default_ranged_hash&)
      : _M_extract(__ex), _M_eq(__eq), _M_h1(__h1), _M_h2(__h2) { }

      typedef std::size_t _Hash_code_type;

      _Hash_code_type
      _M_hash_code(const _Key& __k) const
      { return _M_h1(__k); }

      std::size_t
      _M_bucket_index(const _Key&, _Hash_code_type __c,
        std::size_t __n) const
      { return _M_h2(__c, __n); }

      std::size_t
      _M_bucket_index(const _Hash_node<_Value, false>* __p,
        std::size_t __n) const
      { return _M_h2(_M_h1(_M_extract(__p->_M_v)), __n); }

      bool
      _M_compare(const _Key& __k, _Hash_code_type,
   _Hash_node<_Value, false>* __n) const
      { return _M_eq(__k, _M_extract(__n->_M_v)); }

      void
      _M_store_code(_Hash_node<_Value, false>*, _Hash_code_type) const
      { }

      void
      _M_copy_code(_Hash_node<_Value, false>*,
     const _Hash_node<_Value, false>*) const
      { }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract, __x._M_extract);
 std::swap(_M_eq, __x._M_eq);
 std::swap(_M_h1, __x._M_h1);
 std::swap(_M_h2, __x._M_h2);
      }

    protected:
      _ExtractKey _M_extract;
      _Equal _M_eq;
      _H1 _M_h1;
      _H2 _M_h2;
    };




  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,
      _Default_ranged_hash, true>
    {
      typedef _H1 hasher;

      hasher
      hash_function() const
      { return _M_h1; }

    protected:
      _Hash_code_base(const _ExtractKey& __ex, const _Equal& __eq,
        const _H1& __h1, const _H2& __h2,
        const _Default_ranged_hash&)
      : _M_extract(__ex), _M_eq(__eq), _M_h1(__h1), _M_h2(__h2) { }

      typedef std::size_t _Hash_code_type;

      _Hash_code_type
      _M_hash_code(const _Key& __k) const
      { return _M_h1(__k); }

      std::size_t
      _M_bucket_index(const _Key&, _Hash_code_type __c,
        std::size_t __n) const
      { return _M_h2(__c, __n); }

      std::size_t
      _M_bucket_index(const _Hash_node<_Value, true>* __p,
        std::size_t __n) const
      { return _M_h2(__p->_M_hash_code, __n); }

      bool
      _M_compare(const _Key& __k, _Hash_code_type __c,
   _Hash_node<_Value, true>* __n) const
      { return __c == __n->_M_hash_code && _M_eq(__k, _M_extract(__n->_M_v)); }

      void
      _M_store_code(_Hash_node<_Value, true>* __n, _Hash_code_type __c) const
      { __n->_M_hash_code = __c; }

      void
      _M_copy_code(_Hash_node<_Value, true>* __to,
     const _Hash_node<_Value, true>* __from) const
      { __to->_M_hash_code = __from->_M_hash_code; }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract, __x._M_extract);
 std::swap(_M_eq, __x._M_eq);
 std::swap(_M_h1, __x._M_h1);
 std::swap(_M_h2, __x._M_h2);
      }

    protected:
      _ExtractKey _M_extract;
      _Equal _M_eq;
      _H1 _M_h1;
      _H2 _M_h2;
    };

}
}
}
# 37 "/usr/include/c++/7/tr1/hashtable.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
namespace tr1
{

# 101 "/usr/include/c++/7/tr1/hashtable.h" 3
  template<typename _Key, typename _Value, typename _Allocator,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy,
    bool __cache_hash_code,
    bool __constant_iterators,
    bool __unique_keys>
    class _Hashtable
    : public __detail::_Rehash_base<_RehashPolicy,
        _Hashtable<_Key, _Value, _Allocator,
            _ExtractKey,
            _Equal, _H1, _H2, _Hash,
            _RehashPolicy,
            __cache_hash_code,
            __constant_iterators,
            __unique_keys> >,
      public __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,
           _H1, _H2, _Hash, __cache_hash_code>,
      public __detail::_Map_base<_Key, _Value, _ExtractKey, __unique_keys,
     _Hashtable<_Key, _Value, _Allocator,
         _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy,
         __cache_hash_code,
         __constant_iterators,
         __unique_keys> >
    {
    public:
      typedef _Allocator allocator_type;
      typedef _Value value_type;
      typedef _Key key_type;
      typedef _Equal key_equal;


      typedef typename _Allocator::difference_type difference_type;
      typedef typename _Allocator::size_type size_type;
      typedef typename _Allocator::pointer pointer;
      typedef typename _Allocator::const_pointer const_pointer;
      typedef typename _Allocator::reference reference;
      typedef typename _Allocator::const_reference const_reference;

      typedef __detail::_Node_iterator<value_type, __constant_iterators,
           __cache_hash_code>
         local_iterator;
      typedef __detail::_Node_const_iterator<value_type,
          __constant_iterators,
          __cache_hash_code>
         const_local_iterator;

      typedef __detail::_Hashtable_iterator<value_type, __constant_iterators,
         __cache_hash_code>
         iterator;
      typedef __detail::_Hashtable_const_iterator<value_type,
        __constant_iterators,
        __cache_hash_code>
         const_iterator;

      template<typename _Key2, typename _Value2, typename _Ex2, bool __unique2,
        typename _Hashtable2>
 friend struct __detail::_Map_base;

    private:
      typedef __detail::_Hash_node<_Value, __cache_hash_code> _Node;
      typedef typename _Allocator::template rebind<_Node>::other
       _Node_allocator_type;
      typedef typename _Allocator::template rebind<_Node*>::other
       _Bucket_allocator_type;

      typedef typename _Allocator::template rebind<_Value>::other
       _Value_allocator_type;

      _Node_allocator_type _M_node_allocator;
      _Node** _M_buckets;
      size_type _M_bucket_count;
      size_type _M_element_count;
      _RehashPolicy _M_rehash_policy;

      _Node*
      _M_allocate_node(const value_type& __v);

      void
      _M_deallocate_node(_Node* __n);

      void
      _M_deallocate_nodes(_Node**, size_type);

      _Node**
      _M_allocate_buckets(size_type __n);

      void
      _M_deallocate_buckets(_Node**, size_type __n);

    public:

      _Hashtable(size_type __bucket_hint,
   const _H1&, const _H2&, const _Hash&,
   const _Equal&, const _ExtractKey&,
   const allocator_type&);

      template<typename _InputIterator>
 _Hashtable(_InputIterator __first, _InputIterator __last,
     size_type __bucket_hint,
     const _H1&, const _H2&, const _Hash&,
     const _Equal&, const _ExtractKey&,
     const allocator_type&);

      _Hashtable(const _Hashtable&);

      _Hashtable&
      operator=(const _Hashtable&);

      ~_Hashtable();

      void swap(_Hashtable&);


      iterator
      begin()
      {
 iterator __i(_M_buckets);
 if (!__i._M_cur_node)
   __i._M_incr_bucket();
 return __i;
      }

      const_iterator
      begin() const
      {
 const_iterator __i(_M_buckets);
 if (!__i._M_cur_node)
   __i._M_incr_bucket();
 return __i;
      }

      iterator
      end()
      { return iterator(_M_buckets + _M_bucket_count); }

      const_iterator
      end() const
      { return const_iterator(_M_buckets + _M_bucket_count); }

      size_type
      size() const
      { return _M_element_count; }

      bool
      empty() const
      { return size() == 0; }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_node_allocator); }

      _Value_allocator_type
      _M_get_Value_allocator() const
      { return _Value_allocator_type(_M_node_allocator); }

      size_type
      max_size() const
      { return _M_node_allocator.max_size(); }


      key_equal
      key_eq() const
      { return this->_M_eq; }




      size_type
      bucket_count() const
      { return _M_bucket_count; }

      size_type
      max_bucket_count() const
      { return max_size(); }

      size_type
      bucket_size(size_type __n) const
      { return std::distance(begin(__n), end(__n)); }

      size_type
      bucket(const key_type& __k) const
      {
 return this->_M_bucket_index(__k, this->_M_hash_code(__k),
         bucket_count());
      }

      local_iterator
      begin(size_type __n)
      { return local_iterator(_M_buckets[__n]); }

      local_iterator
      end(size_type)
      { return local_iterator(0); }

      const_local_iterator
      begin(size_type __n) const
      { return const_local_iterator(_M_buckets[__n]); }

      const_local_iterator
      end(size_type) const
      { return const_local_iterator(0); }

      float
      load_factor() const
      {
 return static_cast<float>(size()) / static_cast<float>(bucket_count());
      }





      const _RehashPolicy&
      __rehash_policy() const
      { return _M_rehash_policy; }

      void
      __rehash_policy(const _RehashPolicy&);


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      std::pair<iterator, iterator>
      equal_range(const key_type& __k);

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;

    private:




      typedef typename __gnu_cxx::__conditional_type<__unique_keys,
              std::pair<iterator, bool>, iterator>::__type
 _Insert_Return_Type;

      typedef typename __gnu_cxx::__conditional_type<__unique_keys,
       std::_Select1st<_Insert_Return_Type>,
         std::_Identity<_Insert_Return_Type>
       >::__type
 _Insert_Conv_Type;

      _Node*
      _M_find_node(_Node*, const key_type&,
     typename _Hashtable::_Hash_code_type) const;

      iterator
      _M_insert_bucket(const value_type&, size_type,
         typename _Hashtable::_Hash_code_type);

      std::pair<iterator, bool>
      _M_insert(const value_type&, std::tr1::true_type);

      iterator
      _M_insert(const value_type&, std::tr1::false_type);

      void
      _M_erase_node(_Node*, _Node**);

    public:

      _Insert_Return_Type
      insert(const value_type& __v)
      { return _M_insert(__v, std::tr1::integral_constant<bool,
    __unique_keys>()); }

      iterator
      insert(iterator, const value_type& __v)
      { return iterator(_Insert_Conv_Type()(this->insert(__v))); }

      const_iterator
      insert(const_iterator, const value_type& __v)
      { return const_iterator(_Insert_Conv_Type()(this->insert(__v))); }

      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last);

      iterator
      erase(iterator);

      const_iterator
      erase(const_iterator);

      size_type
      erase(const key_type&);

      iterator
      erase(iterator, iterator);

      const_iterator
      erase(const_iterator, const_iterator);

      void
      clear();


      void rehash(size_type __n);

    private:

      void _M_rehash(size_type __n);
    };



  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   __chc, __cit, __uk>::_Node*
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_allocate_node(const value_type& __v)
    {
      _Node* __n = _M_node_allocator.allocate(1);
      try
 {
   _M_get_Value_allocator().construct(&__n->_M_v, __v);
   __n->_M_next = 0;
   return __n;
 }
      catch(...)
 {
   _M_node_allocator.deallocate(__n, 1);
   throw;
 }
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_deallocate_node(_Node* __n)
    {
      _M_get_Value_allocator().destroy(&__n->_M_v);
      _M_node_allocator.deallocate(__n, 1);
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_deallocate_nodes(_Node** __array, size_type __n)
    {
      for (size_type __i = 0; __i < __n; ++__i)
 {
   _Node* __p = __array[__i];
   while (__p)
     {
       _Node* __tmp = __p;
       __p = __p->_M_next;
       _M_deallocate_node(__tmp);
     }
   __array[__i] = 0;
 }
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   __chc, __cit, __uk>::_Node**
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_allocate_buckets(size_type __n)
    {
      _Bucket_allocator_type __alloc(_M_node_allocator);



      _Node** __p = __alloc.allocate(__n + 1);
      std::fill(__p, __p + __n, (_Node*) 0);
      __p[__n] = reinterpret_cast<_Node*>(0x1000);
      return __p;
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_deallocate_buckets(_Node** __p, size_type __n)
    {
      _Bucket_allocator_type __alloc(_M_node_allocator);
      __alloc.deallocate(__p, __n + 1);
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _Hashtable(size_type __bucket_hint,
        const _H1& __h1, const _H2& __h2, const _Hash& __h,
        const _Equal& __eq, const _ExtractKey& __exk,
        const allocator_type& __a)
    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(),
      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,
    _H1, _H2, _Hash, __chc>(__exk, __eq,
       __h1, __h2, __h),
      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),
      _M_node_allocator(__a),
      _M_bucket_count(0),
      _M_element_count(0),
      _M_rehash_policy()
    {
      _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);
      _M_buckets = _M_allocate_buckets(_M_bucket_count);
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    template<typename _InputIterator>
      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
      _Hashtable(_InputIterator __f, _InputIterator __l,
   size_type __bucket_hint,
   const _H1& __h1, const _H2& __h2, const _Hash& __h,
   const _Equal& __eq, const _ExtractKey& __exk,
   const allocator_type& __a)
      : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(),
 __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,
      _H1, _H2, _Hash, __chc>(__exk, __eq,
         __h1, __h2, __h),
 __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),
 _M_node_allocator(__a),
 _M_bucket_count(0),
 _M_element_count(0),
 _M_rehash_policy()
      {
 _M_bucket_count = std::max(_M_rehash_policy._M_next_bkt(__bucket_hint),
       _M_rehash_policy.
       _M_bkt_for_elements(__detail::
             __distance_fw(__f,
             __l)));
 _M_buckets = _M_allocate_buckets(_M_bucket_count);
 try
   {
     for (; __f != __l; ++__f)
       this->insert(*__f);
   }
 catch(...)
   {
     clear();
     _M_deallocate_buckets(_M_buckets, _M_bucket_count);
     throw;
   }
      }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _Hashtable(const _Hashtable& __ht)
    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(__ht),
      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,
    _H1, _H2, _Hash, __chc>(__ht),
      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(__ht),
      _M_node_allocator(__ht._M_node_allocator),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      _M_buckets = _M_allocate_buckets(_M_bucket_count);
      try
 {
   for (size_type __i = 0; __i < __ht._M_bucket_count; ++__i)
     {
       _Node* __n = __ht._M_buckets[__i];
       _Node** __tail = _M_buckets + __i;
       while (__n)
  {
    *__tail = _M_allocate_node(__n->_M_v);
    this->_M_copy_code(*__tail, __n);
    __tail = &((*__tail)->_M_next);
    __n = __n->_M_next;
  }
     }
 }
      catch(...)
 {
   clear();
   _M_deallocate_buckets(_M_buckets, _M_bucket_count);
   throw;
 }
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>&
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    operator=(const _Hashtable& __ht)
    {
      _Hashtable __tmp(__ht);
      this->swap(__tmp);
      return *this;
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    ~_Hashtable()
    {
      clear();
      _M_deallocate_buckets(_M_buckets, _M_bucket_count);
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    swap(_Hashtable& __x)
    {



      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,
 _H1, _H2, _Hash, __chc>::_M_swap(__x);



      std::__alloc_swap<_Node_allocator_type>::_S_do_it(_M_node_allocator,
       __x._M_node_allocator);

      std::swap(_M_rehash_policy, __x._M_rehash_policy);
      std::swap(_M_buckets, __x._M_buckets);
      std::swap(_M_bucket_count, __x._M_bucket_count);
      std::swap(_M_element_count, __x._M_element_count);
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    __rehash_policy(const _RehashPolicy& __pol)
    {
      _M_rehash_policy = __pol;
      size_type __n_bkt = __pol._M_bkt_for_elements(_M_element_count);
      if (__n_bkt > _M_bucket_count)
 _M_rehash(__n_bkt);
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   __chc, __cit, __uk>::iterator
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    find(const key_type& __k)
    {
      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);
      _Node* __p = _M_find_node(_M_buckets[__n], __k, __code);
      return __p ? iterator(__p, _M_buckets + __n) : this->end();
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   __chc, __cit, __uk>::const_iterator
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    find(const key_type& __k) const
    {
      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);
      _Node* __p = _M_find_node(_M_buckets[__n], __k, __code);
      return __p ? const_iterator(__p, _M_buckets + __n) : this->end();
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   __chc, __cit, __uk>::size_type
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    count(const key_type& __k) const
    {
      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);
      std::size_t __result = 0;
      for (_Node* __p = _M_buckets[__n]; __p; __p = __p->_M_next)
 if (this->_M_compare(__k, __code, __p))
   ++__result;
      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    std::pair<typename _Hashtable<_Key, _Value, _Allocator,
      _ExtractKey, _Equal, _H1,
      _H2, _Hash, _RehashPolicy,
      __chc, __cit, __uk>::iterator,
       typename _Hashtable<_Key, _Value, _Allocator,
      _ExtractKey, _Equal, _H1,
      _H2, _Hash, _RehashPolicy,
      __chc, __cit, __uk>::iterator>
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    equal_range(const key_type& __k)
    {
      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);
      _Node** __head = _M_buckets + __n;
      _Node* __p = _M_find_node(*__head, __k, __code);

      if (__p)
 {
   _Node* __p1 = __p->_M_next;
   for (; __p1; __p1 = __p1->_M_next)
     if (!this->_M_compare(__k, __code, __p1))
       break;

   iterator __first(__p, __head);
   iterator __last(__p1, __head);
   if (!__p1)
     __last._M_incr_bucket();
   return std::make_pair(__first, __last);
 }
      else
 return std::make_pair(this->end(), this->end());
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    std::pair<typename _Hashtable<_Key, _Value, _Allocator,
      _ExtractKey, _Equal, _H1,
      _H2, _Hash, _RehashPolicy,
      __chc, __cit, __uk>::const_iterator,
       typename _Hashtable<_Key, _Value, _Allocator,
      _ExtractKey, _Equal, _H1,
      _H2, _Hash, _RehashPolicy,
      __chc, __cit, __uk>::const_iterator>
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    equal_range(const key_type& __k) const
    {
      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);
      _Node** __head = _M_buckets + __n;
      _Node* __p = _M_find_node(*__head, __k, __code);

      if (__p)
 {
   _Node* __p1 = __p->_M_next;
   for (; __p1; __p1 = __p1->_M_next)
     if (!this->_M_compare(__k, __code, __p1))
       break;

   const_iterator __first(__p, __head);
   const_iterator __last(__p1, __head);
   if (!__p1)
     __last._M_incr_bucket();
   return std::make_pair(__first, __last);
 }
      else
 return std::make_pair(this->end(), this->end());
    }



  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey,
   _Equal, _H1, _H2, _Hash, _RehashPolicy,
   __chc, __cit, __uk>::_Node*
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_find_node(_Node* __p, const key_type& __k,
  typename _Hashtable::_Hash_code_type __code) const
    {
      for (; __p; __p = __p->_M_next)
 if (this->_M_compare(__k, __code, __p))
   return __p;
      return 0;
    }


  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   __chc, __cit, __uk>::iterator
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_insert_bucket(const value_type& __v, size_type __n,
      typename _Hashtable::_Hash_code_type __code)
    {
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count,
       _M_element_count, 1);



      _Node* __new_node = _M_allocate_node(__v);

      try
 {
   if (__do_rehash.first)
     {
       const key_type& __k = this->_M_extract(__v);
       __n = this->_M_bucket_index(__k, __code, __do_rehash.second);
       _M_rehash(__do_rehash.second);
     }

   __new_node->_M_next = _M_buckets[__n];
   this->_M_store_code(__new_node, __code);
   _M_buckets[__n] = __new_node;
   ++_M_element_count;
   return iterator(__new_node, _M_buckets + __n);
 }
      catch(...)
 {
   _M_deallocate_node(__new_node);
   throw;
 }
    }


  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    std::pair<typename _Hashtable<_Key, _Value, _Allocator,
      _ExtractKey, _Equal, _H1,
      _H2, _Hash, _RehashPolicy,
      __chc, __cit, __uk>::iterator, bool>
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
  _M_insert(const value_type& __v, std::tr1::true_type)
    {
      const key_type& __k = this->_M_extract(__v);
      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
      size_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);

      if (_Node* __p = _M_find_node(_M_buckets[__n], __k, __code))
 return std::make_pair(iterator(__p, _M_buckets + __n), false);
      return std::make_pair(_M_insert_bucket(__v, __n, __code), true);
    }


  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   __chc, __cit, __uk>::iterator
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_insert(const value_type& __v, std::tr1::false_type)
    {
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count,
       _M_element_count, 1);
      if (__do_rehash.first)
 _M_rehash(__do_rehash.second);

      const key_type& __k = this->_M_extract(__v);
      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
      size_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);


      _Node* __prev = _M_find_node(_M_buckets[__n], __k, __code);
      _Node* __new_node = _M_allocate_node(__v);

      if (__prev)
 {
   __new_node->_M_next = __prev->_M_next;
   __prev->_M_next = __new_node;
 }
      else
 {
   __new_node->_M_next = _M_buckets[__n];
   _M_buckets[__n] = __new_node;
 }
      this->_M_store_code(__new_node, __code);

      ++_M_element_count;
      return iterator(__new_node, _M_buckets + __n);
    }


  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_erase_node(_Node* __p, _Node** __b)
    {
      _Node* __cur = *__b;
      if (__cur == __p)
 *__b = __cur->_M_next;
      else
 {
   _Node* __next = __cur->_M_next;
   while (__next != __p)
     {
       __cur = __next;
       __next = __cur->_M_next;
     }
   __cur->_M_next = __next->_M_next;
 }

      _M_deallocate_node(__p);
      --_M_element_count;
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    template<typename _InputIterator>
      void
      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
      insert(_InputIterator __first, _InputIterator __last)
      {
 size_type __n_elt = __detail::__distance_fw(__first, __last);
 std::pair<bool, std::size_t> __do_rehash
   = _M_rehash_policy._M_need_rehash(_M_bucket_count,
         _M_element_count, __n_elt);
 if (__do_rehash.first)
   _M_rehash(__do_rehash.second);

 for (; __first != __last; ++__first)
   this->insert(*__first);
      }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   __chc, __cit, __uk>::iterator
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    erase(iterator __it)
    {
      iterator __result = __it;
      ++__result;
      _M_erase_node(__it._M_cur_node, __it._M_cur_bucket);
      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   __chc, __cit, __uk>::const_iterator
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    erase(const_iterator __it)
    {
      const_iterator __result = __it;
      ++__result;
      _M_erase_node(__it._M_cur_node, __it._M_cur_bucket);
      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   __chc, __cit, __uk>::size_type
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    erase(const key_type& __k)
    {
      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);
      size_type __result = 0;

      _Node** __slot = _M_buckets + __n;
      while (*__slot && !this->_M_compare(__k, __code, *__slot))
 __slot = &((*__slot)->_M_next);

      _Node** __saved_slot = 0;
      while (*__slot && this->_M_compare(__k, __code, *__slot))
 {



   if (&this->_M_extract((*__slot)->_M_v) != &__k)
     {
       _Node* __p = *__slot;
       *__slot = __p->_M_next;
       _M_deallocate_node(__p);
       --_M_element_count;
       ++__result;
     }
   else
     {
       __saved_slot = __slot;
       __slot = &((*__slot)->_M_next);
     }
 }

      if (__saved_slot)
 {
   _Node* __p = *__saved_slot;
   *__saved_slot = __p->_M_next;
   _M_deallocate_node(__p);
   --_M_element_count;
   ++__result;
 }

      return __result;
    }




  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   __chc, __cit, __uk>::iterator
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    erase(iterator __first, iterator __last)
    {
      while (__first != __last)
 __first = this->erase(__first);
      return __last;
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   __chc, __cit, __uk>::const_iterator
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    erase(const_iterator __first, const_iterator __last)
    {
      while (__first != __last)
 __first = this->erase(__first);
      return __last;
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    clear()
    {
      _M_deallocate_nodes(_M_buckets, _M_bucket_count);
      _M_element_count = 0;
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    rehash(size_type __n)
    {
      _M_rehash(std::max(_M_rehash_policy._M_next_bkt(__n),
    _M_rehash_policy._M_bkt_for_elements(_M_element_count
             + 1)));
    }

  template<typename _Key, typename _Value,
    typename _Allocator, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_rehash(size_type __n)
    {
      _Node** __new_array = _M_allocate_buckets(__n);
      try
 {
   for (size_type __i = 0; __i < _M_bucket_count; ++__i)
     while (_Node* __p = _M_buckets[__i])
       {
  std::size_t __new_index = this->_M_bucket_index(__p, __n);
  _M_buckets[__i] = __p->_M_next;
  __p->_M_next = __new_array[__new_index];
  __new_array[__new_index] = __p;
       }
   _M_deallocate_buckets(_M_buckets, _M_bucket_count);
   _M_bucket_count = __n;
   _M_buckets = __new_array;
 }
      catch(...)
 {




   _M_deallocate_nodes(__new_array, __n);
   _M_deallocate_buckets(__new_array, __n);
   _M_deallocate_nodes(_M_buckets, _M_bucket_count);
   _M_element_count = 0;
   throw;
 }
    }


}
}
# 42 "/usr/include/c++/7/tr1/unordered_map" 2 3
# 1 "/usr/include/c++/7/tr1/unordered_map.h" 1 3
# 30 "/usr/include/c++/7/tr1/unordered_map.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
namespace tr1
{




  template<class _Key, class _Tp,
    class _Hash = hash<_Key>,
    class _Pred = std::equal_to<_Key>,
    class _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    bool __cache_hash_code = false>
    class __unordered_map
    : public _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc,
   std::_Select1st<std::pair<const _Key, _Tp> >, _Pred,
   _Hash, __detail::_Mod_range_hashing,
   __detail::_Default_ranged_hash,
   __detail::_Prime_rehash_policy,
   __cache_hash_code, false, true>
    {
      typedef _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc,
    std::_Select1st<std::pair<const _Key, _Tp> >, _Pred,
    _Hash, __detail::_Mod_range_hashing,
    __detail::_Default_ranged_hash,
    __detail::_Prime_rehash_policy,
    __cache_hash_code, false, true>
 _Base;

    public:
      typedef typename _Base::size_type size_type;
      typedef typename _Base::hasher hasher;
      typedef typename _Base::key_equal key_equal;
      typedef typename _Base::allocator_type allocator_type;

      explicit
      __unordered_map(size_type __n = 10,
        const hasher& __hf = hasher(),
        const key_equal& __eql = key_equal(),
        const allocator_type& __a = allocator_type())
      : _Base(__n, __hf, __detail::_Mod_range_hashing(),
       __detail::_Default_ranged_hash(),
       __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)
      { }

      template<typename _InputIterator>
 __unordered_map(_InputIterator __f, _InputIterator __l,
   size_type __n = 10,
   const hasher& __hf = hasher(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type())
 : _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),
  __detail::_Default_ranged_hash(),
  __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)
 { }
    };

  template<class _Key, class _Tp,
    class _Hash = hash<_Key>,
    class _Pred = std::equal_to<_Key>,
    class _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    bool __cache_hash_code = false>
    class __unordered_multimap
    : public _Hashtable<_Key, std::pair<const _Key, _Tp>,
   _Alloc,
   std::_Select1st<std::pair<const _Key, _Tp> >, _Pred,
   _Hash, __detail::_Mod_range_hashing,
   __detail::_Default_ranged_hash,
   __detail::_Prime_rehash_policy,
   __cache_hash_code, false, false>
    {
      typedef _Hashtable<_Key, std::pair<const _Key, _Tp>,
    _Alloc,
    std::_Select1st<std::pair<const _Key, _Tp> >, _Pred,
    _Hash, __detail::_Mod_range_hashing,
    __detail::_Default_ranged_hash,
    __detail::_Prime_rehash_policy,
    __cache_hash_code, false, false>
 _Base;

    public:
      typedef typename _Base::size_type size_type;
      typedef typename _Base::hasher hasher;
      typedef typename _Base::key_equal key_equal;
      typedef typename _Base::allocator_type allocator_type;

      explicit
      __unordered_multimap(size_type __n = 10,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __hf, __detail::_Mod_range_hashing(),
       __detail::_Default_ranged_hash(),
       __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)
      { }


      template<typename _InputIterator>
 __unordered_multimap(_InputIterator __f, _InputIterator __l,
        typename _Base::size_type __n = 0,
        const hasher& __hf = hasher(),
        const key_equal& __eql = key_equal(),
        const allocator_type& __a = allocator_type())
 : _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),
  __detail::_Default_ranged_hash(),
  __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)
 { }
    };

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,
    bool __cache_hash_code>
    inline void
    swap(__unordered_map<_Key, _Tp, _Hash, _Pred,
  _Alloc, __cache_hash_code>& __x,
  __unordered_map<_Key, _Tp, _Hash, _Pred,
  _Alloc, __cache_hash_code>& __y)
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,
    bool __cache_hash_code>
    inline void
    swap(__unordered_multimap<_Key, _Tp, _Hash, _Pred,
  _Alloc, __cache_hash_code>& __x,
  __unordered_multimap<_Key, _Tp, _Hash, _Pred,
  _Alloc, __cache_hash_code>& __y)
    { __x.swap(__y); }
# 176 "/usr/include/c++/7/tr1/unordered_map.h" 3
  template<class _Key, class _Tp,
    class _Hash = hash<_Key>,
    class _Pred = std::equal_to<_Key>,
    class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class unordered_map
    : public __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>
    {
      typedef __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> _Base;

    public:
      typedef typename _Base::value_type value_type;
      typedef typename _Base::size_type size_type;
      typedef typename _Base::hasher hasher;
      typedef typename _Base::key_equal key_equal;
      typedef typename _Base::allocator_type allocator_type;

      explicit
      unordered_map(size_type __n = 10,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __hf, __eql, __a)
      { }

      template<typename _InputIterator>
 unordered_map(_InputIterator __f, _InputIterator __l,
        size_type __n = 10,
        const hasher& __hf = hasher(),
        const key_equal& __eql = key_equal(),
        const allocator_type& __a = allocator_type())
 : _Base(__f, __l, __n, __hf, __eql, __a)
 { }
    };
# 228 "/usr/include/c++/7/tr1/unordered_map.h" 3
  template<class _Key, class _Tp,
    class _Hash = hash<_Key>,
    class _Pred = std::equal_to<_Key>,
    class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class unordered_multimap
    : public __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>
    {
      typedef __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> _Base;

    public:
      typedef typename _Base::value_type value_type;
      typedef typename _Base::size_type size_type;
      typedef typename _Base::hasher hasher;
      typedef typename _Base::key_equal key_equal;
      typedef typename _Base::allocator_type allocator_type;

      explicit
      unordered_multimap(size_type __n = 10,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _Base(__n, __hf, __eql, __a)
      { }


      template<typename _InputIterator>
 unordered_multimap(_InputIterator __f, _InputIterator __l,
      typename _Base::size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
 : _Base(__f, __l, __n, __hf, __eql, __a)
 { }

    };

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { __x.swap(__y); }


}
}
# 43 "/usr/include/c++/7/tr1/unordered_map" 2 3
# 57 "/usr/local/include/ibex/ibex_SymbolMap.h" 2 3
# 70 "/usr/local/include/ibex/ibex_SymbolMap.h" 3
namespace ibex {




template <typename T>
class SymbolMap {
public:



 SymbolMap() { }





 SymbolMap(const SymbolMap<T>& tab) {
  typename std::tr1::unordered_map<const char*, T, struct ibex::hash_string, struct ibex::equal_string>::const_iterator it=tab.map.begin();
  for(; it!=tab.map.end(); it++) {
   insert_new(it->first, it->second);
  }
 }




 ~SymbolMap() {
  clean();
 }





 size_t size() const {
  return map.size();
 }





 void clean() {
  if (map.size()>0) {
   typename std::tr1::unordered_map<const char*, T, struct ibex::hash_string, struct ibex::equal_string>::const_iterator it=map.begin();
   typename std::tr1::unordered_map<const char*, T, struct ibex::hash_string, struct ibex::equal_string>::const_iterator it2=map.begin();
   it++;
   for(; it!=map.end(); it++) {
    free((char*) it2->first);;
    it2 = it;
   }
   free((char*) it2->first);
  }
  map.clear();
 }




 bool used(const char* id) const {
  return map.find(id)!=map.end();
 }







 const char* insert_new(const char* id, T data) {
  (static_cast <bool> (!used(id)) ? void (0) : __assert_fail ("!used(id)", "/usr/local/include/ibex/ibex_SymbolMap.h", 141, __extension__ __PRETTY_FUNCTION__));

  char* copy = strdup(id);
  map.insert(std::pair<const char*,T>(copy, data));
  return copy;
 }




 void erase(const char* id) {
  if (used(id)) {
   typename std::tr1::unordered_map<const char*, T, struct ibex::hash_string, struct ibex::equal_string>::iterator it = map.find (id);
   const char* name=it->first;
   map.erase(it);
   free((char*) name);
  }
 }





 const T& operator[](const char* id) const {
  typename std::tr1::unordered_map<const char*, T, struct ibex::hash_string, struct ibex::equal_string>::const_iterator it = map.find (id);
  (static_cast <bool> (it != map.end()) ? void (0) : __assert_fail ("it != map.end()", "/usr/local/include/ibex/ibex_SymbolMap.h", 166, __extension__ __PRETTY_FUNCTION__));
  return it->second;
 }





 T& operator[](const char* id) {
  return (T&) ((const SymbolMap<T>*) this)->operator[](id);
 }




 friend std::ostream& operator<<(std::ostream& os, const SymbolMap<T>& idtab) {
  int i=0;
  for (typename std::tr1::unordered_map<const char*, T, struct ibex::hash_string, struct ibex::equal_string>::const_iterator it=idtab.map.begin(); it!=idtab.map.end(); it++) {
   os << it->first << " " << it->second << "    ";
   if (++i%8==0) os << std::endl;
  }
  return os;
 }

 typename std::tr1::unordered_map<const char*, T, struct ibex::hash_string, struct ibex::equal_string>::iterator begin() {
  return map.begin();
 }

 typename std::tr1::unordered_map<const char*, T, struct ibex::hash_string, struct ibex::equal_string>::iterator end() {
  return map.end();
 }

 typename std::tr1::unordered_map<const char*, T, struct ibex::hash_string, struct ibex::equal_string>::const_iterator begin() const {
  return map.begin();
 }

 typename std::tr1::unordered_map<const char*, T, struct ibex::hash_string, struct ibex::equal_string>::const_iterator end() const {
  return map.end();
 }

private:
 std::tr1::unordered_map<const char*, T, struct ibex::hash_string, struct ibex::equal_string> map;

};

}
# 17 "/usr/local/include/ibex/ibex_Cell.h" 2 3


namespace ibex {
# 40 "/usr/local/include/ibex/ibex_Cell.h" 3
class Cell {
public:






 Cell(const IntervalVector& box);
# 62 "/usr/local/include/ibex/ibex_Cell.h" 3
 std::pair<Cell*,Cell*> bisect(const IntervalVector& left, const IntervalVector& right);




 virtual ~Cell();
# 80 "/usr/local/include/ibex/ibex_Cell.h" 3
 template<typename T>
 T& get() {
  return (T&) *data[typeid(T).name()];
 }







 template<typename T>
 const T& get() const {
  return (T&) *data[typeid(T).name()];
 }







 template<typename T>
 void add() {
  const char* id=typeid(T).name();
  if (!data.used(id)) data.insert_new(id,new T());
 }




 IntervalVector box;



 SymbolMap<Backtrackable*> data;




 unsigned long id;

private:


};

std::ostream& operator<<(std::ostream& os, const Cell& c);

}
# 15 "/usr/local/include/ibex/ibex_Bsc.h" 2 3


namespace ibex {

class Cell;
# 44 "/usr/local/include/ibex/ibex_Bsc.h" 3
class Bsc {

public:
# 55 "/usr/local/include/ibex/ibex_Bsc.h" 3
 Bsc(double prec);
# 66 "/usr/local/include/ibex/ibex_Bsc.h" 3
 Bsc(const Vector& prec);




 virtual ~Bsc() { }




 virtual std::pair<IntervalVector,IntervalVector> bisect(const IntervalVector& box)=0;
# 86 "/usr/local/include/ibex/ibex_Bsc.h" 3
 virtual std::pair<IntervalVector,IntervalVector> bisect(Cell& cell);







 virtual void add_backtrackable(Cell& root);




 static double default_ratio();




 bool uniform_prec() const;




 double prec(int i) const;





 bool too_small(const IntervalVector& box, int i) const;


private:






 const Vector _prec;
};






class BisectedVar : public Backtrackable {
public:
 BisectedVar() : var(-1) { }

 BisectedVar(int x) : var(x) { }

 std::pair<Backtrackable*,Backtrackable*> down() {
  return std::pair<Backtrackable*,Backtrackable*>(new BisectedVar(var),new BisectedVar(var));
 }

 int var;
};




inline bool Bsc::uniform_prec() const {
 return _prec.size()==1;
}

inline double Bsc::prec(int i) const {
 return uniform_prec() ? _prec[0]
                       : _prec[i];
}

inline bool Bsc::too_small(const IntervalVector& box, int i) const {
 return (box[i].diam()<prec(i)
  || !box[i].is_bisectable()
     );
}

}
# 29 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_LargestFirst.h" 1 3
# 17 "/usr/local/include/ibex/ibex_LargestFirst.h" 3
namespace ibex {







class LargestFirst : public Bsc {
public:
# 35 "/usr/local/include/ibex/ibex_LargestFirst.h" 3
 LargestFirst(double prec=0, double ratio=Bsc::default_ratio());
# 44 "/usr/local/include/ibex/ibex_LargestFirst.h" 3
 LargestFirst(const Vector& prec, double ratio=Bsc::default_ratio());






 virtual std::pair<IntervalVector,IntervalVector> bisect(const IntervalVector& box);
# 61 "/usr/local/include/ibex/ibex_LargestFirst.h" 3
 const double ratio;


};

}
# 30 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_NoBisectableVariableException.h" 1 3
# 18 "/usr/local/include/ibex/ibex_NoBisectableVariableException.h" 3
namespace ibex {





class NoBisectableVariableException : public Exception {

};

}
# 31 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_RoundRobin.h" 1 3
# 17 "/usr/local/include/ibex/ibex_RoundRobin.h" 3
namespace ibex {







class RoundRobin : public Bsc {
public:







 RoundRobin(double prec, double ratio=Bsc::default_ratio());
# 43 "/usr/local/include/ibex/ibex_RoundRobin.h" 3
 RoundRobin(const Vector& prec, double ratio=Bsc::default_ratio());
# 55 "/usr/local/include/ibex/ibex_RoundRobin.h" 3
 virtual std::pair<IntervalVector,IntervalVector> bisect(const IntervalVector& box, int& last_var);







 virtual std::pair<IntervalVector,IntervalVector> bisect(const IntervalVector& box);
# 72 "/usr/local/include/ibex/ibex_RoundRobin.h" 3
 virtual std::pair<IntervalVector,IntervalVector> bisect(Cell& cell);




 void add_backtrackable(Cell& root);







 const double ratio;
};

}
# 32 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_SmearFunction.h" 1 3
# 17 "/usr/local/include/ibex/ibex_SmearFunction.h" 3
# 1 "/usr/local/include/ibex/ibex_System.h" 1 3
# 15 "/usr/local/include/ibex/ibex_System.h" 3
# 1 "/usr/local/include/ibex/ibex_Setting.h" 1 3
# 16 "/usr/local/include/ibex/ibex_System.h" 2 3


# 1 "/usr/local/include/ibex/ibex_NumConstraint.h" 1 3
# 15 "/usr/local/include/ibex/ibex_NumConstraint.h" 3
# 1 "/usr/local/include/ibex/ibex_Function.h" 1 3
# 15 "/usr/local/include/ibex/ibex_Function.h" 3
# 1 "/usr/local/include/ibex/ibex_Expr.h" 1 3
# 19 "/usr/local/include/ibex/ibex_Expr.h" 3
# 1 "/usr/local/include/ibex/ibex_ExprVisitor.h" 1 3
# 18 "/usr/local/include/ibex/ibex_ExprVisitor.h" 3
namespace ibex {

class ExprNode;

class ExprIndex;
class ExprLeaf;
class ExprNAryOp;
class ExprBinaryOp;
class ExprUnaryOp;

class ExprSymbol;
class ExprConstant;

class ExprVector;
class ExprApply;
class ExprChi;

class ExprAdd;
class ExprMul;
class ExprSub;
class ExprDiv;
class ExprMax;
class ExprMin;
class ExprAtan2;

class ExprMinus;
class ExprTrans;
class ExprSign;
class ExprAbs;
class ExprPower;
class ExprSqr;
class ExprSqrt;
class ExprExp;
class ExprLog;
class ExprCos;
class ExprSin;
class ExprTan;
class ExprCosh;
class ExprSinh;
class ExprTanh;
class ExprAcos;
class ExprAsin;
class ExprAtan;
class ExprAcosh;
class ExprAsinh;
class ExprAtanh;
# 74 "/usr/local/include/ibex/ibex_ExprVisitor.h" 3
class ExprVisitor {

 public:
  virtual ~ExprVisitor() { }






  virtual void visit(const ExprNode&)=0;


  virtual void visit(const ExprIndex&)=0;


  virtual void visit(const ExprLeaf&)=0;


  virtual void visit(const ExprNAryOp&)=0;


  virtual void visit(const ExprBinaryOp&)=0;


  virtual void visit(const ExprUnaryOp&)=0;







  virtual void visit(const ExprSymbol& e) {
    visit((const ExprLeaf&) e);
  }


  virtual void visit(const ExprConstant& e) {
    visit((const ExprLeaf&) e);
  }




   virtual void visit(const ExprVector& e) {
    visit((const ExprNAryOp&) e);
   }



   virtual void visit(const ExprApply& e) {
    visit((const ExprNAryOp&) e);
   }



   virtual void visit(const ExprChi& ee) {
    visit((const ExprNAryOp&) ee);
   }




  virtual void visit(const ExprAdd& e) {
   visit((const ExprBinaryOp&) e);
  }



  virtual void visit(const ExprMul& e) {
   visit((const ExprBinaryOp&) e);
  }



  virtual void visit(const ExprSub& e) {
   visit((const ExprBinaryOp&) e);
  }



  virtual void visit(const ExprDiv& e) {
   visit((const ExprBinaryOp&) e);
  }



  virtual void visit(const ExprMax& e) {
   visit((const ExprBinaryOp&) e);
  }



  virtual void visit(const ExprMin& e) {
   visit((const ExprBinaryOp&) e);
  }



  virtual void visit(const ExprAtan2& e) {
   visit((const ExprBinaryOp&) e);
  }





  virtual void visit(const ExprMinus& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprTrans& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprSign& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprAbs& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprPower& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprSqr& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprSqrt& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprExp& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprLog& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprCos& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprSin& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprTan& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprCosh& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprSinh& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprTanh& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprAcos& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprAsin& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprAtan& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprAcosh& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprAsinh& e) {
   visit((const ExprUnaryOp&) e);
  }



  virtual void visit(const ExprAtanh& e) {
   visit((const ExprUnaryOp&) e);
  }

 protected:





};

}
# 20 "/usr/local/include/ibex/ibex_Expr.h" 2 3





# 1 "/usr/local/include/ibex/ibex_ExprLabel.h" 1 3
# 18 "/usr/local/include/ibex/ibex_ExprLabel.h" 3
namespace ibex {

class Function;





class ExprLabel {
public:




 ExprLabel();




 ~ExprLabel();




 Function* f;




 Affine2Domain *af2;
 AffineLinDomain *af_lin;




 Domain *d;




 Domain *g;






 Domain *p;






 std::vector<Affine2Domain> *taylor_comps_aff;


private:
 ExprLabel(const ExprLabel&);
};

std::ostream& operator<<(std::ostream& os, const ExprLabel&);

}
# 26 "/usr/local/include/ibex/ibex_Expr.h" 2 3

namespace ibex {

class ExprCtr;
class ExprIndex;
class Function;
# 49 "/usr/local/include/ibex/ibex_Expr.h" 3
class ExprNode {

public:


 ExprNode(int height, int size, const Dim& dim);


 virtual void acceptVisitor(ExprVisitor& v) const = 0;

 friend class Visitor;






 virtual ~ExprNode();


 friend std::ostream& operator<<(std::ostream&, const ExprNode&);






 bool operator==(const ExprNode&) const;




 bool operator!=(const ExprNode&) const;



 const int height;



 const int size;







 const long id;


 const Dim dim;




 mutable ExprLabel deco;
# 116 "/usr/local/include/ibex/ibex_Expr.h" 3
 Array<const ExprNode> fathers;


 virtual bool is_zero() const;


 Dim::Type type() const;


 const ExprIndex& operator[](int index) const;


 const ExprCtr& operator=(const ExprNode& right) const;


 const ExprCtr& operator=(const Interval& value) const;


 const ExprCtr& operator=(const IntervalVector& value) const;


 const ExprCtr& operator=(const IntervalMatrix& value) const;


 const ExprCtr& operator<=(const ExprNode& right) const;


 const ExprCtr& operator<=(const Interval& value) const;


 const ExprCtr& operator>=(const ExprNode& right) const;


 const ExprCtr& operator>=(const Interval& value) const;


 const ExprCtr& operator<(const ExprNode& right) const;


 const ExprCtr& operator<(const Interval& value) const;


 const ExprCtr& operator>(const ExprNode& right) const;


 const ExprCtr& operator>(const Interval& value) const;
};




std::ostream& operator<<(std::ostream&, const ExprNode&);






void cleanup(const Array<const ExprNode>& expr, bool delete_symbols);





class ExprIndex : public ExprNode {

public:

 void acceptVisitor(ExprVisitor& v) const { v.visit(*this); }


 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalVector& value) const { return ((ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalMatrix& value) const { return ((ExprNode&) *this)=value; }


 const ExprNode& expr;


 const int index;






 bool indexed_symbol() const;






 std::pair<const ExprSymbol*, int> symbol_shift() const;

 static const ExprIndex& new_(const ExprNode& subexpr, int index);

private:

 ExprIndex(const ExprNode& subexpr, int index);

};





class ExprNAryOp : public ExprNode {
public:


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };


 const ExprNode& arg(int i) const { return args[i]; }


 const Array<const ExprNode> args;


 const int nb_args;

protected:
 ExprNAryOp(const Array<const ExprNode>& args, const Dim& dim);
};
# 263 "/usr/local/include/ibex/ibex_Expr.h" 3
class ExprVector : public ExprNAryOp {
public:



 void acceptVisitor(ExprVisitor& v) const { v.visit(*this); }




 static const ExprVector& new_(const Array<const ExprNode>& components, bool in_rows);




 static const ExprVector& new_(const ExprNode& e1, const ExprNode& e2, bool in_rows);
# 288 "/usr/local/include/ibex/ibex_Expr.h" 3
 bool row_vector() const;
# 297 "/usr/local/include/ibex/ibex_Expr.h" 3
 const ExprNode& get(int i) const { return arg(i); }
# 306 "/usr/local/include/ibex/ibex_Expr.h" 3
 int length() const { return nb_args; }

private:
 ExprVector(const Array<const ExprNode>&, bool in_row);

};




class Return {
public:
 Return(const ExprNode& f1, const ExprNode& f2, bool in_rows=false) :
  vec(ExprVector::new_(f1,f2,in_rows)) { }
 Return(const ExprNode& f1, const ExprNode& f2, const ExprNode& f3, bool in_rows=false) :
  vec(ExprVector::new_(Array<const ExprNode>(f1,f2,f3),in_rows)) { }
 Return(const ExprNode& f1, const ExprNode& f2, const ExprNode& f3, const ExprNode& f4, bool in_rows=false) :
  vec(ExprVector::new_(Array<const ExprNode>(f1,f2,f3,f4),in_rows)) { }
 Return(const ExprNode& f1, const ExprNode& f2, const ExprNode& f3, const ExprNode& f4, const ExprNode& f5, bool in_rows=false) :
  vec(ExprVector::new_(Array<const ExprNode>(f1,f2,f3,f4,f5),in_rows)) { }
 Return(const ExprNode& f1, const ExprNode& f2, const ExprNode& f3, const ExprNode& f4, const ExprNode& f5, const ExprNode& f6, bool in_rows=false) :
  vec(ExprVector::new_(Array<const ExprNode>(f1,f2,f3,f4,f5,f6),in_rows)) { }

 operator const ExprVector&() const { return vec; }

 operator const ExprNode&() const { return vec; }

 const ExprIndex& operator[](int index) { return vec[index]; }

 const ExprVector& vec;
};
# 361 "/usr/local/include/ibex/ibex_Expr.h" 3
class ExprApply : public ExprNAryOp {

public:


 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalVector& value) const { return ((ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalMatrix& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };


 const Function& func;

 static const ExprApply& new_(const Function& func, const Array<const ExprNode>& args) {
  return *new ExprApply(func,args);
 }

private:

 ExprApply(const Function& expr, const Array<const ExprNode>& args);
};





class ExprChi : public ExprNAryOp {
public:


 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprChi& new_(const Array<const ExprNode>& args);
 static const ExprChi& new_(const ExprNode& a, const ExprNode& b, const ExprNode& c);

private:
 ExprChi(const Array<const ExprNode>& args) : ExprNAryOp(args,Dim()) { }

 ExprChi(const ExprChi&);
};


namespace parser {
class ExprEntity;
}






class ExprLeaf : public ExprNode {
protected:
 ExprLeaf(const Dim& dim);
};
# 439 "/usr/local/include/ibex/ibex_Expr.h" 3
class ExprSymbol : public ExprLeaf {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalVector& value) const { return ((ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalMatrix& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };


 virtual ~ExprSymbol();


 const char* name;




 int key;


 static const ExprSymbol& new_(const Dim& dim=Dim::scalar());


 static const ExprSymbol& new_(const char* name, const Dim& dim=Dim::scalar());

private:
 friend class Variable;
 friend class parser::ExprEntity;


 ExprSymbol(const Dim& dim);


 ExprSymbol(const char* name, const Dim& dim);


 ExprSymbol(const ExprSymbol&);
};






class Variable {
public:

 explicit Variable(const Dim& dim=Dim::scalar());


 explicit Variable(const char* name);


 Variable(const Dim& dim, const char* name);


 explicit Variable(int n);


 Variable(int n, const char* name);


 Variable(int m, int n);


 Variable(int m, int n, const char* name);


 Variable(int k, int m, int n);


 Variable(int k, int m, int n, const char* name);


 ~Variable();


 operator const ExprSymbol&() const;


 operator const ExprNode&() const;


 const ExprIndex& operator[](int index) { return ((const ExprNode&) *this)[index]; }


 const ExprCtr& operator=(const Variable& y) const { return ((const ExprNode&) *this)=y; }


 const ExprCtr& operator=(const Interval& value) const { return ((const ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalVector& value) const { return ((const ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalMatrix& value) const { return ((const ExprNode&) *this)=value; }


 const ExprCtr& operator<=(const Interval& value) const { return ((const ExprNode&) *this)<=value; }


 const ExprCtr& operator>=(const Interval& value) const { return ((const ExprNode&) *this)>=value; }


 const ExprCtr& operator<(const Interval& value) const { return ((const ExprNode&) *this)<value; }


 const ExprCtr& operator>(const Interval& value) const { return ((const ExprNode&) *this)>value; }


 const ExprCtr& operator=(const ExprNode& value) const { return ((const ExprNode&) *this)=value; }


 const ExprCtr& operator<=(const ExprNode& value) const { return ((const ExprNode&) *this)<=value; }


 const ExprCtr& operator>=(const ExprNode& value) const { return ((const ExprNode&) *this)>=value; }


 const ExprCtr& operator<(const ExprNode& value) const { return ((const ExprNode&) *this)<value; }


 const ExprCtr& operator>(const ExprNode& value) const { return ((const ExprNode&) *this)>value; }

 mutable ExprSymbol* symbol;
};





class ExprConstant : public ExprLeaf {

public:

 static const ExprConstant& new_scalar(const Interval& value);


 static const ExprConstant& new_vector(const IntervalVector& value, bool in_row);


 static const ExprConstant& new_matrix(const IntervalMatrix& value);


 static const ExprConstant& new_matrix_array(const IntervalMatrixArray& value);


 static const ExprConstant& new_(const Domain& d, bool reference=false);


 virtual bool is_zero() const;


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };


 const Interval& get_value() const;


 const IntervalVector& get_vector_value() const;


 const IntervalMatrix& get_matrix_value() const;


 const IntervalMatrixArray& get_matrix_array_value() const;


 const Domain& get() const;



 const ExprConstant& copy() const;

private:
 friend class Visitor;

 ExprConstant(const Interval& value);

 ExprConstant(const IntervalVector& value, bool in_row);

 ExprConstant(const IntervalMatrix& value);

 ExprConstant(const IntervalMatrixArray& value);

 ExprConstant(const Domain& value, bool reference);


 ExprConstant(const ExprConstant& c);

 Domain value;
};
# 651 "/usr/local/include/ibex/ibex_Expr.h" 3
class ExprBinaryOp : public ExprNode {
public:

 const ExprNode& left;


 const ExprNode& right;

protected:
 friend class Visitor;

 ExprBinaryOp(const ExprNode& left, const ExprNode& right, const Dim& dim);

private:
 ExprBinaryOp(const ExprBinaryOp&);
};





class ExprAdd : public ExprBinaryOp {
public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalVector& value) const { return ((ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalMatrix& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const {
  v.visit(*this); };

 static const ExprAdd& new_(const ExprNode& left, const ExprNode& right) {
  return *new ExprAdd(left,right);
 }

private:
 ExprAdd(const ExprNode& left, const ExprNode& right);
 ExprAdd(const ExprAdd&);
};





class ExprMul : public ExprBinaryOp {
public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalVector& value) const { return ((ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalMatrix& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprMul& new_(const ExprNode& left, const ExprNode& right) {
  return *new ExprMul(left,right);
 }

private:
 ExprMul(const ExprNode& left, const ExprNode& right);
 ExprMul(const ExprMul&);
};






class ExprSub : public ExprBinaryOp {
public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalVector& value) const { return ((ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalMatrix& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprSub& new_(const ExprNode& left, const ExprNode& right) {
  return *new ExprSub(left,right);
 }

private:
 ExprSub(const ExprNode& left, const ExprNode& right);
 ExprSub(const ExprSub&);
};





class ExprDiv : public ExprBinaryOp {
public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprDiv& new_(const ExprNode& left, const ExprNode& right) {
  return *new ExprDiv(left,right);
 }

private:
 ExprDiv(const ExprNode& left, const ExprNode& right);
 ExprDiv(const ExprDiv&);
};





class ExprMax : public ExprBinaryOp {
public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprMax& new_(const ExprNode& left, const ExprNode& right) {
  return *new ExprMax(left,right);
 }

private:
 ExprMax(const ExprNode& left, const ExprNode& right);
 ExprMax(const ExprMax&);
};





class ExprMin : public ExprBinaryOp {
public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprMin& new_(const ExprNode& left, const ExprNode& right) {
  return *new ExprMin(left,right);
 }

private:
 ExprMin(const ExprNode& left, const ExprNode& right);
 ExprMin(const ExprMin&);
};





class ExprAtan2 : public ExprBinaryOp {
public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprAtan2& new_(const ExprNode& left, const ExprNode& right) {
  return *new ExprAtan2(left,right);
 }

private:
 ExprAtan2(const ExprNode& left, const ExprNode& right);
 ExprAtan2(const ExprAtan2&);
};
# 863 "/usr/local/include/ibex/ibex_Expr.h" 3
class ExprUnaryOp : public ExprNode {
public:


 const ExprNode& expr;

protected:
 ExprUnaryOp(const ExprNode& subexpr, const Dim& dim);

};





class ExprMinus : public ExprUnaryOp {
public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalVector& value) const { return ((ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalMatrix& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprMinus& new_(const ExprNode& expr) { return *new ExprMinus(expr); }

private:
 ExprMinus(const ExprNode& expr) : ExprUnaryOp(expr,expr.dim) { }
 ExprMinus(const ExprMinus&);
};





class ExprTrans : public ExprUnaryOp {
public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalVector& value) const { return ((ExprNode&) *this)=value; }


 const ExprCtr& operator=(const IntervalMatrix& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprTrans& new_(const ExprNode& expr) { return *new ExprTrans(expr); }

private:
 ExprTrans(const ExprNode& expr) : ExprUnaryOp(expr,expr.dim.transpose_dim()) { }
 ExprTrans(const ExprTrans&);
};





class ExprSign : public ExprUnaryOp {
public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprSign& new_(const ExprNode& expr) { return *new ExprSign(expr); }

private:
 ExprSign(const ExprNode& expr);
 ExprSign(const ExprSign&);
};





class ExprAbs : public ExprUnaryOp {
public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprAbs& new_(const ExprNode& expr) { return *new ExprAbs(expr); }

private:
 ExprAbs(const ExprNode& expr);
 ExprAbs(const ExprAbs&);
};






class ExprPower : public ExprUnaryOp {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprPower& new_(const ExprNode& expr, int expon) {
  return *new ExprPower(expr,expon);
 }

 const int expon;

private:
 ExprPower(const ExprNode& expr, int expon) : ExprUnaryOp(expr,expr.dim), expon(expon) { }
 ExprPower(const ExprPower&);
};





class ExprSqr : public ExprUnaryOp {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprSqr& new_(const ExprNode& expr) {
  return *new ExprSqr(expr);
 }

private:
 ExprSqr(const ExprNode& expr);
 ExprSqr(const ExprSqr&);
};





class ExprSqrt : public ExprUnaryOp {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprSqrt& new_(const ExprNode& expr) { return *new ExprSqrt(expr); }

private:
 ExprSqrt(const ExprNode& expr);
 ExprSqrt(const ExprSqrt&);
};





class ExprExp : public ExprUnaryOp {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprExp& new_(const ExprNode& expr) {
  return *new ExprExp(expr);
 }

private:
 ExprExp(const ExprNode& expr);
 ExprExp(const ExprExp&);
};





class ExprLog : public ExprUnaryOp {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprLog& new_(const ExprNode& expr) {
  return *new ExprLog(expr);
 }

private:
 ExprLog(const ExprNode& expr);
 ExprLog(const ExprLog&);
};





class ExprCos : public ExprUnaryOp {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprCos& new_(const ExprNode& expr) {
  return *new ExprCos(expr);
 }

private:
 ExprCos(const ExprNode& expr);
 ExprCos(const ExprCos&);
};





class ExprSin : public ExprUnaryOp {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprSin& new_(const ExprNode& expr) {
  return *new ExprSin(expr);
 }

private:
 ExprSin(const ExprNode& expr);
 ExprSin(const ExprSin&);
};





class ExprTan : public ExprUnaryOp {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprTan& new_(const ExprNode& expr) {
  return *new ExprTan(expr);
 }

private:
 ExprTan(const ExprNode& expr);
 ExprTan(const ExprTan&);
};





class ExprCosh : public ExprUnaryOp {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprCosh& new_(const ExprNode& expr) {
  return *new ExprCosh(expr);
 }

private:
 ExprCosh(const ExprNode& expr);
 ExprCosh(const ExprCosh&);
};





class ExprSinh : public ExprUnaryOp {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprSinh& new_(const ExprNode& expr) {
  return *new ExprSinh(expr);
 }

private:
 ExprSinh(const ExprNode& expr);
 ExprSinh(const ExprSinh&);
};





class ExprTanh : public ExprUnaryOp {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprTanh& new_(const ExprNode& expr) {
  return *new ExprTanh(expr);
 }

private:
 ExprTanh(const ExprNode& expr);
 ExprTanh(const ExprTanh&);
};





class ExprAcos : public ExprUnaryOp {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprAcos& new_(const ExprNode& expr) {
  return *new ExprAcos(expr);
 }

private:
 ExprAcos(const ExprNode& expr);
 ExprAcos(const ExprAcos&);
};





class ExprAsin : public ExprUnaryOp {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprAsin& new_(const ExprNode& expr) {
  return *new ExprAsin(expr);
 }

private:
 ExprAsin(const ExprNode& expr);
 ExprAsin(const ExprAsin&);
};





class ExprAtan : public ExprUnaryOp {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprAtan& new_(const ExprNode& expr) {
  return *new ExprAtan(expr);
 }

private:
 ExprAtan(const ExprNode& expr);
 ExprAtan(const ExprAtan&);
};





class ExprAcosh : public ExprUnaryOp {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprAcosh& new_(const ExprNode& expr) {
  return *new ExprAcosh(expr);
 }

private:
 ExprAcosh(const ExprNode& expr);
 ExprAcosh(const ExprAcosh&);
};





class ExprAsinh : public ExprUnaryOp {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprAsinh& new_(const ExprNode& expr) {
  return *new ExprAsinh(expr);
 }

private:
 ExprAsinh(const ExprNode& expr);
 ExprAsinh(const ExprAsinh&);
};





class ExprAtanh : public ExprUnaryOp {

public:

 const ExprCtr& operator=(const ExprNode& expr) const { return ((ExprNode&) *this)=expr; }


 const ExprCtr& operator=(const Interval& value) const { return ((ExprNode&) *this)=value; }


 virtual void acceptVisitor(ExprVisitor& v) const { v.visit(*this); };

 static const ExprAtanh& new_(const ExprNode& expr) {
  return *new ExprAtanh(expr);
 }

private:
 ExprAtanh(const ExprNode& expr);
 ExprAtanh(const ExprAtanh&);
};






inline ExprNode::~ExprNode() {
}

inline bool ExprNode::is_zero() const {
 return false; }

inline Dim::Type ExprNode::type() const {
 return dim.type(); }

inline const ExprIndex& ExprNode::operator[](int index) const {
 return ExprIndex::new_(*this, index); }

inline const ExprIndex& ExprIndex::new_(const ExprNode& subexpr, int index) {
 return *new ExprIndex(subexpr,index); }

inline bool ExprVector::row_vector() const {
 return (dim.type()==Dim::ROW_VECTOR || get(0).type()==Dim::COL_VECTOR); }

inline ExprLeaf::ExprLeaf(const Dim& dim) : ExprNode(0,1,dim) { }

inline const ExprSymbol& ExprSymbol::new_(const char* name, const Dim& dim) {
 return *new ExprSymbol(name,dim); }

inline ExprSymbol::ExprSymbol(const char* name, const Dim& dim)
: ExprLeaf(dim), name(strdup(name)), key(-1) { }

inline const ExprConstant& ExprConstant::new_scalar(const Interval& value) {
 return *new ExprConstant(value); }

inline const ExprConstant& ExprConstant::new_vector(const IntervalVector& value, bool in_row) {
 return *new ExprConstant(value,in_row); }

inline const ExprConstant& ExprConstant::new_matrix(const IntervalMatrix& value) {
 return *new ExprConstant(value); }

inline const ExprConstant& ExprConstant::new_matrix_array(const IntervalMatrixArray& value) {
 return *new ExprConstant(value); }

inline const ExprConstant& ExprConstant::new_(const Domain& value, bool reference) {
 return *new ExprConstant(value,reference); }

inline const Interval& ExprConstant::get_value() const {
 return value.i(); }

inline const IntervalVector& ExprConstant::get_vector_value() const {
 return value.v(); }

inline const IntervalMatrix& ExprConstant::get_matrix_value() const {
 return value.m(); }

inline const IntervalMatrixArray& ExprConstant::get_matrix_array_value() const {
 return value.ma(); }

inline const Domain& ExprConstant::get() const {
 return value; }


inline const ExprAdd& operator+(const ExprNode& left, const ExprNode& right) {
 return ExprAdd::new_(left, right); }


inline const ExprSub& operator-(const ExprNode& left, const ExprNode& right) {
 return ExprSub::new_(left, right); }


inline const ExprMul& operator*(const ExprNode& left, const ExprNode& right) {
 return ExprMul::new_(left, right); }


inline const ExprDiv& operator/(const ExprNode& left, const ExprNode& right) {
 return ExprDiv::new_(left, right); }


inline const ExprMax& max(const ExprNode& left, const ExprNode& right) {
 return ExprMax::new_(left, right); }


inline const ExprMax& max(const Array<const ExprNode> args) {
 (static_cast <bool> (args.size()>1) ? void (0) : __assert_fail ("args.size()>1", "/usr/local/include/ibex/ibex_Expr.h", 1483, __extension__ __PRETTY_FUNCTION__));
 const ExprMax* _max=&max(args[0],args[1]);
 for (int i=2; i<args.size(); i++)
  _max = & max(*_max, args[i]);
 return *_max;
}


inline const ExprMin& min(const ExprNode& left, const ExprNode& right) {
 return ExprMin::new_(left, right); }


inline const ExprMin& min(const Array<const ExprNode> args) {
 (static_cast <bool> (args.size()>1) ? void (0) : __assert_fail ("args.size()>1", "/usr/local/include/ibex/ibex_Expr.h", 1496, __extension__ __PRETTY_FUNCTION__));
 const ExprMin* _min=&min(args[0],args[1]);
 for (int i=2; i<args.size(); i++)
  _min = & min(*_min, args[i]);
 return *_min;
}


inline const ExprAtan2& atan2(const ExprNode& exp1, const ExprNode& exp2) {
 return ExprAtan2::new_(exp1, exp2); }


inline const ExprChi& chi(const ExprNode& exp1, const ExprNode& exp2, const ExprNode& exp3) {
 return ExprChi::new_(exp1, exp2, exp3); }


inline const ExprAdd& operator+(const ExprNode& left, double value) {
 return left+ExprConstant::new_scalar(value); }


inline const ExprSub& operator-(const ExprNode& left, double value) {
 return left-ExprConstant::new_scalar(value); }


inline const ExprMul& operator*(const ExprNode& left, double value) {
 return left*ExprConstant::new_scalar(value); }


inline const ExprDiv& operator/(const ExprNode& left, double value) {
 return left/ExprConstant::new_scalar(value); }


inline const ExprMax& max(const ExprNode& left, double value) {
 return max(left, ExprConstant::new_scalar(value)); }


inline const ExprMin& min(const ExprNode& left, double value) {
 return min(left, ExprConstant::new_scalar(value)); }


inline const ExprAtan2& atan2(const ExprNode& exp1, double value) {
 return ExprAtan2::new_(exp1, ExprConstant::new_scalar(value)); }


inline const ExprAdd& operator+(double value, const ExprNode& right) {
 return ExprConstant::new_scalar(value)+right; }


inline const ExprSub& operator-(double value, const ExprNode& right) {
 return ExprConstant::new_scalar(value)-right; }


inline const ExprMul& operator*(double value, const ExprNode& right) {
 return ExprConstant::new_scalar(value)*right; }


inline const ExprDiv& operator/(double value, const ExprNode& right) {
 return ExprConstant::new_scalar(value)/right; }


inline const ExprMax& max (double value, const ExprNode& right) {
 return max(ExprConstant::new_scalar(value), right); }


inline const ExprMin& min (double value, const ExprNode& right) {
 return min(ExprConstant::new_scalar(value), right); }


inline const ExprAtan2& atan2(double value, const ExprNode& exp2) {
 return ExprAtan2::new_(ExprConstant::new_scalar(value), exp2); }


inline const ExprSqr& sqr (const ExprNode& exp) { return ExprSqr::new_(exp); }


inline const ExprSqrt& sqrt (const ExprNode& exp) { return ExprSqrt::new_(exp); }


inline const ExprExp& exp (const ExprNode& exp) { return ExprExp::new_(exp); }


inline const ExprLog& log (const ExprNode& exp) { return ExprLog::new_(exp); }


inline const ExprCos& cos (const ExprNode& exp) { return ExprCos::new_(exp); }


inline const ExprSin& sin (const ExprNode& exp) { return ExprSin::new_(exp); }


inline const ExprTan& tan (const ExprNode& exp) { return ExprTan::new_(exp); }


inline const ExprAcos& acos (const ExprNode& exp) { return ExprAcos::new_(exp); }


inline const ExprAsin& asin (const ExprNode& exp) { return ExprAsin::new_(exp); }


inline const ExprAtan& atan (const ExprNode& exp) { return ExprAtan::new_(exp); }


inline const ExprCosh& cosh (const ExprNode& exp) { return ExprCosh::new_(exp); }


inline const ExprSinh& sinh (const ExprNode& exp) { return ExprSinh::new_(exp); }


inline const ExprTanh& tanh (const ExprNode& exp) { return ExprTanh::new_(exp); }


inline const ExprAcosh& acosh(const ExprNode& exp) { return ExprAcosh::new_(exp); }


inline const ExprAsinh& asinh(const ExprNode& exp) { return ExprAsinh::new_(exp); }


inline const ExprAtanh& atanh(const ExprNode& exp) { return ExprAtanh::new_(exp); }




inline const ExprNode& pow(const ExprNode& left, int expon) {
 if (expon==1) return left;
 if (expon==2) return sqr(left);
 return ExprPower::new_(left, expon);
}


inline const ExprMinus& operator-(const ExprNode& expr) {
 return ExprMinus::new_(expr);
}


inline const ExprTrans& transpose(const ExprNode& expr) {
 return ExprTrans::new_(expr);
}


inline const ExprSign& sign(const ExprNode& expr) {
 return ExprSign::new_(expr);
}


inline const ExprAbs& abs(const ExprNode& expr) {
 return ExprAbs::new_(expr);
}


inline const ExprExp& pow(const ExprNode& left, const ExprNode& right) {
 return exp(right*log(left));
}


inline const ExprExp& pow(const ExprNode& left, double value) {
 return exp(ExprConstant::new_scalar(value)*log(left));
}

inline const ExprExp& pow(double value, const ExprNode& right) {
 return exp(right*log(ExprConstant::new_scalar(value)));
}

}
# 16 "/usr/local/include/ibex/ibex_Function.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CompiledFunction.h" 1 3
# 14 "/usr/local/include/ibex/ibex_CompiledFunction.h" 3
# 1 "/usr/include/c++/7/stack" 1 3
# 58 "/usr/include/c++/7/stack" 3
       
# 59 "/usr/include/c++/7/stack" 3

# 1 "/usr/include/c++/7/deque" 1 3
# 58 "/usr/include/c++/7/deque" 3
       
# 59 "/usr/include/c++/7/deque" 3





# 1 "/usr/include/c++/7/bits/stl_deque.h" 1 3
# 68 "/usr/include/c++/7/bits/stl_deque.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 90 "/usr/include/c++/7/bits/stl_deque.h" 3
  constexpr inline size_t
  __deque_buf_size(size_t __size)
  { return (__size < 512
     ? size_t(512 / __size) : size_t(1)); }
# 107 "/usr/include/c++/7/bits/stl_deque.h" 3
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {






    private:
      template<typename _Up>
 using __ptr_to = typename pointer_traits<_Ptr>::template rebind<_Up>;
      template<typename _CvTp>
 using __iter = _Deque_iterator<_Tp, _CvTp&, __ptr_to<_CvTp>>;
    public:
      typedef __iter<_Tp> iterator;
      typedef __iter<const _Tp> const_iterator;
      typedef __ptr_to<_Tp> _Elt_pointer;
      typedef __ptr_to<_Elt_pointer> _Map_pointer;


      static size_t _S_buffer_size() noexcept
      { return __deque_buf_size(sizeof(_Tp)); }

      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Deque_iterator _Self;

      _Elt_pointer _M_cur;
      _Elt_pointer _M_first;
      _Elt_pointer _M_last;
      _Map_pointer _M_node;

      _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) noexcept
      : _M_cur(__x), _M_first(*__y),
 _M_last(*__y + _S_buffer_size()), _M_node(__y) { }

      _Deque_iterator() noexcept
      : _M_cur(), _M_first(), _M_last(), _M_node() { }

      _Deque_iterator(const iterator& __x) noexcept
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
 _M_last(__x._M_last), _M_node(__x._M_node) { }

      iterator
      _M_const_cast() const noexcept
      { return iterator(_M_cur, _M_node); }

      reference
      operator*() const noexcept
      { return *_M_cur; }

      pointer
      operator->() const noexcept
      { return _M_cur; }

      _Self&
      operator++() noexcept
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }

      _Self&
      operator+=(difference_type __n) noexcept
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
      : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }

      _Self
      operator+(difference_type __n) const noexcept
      {
 _Self __tmp = *this;
 return __tmp += __n;
      }

      _Self&
      operator-=(difference_type __n) noexcept
      { return *this += -__n; }

      _Self
      operator-(difference_type __n) const noexcept
      {
 _Self __tmp = *this;
 return __tmp -= __n;
      }

      reference
      operator[](difference_type __n) const noexcept
      { return *(*this + __n); }






      void
      _M_set_node(_Map_pointer __new_node) noexcept
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }
    };




  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return !(__x == __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return !(__x == __y); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
       : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
       : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return __y < __x; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return __y < __x; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return !(__y < __x); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return !(__y < __x); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return !(__x < __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return !(__x < __y); }





  template<typename _Tp, typename _Ref, typename _Ptr>
    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    {
      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
 (_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    {
      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
 (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline _Deque_iterator<_Tp, _Ref, _Ptr>
    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
    noexcept
    { return __x + __n; }

  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>&,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>&, const _Tp&);

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
         _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
         __result); }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy_backward(_Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__first),
    _Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__last),
    __result); }


  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
         _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
         __result); }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::move_backward(_Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__first),
    _Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__last),
    __result); }
# 459 "/usr/include/c++/7/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    protected:
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;





      typedef typename _Alloc_traits::pointer _Ptr;
      typedef typename _Alloc_traits::const_pointer _Ptr_const;


      typedef typename _Alloc_traits::template rebind<_Ptr>::other
 _Map_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Map_alloc_type> _Map_alloc_traits;

    public:
      typedef _Alloc allocator_type;
      typedef typename _Alloc_traits::size_type size_type;

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      typedef _Deque_iterator<_Tp, _Tp&, _Ptr> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, _Ptr_const> const_iterator;

      _Deque_base()
      : _M_impl()
      { _M_initialize_map(0); }

      _Deque_base(size_t __num_elements)
      : _M_impl()
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }


      _Deque_base(_Deque_base&& __x, false_type)
      : _M_impl(__x._M_move_impl())
      { }

      _Deque_base(_Deque_base&& __x, true_type)
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      {
 _M_initialize_map(0);
 if (__x._M_impl._M_map)
   this->_M_impl._M_swap_data(__x._M_impl);
      }

      _Deque_base(_Deque_base&& __x)
      : _Deque_base(std::move(__x), typename _Alloc_traits::is_always_equal{})
      { }

      _Deque_base(_Deque_base&& __x, const allocator_type& __a, size_type __n)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   {
     if (__x._M_impl._M_map)
       {
  _M_initialize_map(0);
  this->_M_impl._M_swap_data(__x._M_impl);
       }
   }
 else
   {
     _M_initialize_map(__n);
   }
      }


      ~_Deque_base() noexcept;

    protected:
      typedef typename iterator::_Map_pointer _Map_pointer;




      struct _Deque_impl
      : public _Tp_alloc_type
      {
 _Map_pointer _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;

 _Deque_impl()
 : _Tp_alloc_type(), _M_map(), _M_map_size(0),
   _M_start(), _M_finish()
 { }

 _Deque_impl(const _Tp_alloc_type& __a) noexcept
 : _Tp_alloc_type(__a), _M_map(), _M_map_size(0),
   _M_start(), _M_finish()
 { }


 _Deque_impl(_Deque_impl&&) = default;

 _Deque_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a)), _M_map(), _M_map_size(0),
   _M_start(), _M_finish()
 { }


 void _M_swap_data(_Deque_impl& __x) noexcept
 {
   using std::swap;
   swap(this->_M_start, __x._M_start);
   swap(this->_M_finish, __x._M_finish);
   swap(this->_M_map, __x._M_map);
   swap(this->_M_map_size, __x._M_map_size);
 }
      };

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      _Map_alloc_type
      _M_get_map_allocator() const noexcept
      { return _Map_alloc_type(_M_get_Tp_allocator()); }

      _Ptr
      _M_allocate_node()
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
 return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
      }

      void
      _M_deallocate_node(_Ptr __p) noexcept
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
 _Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));
      }

      _Map_pointer
      _M_allocate_map(size_t __n)
      {
 _Map_alloc_type __map_alloc = _M_get_map_allocator();
 return _Map_alloc_traits::allocate(__map_alloc, __n);
      }

      void
      _M_deallocate_map(_Map_pointer __p, size_t __n) noexcept
      {
 _Map_alloc_type __map_alloc = _M_get_map_allocator();
 _Map_alloc_traits::deallocate(__map_alloc, __p, __n);
      }

    protected:
      void _M_initialize_map(size_t);
      void _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish);
      void _M_destroy_nodes(_Map_pointer __nstart,
       _Map_pointer __nfinish) noexcept;
      enum { _S_initial_map_size = 8 };

      _Deque_impl _M_impl;


    private:
      _Deque_impl
      _M_move_impl()
      {
 if (!_M_impl._M_map)
   return std::move(_M_impl);


 _Tp_alloc_type __alloc{_M_get_Tp_allocator()};

 _Tp_alloc_type __sink __attribute((__unused__)) {std::move(__alloc)};

 _Deque_base __empty{__alloc};
 __empty._M_initialize_map(0);

 _Deque_impl __ret{std::move(_M_get_Tp_allocator())};
 _M_impl._M_swap_data(__ret);
 _M_impl._M_swap_data(__empty._M_impl);
 return __ret;
      }

    };

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base() noexcept
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
# 679 "/usr/include/c++/7/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
      + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);






      _Map_pointer __nstart = (this->_M_impl._M_map
          + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Map_pointer __nfinish = __nstart + __num_nodes;

      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = _Map_pointer();
   this->_M_impl._M_map_size = 0;
   throw;
 }

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)
    {
      _Map_pointer __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Map_pointer __nstart,
       _Map_pointer __nfinish) noexcept
    {
      for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
# 830 "/usr/include/c++/7/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {
# 842 "/usr/include/c++/7/bits/stl_deque.h" 3
      typedef _Deque_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef typename _Base::_Alloc_traits _Alloc_traits;
      typedef typename _Base::_Map_pointer _Map_pointer;

    public:
      typedef _Tp value_type;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      static size_t _S_buffer_size() noexcept
      { return __deque_buf_size(sizeof(_Tp)); }


      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;





      using _Base::_M_impl;

    public:






      deque() : _Base() { }





      explicit
      deque(const allocator_type& __a)
      : _Base(__a, 0) { }
# 907 "/usr/include/c++/7/bits/stl_deque.h" 3
      explicit
      deque(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_default_initialize(); }
# 920 "/usr/include/c++/7/bits/stl_deque.h" 3
      deque(size_type __n, const value_type& __value,
     const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
# 947 "/usr/include/c++/7/bits/stl_deque.h" 3
      deque(const deque& __x)
      : _Base(_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()),
       __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }
# 962 "/usr/include/c++/7/bits/stl_deque.h" 3
      deque(deque&& __x)
      : _Base(std::move(__x)) { }


      deque(const deque& __x, const allocator_type& __a)
      : _Base(__a, __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }


      deque(deque&& __x, const allocator_type& __a)
      : _Base(std::move(__x), __a, __x.size())
      {
 if (__x.get_allocator() != __a)
   {
     std::__uninitialized_move_a(__x.begin(), __x.end(),
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
     __x.clear();
   }
      }
# 996 "/usr/include/c++/7/bits/stl_deque.h" 3
      deque(initializer_list<value_type> __l,
     const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 1021 "/usr/include/c++/7/bits/stl_deque.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
 { _M_initialize_dispatch(__first, __last, __false_type()); }
# 1044 "/usr/include/c++/7/bits/stl_deque.h" 3
      ~deque()
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
# 1056 "/usr/include/c++/7/bits/stl_deque.h" 3
      deque&
      operator=(const deque& __x);
# 1068 "/usr/include/c++/7/bits/stl_deque.h" 3
      deque&
      operator=(deque&& __x) noexcept(_Alloc_traits::_S_always_equal())
      {
 using __always_equal = typename _Alloc_traits::is_always_equal;
 _M_move_assign1(std::move(__x), __always_equal{});
 return *this;
      }
# 1087 "/usr/include/c++/7/bits/stl_deque.h" 3
      deque&
      operator=(initializer_list<value_type> __l)
      {
 _M_assign_aux(__l.begin(), __l.end(),
        random_access_iterator_tag());
 return *this;
      }
# 1106 "/usr/include/c++/7/bits/stl_deque.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 1123 "/usr/include/c++/7/bits/stl_deque.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_dispatch(__first, __last, __false_type()); }
# 1150 "/usr/include/c++/7/bits/stl_deque.h" 3
      void
      assign(initializer_list<value_type> __l)
      { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }



      allocator_type
      get_allocator() const noexcept
      { return _Base::get_allocator(); }






      iterator
      begin() noexcept
      { return this->_M_impl._M_start; }





      const_iterator
      begin() const noexcept
      { return this->_M_impl._M_start; }






      iterator
      end() noexcept
      { return this->_M_impl._M_finish; }






      const_iterator
      end() const noexcept
      { return this->_M_impl._M_finish; }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->_M_impl._M_start); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_start); }






      const_iterator
      cbegin() const noexcept
      { return this->_M_impl._M_start; }






      const_iterator
      cend() const noexcept
      { return this->_M_impl._M_finish; }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_start); }




      size_type
      size() const noexcept
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }


      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
# 1289 "/usr/include/c++/7/bits/stl_deque.h" 3
      void
      resize(size_type __new_size)
      {
 const size_type __len = size();
 if (__new_size > __len)
   _M_default_append(__new_size - __len);
 else if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start
     + difference_type(__new_size));
      }
# 1311 "/usr/include/c++/7/bits/stl_deque.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 const size_type __len = size();
 if (__new_size > __len)
   _M_fill_insert(this->_M_impl._M_finish, __new_size - __len, __x);
 else if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start
     + difference_type(__new_size));
      }
# 1347 "/usr/include/c++/7/bits/stl_deque.h" 3
      void
      shrink_to_fit() noexcept
      { _M_shrink_to_fit(); }






      bool
      empty() const noexcept
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
# 1372 "/usr/include/c++/7/bits/stl_deque.h" 3
      reference
      operator[](size_type __n) noexcept
      {
 ;
 return this->_M_impl._M_start[difference_type(__n)];
      }
# 1390 "/usr/include/c++/7/bits/stl_deque.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      {
 ;
 return this->_M_impl._M_start[difference_type(__n)];
      }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("deque::_M_range_check: __n " "(which is %zu)>= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
# 1421 "/usr/include/c++/7/bits/stl_deque.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 1439 "/usr/include/c++/7/bits/stl_deque.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      {
 ;
 return *begin();
      }





      const_reference
      front() const noexcept
      {
 ;
 return *begin();
      }





      reference
      back() noexcept
      {
 ;
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const noexcept
      {
 ;
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 1504 "/usr/include/c++/7/bits/stl_deque.h" 3
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     _Alloc_traits::construct(this->_M_impl,
         this->_M_impl._M_start._M_cur - 1,
         __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }


      void
      push_front(value_type&& __x)
      { emplace_front(std::move(__x)); }

      template<typename... _Args>



 void

 emplace_front(_Args&&... __args);
# 1541 "/usr/include/c++/7/bits/stl_deque.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     _Alloc_traits::construct(this->_M_impl,
         this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>



 void

 emplace_back(_Args&&... __args);
# 1577 "/usr/include/c++/7/bits/stl_deque.h" 3
      void
      pop_front() noexcept
      {
 ;
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     _Alloc_traits::destroy(this->_M_impl,
       this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
# 1600 "/usr/include/c++/7/bits/stl_deque.h" 3
      void
      pop_back() noexcept
      {
 ;
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     _Alloc_traits::destroy(this->_M_impl,
       this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
# 1625 "/usr/include/c++/7/bits/stl_deque.h" 3
      template<typename... _Args>
 iterator
 emplace(const_iterator __position, _Args&&... __args);
# 1638 "/usr/include/c++/7/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1664 "/usr/include/c++/7/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 1677 "/usr/include/c++/7/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __p, initializer_list<value_type> __l)
      {
 auto __offset = __p - cbegin();
 _M_range_insert_aux(__p._M_const_cast(), __l.begin(), __l.end(),
       std::random_access_iterator_tag());
 return begin() + __offset;
      }
# 1698 "/usr/include/c++/7/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(__position._M_const_cast(), __n, __x);
 return begin() + __offset;
      }
# 1732 "/usr/include/c++/7/bits/stl_deque.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(__position._M_const_cast(),
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1778 "/usr/include/c++/7/bits/stl_deque.h" 3
      iterator

      erase(const_iterator __position)



      { return _M_erase(__position._M_const_cast()); }
# 1802 "/usr/include/c++/7/bits/stl_deque.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)



      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }
# 1821 "/usr/include/c++/7/bits/stl_deque.h" 3
      void
      swap(deque& __x) noexcept
      {


                                                          ;

 _M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
      __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(begin()); }

    protected:






      template<typename _Integer>
 void
 _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
 {
   _M_initialize_map(static_cast<size_type>(__n));
   _M_fill_initialize(__x);
 }


      template<typename _InputIterator>
 void
 _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
 {
   _M_range_initialize(__first, __last,
         std::__iterator_category(__first));
 }
# 1880 "/usr/include/c++/7/bits/stl_deque.h" 3
      template<typename _InputIterator>
 void
 _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag);
# 1902 "/usr/include/c++/7/bits/stl_deque.h" 3
      void
      _M_fill_initialize(const value_type& __value);



      void
      _M_default_initialize();
# 1918 "/usr/include/c++/7/bits/stl_deque.h" 3
      template<typename _Integer>
 void
 _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
 { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
 void
 _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }


      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
 {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       _M_range_insert_aux(end(), __mid, __last,
      std::__iterator_category(__first));
     }
   else
     _M_erase_at_end(std::copy(__first, __last, begin()));
 }



      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     _M_fill_insert(end(), __n - size(), __val);
   }
 else
   {
     _M_erase_at_end(begin() + difference_type(__n));
     std::fill(begin(), end(), __val);
   }
      }
# 1979 "/usr/include/c++/7/bits/stl_deque.h" 3
      template<typename... _Args>
 void _M_push_back_aux(_Args&&... __args);

      template<typename... _Args>
 void _M_push_front_aux(_Args&&... __args);


      void _M_pop_back_aux();

      void _M_pop_front_aux();
# 1998 "/usr/include/c++/7/bits/stl_deque.h" 3
      template<typename _Integer>
 void
 _M_insert_dispatch(iterator __pos,
      _Integer __n, _Integer __x, __true_type)
 { _M_fill_insert(__pos, __n, __x); }


      template<typename _InputIterator>
 void
 _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
 {
   _M_range_insert_aux(__pos, __first, __last,
         std::__iterator_category(__first));
 }


      template<typename _InputIterator>
 void
 _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag);




      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);






      template<typename... _Args>
 iterator
 _M_insert_aux(iterator __pos, _Args&&... __args);



      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);


      template<typename _ForwardIterator>
 void
 _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);




      void
      _M_destroy_data_aux(iterator __first, iterator __last);



      template<typename _Alloc1>
 void
 _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
 { _M_destroy_data_aux(__first, __last); }

      void
      _M_destroy_data(iterator __first, iterator __last,
        const std::allocator<_Tp>&)
      {
 if (!__has_trivial_destructor(value_type))
   _M_destroy_data_aux(__first, __last);
      }


      void
      _M_erase_at_begin(iterator __pos)
      {
 _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
 _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
 this->_M_impl._M_start = __pos;
      }



      void
      _M_erase_at_end(iterator __pos)
      {
 _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
 _M_destroy_nodes(__pos._M_node + 1,
    this->_M_impl._M_finish._M_node + 1);
 this->_M_impl._M_finish = __pos;
      }

      iterator
      _M_erase(iterator __pos);

      iterator
      _M_erase(iterator __first, iterator __last);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();




      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
          - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }

      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }

      void
      _M_new_elements_at_front(size_type __new_elements);

      void
      _M_new_elements_at_back(size_type __new_elements);
# 2148 "/usr/include/c++/7/bits/stl_deque.h" 3
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }

      void
      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }

      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);





      void
      _M_move_assign1(deque&& __x, true_type) noexcept
      {
 this->_M_impl._M_swap_data(__x._M_impl);
 __x.clear();
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }




      void
      _M_move_assign1(deque&& __x, false_type)
      {
 constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign();
 _M_move_assign2(std::move(__x), __bool_constant<__move_storage>());
      }



      template<typename... _Args>
      void
      _M_replace_map(_Args&&... __args)
      {

 deque __newobj(std::forward<_Args>(__args)...);

 clear();
 _M_deallocate_node(*begin()._M_node);
 _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 this->_M_impl._M_map = nullptr;
 this->_M_impl._M_map_size = 0;

 this->_M_impl._M_swap_data(__newobj._M_impl);
      }


      void
      _M_move_assign2(deque&& __x, true_type)
      {

 auto __alloc = __x._M_get_Tp_allocator();


 _M_replace_map(std::move(__x));

 _M_get_Tp_allocator() = std::move(__alloc);
      }



      void
      _M_move_assign2(deque&& __x, false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   {


     _M_replace_map(std::move(__x), __x.get_allocator());
   }
 else
   {


     _M_assign_aux(std::__make_move_if_noexcept_iterator(__x.begin()),
     std::__make_move_if_noexcept_iterator(__x.end()),
     std::random_access_iterator_tag());
     __x.clear();
   }
      }

    };
# 2256 "/usr/include/c++/7/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin()); }
# 2274 "/usr/include/c++/7/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }




}
# 65 "/usr/include/c++/7/deque" 2 3

# 1 "/usr/include/c++/7/bits/deque.tcc" 1 3
# 59 "/usr/include/c++/7/bits/deque.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_default_initialize()
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_default_a(*__cur, *__cur + _S_buffer_size(),
        _M_get_Tp_allocator());
          std::__uninitialized_default_a(this->_M_impl._M_finish._M_first,
      this->_M_impl._M_finish._M_cur,
      _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }


  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      if (&__x != this)
 {

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {


    _M_replace_map(__x, __x.get_allocator());
    std::__alloc_on_copy(_M_get_Tp_allocator(),
           __x._M_get_Tp_allocator());
    return *this;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __len = size();
   if (__len >= __x.size())
     _M_erase_at_end(std::copy(__x.begin(), __x.end(),
          this->_M_impl._M_start));
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       _M_range_insert_aux(this->_M_impl._M_finish, __mid, __x.end(),
      std::random_access_iterator_tag());
     }
 }
      return *this;
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>



      void

      deque<_Tp, _Alloc>::
      emplace_front(_Args&&... __args)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_start._M_cur - 1,
                std::forward<_Args>(__args)...);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(std::forward<_Args>(__args)...);



      }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>



      void

      deque<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_finish._M_cur,
                std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(std::forward<_Args>(__args)...);



      }



  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
 if (__position._M_cur == this->_M_impl._M_start._M_cur)
   {
     emplace_front(std::forward<_Args>(__args)...);
     return this->_M_impl._M_start;
   }
 else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
   {
     emplace_back(std::forward<_Args>(__args)...);
     iterator __tmp = this->_M_impl._M_finish;
     --__tmp;
     return __tmp;
   }
 else
   return _M_insert_aux(__position._M_const_cast(),
          std::forward<_Args>(__args)...);
      }


  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      if (__position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
 return _M_insert_aux(__position._M_const_cast(), __x);
   }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const difference_type __index = __position - begin();
      if (static_cast<size_type>(__index) < (size() >> 1))
 {
   if (__position != begin())
     std::move_backward(begin(), __position, __next);
   pop_front();
 }
      else
 {
   if (__next != end())
     std::move(__next, end(), __position);
   pop_back();
 }
      return begin() + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first == __last)
 return __first;
      else if (__first == begin() && __last == end())
 {
   clear();
   return end();
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = __first - begin();
   if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
     {
       if (__first != begin())
  std::move_backward(begin(), __first, __last);
       _M_erase_at_begin(begin() + __n);
     }
   else
     {
       if (__last != end())
  std::move(__last, end(), __first);
       _M_erase_at_end(end() - __n);
     }
   return begin() + __elems_before;
 }
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
        iterator __cur = begin();
        for (; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          _M_erase_at_end(__cur);
        else
          _M_range_insert_aux(end(), __first, __last,
         std::__iterator_category(__first));
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x, _M_get_Tp_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
        _M_insert_aux(__pos, __n, __x);
    }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_default_a(this->_M_impl._M_finish,
          __new_finish,
          _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    bool
    deque<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      const difference_type __front_capacity
 = (this->_M_impl._M_start._M_cur - this->_M_impl._M_start._M_first);
      if (__front_capacity == 0)
 return false;

      const difference_type __back_capacity
 = (this->_M_impl._M_finish._M_last - this->_M_impl._M_finish._M_cur);
      if (__front_capacity + __back_capacity < _S_buffer_size())
 return false;

      return std::__shrink_to_fit_aux<deque>::_S_do_it(*this);
    }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, _M_get_Tp_allocator());
          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      {
        this->_M_initialize_map(0);
        try
          {
            for (; __first != __last; ++__first)

       emplace_back(*__first);



          }
        catch(...)
          {
            clear();
            throw;
          }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);

        _Map_pointer __cur_node;
        try
          {
            for (__cur_node = this->_M_impl._M_start._M_node;
                 __cur_node < this->_M_impl._M_finish._M_node;
                 ++__cur_node)
       {
  _ForwardIterator __mid = __first;
  std::advance(__mid, _S_buffer_size());
  std::__uninitialized_copy_a(__first, __mid, *__cur_node,
         _M_get_Tp_allocator());
  __first = __mid;
       }
            std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     _M_get_Tp_allocator());
          }
        catch(...)
          {
            std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     _M_get_Tp_allocator());
            throw;
          }
      }


  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_back_aux(_Args&&... __args)





      {
 _M_reserve_map_at_back();
 *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
 try
   {

     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_finish._M_cur,
                std::forward<_Args>(__args)...);



     this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
      + 1);
     this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
   }
 catch(...)
   {
     _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
     throw;
   }
      }


  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_front_aux(_Args&&... __args)





      {
 _M_reserve_map_at_front();
 *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
 try
   {
     this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
            - 1);
     this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;

     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_start._M_cur,
                std::forward<_Args>(__args)...);



   }
 catch(...)
   {
     ++this->_M_impl._M_start;
     _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
     throw;
   }
      }


  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      _Alloc_traits::destroy(_M_get_Tp_allocator(),
        this->_M_impl._M_finish._M_cur);
    }






  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      _Alloc_traits::destroy(_M_get_Tp_allocator(),
        this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         _M_get_Tp_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }

  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos, _Args&&... __args)
      {
 value_type __x_copy(std::forward<_Args>(__args)...);







 difference_type __index = __pos - this->_M_impl._M_start;
 if (static_cast<size_type>(__index) < size() / 2)
   {
     push_front(std::move(front()));
     iterator __front1 = this->_M_impl._M_start;
     ++__front1;
     iterator __front2 = __front1;
     ++__front2;
     __pos = this->_M_impl._M_start + __index;
     iterator __pos1 = __pos;
     ++__pos1;
     std::move(__front2, __pos1, __front1);
   }
 else
   {
     push_back(std::move(back()));
     iterator __back1 = this->_M_impl._M_finish;
     --__back1;
     iterator __back2 = __back1;
     --__back2;
     __pos = this->_M_impl._M_start + __index;
     std::move_backward(__pos, __back2, __back1);
   }
 *__pos = std::move(__x_copy);
 return __pos;
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_move_a(this->_M_impl._M_start,
           __start_n, __new_start,
           _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::move(__start_n, __pos, __old_start);
    std::fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_move_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::move_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_move(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __start_n, __new_start,
      _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::move(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_move_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = this->_M_impl._M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = this->_M_impl._M_finish - __elemsafter;
          try
            {
              if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::move_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
              else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_move(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
            }
          catch(...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
              throw;
            }
        }
      }

   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
     __node < __last._M_node; ++__node)
  std::_Destroy(*__node, *__node + _S_buffer_size(),
         _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  {
    std::_Destroy(__first._M_cur, __first._M_last,
    _M_get_Tp_allocator());
    std::_Destroy(__last._M_first, __last._M_cur,
    _M_get_Tp_allocator());
  }
       else
  std::_Destroy(__first._M_cur, __last._M_cur,
         _M_get_Tp_allocator());
     }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_front"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_back"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
        this->_M_impl._M_finish._M_node + 1,
        __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
                              + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;

   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }



  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;

      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
           __node < __last._M_node; ++__node)
 std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);

      if (__first._M_node != __last._M_node)
 {
   std::fill(__first._M_cur, __first._M_last, __value);
   std::fill(__last._M_first, __last._M_cur, __value);
 }
      else
 std::fill(__first._M_cur, __last._M_cur, __value);
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, std::min(__first._M_last - __first._M_cur,
           __result._M_last - __result._M_cur));
   std::copy(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
   __first += __clen;
   __result += __clen;
   __len -= __clen;
 }
      return __result;
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   difference_type __llen = __last._M_cur - __last._M_first;
   _Tp* __lend = __last._M_cur;

   difference_type __rlen = __result._M_cur - __result._M_first;
   _Tp* __rend = __result._M_cur;

   if (!__llen)
     {
       __llen = _Self::_S_buffer_size();
       __lend = *(__last._M_node - 1) + __llen;
     }
   if (!__rlen)
     {
       __rlen = _Self::_S_buffer_size();
       __rend = *(__result._M_node - 1) + __rlen;
     }

   const difference_type __clen = std::min(__len,
        std::min(__llen, __rlen));
   std::copy_backward(__lend - __clen, __lend, __rend);
   __last -= __clen;
   __result -= __clen;
   __len -= __clen;
 }
      return __result;
    }


  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, std::min(__first._M_last - __first._M_cur,
           __result._M_last - __result._M_cur));
   std::move(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
   __first += __clen;
   __result += __clen;
   __len -= __clen;
 }
      return __result;
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   difference_type __llen = __last._M_cur - __last._M_first;
   _Tp* __lend = __last._M_cur;

   difference_type __rlen = __result._M_cur - __result._M_first;
   _Tp* __rend = __result._M_cur;

   if (!__llen)
     {
       __llen = _Self::_S_buffer_size();
       __lend = *(__last._M_node - 1) + __llen;
     }
   if (!__rlen)
     {
       __rlen = _Self::_S_buffer_size();
       __rend = *(__result._M_node - 1) + __rlen;
     }

   const difference_type __clen = std::min(__len,
        std::min(__llen, __rlen));
   std::move_backward(__lend - __clen, __lend, __rend);
   __last -= __clen;
   __result -= __clen;
   __len -= __clen;
 }
      return __result;
    }



}
# 67 "/usr/include/c++/7/deque" 2 3
# 61 "/usr/include/c++/7/stack" 2 3
# 1 "/usr/include/c++/7/bits/stl_stack.h" 1 3
# 65 "/usr/include/c++/7/bits/stl_stack.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 98 "/usr/include/c++/7/bits/stl_stack.h" 3
  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class stack
    {
# 111 "/usr/include/c++/7/bits/stl_stack.h" 3
      template<typename _Tp1, typename _Seq1>
 friend bool
 operator==(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);

      template<typename _Tp1, typename _Seq1>
 friend bool
 operator<(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);


      template<typename _Alloc>
 using _Uses = typename
   enable_if<uses_allocator<_Sequence, _Alloc>::value>::type;


    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:

      _Sequence c;

    public:
# 146 "/usr/include/c++/7/bits/stl_stack.h" 3
      template<typename _Seq = _Sequence, typename _Requires = typename
        enable_if<is_default_constructible<_Seq>::value>::type>
 stack()
 : c() { }

      explicit
      stack(const _Sequence& __c)
      : c(__c) { }

      explicit
      stack(_Sequence&& __c)
      : c(std::move(__c)) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 explicit
 stack(const _Alloc& __a)
 : c(__a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 stack(const _Sequence& __c, const _Alloc& __a)
 : c(__c, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 stack(_Sequence&& __c, const _Alloc& __a)
 : c(std::move(__c), __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 stack(const stack& __q, const _Alloc& __a)
 : c(__q.c, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 stack(stack&& __q, const _Alloc& __a)
 : c(std::move(__q.c), __a) { }





      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      reference
      top()
      {
 ;
 return c.back();
      }





      const_reference
      top() const
      {
 ;
 return c.back();
      }
# 224 "/usr/include/c++/7/bits/stl_stack.h" 3
      void
      push(const value_type& __x)
      { c.push_back(__x); }


      void
      push(value_type&& __x)
      { c.push_back(std::move(__x)); }







      template<typename... _Args>
 void
 emplace(_Args&&... __args)
 { c.emplace_back(std::forward<_Args>(__args)...); }
# 257 "/usr/include/c++/7/bits/stl_stack.h" 3
      void
      pop()
      {
 ;
 c.pop_back();
      }


      void
      swap(stack& __s)

      noexcept(__is_nothrow_swappable<_Sequence>::value)



      {
 using std::swap;
 swap(c, __s.c);
      }

    };
# 291 "/usr/include/c++/7/bits/stl_stack.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator==(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __x.c == __y.c; }
# 309 "/usr/include/c++/7/bits/stl_stack.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator<(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __x.c < __y.c; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator!=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator<=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Seq>
    inline


    typename enable_if<__is_swappable<_Seq>::value>::type



    swap(stack<_Tp, _Seq>& __x, stack<_Tp, _Seq>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<typename _Tp, typename _Seq, typename _Alloc>
    struct uses_allocator<stack<_Tp, _Seq>, _Alloc>
    : public uses_allocator<_Seq, _Alloc>::type { };



}
# 62 "/usr/include/c++/7/stack" 2 3
# 15 "/usr/local/include/ibex/ibex_CompiledFunction.h" 2 3



# 1 "/usr/local/include/ibex/ibex_ExprSubNodes.h" 1 3
# 15 "/usr/local/include/ibex/ibex_ExprSubNodes.h" 3
# 1 "/usr/local/include/ibex/ibex_NodeMap.h" 1 3
# 41 "/usr/local/include/ibex/ibex_NodeMap.h" 3
namespace ibex {

struct same_node {
 bool operator() (const ExprNode* node1, const ExprNode* node2) const {
  return node1->id == node2->id;
 }
};

struct hash_node {
 unsigned long operator()(const ExprNode* node) const {
   return std::tr1::hash<long>()(node->id);
 }
};





template <typename T>
class NodeMap {
public:




 bool found(const ExprNode& e) const {
  return map.find(&e)!=map.end();
 }






 void insert(const ExprNode& e, const T& value) {
  map.insert(std::pair<const ExprNode*,T>(&e,value));
 }





 void erase(const ExprNode& e) {
  map.erase(&e);
 }






 T& operator[](const ExprNode& e) {
  return map[&e];
 }





 const T& operator[](const ExprNode& e) const {
  return ((NodeMap<T>*) this)->map[&e];
 }




 void clean() {
  map.clear();
 }

 typename std::tr1::unordered_map<const ExprNode*,T,hash_node,same_node>::iterator begin() {
  return map.begin();
 }

 typename std::tr1::unordered_map<const ExprNode*,T,hash_node,same_node>::iterator end() {
  return map.end();
 }

 typename std::tr1::unordered_map<const ExprNode*,T,hash_node,same_node>::const_iterator begin() const {
  return map.begin();
 }

 typename std::tr1::unordered_map<const ExprNode*,T,hash_node,same_node>::const_iterator end() const {
  return map.end();
 }

protected:
 std::tr1::unordered_map<const ExprNode*,T,hash_node,same_node> map;
};

}
# 16 "/usr/local/include/ibex/ibex_ExprSubNodes.h" 2 3

namespace ibex {
# 33 "/usr/local/include/ibex/ibex_ExprSubNodes.h" 3
class ExprSubNodes {
public:



 ExprSubNodes(const ExprNode& e);






 ExprSubNodes(Array<const ExprNode> exprs);
# 55 "/usr/local/include/ibex/ibex_ExprSubNodes.h" 3
 ExprSubNodes(const Array<const ExprSymbol>& x, const ExprNode& y);




 ExprSubNodes();




 ~ExprSubNodes();
# 75 "/usr/local/include/ibex/ibex_ExprSubNodes.h" 3
 void init(const Array<const ExprSymbol>* x, const Array<const ExprNode>& y);




 int size() const;




 const ExprNode& operator[](int i) const;




 bool found(const ExprNode& e) const;

private:
 const ExprNode** tab;
 int _size;

 NodeMap<int> map;
};






inline const ExprNode& ExprSubNodes::operator[](int i) const {
 return *tab[i];
}

inline int ExprSubNodes::size() const {
 return _size;
}

inline bool ExprSubNodes::found(const ExprNode& e) const {
 return map.found(e);
}

}
# 19 "/usr/local/include/ibex/ibex_CompiledFunction.h" 2 3
# 1 "/usr/local/include/ibex/ibex_FwdAlgorithm.h" 1 3
# 17 "/usr/local/include/ibex/ibex_FwdAlgorithm.h" 3
namespace ibex {





class FwdAlgorithm {


 void index_fwd(const ExprIndex&, const ExprLabel& exprL, ExprLabel& result);


 void symbol_fwd(const ExprSymbol&, ExprLabel& result);


 void cst_fwd(const ExprConstant&, ExprLabel& result);



 void vector_fwd(const ExprVector&, const ExprLabel** compL, ExprLabel& result);


 void apply_fwd(const ExprApply&, ExprLabel** argL, ExprLabel& result);


 void chi_fwd(const ExprChi&, const ExprLabel& a, const ExprLabel& b, const ExprLabel& c, ExprLabel& result);



 void add_fwd(const ExprAdd&, const ExprLabel& leftL, const ExprLabel& rightL, ExprLabel& result);


 void add_V_fwd(const ExprAdd&, const ExprLabel& leftL, const ExprLabel& rightL, ExprLabel& result);


 void add_M_fwd(const ExprAdd&, const ExprLabel& leftL, const ExprLabel& rightL, ExprLabel& result);


 void mul_fwd(const ExprMul&, const ExprLabel& leftL, const ExprLabel& rightL, ExprLabel& result);


 void mul_SV_fwd(const ExprMul&, const ExprLabel& leftL, const ExprLabel& rightL, ExprLabel& result);


 void mul_SM_fwd(const ExprMul&, const ExprLabel& leftL, const ExprLabel& rightL, ExprLabel& result);


 void mul_VV_fwd(const ExprMul&, const ExprLabel& leftL, const ExprLabel& rightL, ExprLabel& result);


 void mul_MV_fwd(const ExprMul&, const ExprLabel& leftL, const ExprLabel& rightL, ExprLabel& result);


 void mul_VM_fwd(const ExprMul&, const ExprLabel& leftL, const ExprLabel& rightL, ExprLabel& result);


 void mul_MM_fwd(const ExprMul&, const ExprLabel& leftL, const ExprLabel& rightL, ExprLabel& result);


 void sub_fwd(const ExprSub&, const ExprLabel& leftL, const ExprLabel& rightL, ExprLabel& result);


 void sub_V_fwd(const ExprSub&, const ExprLabel& leftL, const ExprLabel& rightL, ExprLabel& result);


 void sub_M_fwd(const ExprSub&, const ExprLabel& leftL, const ExprLabel& rightL, ExprLabel& result);


 void div_fwd(const ExprDiv&, const ExprLabel& leftL, const ExprLabel& rightL, ExprLabel& result);


 void max_fwd(const ExprMax&, const ExprLabel& leftL, const ExprLabel& rightL, ExprLabel& result);


 void min_fwd(const ExprMin&, const ExprLabel& leftL, const ExprLabel& rightL, ExprLabel& result);


 void atan2_fwd(const ExprAtan2&, const ExprLabel& leftL, const ExprLabel& rightL, ExprLabel& result);



 void minus_fwd(const ExprMinus&, const ExprLabel& exprL, ExprLabel& result);


 void trans_V_fwd(const ExprTrans&, const ExprLabel& exprL, ExprLabel& result);


 void trans_M_fwd(const ExprTrans&, const ExprLabel& exprL, ExprLabel& result);


 void sign_fwd(const ExprSign&, const ExprLabel& exprL, ExprLabel& result);


 void abs_fwd(const ExprAbs&, const ExprLabel& exprL, ExprLabel& result);


 void power_fwd(const ExprPower&, const ExprLabel& exprL, ExprLabel& result);


 void sqr_fwd(const ExprSqr&, const ExprLabel& exprL, ExprLabel& result);


 void sqrt_fwd(const ExprSqrt&, const ExprLabel& exprL, ExprLabel& result);


 void exp_fwd(const ExprExp&, const ExprLabel& exprL, ExprLabel& result);


 void log_fwd(const ExprLog&, const ExprLabel& exprL, ExprLabel& result);


 void cos_fwd(const ExprCos&, const ExprLabel& exprL, ExprLabel& result);


 void sin_fwd(const ExprSin&, const ExprLabel& exprL, ExprLabel& result);


 void tan_fwd(const ExprTan&, const ExprLabel& exprL, ExprLabel& result);


 void cosh_fwd(const ExprCosh&, const ExprLabel& exprL, ExprLabel& result);


 void sinh_fwd(const ExprSinh&, const ExprLabel& exprL, ExprLabel& result);


 void tanh_fwd(const ExprTanh&, const ExprLabel& exprL, ExprLabel& result);


 void acos_fwd(const ExprAcos&, const ExprLabel& exprL, ExprLabel& result);


 void asin_fwd(const ExprAsin&, const ExprLabel& exprL, ExprLabel& result);


 void atan_fwd(const ExprAtan&, const ExprLabel& exprL, ExprLabel& result);


 void acosh_fwd(const ExprAcosh&, const ExprLabel& exprL, ExprLabel& result);


 void asinh_fwd(const ExprAsinh&, const ExprLabel& exprL, ExprLabel& result);


 void atanh_fwd(const ExprAtanh&, const ExprLabel& exprL, ExprLabel& result);
};


}
# 20 "/usr/local/include/ibex/ibex_CompiledFunction.h" 2 3
# 1 "/usr/local/include/ibex/ibex_BwdAlgorithm.h" 1 3
# 17 "/usr/local/include/ibex/ibex_BwdAlgorithm.h" 3
namespace ibex {





class BwdAlgorithm {

protected:

 void index_bwd(const ExprIndex&, ExprLabel& exprL, const ExprLabel& result);


 void vector_bwd(const ExprVector&, ExprLabel** compL, const ExprLabel& result);


 void symbol_bwd(const ExprSymbol&, const ExprLabel& result);


 void cst_bwd(const ExprConstant&, const ExprLabel& result);


 void apply_bwd(const ExprApply&, ExprLabel** argL, const ExprLabel& result);


 void chi_bwd(const ExprChi&, ExprLabel& a, ExprLabel& b, ExprLabel& c, const ExprLabel& result);



 void add_bwd(const ExprAdd&, ExprLabel& leftL, ExprLabel& rightL, const ExprLabel& result);


 void add_V_bwd(const ExprAdd&, ExprLabel& leftL, ExprLabel& rightL, const ExprLabel& result);


 void add_M_bwd(const ExprAdd&, ExprLabel& leftL, ExprLabel& rightL, const ExprLabel& result);


 void mul_bwd(const ExprMul&, ExprLabel& leftL, ExprLabel& rightL, const ExprLabel& result);


 void mul_SV_bwd(const ExprMul&, ExprLabel& leftL, ExprLabel& rightL, const ExprLabel& result);


 void mul_SM_bwd(const ExprMul&, ExprLabel& leftL, ExprLabel& rightL, const ExprLabel& result);


 void mul_VV_bwd(const ExprMul&, ExprLabel& leftL, ExprLabel& rightL, const ExprLabel& result);


 void mul_MV_bwd(const ExprMul&, ExprLabel& leftL, ExprLabel& rightL, const ExprLabel& result);


 void mul_VM_bwd(const ExprMul&, ExprLabel& leftL, ExprLabel& rightL, const ExprLabel& result);


 void mul_MM_bwd(const ExprMul&, ExprLabel& leftL, ExprLabel& rightL, const ExprLabel& result);


 void sub_bwd(const ExprSub&, ExprLabel& leftL, ExprLabel& rightL, const ExprLabel& result);


 void sub_V_bwd(const ExprSub&, ExprLabel& leftL, ExprLabel& rightL, const ExprLabel& result);


 void sub_M_bwd(const ExprSub&, ExprLabel& leftL, ExprLabel& rightL, const ExprLabel& result);


 void div_bwd(const ExprDiv&, ExprLabel& leftL, ExprLabel& rightL, const ExprLabel& result);


 void max_bwd(const ExprMax&, ExprLabel& leftL, ExprLabel& rightL, const ExprLabel& result);


 void min_bwd(const ExprMin&, ExprLabel& leftL, ExprLabel& rightL, const ExprLabel& result);


 void atan2_bwd(const ExprAtan2&, ExprLabel& leftL, ExprLabel& rightL, const ExprLabel& result);




 void minus_bwd(const ExprMinus&, ExprLabel& exprL, const ExprLabel& result);


 void trans_V_bwd(const ExprTrans&, ExprLabel& exprL, const ExprLabel& result);


 void trans_M_bwd(const ExprTrans&, ExprLabel& exprL, const ExprLabel& result);


 void sign_bwd(const ExprSign&, ExprLabel& exprL, const ExprLabel& result);


 void abs_bwd(const ExprAbs&, ExprLabel& exprL, const ExprLabel& result);


 void power_bwd(const ExprPower&, ExprLabel& exprL, const ExprLabel& result);


 void sqr_bwd(const ExprSqr&, ExprLabel& exprL, const ExprLabel& result);


 void sqrt_bwd(const ExprSqrt&, ExprLabel& exprL, const ExprLabel& result);


 void exp_bwd(const ExprExp&, ExprLabel& exprL, const ExprLabel& result);


 void log_bwd(const ExprLog&, ExprLabel& exprL, const ExprLabel& result);


 void cos_bwd(const ExprCos&, ExprLabel& exprL, const ExprLabel& result);


 void sin_bwd(const ExprSin&, ExprLabel& exprL, const ExprLabel& result);


 void tan_bwd(const ExprTan&, ExprLabel& exprL, const ExprLabel& result);


 void cosh_bwd(const ExprCosh&, ExprLabel& exprL, const ExprLabel& result);


 void sinh_bwd(const ExprSinh&, ExprLabel& exprL, const ExprLabel& result);


 void tanh_bwd(const ExprTanh&, ExprLabel& exprL, const ExprLabel& result);


 void acos_bwd(const ExprAcos&, ExprLabel& exprL, const ExprLabel& result);


 void asin_bwd(const ExprAsin&, ExprLabel& exprL, const ExprLabel& result);


 void atan_bwd(const ExprAtan&, ExprLabel& exprL, const ExprLabel& result);


 void acosh_bwd(const ExprAcosh&, ExprLabel& exprL, const ExprLabel& result);


 void asinh_bwd(const ExprAsinh&, ExprLabel& exprL, const ExprLabel& result);


 void atanh_bwd(const ExprAtanh&, ExprLabel& exprL, const ExprLabel& result);
};


}
# 21 "/usr/local/include/ibex/ibex_CompiledFunction.h" 2 3

namespace ibex {

class Function;






class CompiledFunction : public ExprVisitor {
public:

 CompiledFunction();





 void compile(const ExprNode& y);




 ~CompiledFunction();







 template<class V>
 ExprLabel& forward(const V& algo) const;





 template<class V>
 void backward(const V& algo) const;




 void print() const;

 friend class Function;

protected:
 typedef enum {
  IDX, VEC, SYM, CST, APPLY, CHI,
  ADD, MUL, SUB, DIV, MAX, MIN, ATAN2,
  MINUS, TRANS_V, TRANS_M, SIGN, ABS, POWER,
  SQR, SQRT, EXP, LOG,
  COS, SIN, TAN, ACOS, ASIN, ATAN,
  COSH, SINH, TANH, ACOSH, ASINH, ATANH,

  ADD_V, ADD_M, SUB_V, SUB_M,
  MUL_SV, MUL_SM, MUL_VV, MUL_MV, MUL_MM, MUL_VM
 } operation;

private:

 void visit(const ExprNAryOp& e, operation op);
 void visit(const ExprBinaryOp& b, operation op);
 void visit(const ExprUnaryOp& u, operation op);

 void visit(const ExprNode& e);
 void visit(const ExprIndex& i);
 void visit(const ExprLeaf& e);
 void visit(const ExprNAryOp& e);
 void visit(const ExprBinaryOp& b);
 void visit(const ExprUnaryOp& u);
 void visit(const ExprSymbol& v);
 void visit(const ExprConstant& c);
 void visit(const ExprVector& e);
 void visit(const ExprApply& e);
 void visit(const ExprChi& e);
 void visit(const ExprAdd& e);
 void visit(const ExprMul& e);
 void visit(const ExprSub& e);
 void visit(const ExprDiv& e);
 void visit(const ExprMax& e);
 void visit(const ExprMin& e);
 void visit(const ExprAtan2& e);
 void visit(const ExprMinus& e);
 void visit(const ExprTrans& e);
 void visit(const ExprSign& e);
 void visit(const ExprAbs& e);
 void visit(const ExprPower& e);
 void visit(const ExprSqr& e);
 void visit(const ExprSqrt& e);
 void visit(const ExprExp& e);
 void visit(const ExprLog& e);
 void visit(const ExprCos& e);
 void visit(const ExprSin& e);
 void visit(const ExprTan& e);
 void visit(const ExprCosh& e);
 void visit(const ExprSinh& e);
 void visit(const ExprTanh& e);
 void visit(const ExprAcos& e);
 void visit(const ExprAsin& e);
 void visit(const ExprAtan& e);
 void visit(const ExprAcosh& e);
 void visit(const ExprAsinh& e);
 void visit(const ExprAtanh& e);

protected:

 const char* op(operation o) const;

 friend std::ostream& operator<<(std::ostream&,const CompiledFunction&);

 int n;
 ExprSubNodes nodes;
 operation *code;
 int* nb_args;
 mutable ExprLabel*** args;

 mutable int ptr;
};

template<class V>
ExprLabel& CompiledFunction::forward(const V& algo) const {
 (static_cast <bool> (dynamic_cast<const FwdAlgorithm* >(&algo)!=__null) ? void (0) : __assert_fail ("dynamic_cast<const FwdAlgorithm* >(&algo)!=NULL", "/usr/local/include/ibex/ibex_CompiledFunction.h", 146, __extension__ __PRETTY_FUNCTION__));

 for (int i=n-1; i>=0; i--) {
  switch(code[i]) {
  case IDX: ((V&) algo).index_fwd((ExprIndex&) nodes[i], *args[i][1], *args[i][0]); break;
  case VEC: ((V&) algo).vector_fwd((ExprVector&) nodes[i], (const ExprLabel**) &(args[i][1]),*args[i][0]); break;
  case SYM: ((V&) algo).symbol_fwd((ExprSymbol&) nodes[i], *args[i][0]); break;
  case CST: ((V&) algo).cst_fwd ((ExprConstant&) nodes[i], *args[i][0]); break;
  case APPLY: ((V&) algo).apply_fwd((ExprApply&) nodes[i], &(args[i][1]),*args[i][0]); break;
  case CHI: ((V&) algo).chi_fwd ((ExprChi&) nodes[i], *args[i][1], *args[i][2], *args[i][3],*args[i][0]); break;
  case ADD: ((V&) algo).add_fwd ((ExprAdd&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case ADD_V: ((V&) algo).add_V_fwd ((ExprAdd&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case ADD_M: ((V&) algo).add_M_fwd ((ExprAdd&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MUL: ((V&) algo).mul_fwd ((ExprMul&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MUL_SV: ((V&) algo).mul_SV_fwd ((ExprMul&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MUL_SM: ((V&) algo).mul_SM_fwd ((ExprMul&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MUL_VV: ((V&) algo).mul_VV_fwd ((ExprMul&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MUL_MV: ((V&) algo).mul_MV_fwd ((ExprMul&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MUL_MM: ((V&) algo).mul_MM_fwd ((ExprMul&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MUL_VM: ((V&) algo).mul_VM_fwd ((ExprMul&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case SUB: ((V&) algo).sub_fwd ((ExprSub&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case SUB_V: ((V&) algo).sub_V_fwd ((ExprSub&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case SUB_M: ((V&) algo).sub_M_fwd ((ExprSub&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case DIV: ((V&) algo).div_fwd ((ExprDiv&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MAX: ((V&) algo).max_fwd ((ExprMax&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MIN: ((V&) algo).min_fwd ((ExprMin&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case ATAN2: ((V&) algo).atan2_fwd((ExprAtan2&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MINUS: ((V&) algo).minus_fwd((ExprMinus&) nodes[i], *args[i][1], *args[i][0]); break;
  case TRANS_V:((V&) algo).trans_V_fwd((ExprTrans&) nodes[i], *args[i][1], *args[i][0]); break;
  case TRANS_M:((V&) algo).trans_M_fwd((ExprTrans&) nodes[i], *args[i][1], *args[i][0]); break;
  case SIGN: ((V&) algo).sign_fwd ((ExprSign&) nodes[i], *args[i][1], *args[i][0]); break;
  case ABS: ((V&) algo).abs_fwd ((ExprAbs&) nodes[i], *args[i][1], *args[i][0]); break;
  case POWER: ((V&) algo).power_fwd((ExprPower&) nodes[i], *args[i][1], *args[i][0]); break;
  case SQR: ((V&) algo).sqr_fwd ((ExprSqr&) nodes[i], *args[i][1], *args[i][0]); break;
  case SQRT: ((V&) algo).sqrt_fwd ((ExprSqrt&) nodes[i], *args[i][1], *args[i][0]); break;
  case EXP: ((V&) algo).exp_fwd ((ExprExp&) nodes[i], *args[i][1], *args[i][0]); break;
  case LOG: ((V&) algo).log_fwd ((ExprLog&) nodes[i], *args[i][1], *args[i][0]); break;
  case COS: ((V&) algo).cos_fwd ((ExprCos&) nodes[i], *args[i][1], *args[i][0]); break;
  case SIN: ((V&) algo).sin_fwd ((ExprSin&) nodes[i], *args[i][1], *args[i][0]); break;
  case TAN: ((V&) algo).tan_fwd ((ExprTan&) nodes[i], *args[i][1], *args[i][0]); break;
  case COSH: ((V&) algo).cosh_fwd ((ExprCosh&) nodes[i], *args[i][1], *args[i][0]); break;
  case SINH: ((V&) algo).sinh_fwd ((ExprSinh&) nodes[i], *args[i][1], *args[i][0]); break;
  case TANH: ((V&) algo).tanh_fwd ((ExprTanh&) nodes[i], *args[i][1], *args[i][0]); break;
  case ACOS: ((V&) algo).acos_fwd ((ExprAcos&) nodes[i], *args[i][1], *args[i][0]); break;
  case ASIN: ((V&) algo).asin_fwd ((ExprAsin&) nodes[i], *args[i][1], *args[i][0]); break;
  case ATAN: ((V&) algo).atan_fwd ((ExprAtan&) nodes[i], *args[i][1], *args[i][0]); break;
  case ACOSH: ((V&) algo).acosh_fwd((ExprAcosh&) nodes[i], *args[i][1], *args[i][0]); break;
  case ASINH: ((V&) algo).asinh_fwd((ExprAsinh&) nodes[i], *args[i][1], *args[i][0]); break;
  case ATANH: ((V&) algo).atanh_fwd((ExprAtanh&) nodes[i], *args[i][1], *args[i][0]); break;
  default: (static_cast <bool> (false) ? void (0) : __assert_fail ("false", "/usr/local/include/ibex/ibex_CompiledFunction.h", 195, __extension__ __PRETTY_FUNCTION__));
  }
 }
 return *args[0][0];
}

template<class V>
void CompiledFunction::backward(const V& algo) const {

 (static_cast <bool> (dynamic_cast<const BwdAlgorithm* >(&algo)!=__null) ? void (0) : __assert_fail ("dynamic_cast<const BwdAlgorithm* >(&algo)!=NULL", "/usr/local/include/ibex/ibex_CompiledFunction.h", 204, __extension__ __PRETTY_FUNCTION__));

 for (int i=0; i<n; i++) {
  switch(code[i]) {
  case IDX: ((V&) algo).index_bwd((ExprIndex&) nodes[i], *args[i][1], *args[i][0]); break;
  case VEC: ((V&) algo).vector_bwd((ExprVector&) nodes[i], &(args[i][1]), *args[i][0]); break;
  case SYM: ((V&) algo).symbol_bwd((ExprSymbol&) nodes[i], *args[i][0]); break;
  case CST: ((V&) algo).cst_bwd ((ExprConstant&) nodes[i], *args[i][0]); break;
  case APPLY: ((V&) algo).apply_bwd ((ExprApply&) nodes[i], &(args[i][1]), *args[i][0]); break;
  case CHI: ((V&) algo).chi_bwd ((ExprChi&) nodes[i], *args[i][1], *args[i][2], *args[i][3], *args[i][0]); break;
  case ADD: ((V&) algo).add_bwd ((ExprAdd&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case ADD_V: ((V&) algo).add_V_bwd ((ExprAdd&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case ADD_M: ((V&) algo).add_M_bwd ((ExprAdd&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MUL: ((V&) algo).mul_bwd ((ExprMul&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MUL_SV: ((V&) algo).mul_SV_bwd ((ExprMul&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MUL_SM: ((V&) algo).mul_SM_bwd ((ExprMul&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MUL_VV: ((V&) algo).mul_VV_bwd ((ExprMul&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MUL_MV: ((V&) algo).mul_MV_bwd ((ExprMul&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MUL_MM: ((V&) algo).mul_MM_bwd ((ExprMul&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MUL_VM: ((V&) algo).mul_VM_bwd ((ExprMul&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case SUB: ((V&) algo).sub_bwd ((ExprSub&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case SUB_V: ((V&) algo).sub_V_bwd ((ExprSub&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case SUB_M: ((V&) algo).sub_M_bwd ((ExprSub&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case DIV: ((V&) algo).div_bwd ((ExprDiv&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MAX: ((V&) algo).max_bwd ((ExprMax&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MIN: ((V&) algo).min_bwd ((ExprMin&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case ATAN2: ((V&) algo).atan2_bwd((ExprAtan2&) nodes[i], *args[i][1], *args[i][2], *args[i][0]); break;
  case MINUS: ((V&) algo).minus_bwd((ExprMinus&) nodes[i], *args[i][1], *args[i][0]); break;
  case TRANS_V:((V&) algo).trans_V_bwd((ExprTrans&) nodes[i], *args[i][1], *args[i][0]); break;
  case TRANS_M:((V&) algo).trans_M_bwd((ExprTrans&) nodes[i], *args[i][1], *args[i][0]); break;
  case SIGN: ((V&) algo).sign_bwd ((ExprSign&) nodes[i], *args[i][1], *args[i][0]); break;
  case ABS: ((V&) algo).abs_bwd ((ExprAbs&) nodes[i], *args[i][1], *args[i][0]); break;
  case POWER: ((V&) algo).power_bwd((ExprPower&) nodes[i], *args[i][1], *args[i][0]); break;
  case SQR: ((V&) algo).sqr_bwd ((ExprSqr&) nodes[i], *args[i][1], *args[i][0]); break;
  case SQRT: ((V&) algo).sqrt_bwd ((ExprSqrt&) nodes[i], *args[i][1], *args[i][0]); break;
  case EXP: ((V&) algo).exp_bwd ((ExprExp&) nodes[i], *args[i][1], *args[i][0]); break;
  case LOG: ((V&) algo).log_bwd ((ExprLog&) nodes[i], *args[i][1], *args[i][0]); break;
  case COS: ((V&) algo).cos_bwd ((ExprCos&) nodes[i], *args[i][1], *args[i][0]); break;
  case SIN: ((V&) algo).sin_bwd ((ExprSin&) nodes[i], *args[i][1], *args[i][0]); break;
  case TAN: ((V&) algo).tan_bwd ((ExprTan&) nodes[i], *args[i][1], *args[i][0]); break;
  case COSH: ((V&) algo).cosh_bwd ((ExprCosh&) nodes[i], *args[i][1], *args[i][0]); break;
  case SINH: ((V&) algo).sinh_bwd ((ExprSinh&) nodes[i], *args[i][1], *args[i][0]); break;
  case TANH: ((V&) algo).tanh_bwd ((ExprTanh&) nodes[i], *args[i][1], *args[i][0]); break;
  case ACOS: ((V&) algo).acos_bwd ((ExprAcos&) nodes[i], *args[i][1], *args[i][0]); break;
  case ASIN: ((V&) algo).asin_bwd ((ExprAsin&) nodes[i], *args[i][1], *args[i][0]); break;
  case ATAN: ((V&) algo).atan_bwd ((ExprAtan&) nodes[i], *args[i][1], *args[i][0]); break;
  case ACOSH: ((V&) algo).acosh_bwd((ExprAcosh&) nodes[i], *args[i][1], *args[i][0]); break;
  case ASINH: ((V&) algo).asinh_bwd((ExprAsinh&) nodes[i], *args[i][1], *args[i][0]); break;
  case ATANH: ((V&) algo).atanh_bwd((ExprAtanh&) nodes[i], *args[i][1], *args[i][0]); break;
  default: (static_cast <bool> (false) ? void (0) : __assert_fail ("false", "/usr/local/include/ibex/ibex_CompiledFunction.h", 253, __extension__ __PRETTY_FUNCTION__));
  }
 }
}


}
# 17 "/usr/local/include/ibex/ibex_Function.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Decorator.h" 1 3
# 19 "/usr/local/include/ibex/ibex_Decorator.h" 3
namespace ibex {

class Function;
# 38 "/usr/local/include/ibex/ibex_Decorator.h" 3
class Decorator : public ExprVisitor {
public:



 void decorate(const Array<const ExprSymbol>& x, const ExprNode& y);




 virtual ~Decorator() { }

protected:

 virtual void visit(const ExprNode& n);

 virtual void visit(const ExprIndex& idx);

 virtual void visit(const ExprLeaf&);

 virtual void visit(const ExprNAryOp&);

 virtual void visit(const ExprUnaryOp&);

 virtual void visit(const ExprBinaryOp&);

 virtual void visit(const ExprConstant&);

 virtual void visit(const ExprSymbol&);


 NodeMap<bool> map;
};

}
# 18 "/usr/local/include/ibex/ibex_Function.h" 2 3





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 1 3 4
# 24 "/usr/local/include/ibex/ibex_Function.h" 2 3


namespace ibex {

class System;
class VarSet;
# 54 "/usr/local/include/ibex/ibex_Function.h" 3
class Function {

public:





 Function(const ExprSymbol& x, const ExprNode& y, const char* name=__null);




 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprNode& y, const char* name=__null);




 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprNode& y, const char* name=__null);





 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprNode& y, const char* name=__null);





 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprNode& y, const char* name=__null);





 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprNode& y, const char* name=__null);





 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprNode& y, const char* name=__null);





 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprNode& y, const char* name=__null);





 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprNode& y, const char* name=__null);





 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprNode& y, const char* name=__null);





 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprNode& y, const char* name=__null);





 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprNode& y, const char* name=__null);





 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprNode& y, const char* name=__null);





 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprNode& y, const char* name=__null);





 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprNode& y, const char* name=__null);





 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprSymbol& x16, const ExprNode& y, const char* name=__null);





 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprSymbol& x16, const ExprSymbol& x17, const ExprNode& y, const char* name=__null);





 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprSymbol& x16, const ExprSymbol& x17, const ExprSymbol& x18, const ExprNode& y, const char* name=__null);





 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprSymbol& x16, const ExprSymbol& x17, const ExprSymbol& x18, const ExprSymbol& x19, const ExprNode& y, const char* name=__null);





 Function(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprSymbol& x16, const ExprSymbol& x17, const ExprSymbol& x18, const ExprSymbol& x19, const ExprSymbol& x20, const ExprNode& y, const char* name=__null);




 Function(const Array<const ExprSymbol>& x, const ExprNode& y, const char* name=__null);
# 193 "/usr/local/include/ibex/ibex_Function.h" 3
 Function(const char* x1, const char* y);






 Function(const char* x1, const char* x2, const char* y);






 Function(const char* x1, const char* x2, const char* x3, const char* y);






 Function(const char* x1, const char* x2, const char* x3, const char* x4, const char* y);






 Function(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* y);






 Function(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* y);






 Function(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* y);






 Function(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* x8, const char* y);




 Function(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* x8, const char* x9, const char* y);




 Function(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* x8, const char* x9, const char* x10, const char* y);




 Function(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* x8, const char* x9, const char* x10, const char* x11, const char* y);




 Function(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* x8, const char* x9, const char* x10, const char* x11, const char* x12, const char* y);




 Function(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* x8, const char* x9, const char* x10, const char* x11, const char* x12, const char* x13, const char* y);




 Function(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* x8, const char* x9, const char* x10, const char* x11, const char* x12, const char* x13, const char* x14, const char* y);




 Function(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* x8, const char* x9, const char* x10, const char* x11, const char* x12, const char* x13, const char* x14, const char* x15, const char* y);




 Function(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* x8, const char* x9, const char* x10, const char* x11, const char* x12, const char* x13, const char* x14, const char* x15, const char* x16, const char* y);




 Function(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* x8, const char* x9, const char* x10, const char* x11, const char* x12, const char* x13, const char* x14, const char* x15, const char* x16, const char* x17, const char* y);




 Function(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* x8, const char* x9, const char* x10, const char* x11, const char* x12, const char* x13, const char* x14, const char* x15, const char* x16, const char* x17, const char* x18, const char* y);




 Function(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* x8, const char* x9, const char* x10, const char* x11, const char* x12, const char* x13, const char* x14, const char* x15, const char* x16, const char* x17, const char* x18, const char* x19, const char* y);




 Function(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* x8, const char* x9, const char* x10, const char* x11, const char* x12, const char* x13, const char* x14, const char* x15, const char* x16, const char* x17, const char* x18, const char* x19, const char* x20, const char* y);




 Function(const char* filename);




 Function(FILE* fd);
# 321 "/usr/local/include/ibex/ibex_Function.h" 3
 Function();




 std::string minibex() const;






 const ExprApply& operator()(const ExprNode& arg1) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3, const ExprNode& arg4) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3, const ExprNode& arg4, const ExprNode& arg5) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3, const ExprNode& arg4, const ExprNode& arg5, const ExprNode& arg6) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3, const ExprNode& arg4, const ExprNode& arg5, const ExprNode& arg6, const ExprNode& arg7) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3, const ExprNode& arg4, const ExprNode& arg5, const ExprNode& arg6, const ExprNode& arg7, const ExprNode& arg8) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3, const ExprNode& arg4, const ExprNode& arg5, const ExprNode& arg6, const ExprNode& arg7, const ExprNode& arg8, const ExprNode& arg9) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3, const ExprNode& arg4, const ExprNode& arg5, const ExprNode& arg6, const ExprNode& arg7, const ExprNode& arg8, const ExprNode& arg9, const ExprNode& arg10) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3, const ExprNode& arg4, const ExprNode& arg5, const ExprNode& arg6, const ExprNode& arg7, const ExprNode& arg8, const ExprNode& arg9, const ExprNode& arg10, const ExprNode& arg11) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3, const ExprNode& arg4, const ExprNode& arg5, const ExprNode& arg6, const ExprNode& arg7, const ExprNode& arg8, const ExprNode& arg9, const ExprNode& arg10, const ExprNode& arg11, const ExprNode& arg12) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3, const ExprNode& arg4, const ExprNode& arg5, const ExprNode& arg6, const ExprNode& arg7, const ExprNode& arg8, const ExprNode& arg9, const ExprNode& arg10, const ExprNode& arg11, const ExprNode& arg12, const ExprNode& arg13) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3, const ExprNode& arg4, const ExprNode& arg5, const ExprNode& arg6, const ExprNode& arg7, const ExprNode& arg8, const ExprNode& arg9, const ExprNode& arg10,const ExprNode& arg11, const ExprNode& arg12, const ExprNode& arg13, const ExprNode& arg14) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3, const ExprNode& arg4, const ExprNode& arg5, const ExprNode& arg6, const ExprNode& arg7, const ExprNode& arg8, const ExprNode& arg9, const ExprNode& arg10, const ExprNode& arg11, const ExprNode& arg12, const ExprNode& arg13, const ExprNode& arg14, const ExprNode& arg15) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3, const ExprNode& arg4, const ExprNode& arg5, const ExprNode& arg6, const ExprNode& arg7, const ExprNode& arg8, const ExprNode& arg9, const ExprNode& arg10, const ExprNode& arg11, const ExprNode& arg12, const ExprNode& arg13, const ExprNode& arg14, const ExprNode& arg15, const ExprNode& arg16) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3, const ExprNode& arg4, const ExprNode& arg5, const ExprNode& arg6, const ExprNode& arg7, const ExprNode& arg8, const ExprNode& arg9, const ExprNode& arg10, const ExprNode& arg11, const ExprNode& arg12, const ExprNode& arg13, const ExprNode& arg14, const ExprNode& arg15, const ExprNode& arg16, const ExprNode& arg17) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3, const ExprNode& arg4, const ExprNode& arg5, const ExprNode& arg6, const ExprNode& arg7, const ExprNode& arg8, const ExprNode& arg9, const ExprNode& arg10, const ExprNode& arg11, const ExprNode& arg12, const ExprNode& arg13, const ExprNode& arg14, const ExprNode& arg15, const ExprNode& arg16, const ExprNode& arg17, const ExprNode& arg18) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3, const ExprNode& arg4, const ExprNode& arg5, const ExprNode& arg6, const ExprNode& arg7, const ExprNode& arg8, const ExprNode& arg9, const ExprNode& arg10, const ExprNode& arg11, const ExprNode& arg12, const ExprNode& arg13, const ExprNode& arg14, const ExprNode& arg15, const ExprNode& arg16, const ExprNode& arg17, const ExprNode& arg18, const ExprNode& arg19) const;






 const ExprApply& operator()(const ExprNode& arg1, const ExprNode& arg2, const ExprNode& arg3, const ExprNode& arg4, const ExprNode& arg5, const ExprNode& arg6, const ExprNode& arg7, const ExprNode& arg8, const ExprNode& arg9, const ExprNode& arg10, const ExprNode& arg11, const ExprNode& arg12, const ExprNode& arg13, const ExprNode& arg14, const ExprNode& arg15, const ExprNode& arg16, const ExprNode& arg17, const ExprNode& arg18, const ExprNode& arg19, const ExprNode& arg20) const;




 const ExprApply& operator()(const std::vector<const ExprNode*>& arg) const;




 const ExprApply& operator()(const Array<const ExprNode>& arg) const;




 void init(const Array<const ExprSymbol>& x, const ExprNode& y, const char* name=__null);






 virtual ~Function();




 typedef enum { COPY, DIFF } copy_mode;
# 510 "/usr/local/include/ibex/ibex_Function.h" 3
 Function(const Function&, copy_mode mode=COPY);




 const Function& diff() const;
# 533 "/usr/local/include/ibex/ibex_Function.h" 3
 Function& operator[](int i);





 Function& operator[](int i) const;
# 548 "/usr/local/include/ibex/ibex_Function.h" 3
 int nb_arg() const;




 int nb_var() const;





 int image_dim() const;
# 568 "/usr/local/include/ibex/ibex_Function.h" 3
 bool used(int i) const;




 int nb_used_vars() const;






 int used_var(int i) const;




 int nb_nodes() const;




 const ExprNode& node(int i) const;




 const Array<const ExprSymbol>& args() const;






 const char* arg_name(int i) const;




 const ExprSymbol& arg(int i) const;






 const ExprNode& expr() const;
# 626 "/usr/local/include/ibex/ibex_Function.h" 3
 template<class V>
 ExprLabel& forward(const V& algo) const;
# 636 "/usr/local/include/ibex/ibex_Function.h" 3
 template<class V>
 void backward(const V& algo) const;
# 647 "/usr/local/include/ibex/ibex_Function.h" 3
 void write_arg_domains(const Array<Domain>& d, bool grad=false) const;







 void write_arg_domains(const Array<const Domain>& d, bool grad=false) const;







 void write_arg_domains(const IntervalVector& box, bool grad=false) const;




 void write_arg_af2_domains(const Array<Affine2Domain>& d) const;




 void write_arg_af2_domains(const Array<const Affine2Domain>& d) const;




 void write_arg_af2_domains(const IntervalVector& box) const;




 void write_arg_af2_domains(const Affine2Vector& box) const;




 void write_arg_af_lin_domains(const Array<AffineLinDomain>& d) const;




 void write_arg_af_lin_domains(const Array<const AffineLinDomain>& d) const;




 void write_arg_af_lin_domains(const IntervalVector& box) const;




 void write_arg_af_lin_domains(const AffineLinVector& box) const;







 void read_arg_domains(Array<Domain>& d, bool grad=false) const;







 void read_arg_domains(IntervalVector& box, bool grad=false) const;






 Interval eval(const IntervalVector& box) const;




 IntervalVector eval_vector(const IntervalVector& box) const;






 IntervalMatrix eval_matrix(const IntervalVector& x) const;
# 748 "/usr/local/include/ibex/ibex_Function.h" 3
 void gradient(const IntervalVector& x, IntervalVector& g) const;





 IntervalVector gradient(const IntervalVector& x) const;
# 763 "/usr/local/include/ibex/ibex_Function.h" 3
 void jacobian(const IntervalVector& x, IntervalMatrix& J) const;





 IntervalMatrix jacobian(const IntervalVector& x) const;







 void jacobian(const IntervalVector& full_box, IntervalMatrix& J, const VarSet& set) const;




 void hansen_matrix(const IntervalVector& x, IntervalMatrix& h) const;







 void hansen_matrix(const IntervalVector& full_box, IntervalMatrix& h, const VarSet& set) const;




 Domain& eval_domain(const IntervalVector& box) const;




 Domain& eval_affine2_domain(const IntervalVector& box) const;







 Domain& eval_affine2_domain(const IntervalVector& box, Affine2Domain& result) const;
 Domain& eval_affine2_domain(const IntervalVector& box, AffineLinDomain& result) const;




 Affine2Domain& eval_affine2_affinedomain(const Affine2Vector& box) const;
 AffineLinDomain& eval_affine2_affinedomain(const AffineLinVector& box) const;





 Interval eval_affine2(const IntervalVector& box) const;





 Affine2 eval_affine2(const Affine2Vector& box) const;
 AffineLin eval_affine2(const AffineLinVector& box) const;






 Interval eval_affine2(const IntervalVector& box, Affine2& result) const;
 Interval eval_affine2(const IntervalVector& box, AffineLin& result) const;






 IntervalVector eval_affine2_vector(const IntervalVector& box) const;
# 852 "/usr/local/include/ibex/ibex_Function.h" 3
 IntervalVector eval_affine2_vector(const IntervalVector& box, Affine2Vector& affine) const;
 IntervalVector eval_affine2_vector(const IntervalVector& box, AffineLinVector& affine) const;






 Affine2Vector eval_affine2_vector(const Affine2Vector& affine) const;
 AffineLinVector eval_affine2_vector(const AffineLinVector& affine) const;






 IntervalMatrix eval_affine2_matrix(const IntervalVector& box) const;
# 877 "/usr/local/include/ibex/ibex_Function.h" 3
 IntervalMatrix eval_affine2_matrix(const IntervalVector& box, Affine2Matrix& affine) const;
 IntervalMatrix eval_affine2_matrix(const IntervalVector& box, AffineLinMatrix& affine) const;






 Affine2Matrix eval_affine2_matrix(const Affine2Vector& box) const;
 AffineLinMatrix eval_affine2_matrix(const AffineLinVector& box) const;





 void backward(const Domain& y, IntervalVector& x) const;





 void backward(const Interval& y, IntervalVector& x) const;





 void backward(const IntervalVector& y, IntervalVector& x) const;





 void backward(const IntervalMatrix& y, IntervalVector& x) const;




 void ibwd(const Domain& y, IntervalVector& x) const;




 void ibwd(const Domain& y, IntervalVector& x, const IntervalVector& xin) const;




 void ibwd(const Interval& y, IntervalVector& x) const;




 void ibwd(const Interval& y, IntervalVector& x, const IntervalVector& xin) const;
# 939 "/usr/local/include/ibex/ibex_Function.h" 3
 void taylor_aff(const Affine2Vector& x, std::vector<Affine2Domain> & taylor_comps, int max_order, const ExprSymbol * t);



 CompiledFunction cf;






 const char* name;





 mutable Array<Domain> arg_domains;






 mutable Array<Domain> arg_deriv;





 mutable Array<Affine2Domain> arg_af2;
 mutable Array<AffineLinDomain> arg_af_lin;


protected:
 friend std::ostream& operator<<(std::ostream& os, const Function& f);




 void generate_comp();




 void generate_used_vars() const;




 void print(std::ostream& os) const;




 void print_expr(std::ostream& os) const;

private:
 friend class VarSet;






 bool all_args_scalar() const;

 void build_from_string(const Array<const char*>& x, const char* y, const char* name=__null);

 Function& operator=(const Function&);







 void decorate(const Array<const ExprSymbol>& x, const ExprNode& y) const;

 int _nb_var;

 int _image_dim;

 Array<const ExprSymbol> symbs;
 std::vector<bool> is_used;


 Function** comp;

 bool __all_symbols_scalar;

 int* symbol_index;



 Function* df;




 Function *zero;


 mutable int _nb_used_vars;


 mutable int* _used_var;
};



inline const Function& Function::diff() const {
 return *(df ? df : (((Function*&) df) = new Function(*this,DIFF)));
}

inline Function& Function::operator[](int i) {
 if (!comp) generate_comp();
 return *comp[i];
}

inline Function& Function::operator[](int i) const {
 if (!comp) ((Function&) *this).generate_comp();
 return *comp[i];
}

inline int Function::nb_arg() const {
 return symbs.size();
}

inline bool Function::used(int i) const {
 return is_used[i];
}

inline const Array<const ExprSymbol>& Function::args() const {
 return symbs;
}

inline const ExprSymbol& Function::arg(int i) const {
 return symbs[i];
}

inline const char* Function::arg_name(int i) const {
 return symbs[i].name;
}

inline int Function::nb_nodes() const {
 return cf.nodes.size();
}

inline const ExprNode& Function::node(int i) const {
 return cf.nodes[i];
}

inline const ExprNode& Function::expr() const {
 return cf.nodes[0];
}

template<class V>
inline ExprLabel& Function::forward(const V& algo) const {
 return cf.forward<V>(algo);
}

template<class V>
inline void Function::backward(const V& algo) const {
 cf.backward<V>(algo);
}

inline bool Function::all_args_scalar() const {
 return __all_symbols_scalar;
}

inline void Function::write_arg_domains(const Array<Domain>& d, bool grad) const {
 if (_nb_used_vars==-1) this->generate_used_vars();
 load(grad? arg_deriv : arg_domains,d,nb_used_vars(),_used_var);
}

inline void Function::write_arg_domains(const Array<const Domain>& d, bool grad) const {
 if (_nb_used_vars==-1) this->generate_used_vars();
 load(grad? arg_deriv : arg_domains,d,nb_used_vars(),_used_var);
}

inline void Function::write_arg_domains(const IntervalVector& box, bool grad) const {
 if (_nb_used_vars==-1) this->generate_used_vars();

 if (all_args_scalar()) {
  int j;
  if (grad)
   for (int i=0; i<nb_used_vars(); i++) {
    j=used_var(i);
    arg_deriv[j].i()=box[j];
   }
  else
   for (int i=0; i<nb_used_vars(); i++) {
    j=used_var(i);
    arg_domains[j].i()=box[j];
   }
 }
 else
  load(grad? arg_deriv : arg_domains, box, nb_used_vars(), _used_var);
}

inline void Function::write_arg_af2_domains(const Array<Affine2Domain>& d) const {
 if (_nb_used_vars==-1) this->generate_used_vars();
 load(arg_af2,d,nb_used_vars(),_used_var);
}

inline void Function::write_arg_af2_domains(const Array<const Affine2Domain>& d) const {
 if (_nb_used_vars==-1) this->generate_used_vars();
 load(arg_af2,d,nb_used_vars(),_used_var);
}

inline void Function::write_arg_af2_domains(const IntervalVector& box) const {
 if (_nb_used_vars==-1) this->generate_used_vars();
 if (all_args_scalar()) {
  int j;
  for (int i=0; i<nb_used_vars(); i++) {
   j=used_var(i);
   arg_af2[j].i()=Affine2(nb_var(),j+1,box[j]);
  }
 }
 else
  load(arg_af2,Affine2Vector(box,true),nb_used_vars(),_used_var);
}

inline void Function::write_arg_af2_domains(const Affine2Vector& box) const {
 if (_nb_used_vars==-1) this->generate_used_vars();
 if (all_args_scalar()) {
  int j;
  for (int i=0; i<nb_used_vars(); i++) {
   j=used_var(i);
   arg_af2[j].i()=box[j];
  }
 }
 else
  load(arg_af2,box,nb_used_vars(),_used_var);
}

inline void Function::write_arg_af_lin_domains(const Array<AffineLinDomain>& d) const {
 if (_nb_used_vars==-1) this->generate_used_vars();
 load(arg_af_lin,d,nb_used_vars(),_used_var);
}

inline void Function::write_arg_af_lin_domains(const Array<const AffineLinDomain>& d) const {
 if (_nb_used_vars==-1) this->generate_used_vars();
 load(arg_af_lin,d,nb_used_vars(),_used_var);
}

inline void Function::write_arg_af_lin_domains(const IntervalVector& box) const {
 if (_nb_used_vars==-1) this->generate_used_vars();
 if (all_args_scalar()) {
  int j;
  for (int i=0; i<nb_used_vars(); i++) {
   j=used_var(i);
   arg_af_lin[j].i()=AffineLin(nb_var(),j+1,box[j]);
  }
 }
 else
  load(arg_af_lin,AffineLinVector(box,true),nb_used_vars(),_used_var);
}

inline void Function::write_arg_af_lin_domains(const AffineLinVector& box) const {
 if (_nb_used_vars==-1) this->generate_used_vars();
 if (all_args_scalar()) {
  int j;
  for (int i=0; i<nb_used_vars(); i++) {
   j=used_var(i);
   arg_af_lin[j].i()=box[j];
  }
 }
 else
  load(arg_af_lin,box,nb_used_vars(),_used_var);
}



inline void Function::read_arg_domains(Array<Domain>& d, bool grad) const {
 if (_nb_used_vars==-1) this->generate_used_vars();
 load(d,grad? arg_deriv : arg_domains,nb_used_vars(),_used_var);
}

inline void Function::read_arg_domains(IntervalVector& box, bool grad) const {
 if (_nb_used_vars==-1) this->generate_used_vars();
 if (all_args_scalar()) {
  int j;
  if (grad)
   for (int i=0; i<nb_used_vars(); i++) {
    j=used_var(i);
    box[j]=arg_deriv[j].i();
   }
  else
   for (int i=0; i<nb_used_vars(); i++) {
    j=used_var(i);
    box[j]=arg_domains[j].i();
   }
 }
 else {
  load(box,grad? arg_deriv : arg_domains, nb_used_vars(), _used_var);
 }
}

inline Interval Function::eval(const IntervalVector& box) const {
 return eval_domain(box).i();
}

inline IntervalVector Function::eval_vector(const IntervalVector& box) const {
 return expr().dim.is_scalar() ? IntervalVector(1,eval_domain(box).i()) : eval_domain(box).v();
}

inline IntervalMatrix Function::eval_matrix(const IntervalVector& box) const {
 switch (expr().dim.type()) {
 case Dim::SCALAR :
  return IntervalMatrix(1,1,eval_domain(box).i());
 case Dim::ROW_VECTOR : {
  IntervalMatrix M(image_dim(),1);
  M.set_row(0,eval_domain(box).v());
  return M;
 }
 case Dim::COL_VECTOR : {
  IntervalMatrix M(1,image_dim());
  M.set_col(0,eval_domain(box).v());
  return M;
 }
 case Dim::MATRIX: return eval_domain(box).m();
 default : {
                throw std::logic_error("should not reach");
 }
 }
}

inline void Function::print_expr(std::ostream& os) const {
 os << expr();
}

inline void Function::backward(const Interval& y, IntervalVector& x) const {
 backward(Domain((Interval&) y),x);
}

inline void Function::backward(const IntervalVector& y, IntervalVector& x) const {
 (static_cast <bool> (expr().dim.is_vector()) ? void (0) : __assert_fail ("expr().dim.is_vector()", "/usr/local/include/ibex/ibex_Function.h", 1277, __extension__ __PRETTY_FUNCTION__));
 backward(Domain((IntervalVector&) y, expr().dim.type()==Dim::ROW_VECTOR),x);
}

inline void Function::backward(const IntervalMatrix& y, IntervalVector& x) const {
 backward(Domain((IntervalMatrix&) y),x);
}

inline void Function::ibwd(const Interval& y, IntervalVector& x) const {
 ibwd(Domain((Interval&) y),x);
}

inline void Function::ibwd(const Interval& y, IntervalVector& x, const IntervalVector& xin) const {
 ibwd(Domain((Interval&) y),x,xin);
}

inline int Function::nb_var() const {
 return _nb_var;
}

inline int Function::image_dim() const {
 return _image_dim;
}

inline IntervalVector Function::gradient(const IntervalVector& x) const {
 IntervalVector g(x.size());
 gradient(x,g);
 return g;
}

inline IntervalMatrix Function::jacobian(const IntervalVector& x) const {
 IntervalMatrix J(image_dim(),x.size());
 jacobian(x,J);
 return J;
}

inline int Function::nb_used_vars() const {
 if (_nb_used_vars==-1) generate_used_vars();
 return _nb_used_vars;
}

inline int Function::used_var(int i) const {
 if (_nb_used_vars==-1) generate_used_vars();
 return _used_var[i];
}


inline std::ostream& operator<<(std::ostream& os, const Function& f) {
 f.print(os);
 return os;
}



}
# 16 "/usr/local/include/ibex/ibex_NumConstraint.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CmpOp.h" 1 3
# 17 "/usr/local/include/ibex/ibex_CmpOp.h" 3
namespace ibex {







typedef enum { LT, LEQ, EQ, GEQ, GT } CmpOp;






CmpOp operator!(CmpOp op);




std::ostream& operator<<(std::ostream&, const CmpOp&);

}
# 17 "/usr/local/include/ibex/ibex_NumConstraint.h" 2 3
# 1 "/usr/local/include/ibex/ibex_ExprCtr.h" 1 3
# 17 "/usr/local/include/ibex/ibex_ExprCtr.h" 3
namespace ibex {
# 26 "/usr/local/include/ibex/ibex_ExprCtr.h" 3
class ExprCtr {
public:


 ExprCtr(const ExprNode& e, CmpOp op);


 const ExprNode& e;

 const CmpOp op;
};


std::ostream& operator<<(std::ostream&, const ExprCtr&);





inline ExprCtr::ExprCtr(const ExprNode& e, CmpOp op) : e(e), op(op) {

}

inline std::ostream& operator<<(std::ostream& os, const ExprCtr& c) {
 return os << c.e << c.op << "0";
}

inline const ExprCtr& ExprNode::operator=(const ExprNode& right) const {
  return *new ExprCtr(right.is_zero()? *this : *this-right, EQ);
}

inline const ExprCtr& ExprNode::operator=(const Interval& value) const {
  return *new ExprCtr(value.lb()==0 && value.ub()==0? *this : *this-value, EQ);
}

inline const ExprCtr& ExprNode::operator=(const IntervalVector& value) const {
  return *new ExprCtr(value.is_zero()? *this : *this-value, EQ);
}

inline const ExprCtr& ExprNode::operator=(const IntervalMatrix& value) const {
  return *new ExprCtr(value.is_zero()? *this : *this-value, EQ);
}

inline const ExprCtr& ExprNode::operator<=(const ExprNode& right) const {
  return *new ExprCtr(right.is_zero()? *this : *this-right, LEQ);
}

inline const ExprCtr& ExprNode::operator<=(const Interval& value) const {
  return *new ExprCtr(value.lb()==0 && value.ub()==0? *this : *this-value, LEQ);
}

inline const ExprCtr& ExprNode::operator>=(const ExprNode& right) const {
  return *new ExprCtr(right.is_zero()? *this : *this-right, GEQ);
}

inline const ExprCtr& ExprNode::operator>=(const Interval& value) const {
  return *new ExprCtr(value.lb()==0 && value.ub()==0? *this : *this-value, GEQ);
}

inline const ExprCtr& ExprNode::operator<(const ExprNode& right) const {
  return *new ExprCtr(right.is_zero()? *this : *this-right, LT);
}

inline const ExprCtr& ExprNode::operator<(const Interval& value) const {
  return *new ExprCtr(value.lb()==0 && value.ub()==0? *this : *this-value, LT);
}

inline const ExprCtr& ExprNode::operator>(const ExprNode& right) const {
  return *new ExprCtr(right.is_zero()? *this : *this-right, GT);
}

inline const ExprCtr& ExprNode::operator>(const Interval& value) const {
  return *new ExprCtr(value.lb()==0 && value.ub()==0? *this : *this-value, GT);
}


}
# 18 "/usr/local/include/ibex/ibex_NumConstraint.h" 2 3

namespace ibex {
# 30 "/usr/local/include/ibex/ibex_NumConstraint.h" 3
class NumConstraint {

public:




 NumConstraint(Function& f, CmpOp op=EQ, bool own_f=false);






 NumConstraint(const ExprSymbol& x1, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprSymbol& x16, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprSymbol& x16, const ExprSymbol& x17, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprSymbol& x16, const ExprSymbol& x17, const ExprSymbol& x18, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprSymbol& x16, const ExprSymbol& x17, const ExprSymbol& x18, const ExprSymbol& x19, const ExprCtr& c);




 NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprSymbol& x16, const ExprSymbol& x17, const ExprSymbol& x18, const ExprSymbol& x19, const ExprSymbol& x20, const ExprCtr& c);




 NumConstraint(const Array<const ExprSymbol>& x, const ExprCtr& c);
# 158 "/usr/local/include/ibex/ibex_NumConstraint.h" 3
 NumConstraint(const char* x1, const char* c);






 NumConstraint(const char* x1, const char* x2, const char* c);






 NumConstraint(const char* x1, const char* x2, const char* x3, const char* c);






 NumConstraint(const char* x1, const char* x2, const char* x3, const char* x4, const char* c);






 NumConstraint(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* c);






 NumConstraint(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* c);






 NumConstraint(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* c);






 NumConstraint(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* x8, const char* c);




 NumConstraint(const Array<const char*>& x, const char* c);




 ~NumConstraint();




 Function& f;




 const CmpOp op;
# 243 "/usr/local/include/ibex/ibex_NumConstraint.h" 3
 std::pair<const ExprNode*, const Interval*> is_thick_equality() const;

private:

 bool own_f;

 void build_from_string(const Array<const char*>& x, const char* c);
};

std::ostream& operator<<(std::ostream&, const NumConstraint&);






inline NumConstraint::NumConstraint(Function& f, CmpOp op, bool own_f) : f(f), op(op), own_f(own_f) { }

inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprCtr& c) : f(*new Function(x1,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprCtr& c): f(*new Function(x1,x2,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprCtr& c): f(*new Function(x1,x2,x3,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprCtr& c): f(*new Function(x1,x2,x3,x4,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprCtr& c): f(*new Function(x1,x2,x3,x4,x5,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprCtr& c): f(*new Function(x1,x2,x3,x4,x5,x6,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprCtr& c):
  f(*new Function(x1,x2,x3,x4,x5,x6,x7,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprCtr& c):
  f(*new Function(x1,x2,x3,x4,x5,x6,x7,x8,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprCtr& c):
  f(*new Function(x1,x2,x3,x4,x5,x6,x7,x8,x9,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprCtr& c):
  f(*new Function(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprCtr& c):
  f(*new Function(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprCtr& c):
  f(*new Function(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprCtr& c):
  f(*new Function(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprCtr& c):
  f(*new Function(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprCtr& c):
  f(*new Function(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprSymbol& x16, const ExprCtr& c):
  f(*new Function(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprSymbol& x16, const ExprSymbol& x17, const ExprCtr& c):
  f(*new Function(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprSymbol& x16, const ExprSymbol& x17, const ExprSymbol& x18, const ExprCtr& c):
  f(*new Function(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprSymbol& x16, const ExprSymbol& x17, const ExprSymbol& x18, const ExprSymbol& x19, const ExprCtr& c):
  f(*new Function(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,c.e)), op(c.op), own_f(true) { }
inline NumConstraint::NumConstraint(const ExprSymbol& x1, const ExprSymbol& x2, const ExprSymbol& x3, const ExprSymbol& x4, const ExprSymbol& x5, const ExprSymbol& x6, const ExprSymbol& x7, const ExprSymbol& x8, const ExprSymbol& x9, const ExprSymbol& x10, const ExprSymbol& x11, const ExprSymbol& x12, const ExprSymbol& x13, const ExprSymbol& x14, const ExprSymbol& x15, const ExprSymbol& x16, const ExprSymbol& x17, const ExprSymbol& x18, const ExprSymbol& x19, const ExprSymbol& x20, const ExprCtr& c):
  f(*new Function(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,c.e)), op(c.op), own_f(true) { }


inline NumConstraint::NumConstraint(const Array<const ExprSymbol>& x, const ExprCtr& c): f(*new Function(x,c.e)), op(c.op), own_f(true) { }

inline NumConstraint::~NumConstraint() {
 if (own_f) delete &f;
}

inline std::ostream& operator<<(std::ostream& os, const NumConstraint& c) {
 return os << c.f.expr() << c.op << "0";
}

}
# 19 "/usr/local/include/ibex/ibex_System.h" 2 3


namespace ibex {

namespace parser {
class MainGenerator;
}

class SystemFactory;
class AmplInterface;
# 45 "/usr/local/include/ibex/ibex_System.h" 3
class System {
public:




 System(const AmplInterface& ampl);




 System(const SystemFactory& factory);




 System(const char* filename);
# 73 "/usr/local/include/ibex/ibex_System.h" 3
 System(int n, const char* syntax);
# 98 "/usr/local/include/ibex/ibex_System.h" 3
 typedef enum { COPY, INEQ_ONLY, EQ_ONLY } copy_mode;
# 111 "/usr/local/include/ibex/ibex_System.h" 3
 System(const System& sys, copy_mode mode=COPY);




 System(const System& sys1, const System& sys2);


 virtual ~System();
# 129 "/usr/local/include/ibex/ibex_System.h" 3
 const int nb_var;


 const int nb_ctr;


 Array<Function> func;


 Function* goal;





 Function f;


 Array<const ExprSymbol> args;



 std::vector<int> sybs;



 std::vector<int> eprs;



 IntervalVector box;





 Array<NumConstraint> ctrs;

protected:

 System();


 void init(const SystemFactory&);

private:
 friend class parser::MainGenerator;
 friend class NumConstraint;

 void load(FILE* file);



 void init_f_from_ctrs();
};

std::ostream& operator<<(std::ostream&, const System&);

}
# 18 "/usr/local/include/ibex/ibex_SmearFunction.h" 2 3

namespace ibex {







class SmearFunction : public RoundRobin {
public:
# 42 "/usr/local/include/ibex/ibex_SmearFunction.h" 3
 SmearFunction(System& sys, double prec, double ratio=Bsc::default_ratio());
# 51 "/usr/local/include/ibex/ibex_SmearFunction.h" 3
 SmearFunction(System& sys, const Vector& prec, double ratio=Bsc::default_ratio());
# 60 "/usr/local/include/ibex/ibex_SmearFunction.h" 3
 virtual std::pair<IntervalVector,IntervalVector> bisect(const IntervalVector& box, int& last_var);
# 69 "/usr/local/include/ibex/ibex_SmearFunction.h" 3
 virtual int var_to_bisect(IntervalMatrix& J, const IntervalVector& box) const=0;

protected :
 int nbvars;
 System& sys;
};







class SmearMax : public SmearFunction {

public :
# 94 "/usr/local/include/ibex/ibex_SmearFunction.h" 3
 SmearMax (System& sys, double prec, double ratio=Bsc::default_ratio());
# 103 "/usr/local/include/ibex/ibex_SmearFunction.h" 3
 SmearMax (System& sys, const Vector& prec, double ratio=Bsc::default_ratio());
# 114 "/usr/local/include/ibex/ibex_SmearFunction.h" 3
 int var_to_bisect(IntervalMatrix& J, const IntervalVector& box) const;
};







class SmearSum : public SmearFunction {

public :
# 134 "/usr/local/include/ibex/ibex_SmearFunction.h" 3
 SmearSum (System& sys, double prec, double ratio=Bsc::default_ratio());
# 143 "/usr/local/include/ibex/ibex_SmearFunction.h" 3
 SmearSum (System& sys, const Vector& prec, double ratio=Bsc::default_ratio());
# 154 "/usr/local/include/ibex/ibex_SmearFunction.h" 3
 int var_to_bisect(IntervalMatrix& J, const IntervalVector& box ) const;
};
# 165 "/usr/local/include/ibex/ibex_SmearFunction.h" 3
class SmearSumRelative : public SmearFunction {

public :







 SmearSumRelative (System& sys, double prec, double ratio=Bsc::default_ratio());






 SmearSumRelative (System& sys, const Vector& prec, double ratio=Bsc::default_ratio());
# 193 "/usr/local/include/ibex/ibex_SmearFunction.h" 3
 int var_to_bisect(IntervalMatrix & J, const IntervalVector& box ) const;
};
# 203 "/usr/local/include/ibex/ibex_SmearFunction.h" 3
class SmearMaxRelative : public SmearFunction {

public :





 SmearMaxRelative (System& sys, double prec, double ratio=Bsc::default_ratio());





 SmearMaxRelative (System& sys, const Vector& prec, double ratio=Bsc::default_ratio());





 int var_to_bisect(IntervalMatrix & J, const IntervalVector& box ) const;
};





inline SmearFunction::SmearFunction(System& sys, double prec, double ratio) : RoundRobin(prec, ratio), sys(sys) {
 nbvars=sys.nb_var;
}

inline SmearFunction::SmearFunction(System& sys, const Vector& prec, double ratio) : RoundRobin(prec, ratio), sys(sys) {
 nbvars=sys.nb_var;
}

inline SmearMax::SmearMax(System& sys, double prec, double ratio) : SmearFunction(sys,prec,ratio) {

}

inline SmearMax::SmearMax(System& sys, const Vector& prec, double ratio) : SmearFunction(sys,prec,ratio) {

}

inline SmearSum::SmearSum(System& sys, double prec, double ratio) : SmearFunction(sys,prec,ratio) {

}

inline SmearSum::SmearSum(System& sys, const Vector& prec, double ratio) : SmearFunction(sys,prec,ratio) {

}

inline SmearSumRelative::SmearSumRelative(System& sys, double prec, double ratio) : SmearFunction(sys,prec,ratio) {

}

inline SmearSumRelative::SmearSumRelative(System& sys, const Vector& prec, double ratio) : SmearFunction(sys,prec,ratio) {

}

inline SmearMaxRelative::SmearMaxRelative(System& sys, double prec, double ratio) : SmearFunction(sys,prec,ratio) {

}

inline SmearMaxRelative::SmearMaxRelative(System& sys, const Vector& prec, double ratio) : SmearFunction(sys,prec,ratio) {

}


}
# 33 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_QInter.h" 1 3
# 17 "/usr/local/include/ibex/ibex_QInter.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-compare"

# 1 "/usr/local/include/ibex/ibex_KCoreGraph.h" 1 3



# 1 "/usr/local/include/ibex/ibex_IntStack.h" 1 3







# 1 "/usr/include/c++/7/cstring" 1 3
# 39 "/usr/include/c++/7/cstring" 3
       
# 40 "/usr/include/c++/7/cstring" 3
# 71 "/usr/include/c++/7/cstring" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 120 "/usr/include/c++/7/cstring" 3

}
# 9 "/usr/local/include/ibex/ibex_IntStack.h" 2 3

namespace ibex {

class IntStack {
public:

 int *list_;
 unsigned int capacity;
 unsigned int size;
 unsigned int *index_;
 unsigned int *start_;

 IntStack(const int lb, const int ub, bool full=true) {
  initialise(lb, ub, full);
 }

 IntStack(IntStack *cpy) {
  size = cpy->size;
  capacity = cpy->capacity;
  int lb = (int)(cpy->start_-cpy->index_);
  list_ = new int[capacity];
  start_ = new unsigned int[capacity];
  index_ = start_ - lb;

  memcpy(list_, cpy->list_, capacity*sizeof(int));
  memcpy(start_, cpy->start_, capacity*sizeof(unsigned int));
 }

 virtual ~IntStack()
    {
      delete [] list_;
      delete [] start_;
    }

 virtual void initialise(const int lb, const int ub, const bool full=true) {
  capacity = ub-lb+1;
  list_ = new int[capacity];
  start_ = new unsigned int[capacity];
  index_ = start_ - lb;

  for(int i=lb; i<=ub; ++i) {
   index_[i] = i-lb;
   list_[i-lb] = i;
  }

  size = (full ? capacity : 0);
 }

 void extend(const int new_elt) {
  int lb = (int)(start_-index_), new_lb = lb;
  int ub = capacity+lb-1, new_ub = ub;
  if(new_elt < lb) {
   new_lb = new_elt;
  } else if (new_elt > ub) {
   new_ub = new_elt;
  } else {
   return;
  }

  unsigned int new_capacity = new_ub-new_lb+1;
  if(new_capacity < capacity*2) new_capacity = capacity*2;
  if(new_lb < lb) {
   new_lb = ub-new_capacity+1;
  } else {
   new_ub = lb+new_capacity-1;
  }

  int *aux_list = list_;
  list_ = new int[new_capacity];
  memcpy(list_, aux_list, capacity*sizeof(int));
  delete [] aux_list;

  unsigned int *aux_start = start_;
  start_ = new unsigned int[new_capacity];
  memcpy(start_+(lb-new_lb), aux_start, capacity*sizeof(unsigned int));
  delete [] aux_start;

  index_ = start_ - new_lb;
  int k = 0;
  for(int i=new_lb; i<lb; ++i) {
   index_[i] = size+k;
   list_[capacity+k++] = i;
  }
  for(int i=ub+1; i<=new_ub; ++i) {
   index_[i] = size+k;
   list_[capacity+k++] = i;
  }

  capacity = new_capacity;
 }

 inline bool contain(const int elt) const {
  return index_[elt]<size;
 }

 inline bool empty()const {
  return !size;
 }

 inline int next(const int elt) const {
  unsigned int idx = index_[elt]+1;
  return (idx < size ? list_[idx] : elt);
 }

 inline void clear() {
  size = 0;
 }

 inline void remove(const int elt) {
  --size;
  index_[list_[size]] = index_[elt];
  list_[index_[elt]] = list_[size];
  list_[size] = elt;
  index_[elt] = size;
 }

 inline int head() {
  return *list_;
 }

 inline void add(const int elt) {
  index_[list_[size]] = index_[elt];
  list_[index_[elt]] = list_[size];
  list_[size] = elt;
  index_[elt] = size;
  ++size;
 }

 inline void revert_to(const int level) {
  size = level;
    }

};

};
# 5 "/usr/local/include/ibex/ibex_KCoreGraph.h" 2 3
# 1 "/usr/local/include/ibex/ibex_BitSet.h" 1 3




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 6 "/usr/local/include/ibex/ibex_BitSet.h" 2 3



namespace ibex {

template <class WORD_TYPE>
void showUint(WORD_TYPE n, std::ostream& os) {
WORD_TYPE mask=1;
while(mask){
if(mask & n) os<<1;
else os<<0;
mask = mask << 1;
}
}

const int getlast[256] = {-1, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7};

const int NOVAL = (int)((~(unsigned int)0)/2);
# 51 "/usr/local/include/ibex/ibex_BitSet.h" 3
template< class WORD_TYPE, class FLOAT_TYPE >
class Bitset
{
public:


 static const WORD_TYPE empt = 0;
 static const WORD_TYPE full = ~0;
 static const unsigned int EXP = (sizeof(empt) == 4 ? 5 : 6 );
 static const unsigned int size_word_bit = (1 << EXP);
 static const unsigned int size_word_byte = (size_word_bit >> 3);
 static const unsigned int CACHE = (size_word_bit - 1);
 static const unsigned int LASTCHAR = (size_word_bit - 8);
 static const unsigned int mantissa = (sizeof(empt) == 4 ? 23 : 52 );
 static const unsigned int float_offset = (sizeof(empt) == 4 ? (0x7f) : (0x3ff) );
 static const WORD_TYPE mask_first_char = 0xff;
 static const WORD_TYPE mask_last_char = (mask_first_char << ((size_word_bit) - 8));




 int pos_words;

 int neg_words;

 WORD_TYPE* table;



 static Bitset empty(int n) {
  return Bitset(0,n-1,empt);
 }

 static Bitset all(int n) {
  Bitset b(0,n-1,empt);
  b.fill(0,n-1);
  return b;
 }


 Bitset()
 {
  initialise();
 }

 Bitset(int sz)
 {
  if(sz>0) {
   initialise(sz,0);
  } else {
   initialise();
  }
 }
 void initialise()
 {
  pos_words = 0;
  neg_words = 0;
  table = __null;
 }
 Bitset(const int sz, const int* elt)
 {
  int lb = NOVAL;
  int ub = -NOVAL;
  for(int i=0; i<sz; ++i) {
   if(elt[i] > ub) ub = elt[i];
   if(elt[i] < lb) lb = elt[i];
  }
  initialise(lb,ub,empt);
  for(int i=0; i<sz; ++i)
   add( elt[i] );
 }
# 149 "/usr/local/include/ibex/ibex_BitSet.h" 3
 Bitset(const int lb, const int ub, const WORD_TYPE p)
 {
  initialise(lb,ub,p,__null);
 }
 inline int word_index(const int elt) const
 {
  return (elt >> EXP);
 }
 bool operator==(const Bitset<WORD_TYPE,FLOAT_TYPE>& s) {
  return equal(s);
 }
 bool operator!=(const Bitset<WORD_TYPE,FLOAT_TYPE>& s) {
  return !equal(s);
 }
 Bitset<WORD_TYPE,FLOAT_TYPE>& operator=(const Bitset<WORD_TYPE,FLOAT_TYPE>& q)
 {
  if(!table)
   clone(q);
  else
   copy(q);
  return *this;
 }
 void reinitialise(const int lb, const int ub, const WORD_TYPE p)
 {
  table += neg_words;
  delete [] table;
  initialise(lb, ub, p, __null);
 }
 void initialise(const int sz, const WORD_TYPE p)
 {
  pos_words = sz;
  neg_words = 0;
  if( sz>=0 ) {
   table = new WORD_TYPE[pos_words];
   for(int i=0; i<pos_words; ++i)
    table[i]=p;
  } else table = __null;
 }
 void initialise(const int lb, const int ub, const WORD_TYPE p, WORD_TYPE *pool=__null)
 {
  neg_words = (lb >> EXP);
  pos_words = (ub >> EXP)+1;
  if(pool==__null) table = new WORD_TYPE[pos_words-neg_words];
  else table = pool;
  for(int i=0; i<pos_words-neg_words; ++i)
   table[i]=p;
  table[pos_words-neg_words-1] &=
    (p >> (size_word_bit-1-(ub & CACHE)));
  table[0] &= (p << (lb & CACHE));
  table -= neg_words;
 }
 void initialise(const Bitset<WORD_TYPE,FLOAT_TYPE>& s)
 {
  pos_words = s.pos_words;
  neg_words = s.neg_words;
  table = new WORD_TYPE[pos_words-neg_words];
  table -= neg_words;
  for(int i=neg_words; i<pos_words; ++i)

   table[i] = s.table[i];
 }
 inline void declare(const int elt)
 {
  int i = (elt >> EXP);
  if( (i < neg_words) ||
    (i >= pos_words) )
  {
   extend(elt);
  }
  fast_add(elt);
 }
 void extend(const int elt)
 {
  int nval = (elt >> EXP);
  if( (nval < neg_words) ||
    (nval >= pos_words) )
  {
   int new_neg_words = neg_words;

   int new_pos_words = pos_words;

   bool need_to_extend = false;
   if(nval < new_neg_words) {
    new_neg_words = nval;
    need_to_extend = true;
   }
   if(nval >= new_pos_words) {
    new_pos_words = nval+1;
    need_to_extend = true;
   }
   if(need_to_extend) {
    WORD_TYPE *aux = table;
    table = new WORD_TYPE[new_pos_words-new_neg_words];
    table -= new_neg_words;
    memcpy(table+neg_words, aux+neg_words,
      (pos_words-neg_words)*sizeof(WORD_TYPE));
    if(new_neg_words < neg_words)
     std::fill(table+new_neg_words, table+neg_words, 0);
    if(new_pos_words > pos_words)
     std::fill(table+pos_words, table+new_pos_words, 0);
    aux += neg_words;
    delete [] aux;
    pos_words = new_pos_words;
    neg_words = new_neg_words;
   }
  }
 }
 Bitset(const Bitset<WORD_TYPE,FLOAT_TYPE>& s)
 {
  initialise();
  clone( s );
 }
 void clone(const Bitset<WORD_TYPE,FLOAT_TYPE>& s)
 {
  if(table) {
   table += neg_words;
   delete [] table;
  }
  neg_words = s.neg_words;
  pos_words = s.pos_words;
  table = new WORD_TYPE[pos_words-neg_words];
  memcpy(table, s.table+neg_words,
    size_word_byte*(pos_words-neg_words));
  table -= neg_words;
 }
 void point_to(Bitset<WORD_TYPE,FLOAT_TYPE>& s)
 {
  neg_words = s.neg_words;
  pos_words = s.pos_words;
  table = s.table;
 }
 void point_to(WORD_TYPE *t)
 {
  neg_words = 0;
  pos_words = 1;
  table = t;
 }
 void copy(const Bitset<WORD_TYPE,FLOAT_TYPE>& s)
 {
  int i = (pos_words > s.pos_words ? s.pos_words : pos_words);
  int k, j = (neg_words < s.neg_words ? s.neg_words : neg_words);
  for( k=neg_words; k<j; ++k)
   table[k] = empt;
  for( k=i; k<pos_words; ++k)
   table[k] = empt;
  if( i>j )
   memcpy(table+j,s.table+j,size_word_byte*(i-j));
 }
 virtual ~Bitset()
 {
  table += neg_words;
  delete [] table;
 }
 void destroy()
 {
  table += neg_words;
  neg_words = 0;
  delete [] table;
  table = __null;
 }
 bool is_built()
 {
  return (table != __null);
 }
 inline void swap(Bitset<WORD_TYPE,FLOAT_TYPE>& s)
 {
  WORD_TYPE *aux = s.table;
  s.table = table;
  table = aux;
 }
 void iterate_into_b(const int size, int *buffer) {
  int elt;
  int idx;
  int nval;
  union {FLOAT_TYPE f; WORD_TYPE i; } t;
  WORD_TYPE b;
  WORD_TYPE v;
  nval = 1;
  elt = buffer[0];
  idx = ((elt+1) >> EXP);
  v = (table[idx] & (full << ((elt+1) & CACHE)));
  while(nval < size) {

   while(!v) v = table[++idx];


   b = v & -v;

   t.f = (FLOAT_TYPE)b;

   elt = t.i >> mantissa;
   elt += idx * size_word_bit - float_offset;
   do {

    buffer[nval] = elt;
    ++nval;

    v ^= b;
    do {

     b <<= 1;
     ++elt;
    } while( b && !(v & b) );
   } while(v);
  }
 }
 void iterate_into(const int size, int *buffer) {
  int elt;
  int idx;
  int nval;
  union {FLOAT_TYPE f; WORD_TYPE i; } t;
  WORD_TYPE b;
  WORD_TYPE v;
  nval = 1;
  elt = buffer[0];
  idx = ((elt+1) >> EXP);
  v = (table[idx] & (full << ((elt+1) & CACHE)));
  elt = (idx * size_word_bit - float_offset);
  while(nval < size) {

   while(!v) {
    v = table[++idx];
    elt += size_word_bit;
   }

   do {

    b = v & -v;

    t.f = (FLOAT_TYPE)b;

    buffer[nval++] = (t.i >> mantissa)+elt;

    v ^= b;
   } while(v);
  }
 }
 inline int lsb_mantissa(const WORD_TYPE v) const {
  union {FLOAT_TYPE f; WORD_TYPE i; } t;
  WORD_TYPE b = v & -v;
  t.f = (FLOAT_TYPE)b;
  b = t.i >> mantissa;
  return b - float_offset;
 }
 inline int lsb_gcc(const WORD_TYPE v) const {
  return __builtin_ctz(v);
 }
 inline int msb_gcc(const WORD_TYPE v) const {
  return __builtin_clz(v);
 }
 inline int minimum_element(int idx, WORD_TYPE v, const int def=NOVAL) const
 {
  while(v == 0) {
   if( ++idx >= pos_words )
    return def;
   v = table[idx];
  }







  return __builtin_ctz(v)
    + (idx * size_word_bit);
 }



 inline int min() const
 {
  int idx = neg_words;
  WORD_TYPE v = table[idx];
  return minimum_element(idx,v);
 }



 inline int max() const
 {
  WORD_TYPE tab;
  int i=pos_words, j, k;
  while( i-- > neg_words )
   if( (tab = table[i]) ) {
    j = size_word_byte;
    while( j-- ) {
     if( (k = getlast[(tab & mask_last_char) >> LASTCHAR]) >= 0 )
      return ( (i<<EXP)+(j<<3)+k );
     tab = (tab << 8);
    }
   }
  return NOVAL;
 }
 inline void remove(const int elt)
 {
  int i = (elt >> EXP);
  if( (i >= neg_words) &&
    (i < pos_words) )
   table[i] &= (full ^ ((WORD_TYPE)1 << (elt & CACHE)));
 }
 inline void fast_remove(const int elt)
 {
  table[(elt >> EXP)] &= (full ^ ((WORD_TYPE)1 << (elt & CACHE)));
 }
 inline void word_remove(const int elt)
 {
  table[neg_words] &= (full ^ ((WORD_TYPE)1 << (elt & CACHE)));
 }
 inline int next(const int elt) const {
  int idx = ((elt+1) >> EXP);
  if(idx >= pos_words) return elt;
  WORD_TYPE v = (table[idx] & (full << ((elt+1) & CACHE)));
  while(v == 0) {
   if(++idx >= pos_words) return elt;
   v = table[idx];
  }
  return lsb_gcc(v) + (idx * size_word_bit);
 }
# 476 "/usr/local/include/ibex/ibex_BitSet.h" 3
 inline int prev(const int elt) const {
  WORD_TYPE tab;
  int i = ((elt-1) >> EXP);
  int SHFT = size_word_byte;
  if( i >= neg_words ) {
   int e = ((elt-1) & CACHE), k;
   int j = 1+(e >> 3);
   if( (tab = ((table[i] & (full >> (CACHE - e))) << ((SHFT-j) << 3))) )
    while( j-- ) {
     if( (k = getlast[(tab & mask_last_char) >> LASTCHAR]) >= 0 )
      return ( (i<<EXP)+(j<<3)+k );
     tab = (tab << 8);
    }
   while( i-- > neg_words )
    if( (tab = table[i]) ) {
     j = size_word_byte;
     while( j-- ) {
      if( (k = getlast[(tab & mask_last_char) >> LASTCHAR]) >= 0 )
       return ( (i<<EXP)+(j<<3)+k );
      tab = (tab << 8);
     }
    }
  }
  return elt;
 }
 inline void xor_to(const Bitset<WORD_TYPE,FLOAT_TYPE>& s)
 {
  int i = (pos_words > s.pos_words ? s.pos_words : pos_words);
  int j = (neg_words < s.neg_words ? s.neg_words : neg_words);
  while( i-- > j )
   s.table[i] ^= table[i];
 }
 inline void fast_xor_to(const Bitset<WORD_TYPE,FLOAT_TYPE>& s)
 {
  int i = pos_words;
  while( i-- > neg_words )
   s.table[i] ^= table[i];
 }
 inline void xor_with(const Bitset<WORD_TYPE,FLOAT_TYPE>& s)
 {
  int i = (pos_words > s.pos_words ? s.pos_words : pos_words);
  int j = (neg_words < s.neg_words ? s.neg_words : neg_words);
  while( i-- > j )
   table[i] ^= s.table[i];
 }
 inline void fast_xor_with(const Bitset<WORD_TYPE,FLOAT_TYPE>& s)
 {
  int i = pos_words;
  while( i-- > neg_words )
   table[i] ^= s.table[i];
 }
 inline void union_with(const Bitset<WORD_TYPE,FLOAT_TYPE>& s)
 {
  int i = (pos_words > s.pos_words ? s.pos_words : pos_words);
  int j = (neg_words < s.neg_words ? s.neg_words : neg_words);
  while( i-- > j )
   table[i] |= s.table[i];
 }
 inline void union_with(const int s)
 {
  if(pos_words>0 && neg_words<=0) table[0] |= s;
 }
 inline void union_to(Bitset<WORD_TYPE,FLOAT_TYPE>& s) const
 {
  s.union_with( *this );
 }
 inline void intersect_with(const Bitset<WORD_TYPE,FLOAT_TYPE>& s)
 {
  int i = (pos_words > s.pos_words ? s.pos_words : pos_words);
  int j = (neg_words < s.neg_words ? s.neg_words : neg_words);
  int k = pos_words;
  while( k > i ) {
   --k;
   table[k] = empt;
  }
  while( k > j ) {
   --k;
   table[k] &= s.table[k];
  }
  while( k-- > neg_words )
   table[k] = empt;
 }
 inline void intersect_with(const int s)
 {
  int i=pos_words;
  while(i-- > 1) table[i] = empt;
  i = 0;
  while(i-- > neg_words) table[i] = empt;
  if(pos_words>0 && neg_words<=0) table[0] &= s;
 }
 inline void intersect_to(Bitset<WORD_TYPE,FLOAT_TYPE>& s) const
 {
  s.intersect_with( *this );
 }
 inline void setminus_with (const Bitset<WORD_TYPE,FLOAT_TYPE>& s)
 {
  int i = (pos_words > s.pos_words ? s.pos_words : pos_words);
  int j = (neg_words < s.neg_words ? s.neg_words : neg_words);
  while( i-- > j )
   table[i] &= (~(s.table[i]));
 }
 inline void setminus_to (Bitset<WORD_TYPE,FLOAT_TYPE>& s) const
 {
  s.setminus_with( *this );
 }
 inline void xor_with(const Bitset<WORD_TYPE,FLOAT_TYPE>* s)
 {
  xor_with(*s);
 }
 inline void union_with (const Bitset<WORD_TYPE,FLOAT_TYPE>* s)
 {
  union_with(*s);
 }
 inline void intersect_with(const Bitset<WORD_TYPE,FLOAT_TYPE>* s)
 {
  intersect_with(*s);
 }
 inline void setminus_with (const Bitset<WORD_TYPE,FLOAT_TYPE>* s)
 {
  setminus_with(*s);
 }
 inline void union_to (Bitset<WORD_TYPE,FLOAT_TYPE>* s) const
 {
  s->union_with(*this);
 }
 inline void intersect_to(Bitset<WORD_TYPE,FLOAT_TYPE>* s) const
 {
  s->intersect_with(*this);
 }
 inline void setminus_to (Bitset<WORD_TYPE,FLOAT_TYPE>* s) const
 {
  s->setminus_with(*this);
 }
 inline bool equal(const Bitset<WORD_TYPE,FLOAT_TYPE>& s) const
 {
  int i=pos_words;
  int j=s.pos_words;
  int k;
  while( j > i )
   if( s.table[--j] ) return false;
  while( i > j )
   if( table[--i] ) return false;
  j=neg_words;
  k=s.neg_words;
  while( j > k )
   if( s.table[k++] ) return false;
  while( k > j )
   if( table[j++] ) return false;
  while( i-- > j )
   if( table[i] != s.table[i] ) return false;
  return true;
 }
 inline bool includes(const WORD_TYPE s) const
 {
  return( pos_words && neg_words<1 && (table[0] & s) == s );
 }
 inline bool included(const WORD_TYPE s) const
 {
  bool inc = true;
  int k = pos_words;
  if(neg_words>0 || pos_words<1) {
   while(k>neg_words && inc) inc = !(table[--k]);
  } else {
   while(k>1 && inc) inc = !(table[--k]);
   inc = ((table[--k] & s) == table[0]);
   while(k>neg_words && inc) inc = !(table[--k]);
  }
  return inc;
 }
 inline bool included(const Bitset<WORD_TYPE,FLOAT_TYPE>& s) const
 {
  int i = (pos_words > s.pos_words ? s.pos_words : pos_words);
  int j = (neg_words < s.neg_words ? s.neg_words : neg_words);
  int k = pos_words;
  while( k > i ) {
   --k;
   if( table[k] ) return false;
  }
  while( k > j ) {
   --k;
   if( table[k] != (table[k] & s.table[k]) ) return false;
  }
  while( k-- > neg_words )
   if( table[k] ) return false;
  return true;
 }
 inline bool includes(const Bitset<WORD_TYPE,FLOAT_TYPE>& s) const
 {
  int i = (pos_words > s.pos_words ? s.pos_words : pos_words);
  int j = (neg_words < s.neg_words ? s.neg_words : neg_words);
  int k = s.pos_words;
  while( k > i ) {
   --k;
   if( s.table[k] ) return false;
  }
  while( k > j ) {
   --k;
   if( s.table[k] != (table[k] & s.table[k]) ) {
    return false;
   }
  }
  while( k-- > s.neg_words ) {
   if( s.table[k] ) return false;
  }
  return true;
 }
 inline bool included(const Bitset<WORD_TYPE,FLOAT_TYPE>* s) const
 {
  return included( *s );
 }
 inline bool includes(const Bitset<WORD_TYPE,FLOAT_TYPE>* s) const
 {
  return includes( *s );
 }
 inline bool intersect(const Bitset<WORD_TYPE,FLOAT_TYPE>* s) const
 {
  return intersect( *s );
 }
 inline bool included(const int lb, const int ub) const
 {
  int neg_int = lb >> EXP;
  int pos_int = ub >> EXP;
  int k = pos_words;
  while( k > pos_int )
   if( table[--k] ) return false;
  k = neg_words;
  while( k < neg_int )
   if( table[k++] ) return false;
  if(neg_int == pos_int) {
   k = ((full << (lb & CACHE)) & (full >> (CACHE - (ub & CACHE))));
   return (k & table[neg_int]) == table[neg_int];
  } else {
   return ((((full << (lb & CACHE)) & table[neg_int]) == table[neg_int]) &&
     (((full >> (CACHE - (ub & CACHE))) & table[pos_int]) == table[pos_int]));
  }
 }
 inline bool includes(const int lb, const int ub) const
 {
  int neg_int = lb >> EXP;
  int pos_int = ub >> EXP;
  int k = pos_int-1;
  unsigned int u, l;
  while( k > neg_int ) {
   if( table[k] != full ) return false;
   --k;
  }
  if(neg_int == pos_int) {
   u = ((full << (lb & CACHE)) & (full >> (CACHE - (ub & CACHE))));
   return (u & table[neg_int]) == u;
  } else {
   u = (full >> (CACHE - (ub & CACHE)));
   l = (full << (lb & CACHE));
   return (((l & table[neg_int]) == l) &&
     ((u & table[pos_int]) == u));
  }
 }







 inline unsigned int word_size(WORD_TYPE v) const
 {
  return __builtin_popcount(v);






 }
 inline unsigned int size() const
 {
  int i=pos_words;
  unsigned int c=0;
  WORD_TYPE v;
  while( i-- > neg_words )
   if( (v = table[i]) )
    c += word_size(v);
  return c;
 }
 inline unsigned int word_size() const
 {
  unsigned int v, c=0;
  if( (v = table[neg_words]) )
   c = word_size(v);
  return c;
 }
 inline unsigned int size( const int i ) const
 {
  WORD_TYPE v;
  unsigned int c=0;
  if( (v = table[i]) )
   c = word_size(v);
  return c;
 }



 inline bool contain(const int elt)const
 {
  int i = (elt >> EXP);
  return ( (i >= neg_words) &&
    (i < pos_words) &&
    (table[i] & ((WORD_TYPE)1 << (elt & CACHE))) );
 }
 inline bool fast_contain(const int elt)const
 {
  return ( (table[(elt >> EXP)] & ((WORD_TYPE)1 << (elt & CACHE))) );
 }
 inline bool word_contain(const int elt)const
 {
  return ( (table[neg_words] & ((WORD_TYPE)1 << (elt & CACHE))) );
 }



 inline void add(const int elt)
 {
  int i = (elt >> EXP);
  if( (i >= neg_words) &&
    (i < pos_words) )
   table[i] |= ((WORD_TYPE)1 << (elt & CACHE));
 }
 inline void fast_add(const int elt)
 {
  table[(elt >> EXP)] |= ((WORD_TYPE)1 << (elt & CACHE));
 }
 inline void word_add(const int elt)
 {
  table[neg_words] |= ((WORD_TYPE)1 << (elt & CACHE));
 }



 inline void invert(const int elt)
 {
  int i = (elt >> EXP);
  if( (i >= neg_words) &&
    (i < pos_words) )
   table[i] ^= ((WORD_TYPE)1 << (elt & CACHE));
 }
 inline void fast_invert(const int elt)
 {
  table[(elt >> EXP)] ^= ((WORD_TYPE)1 << (elt & CACHE));
 }
 inline void word_invert(const int elt)
 {
  table[neg_words] ^= ((WORD_TYPE)1 << (elt & CACHE));
 }



 inline bool empty()const
 {
  int i = pos_words;
  while( i-- > neg_words )
   if(table[i]) return false;
  return true;
 }



 inline bool intersect(const Bitset<WORD_TYPE,FLOAT_TYPE>& s)const
 {
  int i = (pos_words > s.pos_words ? s.pos_words : pos_words);
  int j = (neg_words < s.neg_words ? s.neg_words : neg_words);
  while( i-- > j )
   if(table[i] & s.table[i]) return true;
  return false;
 }



 inline bool intersect(const int s) const
 {
  return(pos_words && neg_words<1 && (table[0]&s));
 }
 inline bool word_intersect(const Bitset<WORD_TYPE,FLOAT_TYPE>& s) const
 {
  return ( table[neg_words] & s.table[neg_words] ) ;
 }
 inline bool fast_intersect(const Bitset<WORD_TYPE,FLOAT_TYPE>& s, int& idx)const
 {
  if( table[idx] & s.table[idx] ) return true;
  if( pos_words > neg_words ) {
   idx = pos_words;
   while( idx > neg_words ) {
    --idx;
    if(table[idx] & s.table[idx]) return true;
   }
  }
  return false;
 }



 inline bool intersect(const int lb, const int ub)const
 {
  int i = (ub >> EXP);
  int j = (lb >> EXP);
  if( i < neg_words || j >= pos_words )
   return false;
  WORD_TYPE masked_lb = (full << (lb & CACHE));
  WORD_TYPE masked_ub = (full >> (CACHE - (ub & CACHE)));
  if( i == j ) {
   if( table[i] & (masked_lb & masked_ub) ) return true;
   else return false;
  }
  if( i >= pos_words )
   i = pos_words-1;
  else if( table[i--] & masked_ub ) return true;
  if( j < neg_words )
   j = neg_words;
  else if( table[j++] & masked_lb ) return true;
  while( i >= j )
   if(table[i--]) return true;
  return false;
 }





 inline void increment(const int v)
 {
  int step = (v >> EXP);
  int i = pos_words;
  int e = (v & CACHE);
  int f = size_word_bit-e;
  int j = neg_words+step;
  WORD_TYPE mask = ((WORD_TYPE)~0 << f);
  while( --i > j )
   table[i] = ((table[i-step] << e) | ((table[i-step-1] & mask) >> f));
  if( i >= neg_words+step ) table[i] = (table[i-step] << e);
  while( i > neg_words ) table[--i] = 0;
 }




 inline void decrement(const int v)
 {
  int step = (v >> EXP);
  int i = neg_words-1;
  int e = (v & CACHE);
  int f = size_word_bit-e;
  int j = pos_words-step-1;
  WORD_TYPE mask = ((WORD_TYPE)~0 >> e);
  while( ++i < j )
   table[i] = ((table[i+step] >> e) | ((table[i+step+1] & mask) << f));
  if( i < pos_words-step ) table[i] = (table[i+step] >> e);
  while( ++i < pos_words ) table[i] = 0;
 }



 inline void negate( Bitset<WORD_TYPE,FLOAT_TYPE>& s ) const
 {
  int i = (pos_words > -s.neg_words ? -s.neg_words : pos_words);
  int j = (neg_words < -s.pos_words ? -s.pos_words : neg_words);
  unsigned int a;
  WORD_TYPE mask, v, aux, rest = ( i < pos_words && (table[i] & 1) );
  while( i-- > j ) {
   aux = (table[i] & 1);
   v = (table[i] >> 1);
   mask = ~0;
   a = sizeof(v) * 8;
   while ((a >>= 1) > 0)
   {
    mask ^= (mask << a);
    v = ((v >> a) & mask) | ((v << a) & ~mask);
   }
   s.table[-i-1] = (v | rest);
   rest = aux;
  }
  if(rest)
   s.table[i+1] |= rest;
 }



 inline void fill()
 {
  int i = pos_words;
  while( i > neg_words )
   table[--i] = full;
 }
 inline void fill(const int lb, const int ub)
 {
  int i = (ub >> EXP);
  int j = (lb >> EXP);
  if( i >= neg_words || j < pos_words ) {
   WORD_TYPE masked_lb = (full << (lb & CACHE));
   WORD_TYPE masked_ub = (full >> (CACHE - (ub & CACHE)));
   if( i == j ) {
    table[i] |= (masked_lb & masked_ub);
   } else {
    if( i >= pos_words ) {
     i = pos_words-1;
    } else {
     table[i--] |= masked_ub;
    }
    if( j < neg_words ) {
     j = neg_words;
    } else {
     table[j++] |= masked_lb;
    }
    while( i >= j )
     table[i--] |= full;
   }
  }
 }



 inline void clear()
 {
  int i = pos_words;
  while( i > neg_words )
   table[--i] = empt;
 }



 inline void set_to( const int v )
 {
  int i, j = (v >> EXP);
  for(i=neg_words; i<j; ++i)
   table[i] = empt;
  table[j] = ((WORD_TYPE)1 << v);
  for(i=j+1; i<pos_words; ++i)
   table[i] = empt;
 }



 inline void flip()
 {
  int i = pos_words;
  while( i > neg_words )
   table[--i] ^= full;
 }



 inline void set_min(const int bound)
 {
  int ith_word=(bound >> EXP);
  if( ith_word >= neg_words ) {
   if( ith_word < pos_words ) {
    int i=ith_word;
    while( i-- > neg_words ) table[i]=0;
    table[ith_word] &= (full << (bound & CACHE));
   } else clear();
  }
 }



 inline void set_max(const int bound)
 {
  int ith_word=(bound >> EXP);
  if( ith_word < pos_words ) {
   if( ith_word >= neg_words ) {
    int i=pos_words;
    while( --i > ith_word ) table[i]=0;
    table[ith_word] &= (full >> (CACHE - (bound & CACHE)));
   } else clear();
  }
 }



 inline void remove_interval(const int lb, const int ub)
 {
  if( lb <= ub ) {
   int lb_word = lb >> EXP;
   int ub_word = ub >> EXP;
   lb_word = ( lb_word < neg_words ? neg_words : lb_word );
   ub_word = ( ub_word >= pos_words ? pos_words-1 : ub_word );
   WORD_TYPE masked_lb = 0;
   WORD_TYPE masked_ub = 0;
   if( lb_word >= neg_words )

    masked_lb = ((full/2) >> (CACHE - (lb & CACHE)));
   if( ub_word < pos_words )
    masked_ub = ((full-1) << (ub & CACHE));
   if( lb_word == ub_word ) {
    table[lb_word] &= (masked_lb | masked_ub);
   } else {
    table[lb_word] &= masked_lb;
    table[ub_word] &= masked_ub;
    while( --ub_word > lb_word )
     table[ub_word] = 0;
   }
  }
 }



 inline void add_interval(int lb, int ub)
 {
  if( lb <= ub ) {
   int lb_word = lb >> EXP;
   int ub_word = ub >> EXP;
   lb_word = ( lb_word < neg_words ? neg_words : lb_word );
   ub_word = ( ub_word >= pos_words ? pos_words-1 : ub_word );
   WORD_TYPE masked_lb = full;
   WORD_TYPE masked_ub = full;
   if( lb_word >= neg_words )

    masked_lb ^= ((full/2) >> (CACHE - (lb & CACHE)));
   if( ub_word < pos_words )

    masked_ub ^= ((full-1) << (ub & CACHE));
   if( lb_word == ub_word )
    table[lb_word] |= (masked_lb & masked_ub);
   else {
    table[lb_word] |= masked_lb;
    table[ub_word] |= masked_ub;
    while( --ub_word > lb_word )
     table[ub_word] = full;
   }
  }
 }
 inline bool operator[](const int i) const
 {
  return fast_contain(i);
 }
 std::ostream& display(std::ostream& os) const {
  os << "{";
  if( !empty() ) {
   int last = NOVAL, cur=min(), aft;
   bool flag=false;
   do{
    aft = next(cur);
    if(aft != cur+1 || cur != last+1) {
     if( flag )
      os << ",";
     os << (int)cur;
     flag = true;
    } else if(flag) {
     os << "..";
     flag = false;
    }
    last = cur;
    cur = aft;
   } while( cur != NOVAL && cur != last );
  }
  os << "}";
  return os;
 }
 void print_bits(std::ostream & os) const
 {
  os << "[";
  for(int i=neg_words; i<pos_words; ++i)
   showUint( table[i], os );
  os << "]";
 }
};

typedef Bitset< unsigned long long int, double > Bitset64;
typedef Bitset< unsigned int, float > Bitset32;







typedef Bitset32 BitSet;



}
# 6 "/usr/local/include/ibex/ibex_KCoreGraph.h" 2 3
# 1 "/usr/local/include/ibex/cliquer.h" 1 3





# 1 "/usr/local/include/ibex/set.h" 1 3
# 13 "/usr/local/include/ibex/set.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 14 "/usr/local/include/ibex/set.h" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 16 "/usr/local/include/ibex/set.h" 2 3

# 1 "/usr/local/include/ibex/misc.h" 1 3




# 1 "/usr/local/include/ibex/cliquerconf.h" 1 3
# 6 "/usr/local/include/ibex/misc.h" 2 3
# 15 "/usr/local/include/ibex/misc.h" 3
typedef int cliquer_boolean;
# 42 "/usr/local/include/ibex/misc.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 43 "/usr/local/include/ibex/misc.h" 2 3
# 18 "/usr/local/include/ibex/set.h" 2 3


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-compare"
# 40 "/usr/local/include/ibex/set.h" 3
typedef unsigned long int setelement;
# 50 "/usr/local/include/ibex/set.h" 3
typedef setelement * set_t;





static int set_bit_count[256] = {
 0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,
 1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
 1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
 2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
 1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
 2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
 2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
 3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
 1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
 2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
 2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
 3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
 2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
 3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
 3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
 4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8 };
# 149 "/usr/local/include/ibex/set.h" 3
__attribute__((unused))
static set_t set_new(int size) {
 int n;
 set_t s;

 if (!(size>0)) { fprintf(stderr,"cliquer file %s: line %d: assertion failed: " "(%s)\n","/usr/local/include/ibex/set.h",154,"size>0"); abort(); };

 n=(size/64 +1)+1;
 s=(set_t)calloc(n,sizeof(setelement));
 s[0]=size;

 return &(s[1]);
}






__attribute__((unused)) inline
static void set_free(set_t s) {
 if (!(s!=__null)) { fprintf(stderr,"cliquer file %s: line %d: assertion failed: " "(%s)\n","/usr/local/include/ibex/set.h",170,"s!=NULL"); abort(); };
 free(&(s[-1]));
}
# 182 "/usr/local/include/ibex/set.h" 3
__attribute__((unused)) inline
static set_t set_resize(set_t s, int size) {
 int n;

 if (!(size>0)) { fprintf(stderr,"cliquer file %s: line %d: assertion failed: " "(%s)\n","/usr/local/include/ibex/set.h",186,"size>0"); abort(); };

 n=(size/64 +1);
 s=((setelement *)realloc(s-1,(n+1)*sizeof(setelement)))+1;

 if (n>(((s)[-1]+64 -1)/64))
  memset(s+(((s)[-1]+64 -1)/64),0,
         (n-(((s)[-1]+64 -1)/64))*sizeof(setelement));
 if (size < ((s)[-1]))
  s[(size-1)/64] &= (((setelement)0xFFFFFFFFFFFFFFFF) >>
         (64 -size%64));
 s[-1]=size;

 return s;
}






__attribute__((unused)) inline
static int set_size(set_t s) {
 int count=0;
 setelement *c;

 for (c=s; c < s+(((s)[-1]+64 -1)/64); c++)
  count+=(set_bit_count[(*c)>>56] + set_bit_count[((*c)>>48)&0xFF] + set_bit_count[((*c)>>40)&0xFF] + set_bit_count[((*c)>>32)&0xFF] + set_bit_count[((*c)>>24)&0xFF] + set_bit_count[((*c)>>16)&0xFF] + set_bit_count[((*c)>>8)&0xFF] + set_bit_count[(*c)&0xFF]);
 return count;
}






__attribute__((unused)) inline
static set_t set_duplicate(set_t s) {
 set_t sn;

 sn=set_new(((s)[-1]));
 memcpy(sn,s,(((s)[-1]+64 -1)/64)*sizeof(setelement));
 return sn;
}
# 238 "/usr/local/include/ibex/set.h" 3
__attribute__((unused)) inline
static set_t set_copy(set_t dest,set_t src) {
 if (dest==__null)
  return set_duplicate(src);
 if (((dest)[-1])<((src)[-1])) {
  set_free(dest);
  return set_duplicate(src);
 }
 memcpy(dest,src,(((src)[-1]+64 -1)/64)*sizeof(setelement));
 memset(dest+(((src)[-1]+64 -1)/64),0,(((((dest)[-1]+64 -1)/64) -
           (((src)[-1]+64 -1)/64)) *
          sizeof(setelement)));
 return dest;
}






__attribute__((unused)) inline
static void set_empty(set_t s) {
 memset(s,0,(((s)[-1]+64 -1)/64)*sizeof(setelement));
 return;
}
# 276 "/usr/local/include/ibex/set.h" 3
__attribute__((unused)) inline
static set_t set_intersection(set_t res,set_t a,set_t b) {
 int i,max;

 if (res==__null) {
  res = set_new((((((a)[-1]))>(((b)[-1])))?(((a)[-1])):(((b)[-1]))));
 } else if (((res)[-1]) < (((((a)[-1]))>(((b)[-1])))?(((a)[-1])):(((b)[-1])))) {
  set_free(res);
  res = set_new((((((a)[-1]))>(((b)[-1])))?(((a)[-1])):(((b)[-1]))));
 } else {
  set_empty(res);
 }

 max=((((((a)[-1]+64 -1)/64))<((((b)[-1]+64 -1)/64)))?((((a)[-1]+64 -1)/64)):((((b)[-1]+64 -1)/64)));
 for (i=0; i<max; i++) {
  res[i]=((a[i])&(b[i]));
 }

 return res;
}
# 309 "/usr/local/include/ibex/set.h" 3
__attribute__((unused)) inline
static set_t set_union(set_t res,set_t a,set_t b) {
 int i,max;

 if (res==__null) {
  res = set_new((((((a)[-1]))>(((b)[-1])))?(((a)[-1])):(((b)[-1]))));
 } else if (((res)[-1]) < (((((a)[-1]))>(((b)[-1])))?(((a)[-1])):(((b)[-1])))) {
  set_free(res);
  res = set_new((((((a)[-1]))>(((b)[-1])))?(((a)[-1])):(((b)[-1]))));
 } else {
  set_empty(res);
 }

 max=((((((a)[-1]+64 -1)/64))>((((b)[-1]+64 -1)/64)))?((((a)[-1]+64 -1)/64)):((((b)[-1]+64 -1)/64)));
 for (i=0; i<max; i++) {
  res[i]=((a[i])|(b[i]));
 }

 return res;
}
# 344 "/usr/local/include/ibex/set.h" 3
__attribute__((unused)) inline
static int set_return_next(set_t s, int n) {
 if (n<0)
  n=0;
 else
  n++;
 if (n >= ((s)[-1]))
  return -1;

 while (n%64) {
  if ((((n)<((s)[-1]))?((((s)[(n)/64])&((setelement)1<<((n)%64)))):(0)))
   return n;
  n++;
  if (n >= ((s)[-1]))
   return -1;
 }

 while (s[n/64]==0) {
  n+=64;
  if (n >= ((s)[-1]))
   return -1;
 }
 while (!(((n)<((s)[-1]))?((((s)[(n)/64])&((setelement)1<<((n)%64)))):(0))) {
  n++;
  if (n >= ((s)[-1]))
   return -1;
 }
 return n;
}
# 381 "/usr/local/include/ibex/set.h" 3
__attribute__((unused))
static void set_print(set_t s) {
 int i;
 printf("size=%d(max %d)",set_size(s),(int)((s)[-1]));
 for (i=0; i<((s)[-1]); i++)
  if ((((i)<((s)[-1]))?((((s)[(i)/64])&((setelement)1<<((i)%64)))):(0)))
   printf(" %d",i);
 printf("\n");
 return;
}


#pragma GCC diagnostic pop
# 7 "/usr/local/include/ibex/cliquer.h" 2 3
# 1 "/usr/local/include/ibex/graph.h" 1 3
# 9 "/usr/local/include/ibex/graph.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-compare"

typedef struct _graph_t graph_t;
struct _graph_t {
 int n;
 set_t *edges;
 int *weights;
};
# 33 "/usr/local/include/ibex/graph.h" 3
extern graph_t *graph_new(int n);
extern void graph_free(graph_t *g);
extern void graph_resize(graph_t *g, int size);
extern void graph_crop(graph_t *g);

extern cliquer_boolean graph_weighted(graph_t *g);
extern int graph_edge_count(graph_t *g);

extern graph_t *graph_read_dimacs(FILE *fp);
extern graph_t *graph_read_dimacs_file(char *file);
extern cliquer_boolean graph_write_dimacs_ascii(graph_t *g, char *comment,FILE *fp);
extern cliquer_boolean graph_write_dimacs_ascii_file(graph_t *g,char *comment,
          char *file);
extern cliquer_boolean graph_write_dimacs_binary(graph_t *g, char *comment,FILE *fp);
extern cliquer_boolean graph_write_dimacs_binary_file(graph_t *g, char *comment,
           char *file);

extern void graph_print(graph_t *g);
extern cliquer_boolean graph_test(graph_t *g, FILE *output);
extern int graph_test_regular(graph_t *g);

__attribute__((unused)) inline
static int graph_subgraph_weight(graph_t *g,set_t s) {
 unsigned int i,j;
 int count=0;
 setelement e;

 for (i=0; i<(((s)[-1]+64 -1)/64); i++) {
  if (s[i]) {
   e=s[i];
   for (j=0; j<64; j++) {
    if (e&1)
     count+=g->weights[i*64 +j];
    e = e>>1;
   }
  }
 }
 return count;
}

__attribute__((unused)) inline
static int graph_vertex_degree(graph_t *g, int v) {
 return set_size(g->edges[v]);
}


#pragma GCC diagnostic pop
# 8 "/usr/local/include/ibex/cliquer.h" 2 3
# 1 "/usr/local/include/ibex/reorder.h" 1 3
# 9 "/usr/local/include/ibex/reorder.h" 3
extern void reorder_set(set_t s,int *order);
extern void reorder_graph(graph_t *g, int *order);
extern int *reorder_duplicate(int *order,int n);
extern void reorder_invert(int *order,int n);
extern void reorder_reverse(int *order,int n);
extern int *reorder_ident(int n);
extern cliquer_boolean reorder_is_bijection(int *order,int n);



extern int *reorder_by_greedy_coloring(graph_t *g, cliquer_boolean weighted);
extern int *reorder_by_weighted_greedy_coloring(graph_t *g, cliquer_boolean weighted);
extern int *reorder_by_unweighted_greedy_coloring(graph_t *g,cliquer_boolean weighted);
extern int *reorder_by_degree(graph_t *g, cliquer_boolean weighted);
extern int *reorder_by_random(graph_t *g, cliquer_boolean weighted);
extern int *reorder_by_ident(graph_t *g, cliquer_boolean weighted);
extern int *reorder_by_reverse(graph_t *g, cliquer_boolean weighted);
# 9 "/usr/local/include/ibex/cliquer.h" 2 3


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-compare"

typedef struct _clique_options clique_options;
struct _clique_options {
 int *(*reorder_function)(graph_t *, cliquer_boolean);
 int *reorder_map;


 cliquer_boolean (*time_function)(int,int,int,int,double,double,
     clique_options *);
 FILE *output;

 cliquer_boolean (*user_function)(set_t,graph_t *,clique_options *);
 void *user_data;
 set_t *clique_list;
 int clique_list_length;
};

extern clique_options *clique_default_options;


extern int clique_max_weight(graph_t *g,clique_options *opts);
extern set_t clique_find_single(graph_t *g,int min_weight,int max_weight,
    cliquer_boolean maximal, clique_options *opts);
extern int clique_find_all(graph_t *g, int req_weight, cliquer_boolean exact,
      cliquer_boolean maximal, clique_options *opts);



extern int clique_unweighted_max_weight(graph_t *g, clique_options *opts);
extern set_t clique_unweighted_find_single(graph_t *g,int min_size,
        int max_size,cliquer_boolean maximal,
        clique_options *opts);
extern int clique_unweighted_find_all(graph_t *g, int min_size, int max_size,
          cliquer_boolean maximal, clique_options *opts);


extern cliquer_boolean clique_print_time(int level, int i, int n, int max,
     double cputime, double realtime,
     clique_options *opts);
extern cliquer_boolean clique_print_time_always(int level, int i, int n, int max,
     double cputime, double realtime,
     clique_options *opts);
# 63 "/usr/local/include/ibex/cliquer.h" 3
#pragma GCC diagnostic pop
# 7 "/usr/local/include/ibex/ibex_KCoreGraph.h" 2 3



# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 44 "/usr/include/c++/7/cassert" 2 3
# 11 "/usr/local/include/ibex/ibex_KCoreGraph.h" 2 3
# 19 "/usr/local/include/ibex/ibex_KCoreGraph.h" 3
namespace ibex {

class KCoreGraph {
public:

 KCoreGraph(const int maxs, const int mind, bool full);
 KCoreGraph(KCoreGraph *cpy);


 ~KCoreGraph();


 inline int size() {return allid->size;};
 inline bool contain(const int elt) {return allid->contain(elt);};
 inline void add(const int elt) {allid->add(elt); add_vertex(elt);};
 inline void remove(const int elt) {allid->remove(elt); remove_vertex(elt); propagate();};
 inline int head() {return allid->head();};
 inline int next(const int elt) {return allid->next(elt);};
 inline bool empty() {return allid->empty();};


 inline void add_edge(const int elt1, const int elt2) {
  neighbourhoods.at(elt1)->add(elt2);
  neighbourhoods.at(elt2)->add(elt1);
 };
 inline bool is_edge(const int elt1, const int elt2) {
  return neighbourhoods.at(elt1)->contain(elt2);
 };


 void apply_coreness();



 int qcoloring(const std::pair<double, int>* boxes, int nboxes, int q);


 inline int maxsize() {return neighbourhoods.size();};
 graph_t *subgraph(IntStack *vset);
private:

 int k;


 IntStack *allid;


 std::vector<IntStack *> neighbourhoods;


 int* colors;
 BitSet *used;


 IntStack *tbr;


 void add_vertex(const int elt);
 void remove_vertex(const int elt);
 void propagate();
};

}
# 21 "/usr/local/include/ibex/ibex_QInter.h" 2 3



namespace ibex {
# 34 "/usr/local/include/ibex/ibex_QInter.h" 3
IntervalVector qinter(const Array<IntervalVector>& boxes, int q);





IntervalVector qinter_projf(const Array<IntervalVector>& _boxes, int q);





IntervalVector qinter_coref(const Array<IntervalVector>& _boxes, int q);





IntervalVector qinter2(const Array<IntervalVector>& _boxes, int q);





IntervalVector qinterex_cliquer(const std::vector<IntervalVector *>& boxes, const std::vector<int>& indices, int q, KCoreGraph* origin);

}



#pragma GCC diagnostic pop
# 34 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Ctc.h" 1 3
# 18 "/usr/local/include/ibex/ibex_Ctc.h" 3
# 1 "/usr/local/include/ibex/ibex_Set.h" 1 3
# 13 "/usr/local/include/ibex/ibex_Set.h" 3
# 1 "/usr/local/include/ibex/ibex_SetNode.h" 1 3
# 14 "/usr/local/include/ibex/ibex_SetNode.h" 3
# 1 "/usr/local/include/ibex/ibex_BoolInterval.h" 1 3
# 15 "/usr/local/include/ibex/ibex_BoolInterval.h" 3
namespace ibex {
# 27 "/usr/local/include/ibex/ibex_BoolInterval.h" 3
typedef enum { EMPTY_BOOL, NO, YES, MAYBE } BoolInterval;




BoolInterval& operator&=(BoolInterval& x, const BoolInterval& y);




BoolInterval& operator|=(BoolInterval& x, const BoolInterval& y);




BoolInterval operator!(const BoolInterval& x);






BoolInterval operator&&(const BoolInterval&, const BoolInterval&);






BoolInterval operator||(const BoolInterval&, const BoolInterval&);




BoolInterval operator^(const BoolInterval&, const BoolInterval&);






BoolInterval operator&(const BoolInterval&, const BoolInterval&);






BoolInterval operator|(const BoolInterval&, const BoolInterval&);
# 92 "/usr/local/include/ibex/ibex_BoolInterval.h" 3
BoolInterval restrict(const BoolInterval& x, const BoolInterval& y);




std::ostream& operator<< (std::ostream& os, const BoolInterval&);





inline BoolInterval& operator&=(BoolInterval& x, const BoolInterval& y) {
 return (x = (x & y));
}

inline BoolInterval& operator|=(BoolInterval& x, const BoolInterval& y) {
 return (x = (x | y));
}

inline BoolInterval operator!(const BoolInterval& x) {
 if (x == YES) return NO;
 if (x == NO) return YES;
 return x;
}

inline BoolInterval operator&&(const BoolInterval& x, const BoolInterval& y) {
 if ((x == EMPTY_BOOL) || (y == EMPTY_BOOL)) return EMPTY_BOOL;
 if ((x == NO) || (y == NO)) return NO;
 if ((x == MAYBE) || (y == MAYBE)) return MAYBE;
 return YES;
}

inline BoolInterval operator||(const BoolInterval& x, const BoolInterval& y) {
 if ((x == EMPTY_BOOL) || (y == EMPTY_BOOL)) return EMPTY_BOOL;
 if ((x == YES) || (y == YES)) return YES;
 if ((x == MAYBE) || (y == MAYBE)) return MAYBE;
 return NO;
}

inline BoolInterval operator^(const BoolInterval& x, const BoolInterval& y) {
 if (x == EMPTY_BOOL) return EMPTY_BOOL;
 if (y == EMPTY_BOOL) return EMPTY_BOOL;
 if (x == MAYBE) return MAYBE;
 if (y == MAYBE) return MAYBE;
 if (x == y) return NO;
 return YES;
}

inline BoolInterval operator&(const BoolInterval& x, const BoolInterval& y) {
 if (x == y) return x;
 if (x == MAYBE) return y;
 if (y == MAYBE) return x;
 return EMPTY_BOOL;
}

inline BoolInterval operator|(const BoolInterval& x, const BoolInterval& y) {
 if (x == EMPTY_BOOL) return y;
  if (y == EMPTY_BOOL) return x;
 if (x == y) return x;
 return MAYBE;
}
# 180 "/usr/local/include/ibex/ibex_BoolInterval.h" 3
inline BoolInterval restrict(const BoolInterval& x, const BoolInterval& y) {
 return x && (!y);
}

inline std::ostream& operator<<(std::ostream& os, const BoolInterval& x) {
 if (x==YES) os << "  YES";
 if (x==NO) os << "   NO";
 if (x==MAYBE) os << "MAYBE";
 return os;
}

}
# 15 "/usr/local/include/ibex/ibex_SetNode.h" 2 3

# 1 "/usr/local/include/ibex/ibex_SetVisitor.h" 1 3
# 13 "/usr/local/include/ibex/ibex_SetVisitor.h" 3
namespace ibex {





class SetVisitor {
public:



 virtual ~SetVisitor() { }






 virtual void visit_node(const IntervalVector& box) { }




 virtual void visit_leaf(const IntervalVector& box, BoolInterval status)=0;

};

}
# 17 "/usr/local/include/ibex/ibex_SetNode.h" 2 3

namespace ibex {

class Sep;
class SetBisect;




class SetNode {

public:
 SetNode();




 SetBisect* father;




 typedef void (*leaf_func) (const IntervalVector&, BoolInterval);




 virtual ~SetNode();




 virtual bool is_leaf() const=0;




 virtual SetNode* inter(bool iset, const IntervalVector& nodebox, Sep& sep, double eps)=0;






 SetNode* inter(bool iset, const IntervalVector& nodebox, const SetNode* other, const IntervalVector& otherbox);
# 70 "/usr/local/include/ibex/ibex_SetNode.h" 3
 virtual SetNode* inter(bool iset, const IntervalVector& nodebox, const IntervalVector& x, BoolInterval x_status)=0;






 SetNode* union_(const IntervalVector& nodebox, const SetNode* other, const IntervalVector& otherbox);







 virtual SetNode* union_(const IntervalVector& nodebox, const IntervalVector& x, BoolInterval x_status)=0;




 virtual void visit(const IntervalVector& nodebox, SetVisitor& visitor) const=0;




 virtual void print(std::ostream& os, const IntervalVector& nodebox, int shift) const=0;




 virtual BoolInterval is_superset(const IntervalVector& nodebox, const IntervalVector& box) const=0;
# 112 "/usr/local/include/ibex/ibex_SetNode.h" 3
 virtual SetNode* contract_no_diff(BoolInterval status, const IntervalVector& nodebox, const IntervalVector& box)=0;

};

}
# 14 "/usr/local/include/ibex/ibex_Set.h" 2 3
# 1 "/usr/local/include/ibex/ibex_SetLeaf.h" 1 3
# 15 "/usr/local/include/ibex/ibex_SetLeaf.h" 3
namespace ibex {






class SetLeaf : public SetNode {

public:



 SetLeaf(BoolInterval status);




 virtual ~SetLeaf();


 virtual bool is_leaf() const;


 virtual SetNode* inter(bool iset, const IntervalVector& nodebox, const IntervalVector& x, BoolInterval x_status);


 virtual SetNode* inter(bool iset, const IntervalVector& nodebox, Sep& sep, double eps);


 virtual SetNode* union_(const IntervalVector& nodebox, const IntervalVector& x, BoolInterval x_status);


 virtual BoolInterval is_superset(const IntervalVector& nodebox, const IntervalVector& box) const;


 virtual SetNode* contract_no_diff(BoolInterval status, const IntervalVector& nodebox, const IntervalVector& box);


 virtual void visit(const IntervalVector& nodebox, SetVisitor& visitor) const;


 virtual void print(std::ostream& os, const IntervalVector& nodebox, int shift) const;




 BoolInterval status;






 void replace_with(SetNode* node);

private:

 SetLeaf(const SetLeaf&);
};
# 87 "/usr/local/include/ibex/ibex_SetLeaf.h" 3
std::pair<SetNode*,SetLeaf*> diff(const IntervalVector& x, const IntervalVector& y, BoolInterval x_status, BoolInterval y_status, double eps);


}
# 15 "/usr/local/include/ibex/ibex_Set.h" 2 3




namespace ibex {
# 30 "/usr/local/include/ibex/ibex_Set.h" 3
class Set {
public:




 Set(int n, BoolInterval status=YES);




 Set(const IntervalVector& box, BoolInterval status=YES);






 Set(const char* filename);




 Set(Function& f, CmpOp op, double eps);




 Set(NumConstraint& ctr, double eps);




 Set(const System& sys, double eps);




 ~Set();
# 79 "/usr/local/include/ibex/ibex_Set.h" 3
 Set& operator&=(const Set& set);
# 89 "/usr/local/include/ibex/ibex_Set.h" 3
 Set& operator|=(const Set& set);






 bool is_empty() const;




 void save(const char* filename);




 void visit(SetVisitor& visitor) const;






 double dist(const Vector& pt, bool inside) const;
# 125 "/usr/local/include/ibex/ibex_Set.h" 3
 std::vector<std::vector<SetLeaf*> > connected_components();




 BoolInterval is_superset(const IntervalVector& box) const;




 IntervalVector node_box(const SetNode* node) const;

protected:
 friend class Sep;




 static IntervalVector inflate_one_float(const IntervalVector& box);




 void load(const char* filename);

 friend std::ostream& operator<<(std::ostream& os, const Set& set);






 SetNode* root;




 IntervalVector Rn;
};

std::ostream& operator<<(std::ostream& os, const Set& set);

}
# 19 "/usr/local/include/ibex/ibex_Ctc.h" 2 3

namespace ibex {
# 30 "/usr/local/include/ibex/ibex_Ctc.h" 3
class Ctc {

public:





 Ctc(int nb_var);




 Ctc(const Array<Ctc>& l);




 virtual void contract(IntervalVector& box)=0;







 void contract(Set& set, double eps);




 virtual ~Ctc();
# 73 "/usr/local/include/ibex/ibex_Ctc.h" 3
 void contract(IntervalVector& box, const BitSet& impact);







 void contract(IntervalVector& box, const BitSet& impact, BitSet& flags);




 const int nb_var;




 BitSet* input;




 BitSet* output;
# 115 "/usr/local/include/ibex/ibex_Ctc.h" 3
 enum {FIXPOINT, INACTIVE, NB_OUTPUT_FLAGS};


protected:







 const BitSet* impact();




 void set_flag(unsigned int);

protected:



 static bool check_nb_var_ctc_list (const Array<Ctc>& l);

private:
 const BitSet* _impact;
 BitSet* _output_flags;


};
# 153 "/usr/local/include/ibex/ibex_Ctc.h" 3
inline Ctc::Ctc(int n) : nb_var(n), input(__null), output(__null), _impact(__null), _output_flags(__null) { }

inline Ctc::Ctc(const Array<Ctc>& l) : nb_var(l[0].nb_var), input(__null), output(__null), _impact(__null), _output_flags(__null) { }

inline Ctc::~Ctc() { }

inline const BitSet* Ctc::impact() {
 return _impact;
}

inline void Ctc::set_flag(unsigned int f) {
 (static_cast <bool> (f<NB_OUTPUT_FLAGS) ? void (0) : __assert_fail ("f<NB_OUTPUT_FLAGS", "/usr/local/include/ibex/ibex_Ctc.h", 164, __extension__ __PRETTY_FUNCTION__));
 if (_output_flags) _output_flags->add(f);
}


}
# 35 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Ctc3BCid.h" 1 3
# 18 "/usr/local/include/ibex/ibex_Ctc3BCid.h" 3
namespace ibex {
# 28 "/usr/local/include/ibex/ibex_Ctc3BCid.h" 3
class Ctc3BCid : public Ctc {
 public:
# 93 "/usr/local/include/ibex/ibex_Ctc3BCid.h" 3
 Ctc3BCid(const BitSet& cid_vars, Ctc& ctc, int s3b=default_s3b, int scid=default_scid,
   int vhandled=-1, double var_min_width=default_var_min_width);





 Ctc3BCid(Ctc& ctc, int s3b=default_s3b, int scid=default_scid,
   int vhandled=-1, double var_min_width=default_var_min_width);
# 114 "/usr/local/include/ibex/ibex_Ctc3BCid.h" 3
 virtual void contract(IntervalVector& box);


 BitSet cid_vars;


 Ctc& ctc;


 static const int default_s3b;


 static const int default_scid;


 static const double default_var_min_width;




 static const int LimitCIDDichotomy;

 protected:






 bool var3BCID(IntervalVector& box, int var);







  virtual bool var3BCID_dicho(IntervalVector& box, int var, double wv);
# 176 "/usr/local/include/ibex/ibex_Ctc3BCid.h" 3
 virtual bool var3BCID_slices(IntervalVector& box, int var, int locs3b, double w_DC, Interval & dom);
# 186 "/usr/local/include/ibex/ibex_Ctc3BCid.h" 3
 bool shave_bound_dicho(IntervalVector& box, int var, double wv, bool left);
# 205 "/usr/local/include/ibex/ibex_Ctc3BCid.h" 3
 bool varCID(int var, IntervalVector &box, IntervalVector &newbox);




 bool equalBoxes (int var, IntervalVector &box1, IntervalVector &box2);


 int s3b;


 int scid;


 int vhandled;


 double var_min_width;


 int start_var;



 BitSet impact;

 virtual int limitCIDDichotomy () ;

};

}
# 36 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcAcid.h" 1 3
# 17 "/usr/local/include/ibex/ibex_CtcAcid.h" 3
namespace ibex {
# 36 "/usr/local/include/ibex/ibex_CtcAcid.h" 3
class CtcAcid : public Ctc3BCid {

public :
# 54 "/usr/local/include/ibex/ibex_CtcAcid.h" 3
    CtcAcid(const System& sys, const BitSet& cid_vars, Ctc& ctc, bool optim=false, int s3b=default_s3b, int scid=default_scid,
     double var_min_width=default_var_min_width, double ct_ratio=default_ctratio);






    CtcAcid(const System& sys, Ctc& ctc, bool optim=false, int s3b=default_s3b, int scid=default_scid,
     double var_min_width=default_var_min_width, double ct_ratio=default_ctratio);
# 81 "/usr/local/include/ibex/ibex_CtcAcid.h" 3
 virtual void contract(IntervalVector& box);

 double nbvar_stat();


 const System& system;


 static double nbvarstat;


 static const double default_ctratio;

protected :




 void compute_smearorder(IntervalVector& box);

 void putobjfirst();
 std::vector<int> smearorder;
 int nbcalls;
 double nbctvar;
 double ctratio;
 int nbcidvar;
 int nbtuning;
 bool optim;
};

}
# 37 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcCompo.h" 1 3
# 17 "/usr/local/include/ibex/ibex_CtcCompo.h" 3
namespace ibex {







class CtcCompo : public Ctc {
public:





 CtcCompo(const Array<Ctc>& list, bool incremental=false, double ratio=default_ratio);






 CtcCompo(Ctc& c1, Ctc& c2, bool incremental=false, double ratio=default_ratio);




 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, bool incremental=false, double ratio=default_ratio);




 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, bool incremental=false, double ratio=default_ratio);




 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, bool incremental=false, double ratio=default_ratio);




 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, bool incremental=false, double ratio=default_ratio);
 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, bool incremental=false, double ratio=default_ratio);
 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, bool incremental=false, double ratio=default_ratio);
 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, bool incremental=false, double ratio=default_ratio);
 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, bool incremental=false, double ratio=default_ratio);
 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, bool incremental=false, double ratio=default_ratio);
 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12, bool incremental=false, double ratio=default_ratio);
 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12, Ctc& c13, bool incremental=false, double ratio=default_ratio);
 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12, Ctc& c13, Ctc& c14, bool incremental=false, double ratio=default_ratio);
 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12, Ctc& c13, Ctc& c14, Ctc& c15, bool incremental=false, double ratio=default_ratio);
 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12, Ctc& c13, Ctc& c14, Ctc& c15, Ctc& c16, bool incremental=false, double ratio=default_ratio);
 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12, Ctc& c13, Ctc& c14, Ctc& c15, Ctc& c16, Ctc& c17, bool incremental=false, double ratio=default_ratio);
 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12, Ctc& c13, Ctc& c14, Ctc& c15, Ctc& c16, Ctc& c17, Ctc& c18, bool incremental=false, double ratio=default_ratio);
 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12, Ctc& c13, Ctc& c14, Ctc& c15, Ctc& c16, Ctc& c17, Ctc& c18, Ctc& c19, bool incremental=false, double ratio=default_ratio);
 CtcCompo(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12, Ctc& c13, Ctc& c14, Ctc& c15, Ctc& c16, Ctc& c17, Ctc& c18, Ctc& c19, Ctc& c20, bool incremental=false, double ratio=default_ratio);




 ~CtcCompo();




 virtual void contract(IntervalVector& box);


 Array<Ctc> list;


 bool incremental;


 double ratio;


 static const double default_ratio;

protected:
 void init_impacts();

 BitSet *impacts;
};

}
# 38 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcEmpty.h" 1 3
# 15 "/usr/local/include/ibex/ibex_CtcEmpty.h" 3
# 1 "/usr/local/include/ibex/ibex_Pdc.h" 1 3
# 17 "/usr/local/include/ibex/ibex_Pdc.h" 3
namespace ibex {
# 30 "/usr/local/include/ibex/ibex_Pdc.h" 3
class Pdc {
public:




 Pdc(int nb_var);




 Pdc(const Array<Pdc>& list);





 virtual BoolInterval test(const IntervalVector& box)=0;




 virtual ~Pdc();




 const int nb_var;


protected:




 static bool check_nb_var_pdc_list (const Array<Pdc>& l) {
  int i=1;
  while ( i<l.size() && (l[i].nb_var==l[0].nb_var)) {
   i++;
  }
  return (i==l.size());
 }

};




inline Pdc::Pdc(int n) : nb_var(n) { }

inline Pdc::Pdc(const Array<Pdc>& l) : nb_var(l[0].nb_var) { }

inline Pdc::~Pdc() { }


}
# 16 "/usr/local/include/ibex/ibex_CtcEmpty.h" 2 3
# 1 "/usr/local/include/ibex/ibex_PdcYes.h" 1 3
# 16 "/usr/local/include/ibex/ibex_PdcYes.h" 3
namespace ibex {





class PdcYes : public Pdc {
public:


 PdcYes(int n);




 BoolInterval test(const IntervalVector& box);

};

}
# 17 "/usr/local/include/ibex/ibex_CtcEmpty.h" 2 3

namespace ibex {
# 30 "/usr/local/include/ibex/ibex_CtcEmpty.h" 3
class CtcEmpty : public Ctc {
public:





 CtcEmpty(int n);




 CtcEmpty(Pdc& pdc, bool own=false);




 virtual void contract(IntervalVector& box);




 ~CtcEmpty();




 Pdc& pdc;


private:
 bool own_pdc;
};

}
# 39 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcExist.h" 1 3
# 13 "/usr/local/include/ibex/ibex_CtcExist.h" 3
# 1 "/usr/local/include/ibex/ibex_CtcQuantif.h" 1 3
# 18 "/usr/local/include/ibex/ibex_CtcQuantif.h" 3
# 1 "/usr/local/include/ibex/ibex_VarSet.h" 1 3
# 16 "/usr/local/include/ibex/ibex_VarSet.h" 3
namespace ibex {
# 26 "/usr/local/include/ibex/ibex_VarSet.h" 3
class VarSet {
public:





 VarSet(Function& f, const ExprNode& x1, bool var=true);





 VarSet(Function& f, const ExprNode& x1, const ExprNode& x2, bool var=true);





 VarSet(Function& f, const ExprNode& x1, const ExprNode& x2, const ExprNode& x3, bool var=true);





 VarSet(Function& f, const ExprNode& x1, const ExprNode& x2, const ExprNode& x3, const ExprNode& x4, bool var=true);





 VarSet(Function& f, const ExprNode& x1, const ExprNode& x2, const ExprNode& x3, const ExprNode& x4, const ExprNode& x5, bool var=true);





 VarSet(Function& f, const ExprNode& x1, const ExprNode& x2, const ExprNode& x3, const ExprNode& x4, const ExprNode& x5, const ExprNode& x6, bool var=true);





 VarSet(Function& f, const ExprNode& x1, const ExprNode& x2, const ExprNode& x3, const ExprNode& x4, const ExprNode& x5, const ExprNode& x6, const ExprNode& x7, bool var=true);





 VarSet(Function& f, const ExprNode& x1, const ExprNode& x2, const ExprNode& x3, const ExprNode& x4, const ExprNode& x5, const ExprNode& x6, const ExprNode& x7, const ExprNode& x8, bool var=true);





 VarSet(Function& f, const ExprNode& x1, const ExprNode& x2, const ExprNode& x3, const ExprNode& x4, const ExprNode& x5, const ExprNode& x6, const ExprNode& x7, const ExprNode& x8, const ExprNode& x9, bool var=true);





 VarSet(Function& f, const ExprNode& x1, const ExprNode& x2, const ExprNode& x3, const ExprNode& x4, const ExprNode& x5, const ExprNode& x6, const ExprNode& x7, const ExprNode& x8, const ExprNode& x9, const ExprNode& x10, bool var=true);





 VarSet(Function& f, const ExprNode& x1, const ExprNode& x2, const ExprNode& x3, const ExprNode& x4, const ExprNode& x5, const ExprNode& x6, const ExprNode& x7, const ExprNode& x8, const ExprNode& x9, const ExprNode& x10, const ExprNode& x11, bool var=true);





 VarSet(Function& f, const ExprNode& x1, const ExprNode& x2, const ExprNode& x3, const ExprNode& x4, const ExprNode& x5, const ExprNode& x6, const ExprNode& x7, const ExprNode& x8, const ExprNode& x9, const ExprNode& x10, const ExprNode& x11, const ExprNode& x12, bool var=true);




 VarSet(Function& f, const Array<const ExprNode>& x, bool var=true);
# 113 "/usr/local/include/ibex/ibex_VarSet.h" 3
 VarSet(int total, const BitSet& x, bool var=true);




 IntervalVector full_box(const IntervalVector& var_box, const IntervalVector& param_box) const;




 IntervalVector var_box(const IntervalVector& full_box) const;




 void set_var_box(IntervalVector& full_box, const IntervalVector& var_box) const;




 void set_param_box(IntervalVector& full_box, const IntervalVector& param_box) const;




 IntervalVector param_box(const IntervalVector& full_box) const;
# 147 "/usr/local/include/ibex/ibex_VarSet.h" 3
 const int nb_var;




 const int nb_param;





 BitSet vars;

protected:

 void init(Function& f, const Array<const ExprNode>& x, bool var);
};

}
# 19 "/usr/local/include/ibex/ibex_CtcQuantif.h" 2 3

namespace ibex {
# 29 "/usr/local/include/ibex/ibex_CtcQuantif.h" 3
class CtcQuantif : public Ctc {

public:
# 45 "/usr/local/include/ibex/ibex_CtcQuantif.h" 3
 CtcQuantif(const NumConstraint& c, const VarSet& vars, const IntervalVector& y_init, double prec);
# 59 "/usr/local/include/ibex/ibex_CtcQuantif.h" 3
 CtcQuantif(Ctc& c, const VarSet& vars, const IntervalVector& y_init, double prec, bool own_ctc=false);




 virtual ~CtcQuantif();




 IntervalVector y_init;

protected:






 void contract(IntervalVector& x, IntervalVector& y);




 BitSet flags;
 const BitSet impact;




 Ctc* ctc;




 LargestFirst* bsc;





 VarSet vars;




 double prec;

private:


 bool _own_ctc;
};




}
# 14 "/usr/local/include/ibex/ibex_CtcExist.h" 2 3




namespace ibex {
# 31 "/usr/local/include/ibex/ibex_CtcExist.h" 3
class CtcExist : public CtcQuantif {
public:






 CtcExist(const NumConstraint& c, const ExprNode& y1, const IntervalVector& y_init, double prec);






 CtcExist(const NumConstraint& c, const VarSet& y, const IntervalVector& y_init, double prec);






 CtcExist(Ctc& c, const BitSet& vars, const IntervalVector& y_init, double prec, bool own_ctc=false);




 virtual void contract(IntervalVector& x);

private:
# 72 "/usr/local/include/ibex/ibex_CtcExist.h" 3
 bool proceed(const IntervalVector& x_init, const IntervalVector& x_current, IntervalVector& x_res, IntervalVector& y);




 std::stack<std::pair<IntervalVector,IntervalVector> > l;

};

typedef CtcExist CtcProjUnion;

}
# 40 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcFixPoint.h" 1 3
# 16 "/usr/local/include/ibex/ibex_CtcFixPoint.h" 3
namespace ibex {






class CtcFixPoint : public Ctc {
public:







 CtcFixPoint(Ctc& ctc, double ratio=default_ratio);




 virtual ~CtcFixPoint();







 virtual void contract(IntervalVector& box);


 Ctc& ctc;






 double ratio;


 static const double default_ratio;
};

}
# 41 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcForAll.h" 1 3
# 17 "/usr/local/include/ibex/ibex_CtcForAll.h" 3
namespace ibex {
# 30 "/usr/local/include/ibex/ibex_CtcForAll.h" 3
class CtcForAll : public CtcQuantif {
public:






 CtcForAll(const NumConstraint& c, const ExprNode& y1, const IntervalVector& y_init, double prec);






 CtcForAll(const NumConstraint& c, const VarSet& y, const IntervalVector& y_init, double prec);






 CtcForAll(Ctc& c, const BitSet& vars, const IntervalVector& y_init, double prec, bool own_ctc=false);




 virtual void contract(IntervalVector& x);

private:
# 68 "/usr/local/include/ibex/ibex_CtcForAll.h" 3
 void proceed(IntervalVector& x, const IntervalVector& y, bool& is_inactive);




 std::stack<IntervalVector> l;

};

typedef CtcForAll CtcProjInter;

}
# 42 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcFwdBwd.h" 1 3
# 17 "/usr/local/include/ibex/ibex_CtcFwdBwd.h" 3
# 1 "/usr/local/include/ibex/ibex_HC4Revise.h" 1 3
# 16 "/usr/local/include/ibex/ibex_HC4Revise.h" 3
namespace ibex {

typedef enum { INTERVAL_MODE, AFFINE2_MODE, AFFINE_MODE } FwdMode;






class HC4Revise : public BwdAlgorithm {
public:
# 36 "/usr/local/include/ibex/ibex_HC4Revise.h" 3
 HC4Revise(FwdMode mode=INTERVAL_MODE);
# 49 "/usr/local/include/ibex/ibex_HC4Revise.h" 3
 bool proj(const Function& f, const Domain& y, IntervalVector& x);






 static const double RATIO;

protected:




 class EmptyBoxException { };

public:
 inline void index_bwd (const ExprIndex&, ExprLabel& , const ExprLabel& ) { }
        void vector_bwd(const ExprVector&, ExprLabel** compL, const ExprLabel& result);
 inline void symbol_bwd(const ExprSymbol& , const ExprLabel& ) { }
 inline void cst_bwd (const ExprConstant&, const ExprLabel& ) { }
 inline void apply_bwd (const ExprApply& a, ExprLabel** x, const ExprLabel& y) { proj(a.func,*y.d,x); }
 inline void chi_bwd (const ExprChi&,ExprLabel& a,ExprLabel& b,ExprLabel& c,const ExprLabel& f){ if (!(bwd_chi(f.d->i(),a.d->i(),b.d->i(),c.d->i()))) throw EmptyBoxException(); }
 inline void add_bwd (const ExprAdd&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!(bwd_add(y.d->i(),x1.d->i(),x2.d->i()))) throw EmptyBoxException(); }
 inline void add_V_bwd (const ExprAdd&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!(bwd_add(y.d->v(),x1.d->v(),x2.d->v()))) throw EmptyBoxException(); }
 inline void add_M_bwd (const ExprAdd&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!(bwd_add(y.d->m(),x1.d->m(),x2.d->m()))) throw EmptyBoxException(); }
 inline void mul_bwd (const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!(bwd_mul(y.d->i(),x1.d->i(),x2.d->i()))) throw EmptyBoxException(); }
 inline void mul_SV_bwd (const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!(bwd_mul(y.d->v(),x1.d->i(),x2.d->v()))) throw EmptyBoxException(); }
 inline void mul_SM_bwd (const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!(bwd_mul(y.d->m(),x1.d->i(),x2.d->m()))) throw EmptyBoxException(); }
 inline void mul_VV_bwd (const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!(bwd_mul(y.d->i(),x1.d->v(),x2.d->v()))) throw EmptyBoxException(); }
 inline void mul_MV_bwd (const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!(bwd_mul(y.d->v(),x1.d->m(),x2.d->v(), RATIO))) throw EmptyBoxException(); }
 inline void mul_VM_bwd (const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!(bwd_mul(y.d->v(),x1.d->v(),x2.d->m(), RATIO))) throw EmptyBoxException(); }
 inline void mul_MM_bwd (const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!(bwd_mul(y.d->m(),x1.d->m(),x2.d->m(), RATIO))) throw EmptyBoxException(); }
 inline void sub_bwd (const ExprSub&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!(bwd_sub(y.d->i(),x1.d->i(),x2.d->i()))) throw EmptyBoxException(); }
 inline void sub_V_bwd (const ExprSub&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!(bwd_sub(y.d->v(),x1.d->v(),x2.d->v()))) throw EmptyBoxException(); }
 inline void sub_M_bwd (const ExprSub&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!(bwd_sub(y.d->m(),x1.d->m(),x2.d->m()))) throw EmptyBoxException(); }
 inline void div_bwd (const ExprDiv&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!(bwd_div(y.d->i(),x1.d->i(),x2.d->i()))) throw EmptyBoxException(); }
 inline void max_bwd (const ExprMax&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!(bwd_max(y.d->i(),x1.d->i(),x2.d->i()))) throw EmptyBoxException(); }
 inline void min_bwd (const ExprMin&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!(bwd_min(y.d->i(),x1.d->i(),x2.d->i()))) throw EmptyBoxException(); }
 inline void atan2_bwd (const ExprAtan2& , ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!(bwd_atan2(y.d->i(),x1.d->i(),x2.d->i()))) throw EmptyBoxException(); }
 inline void minus_bwd (const ExprMinus& , ExprLabel& x, const ExprLabel& y) { if ((x.d->i() &=-y.d->i()).is_empty()) throw EmptyBoxException(); }
    inline void trans_V_bwd(const ExprTrans& ,ExprLabel& x, const ExprLabel& y) { if ((x.d->v() &= y.d->v()).is_empty()) throw EmptyBoxException(); }
    inline void trans_M_bwd(const ExprTrans& ,ExprLabel& x, const ExprLabel& y) { if ((x.d->m() &= y.d->m().transpose()).is_empty()) throw EmptyBoxException(); }
 inline void sign_bwd (const ExprSign& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_sign(y.d->i(),x.d->i()))) throw EmptyBoxException(); }
 inline void abs_bwd (const ExprAbs& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_abs(y.d->i(),x.d->i()))) throw EmptyBoxException(); }
 inline void power_bwd (const ExprPower& e, ExprLabel& x, const ExprLabel& y) { if (!(bwd_pow(y.d->i(),e.expon, x.d->i()))) throw EmptyBoxException(); }
 inline void sqr_bwd (const ExprSqr& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_sqr(y.d->i(),x.d->i()))) throw EmptyBoxException(); }
 inline void sqrt_bwd (const ExprSqrt& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_sqrt(y.d->i(),x.d->i()))) throw EmptyBoxException(); }
 inline void exp_bwd (const ExprExp& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_exp(y.d->i(),x.d->i()))) throw EmptyBoxException(); }
 inline void log_bwd (const ExprLog& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_log(y.d->i(),x.d->i()))) throw EmptyBoxException(); }
 inline void cos_bwd (const ExprCos& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_cos(y.d->i(),x.d->i()))) throw EmptyBoxException(); }
 inline void sin_bwd (const ExprSin& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_sin(y.d->i(),x.d->i()))) throw EmptyBoxException(); }
 inline void tan_bwd (const ExprTan& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_tan(y.d->i(),x.d->i()))) throw EmptyBoxException(); }
 inline void cosh_bwd (const ExprCosh& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_cosh(y.d->i(),x.d->i()))) throw EmptyBoxException(); }
 inline void sinh_bwd (const ExprSinh& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_sinh(y.d->i(),x.d->i()))) throw EmptyBoxException(); }
 inline void tanh_bwd (const ExprTanh& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_tanh(y.d->i(),x.d->i()))) throw EmptyBoxException(); }
 inline void acos_bwd (const ExprAcos& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_acos(y.d->i(),x.d->i()))) throw EmptyBoxException(); }
 inline void asin_bwd (const ExprAsin& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_asin(y.d->i(),x.d->i()))) throw EmptyBoxException(); }
 inline void atan_bwd (const ExprAtan& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_atan(y.d->i(),x.d->i()))) throw EmptyBoxException(); }
 inline void acosh_bwd (const ExprAcosh& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_acosh(y.d->i(),x.d->i()))) throw EmptyBoxException(); }
 inline void asinh_bwd (const ExprAsinh& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_asinh(y.d->i(),x.d->i()))) throw EmptyBoxException(); }
 inline void atanh_bwd (const ExprAtanh& , ExprLabel& x, const ExprLabel& y) { if (!(bwd_atanh(y.d->i(),x.d->i()))) throw EmptyBoxException(); }

protected:
 void proj(const Function& f, const Domain& y, ExprLabel** x);
 FwdMode fwd_mode;
};

}
# 18 "/usr/local/include/ibex/ibex_CtcFwdBwd.h" 2 3

namespace ibex {






class CtcFwdBwd: public Ctc {

public:







 CtcFwdBwd(Function& f, CmpOp op=EQ, FwdMode mode=INTERVAL_MODE);




 CtcFwdBwd(Function& f, const Domain& y, FwdMode mode=INTERVAL_MODE);




 CtcFwdBwd(Function& f, const Interval& y, FwdMode mode=INTERVAL_MODE);




 CtcFwdBwd(Function& f, const IntervalVector& y, FwdMode mode=INTERVAL_MODE);




 CtcFwdBwd(Function& f, const IntervalMatrix& y, FwdMode mode=INTERVAL_MODE);




 CtcFwdBwd(const NumConstraint& ctr, FwdMode mode=INTERVAL_MODE);




 ~CtcFwdBwd();




 virtual void contract(IntervalVector& box);
# 81 "/usr/local/include/ibex/ibex_CtcFwdBwd.h" 3
 const Function& f;


 Domain d;

protected:
 HC4Revise hc4r;

 void init();
};

}
# 43 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcHC4.h" 1 3
# 14 "/usr/local/include/ibex/ibex_CtcHC4.h" 3
# 1 "/usr/local/include/ibex/ibex_CtcPropag.h" 1 3
# 15 "/usr/local/include/ibex/ibex_CtcPropag.h" 3
# 1 "/usr/local/include/ibex/ibex_Agenda.h" 1 3
# 16 "/usr/local/include/ibex/ibex_Agenda.h" 3
# 1 "/usr/local/include/ibex/ibex_HyperGraph.h" 1 3
# 17 "/usr/local/include/ibex/ibex_HyperGraph.h" 3
namespace ibex {






class HyperGraph {
public:




 HyperGraph(int nb_ctr, int nb_var);




 HyperGraph(const HyperGraph&);




 ~HyperGraph();




 inline int nb_ctr() const { return m; }




 inline int nb_var() const { return n; }




 void add_arc(int ctr, int var, int value);





 inline int arc(int ctr, int var) const { return matrix[ctr][var]; }







 inline int ctr_nb_vars(int ctr) const { return ctr_adj[ctr][0]; }







 inline int ctr_ith_var(int ctr, int i) const { return ctr_adj[ctr][i+1]; }







 inline int var_nb_ctrs(int var) const { return var_adj[var][0]; }







 inline int var_ith_ctr(int var, int i) const { return var_adj[var][i+1]; }






 friend std::ostream& operator<<(std::ostream& os, const HyperGraph& a);

private:

 const int m;
 const int n;
 int **matrix;
 int **ctr_adj;
 int **var_adj;
};

}
# 17 "/usr/local/include/ibex/ibex_Agenda.h" 2 3


namespace ibex {







class EmptyAgendaException : public Exception { };






class Agenda {

 public:

  Agenda(int size) : size(size), first(-1), last(-1) {
    table = new int[size];
    for (int i=0; i<size; i++) {
      table[i]=-1;
    }
  }

  virtual ~Agenda() {
    delete[] table;
  }

  inline void push(int p) {
    if (table[p]!=-1) return;

    if (first==-1) first = p;
    else table[last] = p;

    last = p;
    table[last] = first;
  }

  inline void pop(int& p) {
    if (first == -1) throw EmptyAgendaException();

    p = first;

    int tmp = table[first];
    table[first] = -1;

    if (first == tmp) {
      first = -1;
    } else {
      first = tmp;
      table[last] = first;
    }
  }

  inline void flush() {
    int ignore;
    while (!empty()) pop(ignore);
  }

  inline bool empty() const {
    return first==-1;
  }

  friend std::ostream& operator<<(std::ostream& os, const Agenda& q);

 protected:
  int size;
  int first, last;
  int *table;

  private:
  bool delete_it;
};
# 103 "/usr/local/include/ibex/ibex_Agenda.h" 3
class ArcAgenda : Agenda {

 public:



  ArcAgenda(int nb_ctr, int nb_var) : Agenda(nb_ctr*nb_var), nb_ctr(nb_ctr), nb_var(nb_var) {
  }


  const int nb_ctr;


  const int nb_var;



  inline void push(int ctr, int var) {
    Agenda::push(ctr*nb_var+var);
  }




  inline void pop(int& ctr, int& var) {
    int p;
    Agenda::pop(p);
    ctr = p / nb_var;
    var = p % nb_var;
  }


  inline void flush() {
    Agenda::flush();
  }


  inline bool empty() const {
    return Agenda::empty();
  }







  void init(const HyperGraph& g);






  inline void propagate(const HyperGraph& g, int var) { propagate(g,-1,var); }







  void propagate(const HyperGraph& g, const BitSet& m);
# 175 "/usr/local/include/ibex/ibex_Agenda.h" 3
  void propagate(const HyperGraph& g, int ctr, int var);




  friend std::ostream& operator<<(std::ostream& os, const ArcAgenda& q);
};

}
# 16 "/usr/local/include/ibex/ibex_CtcPropag.h" 2 3

# 1 "/usr/local/include/ibex/ibex_DirectedHyperGraph.h" 1 3
# 16 "/usr/local/include/ibex/ibex_DirectedHyperGraph.h" 3
# 1 "/usr/include/c++/7/set" 1 3
# 58 "/usr/include/c++/7/set" 3
       
# 59 "/usr/include/c++/7/set" 3

# 1 "/usr/include/c++/7/bits/stl_tree.h" 1 3
# 61 "/usr/include/c++/7/bits/stl_tree.h" 3
       
# 62 "/usr/include/c++/7/bits/stl_tree.h" 3
# 75 "/usr/include/c++/7/bits/stl_tree.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 99 "/usr/include/c++/7/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x) noexcept
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x) noexcept
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x) noexcept
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x) noexcept
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };


  template<typename _Key_compare>
    struct _Rb_tree_key_compare
    {
      _Key_compare _M_key_compare;

      _Rb_tree_key_compare()
      noexcept(is_nothrow_default_constructible<_Key_compare>::value)

      : _M_key_compare()
      { }

      _Rb_tree_key_compare(const _Key_compare& __comp)
      : _M_key_compare(__comp)
      { }



      _Rb_tree_key_compare(const _Rb_tree_key_compare&) = default;

      _Rb_tree_key_compare(_Rb_tree_key_compare&& __x)
 noexcept(is_nothrow_copy_constructible<_Key_compare>::value)
      : _M_key_compare(__x._M_key_compare)
      { }

    };


  struct _Rb_tree_header
  {
    _Rb_tree_node_base _M_header;
    size_t _M_node_count;

    _Rb_tree_header() noexcept
    {
      _M_header._M_color = _S_red;
      _M_reset();
    }


    _Rb_tree_header(_Rb_tree_header&& __x) noexcept
    {
      if (__x._M_header._M_parent != nullptr)
 _M_move_data(__x);
      else
 {
   _M_header._M_color = _S_red;
   _M_reset();
 }
    }


    void
    _M_move_data(_Rb_tree_header& __from)
    {
      _M_header._M_color = __from._M_header._M_color;
      _M_header._M_parent = __from._M_header._M_parent;
      _M_header._M_left = __from._M_header._M_left;
      _M_header._M_right = __from._M_header._M_right;
      _M_header._M_parent->_M_parent = &_M_header;
      _M_node_count = __from._M_node_count;

      __from._M_reset();
    }

    void
    _M_reset()
    {
      _M_header._M_parent = 0;
      _M_header._M_left = &_M_header;
      _M_header._M_right = &_M_header;
      _M_node_count = 0;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
# 231 "/usr/include/c++/7/bits/stl_tree.h" 3
      __gnu_cxx::__aligned_membuf<_Val> _M_storage;

      _Val*
      _M_valptr()
      { return _M_storage._M_ptr(); }

      const _Val*
      _M_valptr() const
      { return _M_storage._M_ptr(); }

    };

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator() noexcept
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Base_ptr __x) noexcept
      : _M_node(__x) { }

      reference
      operator*() const noexcept
      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Link_type> (_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator() noexcept
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Base_ptr __x) noexcept
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it) noexcept
      : _M_node(__it._M_node) { }

      iterator
      _M_const_cast() const noexcept
      { return iterator(const_cast<typename iterator::_Base_ptr>(_M_node)); }

      reference
      operator*() const noexcept
      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Link_type>(_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y) noexcept
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y) noexcept
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header) throw ();

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header) throw ();


  template<typename _Cmp, typename _SfinaeType, typename = __void_t<>>
    struct __has_is_transparent
    { };

  template<typename _Cmp, typename _SfinaeType>
    struct __has_is_transparent<_Cmp, _SfinaeType,
    __void_t<typename _Cmp::is_transparent>>
    { typedef void type; };







  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Rb_tree_node<_Val> >::other _Node_allocator;

      typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;

    private:


      struct _Reuse_or_alloc_node
      {
 _Reuse_or_alloc_node(_Rb_tree& __t)
   : _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t)
 {
   if (_M_root)
     {
       _M_root->_M_parent = 0;

       if (_M_nodes->_M_left)
  _M_nodes = _M_nodes->_M_left;
     }
   else
     _M_nodes = 0;
 }


 _Reuse_or_alloc_node(const _Reuse_or_alloc_node&) = delete;


 ~_Reuse_or_alloc_node()
 { _M_t._M_erase(static_cast<_Link_type>(_M_root)); }

 template<typename _Arg>
   _Link_type



   operator()(_Arg&& __arg)

   {
     _Link_type __node = static_cast<_Link_type>(_M_extract());
     if (__node)
       {
  _M_t._M_destroy_node(__node);
  _M_t._M_construct_node(__node, std::forward<_Arg>(__arg));
  return __node;
       }

     return _M_t._M_create_node(std::forward<_Arg>(__arg));
   }

      private:
 _Base_ptr
 _M_extract()
 {
   if (!_M_nodes)
     return _M_nodes;

   _Base_ptr __node = _M_nodes;
   _M_nodes = _M_nodes->_M_parent;
   if (_M_nodes)
     {
       if (_M_nodes->_M_right == __node)
  {
    _M_nodes->_M_right = 0;

    if (_M_nodes->_M_left)
      {
        _M_nodes = _M_nodes->_M_left;

        while (_M_nodes->_M_right)
   _M_nodes = _M_nodes->_M_right;

        if (_M_nodes->_M_left)
   _M_nodes = _M_nodes->_M_left;
      }
  }
       else
  _M_nodes->_M_left = 0;
     }
   else
     _M_root = 0;

   return __node;
 }

 _Base_ptr _M_root;
 _Base_ptr _M_nodes;
 _Rb_tree& _M_t;
      };



      struct _Alloc_node
      {
 _Alloc_node(_Rb_tree& __t)
   : _M_t(__t) { }

 template<typename _Arg>
   _Link_type



   operator()(_Arg&& __arg) const

   { return _M_t._M_create_node(std::forward<_Arg>(__arg)); }

      private:
 _Rb_tree& _M_t;
      };

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator() noexcept
      { return *static_cast<_Node_allocator*>(&this->_M_impl); }

      const _Node_allocator&
      _M_get_Node_allocator() const noexcept
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _Alloc_traits::allocate(_M_get_Node_allocator(), 1); }

      void
      _M_put_node(_Link_type __p) noexcept
      { _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); }
# 619 "/usr/include/c++/7/bits/stl_tree.h" 3
      template<typename... _Args>
 void
 _M_construct_node(_Link_type __node, _Args&&... __args)
 {
   try
     {
       ::new(__node) _Rb_tree_node<_Val>;
       _Alloc_traits::construct(_M_get_Node_allocator(),
           __node->_M_valptr(),
           std::forward<_Args>(__args)...);
     }
   catch(...)
     {
       __node->~_Rb_tree_node<_Val>();
       _M_put_node(__node);
       throw;
     }
 }

      template<typename... _Args>
        _Link_type
        _M_create_node(_Args&&... __args)
 {
   _Link_type __tmp = _M_get_node();
   _M_construct_node(__tmp, std::forward<_Args>(__args)...);
   return __tmp;
 }

      void
      _M_destroy_node(_Link_type __p) noexcept
      {
 _Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr());
 __p->~_Rb_tree_node<_Val>();
      }


      void
      _M_drop_node(_Link_type __p) noexcept
      {
 _M_destroy_node(__p);
 _M_put_node(__p);
      }

      template<typename _NodeGen>
 _Link_type
 _M_clone_node(_Const_Link_type __x, _NodeGen& __node_gen)
 {
   _Link_type __tmp = __node_gen(*__x->_M_valptr());
   __tmp->_M_color = __x->_M_color;
   __tmp->_M_left = 0;
   __tmp->_M_right = 0;
   return __tmp;
 }

    protected:

      template<typename _Key_compare,
        bool = __is_pod(_Key_compare)>
        struct _Rb_tree_impl
 : public _Node_allocator
 , public _Rb_tree_key_compare<_Key_compare>
 , public _Rb_tree_header
        {
   typedef _Rb_tree_key_compare<_Key_compare> _Base_key_compare;





   _Rb_tree_impl() = default;
   _Rb_tree_impl(_Rb_tree_impl&&) = default;


   _Rb_tree_impl(const _Rb_tree_impl& __x)
   : _Node_allocator(_Alloc_traits::_S_select_on_copy(__x))
   , _Base_key_compare(__x._M_key_compare)
   { }






   _Rb_tree_impl(const _Key_compare& __comp, _Node_allocator&& __a)
   : _Node_allocator(std::move(__a)), _Base_key_compare(__comp)
   { }

 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root() noexcept
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const noexcept
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost() noexcept
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const noexcept
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost() noexcept
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const noexcept
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin() noexcept
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const noexcept
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Base_ptr
      _M_end() noexcept
      { return &this->_M_impl._M_header; }

      _Const_Base_ptr
      _M_end() const noexcept
      { return &this->_M_impl._M_header; }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return *__x->_M_valptr(); }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x) noexcept
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x) noexcept
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x) noexcept
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x) noexcept
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return *static_cast<_Const_Link_type>(__x)->_M_valptr(); }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
# 816 "/usr/include/c++/7/bits/stl_tree.h" 3
      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_unique_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_equal_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_unique_pos(const_iterator __pos,
        const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_equal_pos(const_iterator __pos,
       const key_type& __k);

    private:

      template<typename _Arg, typename _NodeGen>
        iterator
 _M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v, _NodeGen&);

      iterator
      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);

      template<typename _Arg>
        iterator
        _M_insert_lower(_Base_ptr __y, _Arg&& __v);

      template<typename _Arg>
        iterator
        _M_insert_equal_lower(_Arg&& __x);

      iterator
      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);

      iterator
      _M_insert_equal_lower_node(_Link_type __z);
# 867 "/usr/include/c++/7/bits/stl_tree.h" 3
      template<typename _NodeGen>
 _Link_type
 _M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen&);

      template<typename _NodeGen>
 _Link_type
 _M_copy(const _Rb_tree& __x, _NodeGen& __gen)
 {
   _Link_type __root = _M_copy(__x._M_begin(), _M_end(), __gen);
   _M_leftmost() = _S_minimum(__root);
   _M_rightmost() = _S_maximum(__root);
   _M_impl._M_node_count = __x._M_impl._M_node_count;
   return __root;
 }

      _Link_type
      _M_copy(const _Rb_tree& __x)
      {
 _Alloc_node __an(*this);
 return _M_copy(__x, __an);
      }

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Base_ptr __y,
       const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
       const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Base_ptr __y,
       const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
       const _Key& __k) const;

    public:




      _Rb_tree() = default;


      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, _Node_allocator(__a)) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl)
      {
 if (__x._M_root() != 0)
   _M_root() = _M_copy(__x);
      }


      _Rb_tree(const allocator_type& __a)
      : _M_impl(_Compare(), _Node_allocator(__a))
      { }

      _Rb_tree(const _Rb_tree& __x, const allocator_type& __a)
      : _M_impl(__x._M_impl._M_key_compare, _Node_allocator(__a))
      {
 if (__x._M_root() != nullptr)
   _M_root() = _M_copy(__x);
      }

      _Rb_tree(_Rb_tree&&) = default;

      _Rb_tree(_Rb_tree&& __x, const allocator_type& __a)
      : _Rb_tree(std::move(__x), _Node_allocator(__a))
      { }

      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a);


      ~_Rb_tree() noexcept
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_header._M_left); }

      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_header._M_left); }

      iterator
      end() noexcept
      { return iterator(&this->_M_impl._M_header); }

      const_iterator
      end() const noexcept
      { return const_iterator(&this->_M_impl._M_header); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      bool
      empty() const noexcept
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const noexcept
      { return _M_impl._M_node_count; }

      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Node_allocator()); }

      void
      swap(_Rb_tree& __t)
      noexcept(__is_nothrow_swappable<_Compare>::value);



      template<typename _Arg>
        pair<iterator, bool>
        _M_insert_unique(_Arg&& __x);

      template<typename _Arg>
        iterator
        _M_insert_equal(_Arg&& __x);

      template<typename _Arg, typename _NodeGen>
        iterator
 _M_insert_unique_(const_iterator __pos, _Arg&& __x, _NodeGen&);

      template<typename _Arg>
 iterator
 _M_insert_unique_(const_iterator __pos, _Arg&& __x)
 {
   _Alloc_node __an(*this);
   return _M_insert_unique_(__pos, std::forward<_Arg>(__x), __an);
 }

      template<typename _Arg, typename _NodeGen>
 iterator
 _M_insert_equal_(const_iterator __pos, _Arg&& __x, _NodeGen&);

      template<typename _Arg>
 iterator
 _M_insert_equal_(const_iterator __pos, _Arg&& __x)
 {
   _Alloc_node __an(*this);
   return _M_insert_equal_(__pos, std::forward<_Arg>(__x), __an);
 }

      template<typename... _Args>
 pair<iterator, bool>
 _M_emplace_unique(_Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_equal(_Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);
# 1087 "/usr/include/c++/7/bits/stl_tree.h" 3
      template<typename _InputIterator>
        void
        _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
        void
        _M_insert_equal(_InputIterator __first, _InputIterator __last);

    private:
      void
      _M_erase_aux(const_iterator __position);

      void
      _M_erase_aux(const_iterator __first, const_iterator __last);

    public:



      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __position)
      {
 ;
 const_iterator __result = __position;
 ++__result;
 _M_erase_aux(__position);
 return __result._M_const_cast();
      }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      {
 ;
 iterator __result = __position;
 ++__result;
 _M_erase_aux(__position);
 return __result;
      }
# 1143 "/usr/include/c++/7/bits/stl_tree.h" 3
      size_type
      erase(const key_type& __x);




      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __first, const_iterator __last)
      {
 _M_erase_aux(__first, __last);
 return __last._M_const_cast();
      }
# 1165 "/usr/include/c++/7/bits/stl_tree.h" 3
      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear() noexcept
      {
        _M_erase(_M_begin());
 _M_impl._M_reset();
      }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;


      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 iterator
 _M_find_tr(const _Kt& __k)
 {
   const _Rb_tree* __const_this = this;
   return __const_this->_M_find_tr(__k)._M_const_cast();
 }

      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 const_iterator
 _M_find_tr(const _Kt& __k) const
 {
   auto __j = _M_lower_bound_tr(__k);
   if (__j != end() && _M_impl._M_key_compare(__k, _S_key(__j._M_node)))
     __j = end();
   return __j;
 }

      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 size_type
 _M_count_tr(const _Kt& __k) const
 {
   auto __p = _M_equal_range_tr(__k);
   return std::distance(__p.first, __p.second);
 }

      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 iterator
 _M_lower_bound_tr(const _Kt& __k)
 {
   const _Rb_tree* __const_this = this;
   return __const_this->_M_lower_bound_tr(__k)._M_const_cast();
 }

      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 const_iterator
 _M_lower_bound_tr(const _Kt& __k) const
 {
   auto __x = _M_begin();
   auto __y = _M_end();
   while (__x != 0)
     if (!_M_impl._M_key_compare(_S_key(__x), __k))
       {
  __y = __x;
  __x = _S_left(__x);
       }
     else
       __x = _S_right(__x);
   return const_iterator(__y);
 }

      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 iterator
 _M_upper_bound_tr(const _Kt& __k)
 {
   const _Rb_tree* __const_this = this;
   return __const_this->_M_upper_bound_tr(__k)._M_const_cast();
 }

      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 const_iterator
 _M_upper_bound_tr(const _Kt& __k) const
 {
   auto __x = _M_begin();
   auto __y = _M_end();
   while (__x != 0)
     if (_M_impl._M_key_compare(__k, _S_key(__x)))
       {
  __y = __x;
  __x = _S_left(__x);
       }
     else
       __x = _S_right(__x);
   return const_iterator(__y);
 }

      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 pair<iterator, iterator>
 _M_equal_range_tr(const _Kt& __k)
 {
   const _Rb_tree* __const_this = this;
   auto __ret = __const_this->_M_equal_range_tr(__k);
   return { __ret.first._M_const_cast(), __ret.second._M_const_cast() };
 }

      template<typename _Kt,
        typename _Req =
   typename __has_is_transparent<_Compare, _Kt>::type>
 pair<const_iterator, const_iterator>
 _M_equal_range_tr(const _Kt& __k) const
 {
   auto __low = _M_lower_bound_tr(__k);
   auto __high = __low;
   auto& __cmp = _M_impl._M_key_compare;
   while (__high != end() && !__cmp(__k, _S_key(__high._M_node)))
     ++__high;
   return { __low, __high };
 }



      bool
      __rb_verify() const;


      _Rb_tree&
      operator=(_Rb_tree&&)
      noexcept(_Alloc_traits::_S_nothrow_move()
        && is_nothrow_move_assignable<_Compare>::value);

      template<typename _Iterator>
 void
 _M_assign_unique(_Iterator, _Iterator);

      template<typename _Iterator>
 void
 _M_assign_equal(_Iterator, _Iterator);

    private:

      void
      _M_move_data(_Rb_tree& __x, std::true_type)
      { _M_impl._M_move_data(__x._M_impl); }



      void
      _M_move_data(_Rb_tree&, std::false_type);


      void
      _M_move_assign(_Rb_tree&, std::true_type);



      void
      _M_move_assign(_Rb_tree&, std::false_type);
# 1528 "/usr/include/c++/7/bits/stl_tree.h" 3
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a)
    : _M_impl(__x._M_impl._M_key_compare, std::move(__a))
    {
      using __eq = typename _Alloc_traits::is_always_equal;
      if (__x._M_root() != nullptr)
 _M_move_data(__x, __eq());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_data(_Rb_tree& __x, std::false_type)
    {
      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
 _M_move_data(__x, std::true_type());
      else
 {
   _Alloc_node __an(*this);
   auto __lbd =
     [&__an](const value_type& __cval)
     {
       auto& __val = const_cast<value_type&>(__cval);
       return __an(std::move_if_noexcept(__val));
     };
   _M_root() = _M_copy(__x, __lbd);
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_assign(_Rb_tree& __x, true_type)
    {
      clear();
      if (__x._M_root() != nullptr)
 _M_move_data(__x, std::true_type());
      std::__alloc_on_move(_M_get_Node_allocator(),
      __x._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_assign(_Rb_tree& __x, false_type)
    {
      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
 return _M_move_assign(__x, true_type{});



      _Reuse_or_alloc_node __roan(*this);
      _M_impl._M_reset();
      if (__x._M_root() != nullptr)
 {
   auto __lbd =
     [&__roan](const value_type& __cval)
     {
       auto& __val = const_cast<value_type&>(__cval);
       return __roan(std::move_if_noexcept(__val));
     };
   _M_root() = _M_copy(__x, __lbd);
   __x.clear();
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(_Rb_tree&& __x)
    noexcept(_Alloc_traits::_S_nothrow_move()
      && is_nothrow_move_assignable<_Compare>::value)
    {
      _M_impl._M_key_compare = std::move(__x._M_impl._M_key_compare);
      _M_move_assign(__x, __bool_constant<_Alloc_traits::_S_nothrow_move()>());
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename _Iterator>
      void
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_assign_unique(_Iterator __first, _Iterator __last)
      {
 _Reuse_or_alloc_node __roan(*this);
 _M_impl._M_reset();
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first, __roan);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename _Iterator>
      void
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_assign_equal(_Iterator __first, _Iterator __last)
      {
 _Reuse_or_alloc_node __roan(*this);
 _M_impl._M_reset();
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first, __roan);
      }


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree& __x)
    {
      if (this != &__x)
 {


   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       auto& __this_alloc = this->_M_get_Node_allocator();
       auto& __that_alloc = __x._M_get_Node_allocator();
       if (!_Alloc_traits::_S_always_equal()
    && __this_alloc != __that_alloc)
  {


    clear();
    std::__alloc_on_copy(__this_alloc, __that_alloc);
  }
     }


   _Reuse_or_alloc_node __roan(*this);
   _M_impl._M_reset();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     _M_root() = _M_copy(__x, __roan);
 }

      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_(_Base_ptr __x, _Base_ptr __p,

   _Arg&& __v,



   _NodeGen& __node_gen)
      {
 bool __insert_left = (__x != 0 || __p == _M_end()
         || _M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key(__p)));

 _Link_type __z = __node_gen(std::forward<_Arg>(__v));

 _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
          this->_M_impl._M_header);
 ++_M_impl._M_node_count;
 return iterator(__z);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_lower(_Base_ptr __p, _Arg&& __v)



    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node(std::forward<_Arg>(__v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_equal_lower(_Arg&& __v)



    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__y, std::forward<_Arg>(__v));
    }

  template<typename _Key, typename _Val, typename _KoV,
    typename _Compare, typename _Alloc>
    template<typename _NodeGen>
      typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
      _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
      _M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen& __node_gen)
      {

 _Link_type __top = _M_clone_node(__x, __node_gen);
 __top->_M_parent = __p;

 try
   {
     if (__x->_M_right)
       __top->_M_right = _M_copy(_S_right(__x), __top, __node_gen);
     __p = __top;
     __x = _S_left(__x);

     while (__x != 0)
       {
  _Link_type __y = _M_clone_node(__x, __node_gen);
  __p->_M_left = __y;
  __y->_M_parent = __p;
  if (__x->_M_right)
    __y->_M_right = _M_copy(_S_right(__x), __y, __node_gen);
  __p = __y;
  __x = _S_left(__x);
       }
   }
 catch(...)
   {
     _M_erase(__top);
     throw;
   }
 return __top;
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_drop_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Base_ptr __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Base_ptr __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x);
       _Base_ptr __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
            iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Base_ptr __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x);
       _Const_Base_ptr __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
            const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree& __t)
    noexcept(__is_nothrow_swappable<_Compare>::value)
    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     _M_impl._M_move_data(__t._M_impl);
 }
      else if (__t._M_root() == 0)
 __t._M_impl._M_move_data(_M_impl);
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
   std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
 }

      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);

      _Alloc_traits::_S_on_swap(_M_get_Node_allocator(),
    __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_unique_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(__k, _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return _Res(__x, __y);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
 return _Res(__x, __y);
      return _Res(__j._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_equal_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _Res(__x, __y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_unique(_Arg&& __v)



    {
      typedef pair<iterator, bool> _Res;
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_unique_pos(_KeyOfValue()(__v));

      if (__res.second)
 {
   _Alloc_node __an(*this);
   return _Res(_M_insert_(__res.first, __res.second,
     std::forward<_Arg>(__v), __an),
        true);
 }

      return _Res(iterator(__res.first), false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_equal(_Arg&& __v)



    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_equal_pos(_KeyOfValue()(__v));
      _Alloc_node __an(*this);
      return _M_insert_(__res.first, __res.second,
   std::forward<_Arg>(__v), __an);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
         typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_unique_pos(const_iterator __position,
      const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else

 return _Res(__pos._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_unique_(const_iterator __position,

   _Arg&& __v,



   _NodeGen& __node_gen)
    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));

      if (__res.second)
 return _M_insert_(__res.first, __res.second,
     std::forward<_Arg>(__v),
     __node_gen);
      return iterator(__res.first);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
         typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_equal_pos(__k);
 }
      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_equal_pos(__k);
 }
      else
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _Res(0, 0);
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_equal_(const_iterator __position,

         _Arg&& __v,



         _NodeGen& __node_gen)
      {
 pair<_Base_ptr, _Base_ptr> __res
   = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));

 if (__res.second)
   return _M_insert_(__res.first, __res.second,
       std::forward<_Arg>(__v),
       __node_gen);

 return _M_insert_equal_lower(std::forward<_Arg>(__v));
      }


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_S_key(__z),
            _S_key(__p)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_lower_node(_Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _S_key(__z)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_lower_node(_Link_type __z)
    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _S_key(__z)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower_node(__y, __z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator, bool>
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_unique(_Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     typedef pair<iterator, bool> _Res;
     auto __res = _M_get_insert_unique_pos(_S_key(__z));
     if (__res.second)
       return _Res(_M_insert_node(__res.first, __res.second, __z), true);

     _M_drop_node(__z);
     return _Res(iterator(__res.first), false);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_equal(_Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_equal_pos(_S_key(__z));
     return _M_insert_node(__res.first, __res.second, __z);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));

     if (__res.second)
       return _M_insert_node(__res.first, __res.second, __z);

     _M_drop_node(__z);
     return iterator(__res.first);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_hint_equal_pos(__pos, _S_key(__z));

     if (__res.second)
       return _M_insert_node(__res.first, __res.second, __z);

     return _M_insert_equal_lower_node(__z);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }


  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 _Alloc_node __an(*this);
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first, __an);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 _Alloc_node __an(*this);
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first, __an);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_drop_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   _M_erase_aux(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      _M_erase_aux(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  __attribute__ ((__pure__)) unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root) throw ();

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }
# 2611 "/usr/include/c++/7/bits/stl_tree.h" 3

}
# 61 "/usr/include/c++/7/set" 2 3
# 1 "/usr/include/c++/7/bits/stl_set.h" 1 3
# 64 "/usr/include/c++/7/bits/stl_set.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Key, typename _Compare, typename _Alloc>
    class multiset;
# 91 "/usr/include/c++/7/bits/stl_set.h" 3
  template<typename _Key, typename _Compare = std::less<_Key>,
    typename _Alloc = std::allocator<_Key> >
    class set
    {
# 106 "/usr/include/c++/7/bits/stl_set.h" 3
    public:



      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;


    private:
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;
      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;

    public:


      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
# 157 "/usr/include/c++/7/bits/stl_set.h" 3
      set() = default;







      explicit
      set(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a)) { }
# 180 "/usr/include/c++/7/bits/stl_set.h" 3
      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_unique(__first, __last); }
# 197 "/usr/include/c++/7/bits/stl_set.h" 3
      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Key_alloc_type(__a))
 { _M_t._M_insert_unique(__first, __last); }
# 213 "/usr/include/c++/7/bits/stl_set.h" 3
      set(const set&) = default;







      set(set&&) = default;
# 233 "/usr/include/c++/7/bits/stl_set.h" 3
      set(initializer_list<value_type> __l,
   const _Compare& __comp = _Compare(),
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }


      explicit
      set(const allocator_type& __a)
      : _M_t(_Compare(), _Key_alloc_type(__a)) { }


      set(const set& __x, const allocator_type& __a)
      : _M_t(__x._M_t, _Key_alloc_type(__a)) { }


      set(set&& __x, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__x._M_t), _Key_alloc_type(__a)) { }


      set(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Key_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }


      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last,
     const allocator_type& __a)
 : _M_t(_Compare(), _Key_alloc_type(__a))
 { _M_t._M_insert_unique(__first, __last); }






      ~set() = default;
# 287 "/usr/include/c++/7/bits/stl_set.h" 3
      set&
      operator=(const set&) = default;


      set&
      operator=(set&&) = default;
# 305 "/usr/include/c++/7/bits/stl_set.h" 3
      set&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_unique(__l.begin(), __l.end());
 return *this;
      }





      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }






      iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      iterator
      cend() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }



      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 430 "/usr/include/c++/7/bits/stl_set.h" 3
      void
      swap(set& __x)
      noexcept(__is_nothrow_swappable<_Compare>::value)
      { _M_t.swap(__x._M_t); }
# 450 "/usr/include/c++/7/bits/stl_set.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
# 476 "/usr/include/c++/7/bits/stl_set.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_unique(__pos,
          std::forward<_Args>(__args)...);
 }
# 498 "/usr/include/c++/7/bits/stl_set.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(__x);
 return std::pair<iterator, bool>(__p.first, __p.second);
      }


      std::pair<iterator, bool>
      insert(value_type&& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(std::move(__x));
 return std::pair<iterator, bool>(__p.first, __p.second);
      }
# 535 "/usr/include/c++/7/bits/stl_set.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }


      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_unique_(__position, std::move(__x)); }
# 554 "/usr/include/c++/7/bits/stl_set.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_unique(__first, __last); }
# 567 "/usr/include/c++/7/bits/stl_set.h" 3
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
# 642 "/usr/include/c++/7/bits/stl_set.h" 3
      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }
# 673 "/usr/include/c++/7/bits/stl_set.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 694 "/usr/include/c++/7/bits/stl_set.h" 3
      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 722 "/usr/include/c++/7/bits/stl_set.h" 3
      void
      clear() noexcept
      { _M_t.clear(); }
# 737 "/usr/include/c++/7/bits/stl_set.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }


      template<typename _Kt>
 auto
 count(const _Kt& __x) const
 -> decltype(_M_t._M_count_tr(__x))
 { return _M_t._M_count_tr(__x); }
# 764 "/usr/include/c++/7/bits/stl_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x)
 -> decltype(iterator{_M_t._M_find_tr(__x)})
 { return iterator{_M_t._M_find_tr(__x)}; }

      template<typename _Kt>
 auto
 find(const _Kt& __x) const
 -> decltype(const_iterator{_M_t._M_find_tr(__x)})
 { return const_iterator{_M_t._M_find_tr(__x)}; }
# 799 "/usr/include/c++/7/bits/stl_set.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x)
 -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
 { return iterator(_M_t._M_lower_bound_tr(__x)); }

      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x) const
 -> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
 { return const_iterator(_M_t._M_lower_bound_tr(__x)); }
# 829 "/usr/include/c++/7/bits/stl_set.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x)
 -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 { return iterator(_M_t._M_upper_bound_tr(__x)); }

      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x) const
 -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 { return const_iterator(_M_t._M_upper_bound_tr(__x)); }
# 868 "/usr/include/c++/7/bits/stl_set.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x)
 -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }

      template<typename _Kt>
 auto
 equal_range(const _Kt& __x) const
 -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }



      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
    };
# 911 "/usr/include/c++/7/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 928 "/usr/include/c++/7/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


# 992 "/usr/include/c++/7/bits/stl_set.h" 3
}
# 62 "/usr/include/c++/7/set" 2 3
# 1 "/usr/include/c++/7/bits/stl_multiset.h" 1 3
# 64 "/usr/include/c++/7/bits/stl_multiset.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Key, typename _Compare, typename _Alloc>
    class set;
# 93 "/usr/include/c++/7/bits/stl_multiset.h" 3
  template <typename _Key, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<_Key> >
    class multiset
    {
# 108 "/usr/include/c++/7/bits/stl_multiset.h" 3
    public:

      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;

      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;

    public:
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
# 154 "/usr/include/c++/7/bits/stl_multiset.h" 3
      multiset() = default;







      explicit
      multiset(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a)) { }
# 176 "/usr/include/c++/7/bits/stl_multiset.h" 3
      template<typename _InputIterator>
 multiset(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_equal(__first, __last); }
# 192 "/usr/include/c++/7/bits/stl_multiset.h" 3
      template<typename _InputIterator>
 multiset(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Key_alloc_type(__a))
 { _M_t._M_insert_equal(__first, __last); }
# 208 "/usr/include/c++/7/bits/stl_multiset.h" 3
      multiset(const multiset&) = default;
# 217 "/usr/include/c++/7/bits/stl_multiset.h" 3
      multiset(multiset&&) = default;
# 229 "/usr/include/c++/7/bits/stl_multiset.h" 3
      multiset(initializer_list<value_type> __l,
        const _Compare& __comp = _Compare(),
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }


      explicit
      multiset(const allocator_type& __a)
      : _M_t(_Compare(), _Key_alloc_type(__a)) { }


      multiset(const multiset& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Key_alloc_type(__a)) { }


      multiset(multiset&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Key_alloc_type(__a)) { }


      multiset(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Key_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }


      template<typename _InputIterator>
 multiset(_InputIterator __first, _InputIterator __last,
   const allocator_type& __a)
 : _M_t(_Compare(), _Key_alloc_type(__a))
 { _M_t._M_insert_equal(__first, __last); }






      ~multiset() = default;
# 283 "/usr/include/c++/7/bits/stl_multiset.h" 3
      multiset&
      operator=(const multiset&) = default;


      multiset&
      operator=(multiset&&) = default;
# 301 "/usr/include/c++/7/bits/stl_multiset.h" 3
      multiset&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_equal(__l.begin(), __l.end());
 return *this;
      }





      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }






      iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      iterator
      cend() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }



      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 426 "/usr/include/c++/7/bits/stl_multiset.h" 3
      void
      swap(multiset& __x)
      noexcept(__is_nothrow_swappable<_Compare>::value)
      { _M_t.swap(__x._M_t); }
# 445 "/usr/include/c++/7/bits/stl_multiset.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }
# 471 "/usr/include/c++/7/bits/stl_multiset.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_equal(__pos,
         std::forward<_Args>(__args)...);
 }
# 491 "/usr/include/c++/7/bits/stl_multiset.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }


      iterator
      insert(value_type&& __x)
      { return _M_t._M_insert_equal(std::move(__x)); }
# 521 "/usr/include/c++/7/bits/stl_multiset.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }


      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_equal_(__position, std::move(__x)); }
# 539 "/usr/include/c++/7/bits/stl_multiset.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_equal(__first, __last); }
# 552 "/usr/include/c++/7/bits/stl_multiset.h" 3
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
# 627 "/usr/include/c++/7/bits/stl_multiset.h" 3
      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }
# 658 "/usr/include/c++/7/bits/stl_multiset.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 679 "/usr/include/c++/7/bits/stl_multiset.h" 3
      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 707 "/usr/include/c++/7/bits/stl_multiset.h" 3
      void
      clear() noexcept
      { _M_t.clear(); }
# 719 "/usr/include/c++/7/bits/stl_multiset.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }


      template<typename _Kt>
 auto
 count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 { return _M_t._M_count_tr(__x); }
# 745 "/usr/include/c++/7/bits/stl_multiset.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x)
 -> decltype(iterator{_M_t._M_find_tr(__x)})
 { return iterator{_M_t._M_find_tr(__x)}; }

      template<typename _Kt>
 auto
 find(const _Kt& __x) const
 -> decltype(const_iterator{_M_t._M_find_tr(__x)})
 { return const_iterator{_M_t._M_find_tr(__x)}; }
# 780 "/usr/include/c++/7/bits/stl_multiset.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x)
 -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
 { return iterator(_M_t._M_lower_bound_tr(__x)); }

      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x) const
 -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
 { return iterator(_M_t._M_lower_bound_tr(__x)); }
# 810 "/usr/include/c++/7/bits/stl_multiset.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x)
 -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 { return iterator(_M_t._M_upper_bound_tr(__x)); }

      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x) const
 -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 { return iterator(_M_t._M_upper_bound_tr(__x)); }
# 849 "/usr/include/c++/7/bits/stl_multiset.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x)
 -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }

      template<typename _Kt>
 auto
 equal_range(const _Kt& __x) const
 -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }



      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator==(const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator< (const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);
    };
# 894 "/usr/include/c++/7/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 911 "/usr/include/c++/7/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
       const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>& __x,
  multiset<_Key, _Compare, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


# 977 "/usr/include/c++/7/bits/stl_multiset.h" 3
}
# 63 "/usr/include/c++/7/set" 2 3
# 17 "/usr/local/include/ibex/ibex_DirectedHyperGraph.h" 2 3

namespace ibex {






class DirectedHyperGraph {
public:




 DirectedHyperGraph(int nb_ctr, int nb_var);




 ~DirectedHyperGraph();




  int nb_ctr() const;




  int nb_var() const;
# 55 "/usr/local/include/ibex/ibex_DirectedHyperGraph.h" 3
 void add_arc(int ctr, int var, bool incoming);





  const std::set<int>& input_vars(int ctr) const;





  const std::set<int>& output_vars(int ctr) const;






  const std::set<int>& input_ctrs(int var) const;






  const std::set<int>& output_ctrs(int var) const;






 friend std::ostream& operator<<(std::ostream& os, const DirectedHyperGraph& a);

private:
 DirectedHyperGraph(const DirectedHyperGraph&);

 const int m;
 const int n;
 std::set<int> *ctr_input_adj;
 std::set<int> *ctr_output_adj;
 std::set<int> *var_input_adj;
 std::set<int> *var_output_adj;
};




inline DirectedHyperGraph::DirectedHyperGraph(int nb_ctr, int nb_var) : m(nb_ctr), n(nb_var) {
 ctr_input_adj = new std::set<int>[m];
 ctr_output_adj = new std::set<int>[m];
 var_input_adj = new std::set<int>[n];
 var_output_adj = new std::set<int>[n];
}

inline DirectedHyperGraph::~DirectedHyperGraph() {
 delete[] ctr_input_adj;
 delete[] ctr_output_adj;
 delete[] var_input_adj;
 delete[] var_output_adj;
}

inline int DirectedHyperGraph::nb_ctr() const {
 return m;
}

inline int DirectedHyperGraph::nb_var() const {
 return n;
}

inline void DirectedHyperGraph::add_arc(int ctr, int var, bool incoming) {
 if (incoming) {
  ctr_input_adj[ctr].insert(var);
  var_output_adj[var].insert(ctr);
 } else {
  ctr_output_adj[ctr].insert(var);
  var_input_adj[var].insert(ctr);
 }
}

inline const std::set<int>& DirectedHyperGraph::input_vars(int ctr) const {
 return ctr_input_adj[ctr];
}

inline const std::set<int>& DirectedHyperGraph::output_vars(int ctr) const {
 return ctr_output_adj[ctr];
}

inline const std::set<int>& DirectedHyperGraph::input_ctrs(int var) const {
 return var_input_adj[var];
}

inline const std::set<int>& DirectedHyperGraph::output_ctrs(int var) const {
 return var_output_adj[var];
}

}
# 18 "/usr/local/include/ibex/ibex_CtcPropag.h" 2 3


namespace ibex {
# 31 "/usr/local/include/ibex/ibex_CtcPropag.h" 3
class CtcPropag : public Ctc {
public:
# 47 "/usr/local/include/ibex/ibex_CtcPropag.h" 3
 CtcPropag(const Array<Ctc>& cl, double ratio=default_ratio, bool incr=false);
# 60 "/usr/local/include/ibex/ibex_CtcPropag.h" 3
 virtual void contract(IntervalVector& box);


 Array<Ctc> list;


 const double ratio;


 const bool incremental;


 bool accumulate;


 static const double default_ratio;

protected:


 DirectedHyperGraph g;

 Agenda agenda;

 BitSet _impact;

 BitSet flags;

 BitSet active;


};

}
# 15 "/usr/local/include/ibex/ibex_CtcHC4.h" 2 3



namespace ibex {






class CtcHC4 : public CtcPropag {
  public:






  CtcHC4(const Array<NumConstraint>& csp, double ratio=default_ratio, bool incremental=false);







  CtcHC4(const System& sys, double ratio=default_ratio, bool incremental=false);




  ~CtcHC4();
};


}
# 44 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcIdentity.h" 1 3
# 16 "/usr/local/include/ibex/ibex_CtcIdentity.h" 3
namespace ibex {





class CtcIdentity : public Ctc {
public:




 CtcIdentity(int n);




 virtual void contract(IntervalVector& box);
};

}
# 45 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcInteger.h" 1 3
# 16 "/usr/local/include/ibex/ibex_CtcInteger.h" 3
namespace ibex {
# 26 "/usr/local/include/ibex/ibex_CtcInteger.h" 3
class CtcInteger : public Ctc {
public:



 CtcInteger(int nb_var, const BitSet& is_int);




 ~CtcInteger();

 virtual void contract(IntervalVector& box);



 virtual bool idempotent();




 BitSet is_int;
};

}
# 46 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcInverse.h" 1 3
# 17 "/usr/local/include/ibex/ibex_CtcInverse.h" 3
namespace ibex {

class CtcInverse : public Ctc {
public:
 CtcInverse(Ctc& c, Function& f);
 ~CtcInverse();
 virtual void contract(IntervalVector& box);

 Ctc& c;
 Function& f;

private:
 Function *id;
 IntervalVector y;
};

}
# 47 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcMohc.h" 1 3
# 16 "/usr/local/include/ibex/ibex_CtcMohc.h" 3
# 1 "/usr/local/include/ibex/ibex_ExprSplitOcc.h" 1 3
# 15 "/usr/local/include/ibex/ibex_ExprSplitOcc.h" 3
# 1 "/usr/local/include/ibex/ibex_ExprCopy.h" 1 3
# 20 "/usr/local/include/ibex/ibex_ExprCopy.h" 3
namespace ibex {
# 30 "/usr/local/include/ibex/ibex_ExprCopy.h" 3
void varcopy(const Array<const ExprSymbol>& src, Array<const ExprSymbol>& dest);





bool varequals(const Array<const ExprSymbol>& args1, Array<const ExprSymbol>& args2);





class ExprCopy : public virtual ExprVisitor {

public:
# 58 "/usr/local/include/ibex/ibex_ExprCopy.h" 3
 const ExprNode& copy(const Array<const ExprSymbol>& old_x, const Array<const ExprNode>& new_x, const ExprNode& y, bool fold_cst=false);






 const ExprNode& copy(const Array<const ExprSymbol>& old_x, const Array<const ExprSymbol>& new_x, const ExprNode& y, bool fold_cst=false);







 const ExprNode& index_copy(const Array<const ExprSymbol>& old_x, const Array<const ExprNode>& new_x, const ExprNode& y, int i, bool fold_cst=false);






 const ExprNode& index_copy(const Array<const ExprSymbol>& old_x, const Array<const ExprSymbol>& new_x, const ExprNode& y, int i, bool fold_cst=false);
# 89 "/usr/local/include/ibex/ibex_ExprCopy.h" 3
 const ExprNode& index_copy(const Array<const ExprSymbol>& old_x, const Array<const ExprNode>& new_x, const ExprNode& y, int i, int j, bool fold_cst=false);






 const ExprNode& index_copy(const Array<const ExprSymbol>& old_x, const Array<const ExprSymbol>& new_x, const ExprNode& y, int i, int j, bool fold_cst=false);

protected:
 void visit(const ExprNode& e);
 void visit(const ExprIndex& i);
 void visit(const ExprNAryOp& e);
 void visit(const ExprLeaf& e);
 void visit(const ExprBinaryOp& b);
 void visit(const ExprUnaryOp& u);
 void visit(const ExprSymbol& x);
 void visit(const ExprConstant& c);
 void visit(const ExprVector& e);
 void visit(const ExprApply& e);
 void visit(const ExprChi& e);
 void visit(const ExprAdd& e);
 void visit(const ExprMul& e);
 void visit(const ExprSub& e);
 void visit(const ExprDiv& e);
 void visit(const ExprMax& e);
 void visit(const ExprMin& e);
 void visit(const ExprAtan2& e);
 void visit(const ExprMinus& e);
 void visit(const ExprTrans& e);
 void visit(const ExprSign& e);
 void visit(const ExprAbs& e);
 void visit(const ExprPower& e);
 void visit(const ExprSqr& e);
 void visit(const ExprSqrt& e);
 void visit(const ExprExp& e);
 void visit(const ExprLog& e);
 void visit(const ExprCos& e);
 void visit(const ExprSin& e);
 void visit(const ExprTan& e);
 void visit(const ExprCosh& e);
 void visit(const ExprSinh& e);
 void visit(const ExprTanh& e);
 void visit(const ExprAcos& e);
 void visit(const ExprAsin& e);
 void visit(const ExprAtan& e);
 void visit(const ExprAcosh& e);
 void visit(const ExprAsinh& e);
 void visit(const ExprAtanh& e);

 bool fold;
 NodeMap<const ExprNode*> clone;
# 153 "/usr/local/include/ibex/ibex_ExprCopy.h" 3
 NodeMap<bool> used;

 void mark(const ExprNode&);
 bool unary_copy(const ExprUnaryOp& e, Domain (*fcst)(const Domain&));
 bool binary_copy(const ExprBinaryOp& e, Domain (*fcst)(const Domain&, const Domain&));
};






inline const ExprNode& ExprCopy::index_copy(const Array<const ExprSymbol>& old_x, const Array<const ExprSymbol>& new_x, const ExprNode& y, int i, bool fold_cst) {
 return index_copy(old_x, (const Array<const ExprNode>&) new_x, y, i, fold_cst);
}


inline const ExprNode& ExprCopy::index_copy(const Array<const ExprSymbol>& old_x, const Array<const ExprSymbol>& new_x, const ExprNode& y, int i, int j, bool fold_cst) {
 return index_copy(old_x, (const Array<const ExprNode>&) new_x, y, i, j, fold_cst);
}

inline const ExprNode& ExprCopy::copy(const Array<const ExprSymbol>& old_x, const Array<const ExprSymbol>& new_x, const ExprNode& y, bool fold_cst) {
 return this->copy(old_x, (const Array<const ExprNode>&) new_x, y, fold_cst);
}


}
# 16 "/usr/local/include/ibex/ibex_ExprSplitOcc.h" 2 3
# 44 "/usr/local/include/ibex/ibex_ExprSplitOcc.h" 3
namespace ibex {
# 55 "/usr/local/include/ibex/ibex_ExprSplitOcc.h" 3
class ExprSplitOcc: public virtual ExprVisitor {
public:




 ExprSplitOcc(const Array<const ExprSymbol>& x, const ExprNode& y);




 const Array<const ExprSymbol>& get_x() const;




 const ExprNode& get_y() const;







 const ExprNode& node(const ExprSymbol& x) const;
# 91 "/usr/local/include/ibex/ibex_ExprSplitOcc.h" 3
 int var_map(int*& var) const;




 virtual ~ExprSplitOcc();

protected:
 void visit(const ExprNode& e);
 void visit(const ExprIndex& i);
 void visit(const ExprNAryOp& e);
 void visit(const ExprLeaf& e);
 void visit(const ExprBinaryOp& b);
 void visit(const ExprUnaryOp& u);
 void visit(const ExprSymbol& x);
 void visit(const ExprConstant& x);

 void visit(const ExprVector& e);
 void visit(const ExprApply& e);
 void visit(const ExprChi& e);
 void visit(const ExprAdd& e);
 void visit(const ExprMul& e);
 void visit(const ExprSub& e);
 void visit(const ExprDiv& e);
 void visit(const ExprMax& e);
 void visit(const ExprMin& e);
 void visit(const ExprAtan2& e);
 void visit(const ExprMinus& e);
 void visit(const ExprTrans& e);
 void visit(const ExprSign& e);
 void visit(const ExprAbs& e);
 void visit(const ExprPower& e);
 void visit(const ExprSqr& e);
 void visit(const ExprSqrt& e);
 void visit(const ExprExp& e);
 void visit(const ExprLog& e);
 void visit(const ExprCos& e);
 void visit(const ExprSin& e);
 void visit(const ExprTan& e);
 void visit(const ExprCosh& e);
 void visit(const ExprSinh& e);
 void visit(const ExprTanh& e);
 void visit(const ExprAcos& e);
 void visit(const ExprAsin& e);
 void visit(const ExprAtan& e);
 void visit(const ExprAcosh& e);
 void visit(const ExprAsinh& e);
 void visit(const ExprAtanh& e);







 struct IndexClone {
  IndexClone() : nb_clones(0), clones(__null), clone_counter(0) { }



  int nb_clones;


  std::vector<const ExprNode*> nodes;


  const ExprNode** clones;


  int clone_counter;
 };







 struct SymbolClone {
  SymbolClone() : nb_clones(0), clones(__null), clone_counter(0), special_clone(__null) { }


  int nb_clones;


  const ExprSymbol** clones;




  int clone_counter;




  const ExprSymbol* special_clone;

  std::tr1::unordered_map<int,IndexClone*> indices;
 };






 NodeMap<const ExprNode*> clone;


 const Array<const ExprSymbol> old_x;


 const ExprNode& old_y;


 Array<const ExprSymbol> new_x;


 NodeMap<SymbolClone*> symbol_clone;
# 218 "/usr/local/include/ibex/ibex_ExprSplitOcc.h" 3
 NodeMap<const ExprNode*> maps_to;

 void nary_copy(const ExprNAryOp& e, const ExprNode& (*f)(const Array<const ExprNode>&));
 void binary_copy(const ExprBinaryOp& e, const ExprNode& (*f)(const ExprNode&, const ExprNode&));
 void unary_copy(const ExprUnaryOp& e, const ExprNode& (*f)(const ExprNode&));
};



inline const Array<const ExprSymbol>& ExprSplitOcc::get_x() const {
 return new_x;
}

inline const ExprNode& ExprSplitOcc::get_y() const {
 return *(((ExprSplitOcc*) this)->clone[old_y]);
}

inline const ExprNode& ExprSplitOcc::node(const ExprSymbol& x) const {
 return *maps_to[x];
}

}
# 17 "/usr/local/include/ibex/ibex_CtcMohc.h" 2 3






namespace ibex {

class CtcMohcRevise;
# 43 "/usr/local/include/ibex/ibex_CtcMohc.h" 3
class Function_OG {
 friend class CtcMohcRevise;

public:







 Function_OG(const Function& f);
# 65 "/usr/local/include/ibex/ibex_CtcMohc.h" 3
 bool occurrence_grouping(IntervalVector& box, bool y_set=false, bool _og=true);


 Interval eval(IntervalVector& box);





 Interval eval(IntervalVector& box, bool minrevise);


 Interval revise(IntervalVector& box, bool minrevise);


private:

 void set_ra(int i, Interval val);
 void set_rb(int i, Interval val);
 void set_rc(int i, Interval val);

 bool gradient(IntervalVector& box);

 bool occurrence_grouping(int i, bool _og);

 void _eval_leaves(IntervalVector& box, bool minrevise);
 void _proj_leaves(IntervalVector& box);


 void _setbox(IntervalVector& box);

 void OG_case1(int i);
 void OG_case2(int i, Interval inf_G_Xa, Interval inf_G_Xb, Interval sup_G_Xa, Interval sup_G_Xb);
 void OG_case3(std::list<int>& X_m, std::list<int>& X_nm, Interval& G_m);

 ExprSplitOcc eso;
 Function _f;

 IntervalVector r_a;
 IntervalVector r_b;
 IntervalVector r_c;



 std::vector<int>* occ;

 IntervalVector _box;


 IntervalVector _g;


 IntervalVector g;


 IntervalVector ga;


 IntervalVector gb;



 IntervalVector aux;


 Interval Newton_it(Interval b, double x_m, double f_m, int i);
 Interval Newton_it(Interval b, double x_m, double f_m, int i, bool increasing);
 Interval Newton_it_cert(Interval b, double x_m, double f_m, int i);
 void MonoUnivNewton(IntervalVector& box, int i, Interval& b, bool minEval, double w, double min_width);


};
# 147 "/usr/local/include/ibex/ibex_CtcMohc.h" 3
class CtcMohcRevise : public Ctc {

public:
# 160 "/usr/local/include/ibex/ibex_CtcMohc.h" 3
 CtcMohcRevise(const NumConstraint& ctr, double epsilon, double univ_newton_min_width,
   double tau_mohc, bool amohc);


 virtual void contract(IntervalVector& box);


 const NumConstraint ctr;


 Function_OG fog;


 void LazyNarrow();


 void MonoBoxNarrow();





 void MonoBoxNarrow(int i);





 int active_mono_proc;





 static bool _minmax;
 static bool _monobox;
 static bool _opt;
 static bool _og;
 static bool _mohc2;




private:


 void LeftNarrow(int i);
 void RightNarrow(int i);
 void initLeftNarrow(int i);
 void initRightNarrow(int i);


 void initLeftNarrowFmin(int i);
 void initLeftNarrowFmax(int i);
 void initRightNarrowFmin(int i);
 void initRightNarrowFmax(int i);

 void LeftNarrowFmin(int i);
 void LeftNarrowFmax(int i);
 void RightNarrowFmin(int i);
 void RightNarrowFmax(int i);

 void initialize_apply();
 void apply_fmax_to_false_except(int i);
 void apply_fmin_to_false_except(int i);

 bool hasMultOcc(Function &f);
 bool _existence_test(int i);

 void update_active_mono_proc(Interval& z);

 enum _3vl {MAYBE,YES,NO};
 _3vl* ApplyFmin;
 _3vl* ApplyFmax;



 IntervalVector LB;
 IntervalVector RB;

 Interval zmin,zmax;
 IntervalVector box;

 double tau_mohc;
 double epsilon;
 double univ_newton_min_width;
 bool amohc;


};
# 271 "/usr/local/include/ibex/ibex_CtcMohc.h" 3
class CtcMohc : public CtcPropag {
public:
# 288 "/usr/local/include/ibex/ibex_CtcMohc.h" 3
 CtcMohc(const Array<NumConstraint>& csp, double ratio=default_ratio, bool incremental=false, double epsilon=default_epsilon,
   double univ_newton_min_width=default_univ_newton_min_width, double tau_mohc=ADAPTIVE);
# 321 "/usr/local/include/ibex/ibex_CtcMohc.h" 3
 CtcMohc(const Array<NumConstraint>& csp, int* active_mono_proc, double ratio=default_ratio, bool incremental=false, double epsilon=default_epsilon,
   double univ_newton_min_width=default_univ_newton_min_width);

 ~CtcMohc();

 static const double ADAPTIVE;


 virtual void contract(IntervalVector& box){





  for(int i=0;i<list.size();i++){
   CtcMohcRevise* ctc= dynamic_cast<CtcMohcRevise*>(&list[i]);
   ctc->active_mono_proc=(update_active_mono_proc)? -1:active_mono_proc[i];
  }

  CtcPropag::contract(box);


  for(int i=0;i<list.size();i++){
   CtcMohcRevise* ctc= dynamic_cast<CtcMohcRevise*>(&list[i]);
   active_mono_proc[i]=ctc->active_mono_proc;
  }

 }


 static const double default_tau_mohc;


 static const double default_epsilon;


 static const double default_univ_newton_min_width;



 static const double RHO_INTERESTING;
 static const double TAU_FREQ;


 static int nb_calls;
 static int nb_interesting;







 int* active_mono_proc;




private:



 bool update_active_mono_proc;

};
}
# 48 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcNewton.h" 1 3
# 15 "/usr/local/include/ibex/ibex_CtcNewton.h" 3
# 1 "/usr/local/include/ibex/ibex_Newton.h" 1 3
# 17 "/usr/local/include/ibex/ibex_Newton.h" 3
namespace ibex {




extern double default_newton_prec;




extern double default_gauss_seidel_ratio;
# 47 "/usr/local/include/ibex/ibex_Newton.h" 3
bool newton(const Function& f, IntervalVector& box, double prec=default_newton_prec, double gauss_seidel_ratio=default_gauss_seidel_ratio);




bool newton(const Function& f, const VarSet& vars, IntervalVector& full_box, double prec=default_newton_prec, double gauss_seidel_ratio=default_gauss_seidel_ratio);
# 85 "/usr/local/include/ibex/ibex_Newton.h" 3
bool inflating_newton(const Function& f, IntervalVector& box,
  int k_max_iteration=15, double mu_max_divergence=1.0,
  double delta_relative_inflat=1.1, double chi_absolute_inflat=1e-12);
# 98 "/usr/local/include/ibex/ibex_Newton.h" 3
bool inflating_newton(const Function& f, const VarSet& vars, IntervalVector& full_box,
  int k_max_iteration=15, double mu_max_divergence=1.0,
  double delta_relative_inflat=1.1, double chi_absolute_inflat=1e-12);


}
# 16 "/usr/local/include/ibex/ibex_CtcNewton.h" 2 3


namespace ibex {





class CtcNewton : public Ctc {
public:
# 35 "/usr/local/include/ibex/ibex_CtcNewton.h" 3
 CtcNewton(const Function& f,
   double ceil=default_ceil,
   double prec=default_newton_prec,
   double ratio=default_gauss_seidel_ratio);





 CtcNewton(const Function& f, const VarSet& vars,
   double ceil=default_ceil,
   double prec=default_newton_prec,
   double ratio=default_gauss_seidel_ratio);

 void contract(IntervalVector& box);


 const Function& f;







 const VarSet* vars;


 const double ceil;

 const double prec;

 const double gauss_seidel_ratio;


 static const double default_ceil;

};

}
# 49 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcNotIn.h" 1 3
# 17 "/usr/local/include/ibex/ibex_CtcNotIn.h" 3
namespace ibex {







class CtcNotIn : public Ctc {
public:



 CtcNotIn(Function& f, const Domain& y);




 CtcNotIn(Function& f, const Interval& y);




 CtcNotIn(Function& f, const IntervalVector& y);




 CtcNotIn(Function& f, const IntervalMatrix& y);




 ~CtcNotIn();




 virtual void contract(IntervalVector& box);

protected:
 Function& f;






 int diff_size;

 Ctc* _union;

 void init(const Interval& y);

 void init(const IntervalVector& y);

 void init(const IntervalMatrix& y);
};

}
# 50 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcOptimShaving.h" 1 3
# 20 "/usr/local/include/ibex/ibex_CtcOptimShaving.h" 3
namespace ibex {

  class CtcOptimShaving: public Ctc3BCid {
  public:
   CtcOptimShaving(Ctc& ctc, int s3b=default_s3b, int scid=default_scid,
   int vhandled=-1, double var_min_width=default_var_min_width);

   virtual void contract(IntervalVector& box);
 static const int LimitCIDDichotomy;
  protected:
 virtual bool var3BCID_dicho(IntervalVector& box, int var, double wv);
 virtual bool var3BCID_slices(IntervalVector& box, int var, int locs3b, double w_DC, Interval & dom);
 virtual int limitCIDDichotomy () ;
  };


}
# 51 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcPixelMap.h" 1 3
# 16 "/usr/local/include/ibex/ibex_CtcPixelMap.h" 3
# 1 "/usr/local/include/ibex/ibex_PixelMap.h" 1 3
# 13 "/usr/local/include/ibex/ibex_PixelMap.h" 3
# 1 "/usr/include/c++/7/fstream" 1 3
# 36 "/usr/include/c++/7/fstream" 3
       
# 37 "/usr/include/c++/7/fstream" 3



# 1 "/usr/include/c++/7/bits/codecvt.h" 1 3
# 39 "/usr/include/c++/7/bits/codecvt.h" 3
       
# 40 "/usr/include/c++/7/bits/codecvt.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 67 "/usr/include/c++/7/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 115 "/usr/include/c++/7/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 154 "/usr/include/c++/7/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 195 "/usr/include/c++/7/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 236 "/usr/include/c++/7/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };
# 273 "/usr/include/c++/7/bits/codecvt.h" 3
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),
 _M_c_locale_codecvt(0)
      { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
      friend class messages<char>;

    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };






  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
      friend class messages<wchar_t>;

    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };
# 467 "/usr/include/c++/7/bits/codecvt.h" 3
  template<>
    class codecvt<char16_t, char, mbstate_t>
    : public __codecvt_abstract_base<char16_t, char, mbstate_t>
    {
    public:

      typedef char16_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char16_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<>
    class codecvt<char32_t, char, mbstate_t>
    : public __codecvt_abstract_base<char32_t, char, mbstate_t>
    {
    public:

      typedef char32_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char32_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }


      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~codecvt_byname() { }
    };


  template<>
    class codecvt_byname<char16_t, char, mbstate_t>
    : public codecvt<char16_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<char16_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };

  template<>
    class codecvt_byname<char32_t, char, mbstate_t>
    : public codecvt<char32_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<char32_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };





  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);



  extern template class codecvt_byname<char16_t, char, mbstate_t>;
  extern template class codecvt_byname<char32_t, char, mbstate_t>;





}
# 41 "/usr/include/c++/7/fstream" 2 3
# 1 "/usr/include/c++/7/cstdio" 1 3
# 39 "/usr/include/c++/7/cstdio" 3
       
# 40 "/usr/include/c++/7/cstdio" 3
# 42 "/usr/include/c++/7/fstream" 2 3
# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/basic_file.h" 1 3
# 37 "/usr/include/x86_64-linux-gnu/c++/7/bits/basic_file.h" 3
       
# 38 "/usr/include/x86_64-linux-gnu/c++/7/bits/basic_file.h" 3


# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++io.h" 1 3
# 35 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++io.h" 3
# 1 "/usr/include/c++/7/cstdio" 1 3
# 39 "/usr/include/c++/7/cstdio" 3
       
# 40 "/usr/include/c++/7/cstdio" 3
# 36 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++io.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;


}
# 41 "/usr/include/x86_64-linux-gnu/c++/7/bits/basic_file.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _CharT>
    class __basic_file;


  template<>
    class __basic_file<char>
    {

      __c_file* _M_cfile;


      bool _M_cfile_created;

    public:
      __basic_file(__c_lock* __lock = 0) throw ();


      __basic_file(__basic_file&& __rv, __c_lock* __lock = 0) noexcept
      : _M_cfile(__rv._M_cfile), _M_cfile_created(__rv._M_cfile_created)
      {
 __rv._M_cfile = nullptr;
 __rv._M_cfile_created = false;
      }

      __basic_file& operator=(const __basic_file&) = delete;
      __basic_file& operator=(__basic_file&&) = delete;

      void
      swap(__basic_file& __f) noexcept
      {
 std::swap(_M_cfile, __f._M_cfile);
 std::swap(_M_cfile_created, __f._M_cfile_created);
      }


      __basic_file*
      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);

      __basic_file*
      sys_open(__c_file* __file, ios_base::openmode);

      __basic_file*
      sys_open(int __fd, ios_base::openmode __mode) throw ();

      __basic_file*
      close();

      __attribute__ ((__pure__)) bool
      is_open() const throw ();

      __attribute__ ((__pure__)) int
      fd() throw ();

      __attribute__ ((__pure__)) __c_file*
      file() throw ();

      ~__basic_file();

      streamsize
      xsputn(const char* __s, streamsize __n);

      streamsize
      xsputn_2(const char* __s1, streamsize __n1,
        const char* __s2, streamsize __n2);

      streamsize
      xsgetn(char* __s, streamsize __n);

      streamoff
      seekoff(streamoff __off, ios_base::seekdir __way) throw ();

      int
      sync();

      streamsize
      showmanyc();
    };


}
# 43 "/usr/include/c++/7/fstream" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/include/c++/7/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_filebuf : public basic_streambuf<_CharT, _Traits>
    {

      template<typename _Tp>
 using __chk_state = __and_<is_copy_assignable<_Tp>,
       is_copy_constructible<_Tp>,
       is_default_constructible<_Tp>>;

      static_assert(__chk_state<typename _Traits::state_type>::value,
      "state_type must be CopyAssignable, CopyConstructible"
      " and DefaultConstructible");

      static_assert(is_same<typename _Traits::pos_type,
       fpos<typename _Traits::state_type>>::value,
      "pos_type must be fpos<state_type>");

    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef __basic_file<char> __file_type;
      typedef typename traits_type::state_type __state_type;
      typedef codecvt<char_type, char, __state_type> __codecvt_type;

      friend class ios_base;

    protected:


      __c_lock _M_lock;


      __file_type _M_file;


      ios_base::openmode _M_mode;


      __state_type _M_state_beg;




      __state_type _M_state_cur;



      __state_type _M_state_last;


      char_type* _M_buf;






      size_t _M_buf_size;


      bool _M_buf_allocated;
# 147 "/usr/include/c++/7/fstream" 3
      bool _M_reading;
      bool _M_writing;







      char_type _M_pback;
      char_type* _M_pback_cur_save;
      char_type* _M_pback_end_save;
      bool _M_pback_init;



      const __codecvt_type* _M_codecvt;






      char* _M_ext_buf;




      streamsize _M_ext_buf_size;






      const char* _M_ext_next;
      char* _M_ext_end;






      void
      _M_create_pback()
      {
 if (!_M_pback_init)
   {
     _M_pback_cur_save = this->gptr();
     _M_pback_end_save = this->egptr();
     this->setg(&_M_pback, &_M_pback, &_M_pback + 1);
     _M_pback_init = true;
   }
      }






      void
      _M_destroy_pback() throw()
      {
 if (_M_pback_init)
   {

     _M_pback_cur_save += this->gptr() != this->eback();
     this->setg(_M_buf, _M_pback_cur_save, _M_pback_end_save);
     _M_pback_init = false;
   }
      }

    public:







      basic_filebuf();


      basic_filebuf(const basic_filebuf&) = delete;
      basic_filebuf(basic_filebuf&&);





      virtual
      ~basic_filebuf()
      { this->close(); }


      basic_filebuf& operator=(const basic_filebuf&) = delete;
      basic_filebuf& operator=(basic_filebuf&&);
      void swap(basic_filebuf&);






      bool
      is_open() const throw()
      { return _M_file.is_open(); }
# 296 "/usr/include/c++/7/fstream" 3
      __filebuf_type*
      open(const char* __s, ios_base::openmode __mode);
# 306 "/usr/include/c++/7/fstream" 3
      __filebuf_type*
      open(const std::string& __s, ios_base::openmode __mode)
      { return open(__s.c_str(), __mode); }
# 323 "/usr/include/c++/7/fstream" 3
      __filebuf_type*
      close();

    protected:
      void
      _M_allocate_internal_buffer();

      void
      _M_destroy_internal_buffer() throw();


      virtual streamsize
      showmanyc();






      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = _Traits::eof());
# 355 "/usr/include/c++/7/fstream" 3
      virtual int_type
      overflow(int_type __c = _Traits::eof());



      bool
      _M_convert_to_external(char_type*, streamsize);
# 375 "/usr/include/c++/7/fstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n);

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __pos,
       ios_base::openmode __mode = ios_base::in | ios_base::out);


      pos_type
      _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state);

      int
      _M_get_ext_pos(__state_type &__state);

      virtual int
      sync();

      virtual void
      imbue(const locale& __loc);

      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);

      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);


      bool
      _M_terminate_output();
# 421 "/usr/include/c++/7/fstream" 3
      void
      _M_set_buffer(streamsize __off)
      {
 const bool __testin = _M_mode & ios_base::in;
 const bool __testout = (_M_mode & ios_base::out
    || _M_mode & ios_base::app);

 if (__testin && __off > 0)
   this->setg(_M_buf, _M_buf, _M_buf + __off);
 else
   this->setg(_M_buf, _M_buf, _M_buf);

 if (__testout && __off == 0 && _M_buf_size > 1 )
   this->setp(_M_buf, _M_buf + _M_buf_size - 1);
 else
   this->setp(0, 0);
      }
    };
# 454 "/usr/include/c++/7/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ifstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 481 "/usr/include/c++/7/fstream" 3
      basic_ifstream() : __istream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 494 "/usr/include/c++/7/fstream" 3
      explicit
      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 510 "/usr/include/c++/7/fstream" 3
      explicit
      basic_ifstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }

      basic_ifstream(const basic_ifstream&) = delete;

      basic_ifstream(basic_ifstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __istream_type::set_rdbuf(&_M_filebuf); }
# 533 "/usr/include/c++/7/fstream" 3
      ~basic_ifstream()
      { }




      basic_ifstream&
      operator=(const basic_ifstream&) = delete;

      basic_ifstream&
      operator=(basic_ifstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_ifstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 565 "/usr/include/c++/7/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 594 "/usr/include/c++/7/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 614 "/usr/include/c++/7/fstream" 3
      void
      open(const std::string& __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 632 "/usr/include/c++/7/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 655 "/usr/include/c++/7/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ofstream : public basic_ostream<_CharT,_Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 682 "/usr/include/c++/7/fstream" 3
      basic_ofstream(): __ostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 696 "/usr/include/c++/7/fstream" 3
      explicit
      basic_ofstream(const char* __s,
       ios_base::openmode __mode = ios_base::out|ios_base::trunc)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 714 "/usr/include/c++/7/fstream" 3
      explicit
      basic_ofstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::out|ios_base::trunc)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }

      basic_ofstream(const basic_ofstream&) = delete;

      basic_ofstream(basic_ofstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __ostream_type::set_rdbuf(&_M_filebuf); }
# 737 "/usr/include/c++/7/fstream" 3
      ~basic_ofstream()
      { }




      basic_ofstream&
      operator=(const basic_ofstream&) = delete;

      basic_ofstream&
      operator=(basic_ofstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_ofstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 769 "/usr/include/c++/7/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 798 "/usr/include/c++/7/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::out | ios_base::trunc)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 819 "/usr/include/c++/7/fstream" 3
      void
      open(const std::string& __s,
    ios_base::openmode __mode = ios_base::out | ios_base::trunc)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 838 "/usr/include/c++/7/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 861 "/usr/include/c++/7/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_fstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ios<char_type, traits_type> __ios_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 889 "/usr/include/c++/7/fstream" 3
      basic_fstream()
      : __iostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 901 "/usr/include/c++/7/fstream" 3
      explicit
      basic_fstream(const char* __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }







      explicit
      basic_fstream(const std::string& __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }

      basic_fstream(const basic_fstream&) = delete;

      basic_fstream(basic_fstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __iostream_type::set_rdbuf(&_M_filebuf); }
# 939 "/usr/include/c++/7/fstream" 3
      ~basic_fstream()
      { }




      basic_fstream&
      operator=(const basic_fstream&) = delete;

      basic_fstream&
      operator=(basic_fstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_fstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 971 "/usr/include/c++/7/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 1000 "/usr/include/c++/7/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1021 "/usr/include/c++/7/fstream" 3
      void
      open(const std::string& __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1040 "/usr/include/c++/7/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };



  template <class _CharT, class _Traits>
    inline void
    swap(basic_filebuf<_CharT, _Traits>& __x,
  basic_filebuf<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_ifstream<_CharT, _Traits>& __x,
  basic_ifstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_ofstream<_CharT, _Traits>& __x,
  basic_ofstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_fstream<_CharT, _Traits>& __x,
  basic_fstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }



}

# 1 "/usr/include/c++/7/bits/fstream.tcc" 1 3
# 37 "/usr/include/c++/7/bits/fstream.tcc" 3
       
# 38 "/usr/include/c++/7/bits/fstream.tcc" 3




namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_allocate_internal_buffer()
    {


      if (!_M_buf_allocated && !_M_buf)
 {
   _M_buf = new char_type[_M_buf_size];
   _M_buf_allocated = true;
 }
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_destroy_internal_buffer() throw()
    {
      if (_M_buf_allocated)
 {
   delete [] _M_buf;
   _M_buf = 0;
   _M_buf_allocated = false;
 }
      delete [] _M_ext_buf;
      _M_ext_buf = 0;
      _M_ext_buf_size = 0;
      _M_ext_next = 0;
      _M_ext_end = 0;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf() : __streambuf_type(), _M_lock(), _M_file(&_M_lock),
    _M_mode(ios_base::openmode(0)), _M_state_beg(), _M_state_cur(),
    _M_state_last(), _M_buf(0), _M_buf_size(8192),
    _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(),
    _M_pback_cur_save(0), _M_pback_end_save(0), _M_pback_init(false),
    _M_codecvt(0), _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0),
    _M_ext_end(0)
    {
      if (has_facet<__codecvt_type>(this->_M_buf_locale))
 _M_codecvt = &use_facet<__codecvt_type>(this->_M_buf_locale);
    }


  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf(basic_filebuf&& __rhs)
    : __streambuf_type(__rhs),
    _M_lock(), _M_file(std::move(__rhs._M_file), &_M_lock),
    _M_mode(std::__exchange(__rhs._M_mode, ios_base::openmode(0))),
    _M_state_beg(std::move(__rhs._M_state_beg)),
    _M_state_cur(std::move(__rhs._M_state_cur)),
    _M_state_last(std::move(__rhs._M_state_last)),
    _M_buf(std::__exchange(__rhs._M_buf, nullptr)),
    _M_buf_size(std::__exchange(__rhs._M_buf_size, 1)),
    _M_buf_allocated(std::__exchange(__rhs._M_buf_allocated, false)),
    _M_reading(std::__exchange(__rhs._M_reading, false)),
    _M_writing(std::__exchange(__rhs._M_writing, false)),
    _M_pback(__rhs._M_pback),
    _M_pback_cur_save(std::__exchange(__rhs._M_pback_cur_save, nullptr)),
    _M_pback_end_save(std::__exchange(__rhs._M_pback_end_save, nullptr)),
    _M_pback_init(std::__exchange(__rhs._M_pback_init, false)),
    _M_codecvt(__rhs._M_codecvt),
    _M_ext_buf(std::__exchange(__rhs._M_ext_buf, nullptr)),
    _M_ext_buf_size(std::__exchange(__rhs._M_ext_buf_size, 0)),
    _M_ext_next(std::__exchange(__rhs._M_ext_next, nullptr)),
    _M_ext_end(std::__exchange(__rhs._M_ext_end, nullptr))
    {
      __rhs._M_set_buffer(-1);
      __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>&
    basic_filebuf<_CharT, _Traits>::
    operator=(basic_filebuf&& __rhs)
    {
      this->close();
      __streambuf_type::operator=(__rhs);
      _M_file.swap(__rhs._M_file);
      _M_mode = std::__exchange(__rhs._M_mode, ios_base::openmode(0));
      _M_state_beg = std::move(__rhs._M_state_beg);
      _M_state_cur = std::move(__rhs._M_state_cur);
      _M_state_last = std::move(__rhs._M_state_last);
      _M_buf = std::__exchange(__rhs._M_buf, nullptr);
      _M_buf_size = std::__exchange(__rhs._M_buf_size, 1);
      _M_buf_allocated = std::__exchange(__rhs._M_buf_allocated, false);
      _M_ext_buf = std::__exchange(__rhs._M_ext_buf, nullptr);
      _M_ext_buf_size = std::__exchange(__rhs._M_ext_buf_size, 0);
      _M_ext_next = std::__exchange(__rhs._M_ext_next, nullptr);
      _M_ext_end = std::__exchange(__rhs._M_ext_end, nullptr);
      _M_reading = std::__exchange(__rhs._M_reading, false);
      _M_writing = std::__exchange(__rhs._M_writing, false);
      _M_pback_cur_save = std::__exchange(__rhs._M_pback_cur_save, nullptr);
      _M_pback_end_save = std::__exchange(__rhs._M_pback_end_save, nullptr);
      _M_pback_init = std::__exchange(__rhs._M_pback_init, false);
      __rhs._M_set_buffer(-1);
      __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
      return *this;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    swap(basic_filebuf& __rhs)
    {
      __streambuf_type::swap(__rhs);
      _M_file.swap(__rhs._M_file);
      std::swap(_M_mode, __rhs._M_mode);
      std::swap(_M_state_beg, __rhs._M_state_beg);
      std::swap(_M_state_cur, __rhs._M_state_cur);
      std::swap(_M_state_last, __rhs._M_state_last);
      std::swap(_M_buf, __rhs._M_buf);
      std::swap(_M_buf_size, __rhs._M_buf_size);
      std::swap(_M_buf_allocated, __rhs._M_buf_allocated);
      std::swap(_M_ext_buf, __rhs._M_ext_buf);
      std::swap(_M_ext_buf_size, __rhs._M_ext_buf_size);
      std::swap(_M_ext_next, __rhs._M_ext_next);
      std::swap(_M_ext_end, __rhs._M_ext_end);
      std::swap(_M_reading, __rhs._M_reading);
      std::swap(_M_writing, __rhs._M_writing);
      std::swap(_M_pback_cur_save, __rhs._M_pback_cur_save);
      std::swap(_M_pback_end_save, __rhs._M_pback_end_save);
      std::swap(_M_pback_init, __rhs._M_pback_init);
    }


  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    open(const char* __s, ios_base::openmode __mode)
    {
      __filebuf_type *__ret = 0;
      if (!this->is_open())
 {
   _M_file.open(__s, __mode);
   if (this->is_open())
     {
       _M_allocate_internal_buffer();
       _M_mode = __mode;


       _M_reading = false;
       _M_writing = false;
       _M_set_buffer(-1);


       _M_state_last = _M_state_cur = _M_state_beg;


       if ((__mode & ios_base::ate)
    && this->seekoff(0, ios_base::end, __mode)
    == pos_type(off_type(-1)))
  this->close();
       else
  __ret = this;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    close()
    {
      if (!this->is_open())
 return 0;

      bool __testfail = false;
      {

 struct __close_sentry
 {
   basic_filebuf *__fb;
   __close_sentry (basic_filebuf *__fbi): __fb(__fbi) { }
   ~__close_sentry ()
   {
     __fb->_M_mode = ios_base::openmode(0);
     __fb->_M_pback_init = false;
     __fb->_M_destroy_internal_buffer();
     __fb->_M_reading = false;
     __fb->_M_writing = false;
     __fb->_M_set_buffer(-1);
     __fb->_M_state_last = __fb->_M_state_cur = __fb->_M_state_beg;
   }
 } __cs (this);

 try
   {
     if (!_M_terminate_output())
       __testfail = true;
   }
 catch(__cxxabiv1::__forced_unwind&)
   {
     _M_file.close();
     throw;
   }
 catch(...)
   { __testfail = true; }
      }

      if (!_M_file.close())
 __testfail = true;

      if (__testfail)
 return 0;
      else
 return this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    showmanyc()
    {
      streamsize __ret = -1;
      const bool __testin = _M_mode & ios_base::in;
      if (__testin && this->is_open())
 {


   __ret = this->egptr() - this->gptr();







   if (__check_facet(_M_codecvt).encoding() >= 0)

     __ret += _M_file.showmanyc() / _M_codecvt->max_length();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }



   _M_destroy_pback();

   if (this->gptr() < this->egptr())
     return traits_type::to_int_type(*this->gptr());


   const size_t __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;


   bool __got_eof = false;

   streamsize __ilen = 0;
   codecvt_base::result __r = codecvt_base::ok;
   if (__check_facet(_M_codecvt).always_noconv())
     {
       __ilen = _M_file.xsgetn(reinterpret_cast<char*>(this->eback()),
          __buflen);
       if (__ilen == 0)
  __got_eof = true;
     }
   else
     {


       const int __enc = _M_codecvt->encoding();
       streamsize __blen;
       streamsize __rlen;
       if (__enc > 0)
  __blen = __rlen = __buflen * __enc;
       else
  {
    __blen = __buflen + _M_codecvt->max_length() - 1;
    __rlen = __buflen;
  }
       const streamsize __remainder = _M_ext_end - _M_ext_next;
       __rlen = __rlen > __remainder ? __rlen - __remainder : 0;



       if (_M_reading && this->egptr() == this->eback() && __remainder)
  __rlen = 0;



       if (_M_ext_buf_size < __blen)
  {
    char* __buf = new char[__blen];
    if (__remainder)
      __builtin_memcpy(__buf, _M_ext_next, __remainder);

    delete [] _M_ext_buf;
    _M_ext_buf = __buf;
    _M_ext_buf_size = __blen;
  }
       else if (__remainder)
  __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

       _M_ext_next = _M_ext_buf;
       _M_ext_end = _M_ext_buf + __remainder;
       _M_state_last = _M_state_cur;

       do
  {
    if (__rlen > 0)
      {



        if (_M_ext_end - _M_ext_buf + __rlen > _M_ext_buf_size)
   {
     __throw_ios_failure(("basic_filebuf::underflow " "codecvt::max_length() " "is not valid")

                          );
   }
        streamsize __elen = _M_file.xsgetn(_M_ext_end, __rlen);
        if (__elen == 0)
   __got_eof = true;
        else if (__elen == -1)
   break;
        _M_ext_end += __elen;
      }

    char_type* __iend = this->eback();
    if (_M_ext_next < _M_ext_end)
      __r = _M_codecvt->in(_M_state_cur, _M_ext_next,
      _M_ext_end, _M_ext_next,
      this->eback(),
      this->eback() + __buflen, __iend);
    if (__r == codecvt_base::noconv)
      {
        size_t __avail = _M_ext_end - _M_ext_buf;
        __ilen = std::min(__avail, __buflen);
        traits_type::copy(this->eback(),
     reinterpret_cast<char_type*>
     (_M_ext_buf), __ilen);
        _M_ext_next = _M_ext_buf + __ilen;
      }
    else
      __ilen = __iend - this->eback();




    if (__r == codecvt_base::error)
      break;

    __rlen = 1;
  }
       while (__ilen == 0 && !__got_eof);
     }

   if (__ilen > 0)
     {
       _M_set_buffer(__ilen);
       _M_reading = true;
       __ret = traits_type::to_int_type(*this->gptr());
     }
   else if (__got_eof)
     {



       _M_set_buffer(-1);
       _M_reading = false;


       if (__r == codecvt_base::partial)
  __throw_ios_failure(("basic_filebuf::underflow " "incomplete character in file")
                                       );
     }
   else if (__r == codecvt_base::error)
     __throw_ios_failure(("basic_filebuf::underflow " "invalid byte sequence in file")
                                    );
   else
     __throw_ios_failure(("basic_filebuf::underflow " "error reading the file")
                             );
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    pbackfail(int_type __i)
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }


   const bool __testpb = _M_pback_init;
   const bool __testeof = traits_type::eq_int_type(__i, __ret);
   int_type __tmp;
   if (this->eback() < this->gptr())
     {
       this->gbump(-1);
       __tmp = traits_type::to_int_type(*this->gptr());
     }
   else if (this->seekoff(-1, ios_base::cur) != pos_type(off_type(-1)))
     {
       __tmp = this->underflow();
       if (traits_type::eq_int_type(__tmp, __ret))
  return __ret;
     }
   else
     {





       return __ret;
     }



   if (!__testeof && traits_type::eq_int_type(__i, __tmp))
     __ret = __i;
   else if (__testeof)
     __ret = traits_type::not_eof(__i);
   else if (!__testpb)
     {
       _M_create_pback();
       _M_reading = true;
       *this->gptr() = traits_type::to_char_type(__i);
       __ret = __i;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    overflow(int_type __c)
    {
      int_type __ret = traits_type::eof();
      const bool __testeof = traits_type::eq_int_type(__c, __ret);
      const bool __testout = (_M_mode & ios_base::out
         || _M_mode & ios_base::app);
      if (__testout)
 {
          if (_M_reading)
            {
              _M_destroy_pback();
              const int __gptr_off = _M_get_ext_pos(_M_state_last);
              if (_M_seek(__gptr_off, ios_base::cur, _M_state_last)
                  == pos_type(off_type(-1)))
                return __ret;
            }
   if (this->pbase() < this->pptr())
     {

       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }



       if (_M_convert_to_external(this->pbase(),
      this->pptr() - this->pbase()))
  {
    _M_set_buffer(0);
    __ret = traits_type::not_eof(__c);
  }
     }
   else if (_M_buf_size > 1)
     {



       _M_set_buffer(0);
       _M_writing = true;
       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }
       __ret = traits_type::not_eof(__c);
     }
   else
     {

       char_type __conv = traits_type::to_char_type(__c);
       if (__testeof || _M_convert_to_external(&__conv, 1))
  {
    _M_writing = true;
    __ret = traits_type::not_eof(__c);
  }
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_convert_to_external(_CharT* __ibuf, streamsize __ilen)
    {

      streamsize __elen;
      streamsize __plen;
      if (__check_facet(_M_codecvt).always_noconv())
 {
   __elen = _M_file.xsputn(reinterpret_cast<char*>(__ibuf), __ilen);
   __plen = __ilen;
 }
      else
 {


   streamsize __blen = __ilen * _M_codecvt->max_length();
   char* __buf = static_cast<char*>(__builtin_alloca(__blen));

   char* __bend;
   const char_type* __iend;
   codecvt_base::result __r;
   __r = _M_codecvt->out(_M_state_cur, __ibuf, __ibuf + __ilen,
    __iend, __buf, __buf + __blen, __bend);

   if (__r == codecvt_base::ok || __r == codecvt_base::partial)
     __blen = __bend - __buf;
   else if (__r == codecvt_base::noconv)
     {

       __buf = reinterpret_cast<char*>(__ibuf);
       __blen = __ilen;
     }
   else
     __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error")
                           );

   __elen = _M_file.xsputn(__buf, __blen);
   __plen = __blen;


   if (__r == codecvt_base::partial && __elen == __plen)
     {
       const char_type* __iresume = __iend;
       streamsize __rlen = this->pptr() - __iend;
       __r = _M_codecvt->out(_M_state_cur, __iresume,
        __iresume + __rlen, __iend, __buf,
        __buf + __blen, __bend);
       if (__r != codecvt_base::error)
  {
    __rlen = __bend - __buf;
    __elen = _M_file.xsputn(__buf, __rlen);
    __plen = __rlen;
  }
       else
  __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error")
                        );
     }
 }
      return __elen == __plen;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsgetn(_CharT* __s, streamsize __n)
    {

      streamsize __ret = 0;
      if (_M_pback_init)
 {
   if (__n > 0 && this->gptr() == this->eback())
     {
       *__s++ = *this->gptr();
       this->gbump(1);
       __ret = 1;
       --__n;
     }
   _M_destroy_pback();
 }
      else if (_M_writing)
 {
    if (overflow() == traits_type::eof())
      return __ret;
    _M_set_buffer(-1);
    _M_writing = false;
  }




      const bool __testin = _M_mode & ios_base::in;
      const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;

      if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()
     && __testin)
   {

     const streamsize __avail = this->egptr() - this->gptr();
     if (__avail != 0)
       {
        traits_type::copy(__s, this->gptr(), __avail);
         __s += __avail;
        this->setg(this->eback(), this->gptr() + __avail,
     this->egptr());
        __ret += __avail;
        __n -= __avail;
       }



     streamsize __len;
     for (;;)
       {
         __len = _M_file.xsgetn(reinterpret_cast<char*>(__s),
           __n);
         if (__len == -1)
    __throw_ios_failure(("basic_filebuf::xsgetn " "error reading the file")
                                );
         if (__len == 0)
    break;

         __n -= __len;
         __ret += __len;
         if (__n == 0)
    break;

         __s += __len;
       }

     if (__n == 0)
       {

         _M_reading = true;
       }
     else if (__len == 0)
       {



         _M_set_buffer(-1);
         _M_reading = false;
       }
   }
      else
   __ret += __streambuf_type::xsgetn(__s, __n);

      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsputn(const _CharT* __s, streamsize __n)
    {
      streamsize __ret = 0;



      const bool __testout = (_M_mode & ios_base::out
         || _M_mode & ios_base::app);
      if (__check_facet(_M_codecvt).always_noconv()
     && __testout && !_M_reading)
 {

   const streamsize __chunk = 1ul << 10;
   streamsize __bufavail = this->epptr() - this->pptr();


   if (!_M_writing && _M_buf_size > 1)
     __bufavail = _M_buf_size - 1;

   const streamsize __limit = std::min(__chunk, __bufavail);
   if (__n >= __limit)
     {
       const streamsize __buffill = this->pptr() - this->pbase();
       const char* __buf = reinterpret_cast<const char*>(this->pbase());
       __ret = _M_file.xsputn_2(__buf, __buffill,
           reinterpret_cast<const char*>(__s),
           __n);
       if (__ret == __buffill + __n)
  {
    _M_set_buffer(0);
    _M_writing = true;
  }
       if (__ret > __buffill)
  __ret -= __buffill;
       else
  __ret = 0;
     }
   else
     __ret = __streambuf_type::xsputn(__s, __n);
 }
       else
  __ret = __streambuf_type::xsputn(__s, __n);
       return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__streambuf_type*
    basic_filebuf<_CharT, _Traits>::
    setbuf(char_type* __s, streamsize __n)
    {
      if (!this->is_open())
 {
   if (__s == 0 && __n == 0)
     _M_buf_size = 1;
   else if (__s && __n > 0)
     {
# 787 "/usr/include/c++/7/bits/fstream.tcc" 3
       _M_buf = __s;
       _M_buf_size = __n;
     }
 }
      return this;
    }




  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode)
    {
      int __width = 0;
      if (_M_codecvt)
 __width = _M_codecvt->encoding();
      if (__width < 0)
 __width = 0;

      pos_type __ret = pos_type(off_type(-1));
      const bool __testfail = __off != 0 && __width <= 0;
      if (this->is_open() && !__testfail)
 {




   bool __no_movement = __way == ios_base::cur && __off == 0
     && (!_M_writing || _M_codecvt->always_noconv());


   if (!__no_movement)
     _M_destroy_pback();






   __state_type __state = _M_state_beg;
   off_type __computed_off = __off * __width;
   if (_M_reading && __way == ios_base::cur)
     {
       __state = _M_state_last;
       __computed_off += _M_get_ext_pos(__state);
     }
   if (!__no_movement)
     __ret = _M_seek(__computed_off, __way, __state);
   else
     {
       if (_M_writing)
  __computed_off = this->pptr() - this->pbase();

        off_type __file_off = _M_file.seekoff(0, ios_base::cur);
        if (__file_off != off_type(-1))
  {
    __ret = __file_off + __computed_off;
    __ret.state(__state);
  }
     }
 }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekpos(pos_type __pos, ios_base::openmode)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (this->is_open())
 {

   _M_destroy_pback();
   __ret = _M_seek(off_type(__pos), ios_base::beg, __pos.state());
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (_M_terminate_output())
 {
   off_type __file_off = _M_file.seekoff(__off, __way);
   if (__file_off != off_type(-1))
     {
       _M_reading = false;
       _M_writing = false;
       _M_ext_next = _M_ext_end = _M_ext_buf;
       _M_set_buffer(-1);
       _M_state_cur = __state;
       __ret = __file_off;
       __ret.state(_M_state_cur);
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    int basic_filebuf<_CharT, _Traits>::
    _M_get_ext_pos(__state_type& __state)
    {
      if (_M_codecvt->always_noconv())
        return this->gptr() - this->egptr();
      else
        {



          const int __gptr_off =
            _M_codecvt->length(__state, _M_ext_buf, _M_ext_next,
                               this->gptr() - this->eback());
          return _M_ext_buf + __gptr_off - _M_ext_end;
        }
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_terminate_output()
    {

      bool __testvalid = true;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __testvalid = false;
 }


      if (_M_writing && !__check_facet(_M_codecvt).always_noconv()
   && __testvalid)
 {



   const size_t __blen = 128;
   char __buf[__blen];
   codecvt_base::result __r;
   streamsize __ilen = 0;

   do
     {
       char* __next;
       __r = _M_codecvt->unshift(_M_state_cur, __buf,
     __buf + __blen, __next);
       if (__r == codecvt_base::error)
  __testvalid = false;
       else if (__r == codecvt_base::ok ||
         __r == codecvt_base::partial)
  {
    __ilen = __next - __buf;
    if (__ilen > 0)
      {
        const streamsize __elen = _M_file.xsputn(__buf, __ilen);
        if (__elen != __ilen)
   __testvalid = false;
      }
  }
     }
   while (__r == codecvt_base::partial && __ilen > 0 && __testvalid);

   if (__testvalid)
     {




       const int_type __tmp = this->overflow();
       if (traits_type::eq_int_type(__tmp, traits_type::eof()))
  __testvalid = false;
     }
 }
      return __testvalid;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_filebuf<_CharT, _Traits>::
    sync()
    {


      int __ret = 0;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __ret = -1;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    imbue(const locale& __loc)
    {
      bool __testvalid = true;

      const __codecvt_type* _M_codecvt_tmp = 0;
      if (__builtin_expect(has_facet<__codecvt_type>(__loc), true))
 _M_codecvt_tmp = &use_facet<__codecvt_type>(__loc);

      if (this->is_open())
 {

   if ((_M_reading || _M_writing)
       && __check_facet(_M_codecvt).encoding() == -1)
     __testvalid = false;
   else
     {
       if (_M_reading)
  {
    if (__check_facet(_M_codecvt).always_noconv())
      {
        if (_M_codecvt_tmp
     && !__check_facet(_M_codecvt_tmp).always_noconv())
   __testvalid = this->seekoff(0, ios_base::cur, _M_mode)
                 != pos_type(off_type(-1));
      }
    else
      {

        _M_ext_next = _M_ext_buf
   + _M_codecvt->length(_M_state_last, _M_ext_buf,
          _M_ext_next,
          this->gptr() - this->eback());
        const streamsize __remainder = _M_ext_end - _M_ext_next;
        if (__remainder)
   __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

        _M_ext_next = _M_ext_buf;
        _M_ext_end = _M_ext_buf + __remainder;
        _M_set_buffer(-1);
        _M_state_last = _M_state_cur = _M_state_beg;
      }
  }
       else if (_M_writing && (__testvalid = _M_terminate_output()))
  _M_set_buffer(-1);
     }
 }

      if (__testvalid)
 _M_codecvt = _M_codecvt_tmp;
      else
 _M_codecvt = 0;
    }




  extern template class basic_filebuf<char>;
  extern template class basic_ifstream<char>;
  extern template class basic_ofstream<char>;
  extern template class basic_fstream<char>;


  extern template class basic_filebuf<wchar_t>;
  extern template class basic_ifstream<wchar_t>;
  extern template class basic_ofstream<wchar_t>;
  extern template class basic_fstream<wchar_t>;




}
# 1082 "/usr/include/c++/7/fstream" 2 3
# 14 "/usr/local/include/ibex/ibex_PixelMap.h" 2 3


namespace ibex {
# 30 "/usr/local/include/ibex/ibex_PixelMap.h" 3
class PixelMap {
public:




 PixelMap(unsigned int ndim);




 PixelMap(const PixelMap& src);




 virtual ~PixelMap();




 typedef unsigned int DATA_TYPE;




    void save(const char* filename);




    void load(const char* filename);







    virtual void compute_integral_image()=0;


    const unsigned int ndim;


    double *leaf_size_;


    double *origin_;


    int *grid_size_;

protected:

 friend class TestPixelMap;




    DATA_TYPE& operator[](int idx);


    std::vector<DATA_TYPE> data;




    int *divb_mul_;





    DATA_TYPE zero;





 void init();





    void init(const PixelMap& pic);

private:

    static const char* FORMAT_VERSION;
    static const char* FF_DATA_IMAGE_ND;





    void read_header(std::ifstream& in_file, PixelMap& output);





    void write_header(std::ofstream& out_file, const PixelMap& input);
};




class PixelMap2D : public PixelMap {
public:

    PixelMap2D();

 virtual void compute_integral_image();

    void set_origin(double ox, double oy);

    void set_leaf_size(double nx, double ny);

    void set_grid_size(unsigned int ni, unsigned int nj);

    DATA_TYPE& operator()(int i, int j);

};





class PixelMap3D : public PixelMap {
public:

    PixelMap3D();

 virtual void compute_integral_image();

 void set_origin(double ox, double oy, double oz);

 void set_leaf_size(double nx, double ny, double nz);

 void set_grid_size(unsigned int ni, unsigned int nj, unsigned int nk);

 DATA_TYPE& operator()(int i, int j, int k);
};




inline PixelMap::DATA_TYPE& PixelMap::operator[](int idx) {
 return data.at(idx);
}

}
# 17 "/usr/local/include/ibex/ibex_CtcPixelMap.h" 2 3

namespace ibex {
# 31 "/usr/local/include/ibex/ibex_CtcPixelMap.h" 3
class CtcPixelMap : public Ctc {

public:






    CtcPixelMap(PixelMap& data);




    ~CtcPixelMap();






    void contract(IntervalVector& box);


private:




    PixelMap &I;
# 69 "/usr/local/include/ibex/ibex_CtcPixelMap.h" 3
    int *pixel_coords;







    void world_to_grid(IntervalVector box);






    void grid_to_world(IntervalVector& box);




    void contract(int &cxmin, int &cxmax, int &cymin, int &cymax);




    void contract(int &cxmin, int &cxmax, int &cymin, int &cymax, int &czmin, int &czmax);






    unsigned int enclosed_pixels(int xmin, int xmax, int ymin, int ymax);






    unsigned int enclosed_pixels(int xmin, int xmax, int ymin, int ymax, int zmin, int zmax);

};

}
# 52 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcPolytopeHull.h" 1 3
# 15 "/usr/local/include/ibex/ibex_CtcPolytopeHull.h" 3
# 1 "/usr/local/include/ibex/ibex_LinearRelax.h" 1 3
# 15 "/usr/local/include/ibex/ibex_LinearRelax.h" 3
# 1 "/usr/local/include/ibex/ibex_LinearSolver.h" 1 3
# 14 "/usr/local/include/ibex/ibex_LinearSolver.h" 3
# 1 "/usr/local/include/ibex/ibex_Setting.h" 1 3
# 15 "/usr/local/include/ibex/ibex_LinearSolver.h" 2 3
# 26 "/usr/local/include/ibex/ibex_LinearSolver.h" 3
# 1 "/usr/local/include/ibex/ibex_LPException.h" 1 3
# 17 "/usr/local/include/ibex/ibex_LPException.h" 3
namespace ibex {





class LPException : public Exception {

};

}
# 27 "/usr/local/include/ibex/ibex_LinearSolver.h" 2 3
# 37 "/usr/local/include/ibex/ibex_LinearSolver.h" 3
# 1 "/usr/local/include/coin/ClpSimplex.hpp" 1 3
# 15 "/usr/local/include/coin/ClpSimplex.hpp" 3
# 1 "/usr/include/c++/7/cfloat" 1 3
# 39 "/usr/include/c++/7/cfloat" 3
       
# 40 "/usr/include/c++/7/cfloat" 3
# 16 "/usr/local/include/coin/ClpSimplex.hpp" 2 3
# 1 "/usr/local/include/coin/ClpModel.hpp" 1 3
# 9 "/usr/local/include/coin/ClpModel.hpp" 3
# 1 "/usr/local/include/coin/ClpConfig.h" 1 3
# 10 "/usr/local/include/coin/ClpModel.hpp" 2 3


# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 44 "/usr/include/c++/7/cassert" 2 3
# 13 "/usr/local/include/coin/ClpModel.hpp" 2 3
# 1 "/usr/include/c++/7/cmath" 1 3
# 39 "/usr/include/c++/7/cmath" 3
       
# 40 "/usr/include/c++/7/cmath" 3
# 14 "/usr/local/include/coin/ClpModel.hpp" 2 3





# 1 "/usr/local/include/coin/ClpPackedMatrix.hpp" 1 3
# 9 "/usr/local/include/coin/ClpPackedMatrix.hpp" 3
# 1 "/usr/local/include/coin/CoinPragma.hpp" 1 3
# 10 "/usr/local/include/coin/ClpPackedMatrix.hpp" 2 3

# 1 "/usr/local/include/coin/ClpMatrixBase.hpp" 1 3
# 10 "/usr/local/include/coin/ClpMatrixBase.hpp" 3
# 1 "/usr/local/include/coin/CoinTypes.hpp" 1 3
# 9 "/usr/local/include/coin/CoinTypes.hpp" 3
# 1 "/usr/local/include/coin/CoinUtilsConfig.h" 1 3
# 10 "/usr/local/include/coin/CoinTypes.hpp" 2 3
# 25 "/usr/local/include/coin/CoinTypes.hpp" 3
typedef int CoinBigIndex;
# 50 "/usr/local/include/coin/CoinTypes.hpp" 3
typedef double CoinWorkDouble;



typedef double CoinFactorizationDouble;
# 11 "/usr/local/include/coin/ClpMatrixBase.hpp" 2 3

# 1 "/usr/local/include/coin/CoinPackedMatrix.hpp" 1 3
# 9 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
# 1 "/usr/local/include/coin/CoinError.hpp" 1 3
# 11 "/usr/local/include/coin/CoinError.hpp" 3
# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 44 "/usr/include/c++/7/cassert" 2 3
# 12 "/usr/local/include/coin/CoinError.hpp" 2 3
# 1 "/usr/include/c++/7/cstring" 1 3
# 39 "/usr/include/c++/7/cstring" 3
       
# 40 "/usr/include/c++/7/cstring" 3
# 13 "/usr/local/include/coin/CoinError.hpp" 2 3






void WindowsErrorPopupBlocker();
# 42 "/usr/local/include/coin/CoinError.hpp" 3
class CoinError {
    friend void CoinErrorUnitTest();

private:
    CoinError()
      :
      message_(),
      method_(),
      class_(),
      file_(),
      lineNumber_()
    {

    }

public:







    inline const std::string & message() const
    { return message_; }

    inline const std::string & methodName() const
    { return method_; }

    inline const std::string & className() const
    { return class_; }

    inline const std::string & fileName() const
    { return file_; }

    inline int lineNumber() const
    { return lineNumber_; }

    inline void print(bool doPrint = true) const
    {
      if (! doPrint)
        return;
      if (lineNumber_<0) {
        std::cout<<message_<<" in "<<class_<<"::"<<method_<<std::endl;
      } else {
        std::cout<<file_<<":"<<lineNumber_<<" method "<<method_
                 <<" : assertion \'"<<message_<<"\' failed."<<std::endl;
        if(class_!="")
          std::cout<<"Possible reason: "<<class_<<std::endl;
      }
    }






    CoinError (
      std::string message__,
      std::string methodName__,
      std::string className__,
      std::string fileName_ = std::string(),
      int line = -1)
      :
      message_(message__),
      method_(methodName__),
      class_(className__),
      file_(fileName_),
      lineNumber_(line)
    {
      print(printErrors_);
    }


    CoinError (const CoinError & source)
      :
      message_(source.message_),
      method_(source.method_),
      class_(source.class_),
      file_(source.file_),
      lineNumber_(source.lineNumber_)
    {

    }


    CoinError & operator=(const CoinError& rhs)
    {
      if (this != &rhs) {
 message_=rhs.message_;
 method_=rhs.method_;
 class_=rhs.class_;
 file_=rhs.file_;
 lineNumber_ = rhs.lineNumber_;
      }
      return *this;
    }


    virtual ~CoinError ()
    {

    }


private:




    std::string message_;

    std::string method_;

    std::string class_;

    std::string file_;

    int lineNumber_;


public:

  static bool printErrors_;
};
# 250 "/usr/local/include/coin/CoinError.hpp" 3
void
CoinErrorUnitTest();
# 10 "/usr/local/include/coin/CoinPackedMatrix.hpp" 2 3


# 1 "/usr/local/include/coin/CoinPackedVectorBase.hpp" 1 3
# 10 "/usr/local/include/coin/CoinPackedVectorBase.hpp" 3
# 1 "/usr/include/c++/7/map" 1 3
# 58 "/usr/include/c++/7/map" 3
       
# 59 "/usr/include/c++/7/map" 3


# 1 "/usr/include/c++/7/bits/stl_map.h" 1 3
# 66 "/usr/include/c++/7/bits/stl_map.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    class multimap;
# 97 "/usr/include/c++/7/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:
# 120 "/usr/include/c++/7/bits/stl_map.h" 3
    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<value_type>::other _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;

    public:


      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
# 177 "/usr/include/c++/7/bits/stl_map.h" 3
      map() = default;







      explicit
      map(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
# 199 "/usr/include/c++/7/bits/stl_map.h" 3
      map(const map&) = default;







      map(map&&) = default;
# 220 "/usr/include/c++/7/bits/stl_map.h" 3
      map(initializer_list<value_type> __l,
   const _Compare& __comp = _Compare(),
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }


      explicit
      map(const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }


      map(const map& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }


      map(map&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }


      map(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }


      template<typename _InputIterator>
 map(_InputIterator __first, _InputIterator __last,
     const allocator_type& __a)
 : _M_t(_Compare(), _Pair_alloc_type(__a))
 { _M_t._M_insert_unique(__first, __last); }
# 264 "/usr/include/c++/7/bits/stl_map.h" 3
      template<typename _InputIterator>
 map(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_unique(__first, __last); }
# 281 "/usr/include/c++/7/bits/stl_map.h" 3
      template<typename _InputIterator>
 map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
 { _M_t._M_insert_unique(__first, __last); }







      ~map() = default;
# 310 "/usr/include/c++/7/bits/stl_map.h" 3
      map&
      operator=(const map&) = default;


      map&
      operator=(map&&) = default;
# 328 "/usr/include/c++/7/bits/stl_map.h" 3
      map&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_unique(__l.begin(), __l.end());
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin() noexcept
      { return _M_t.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() noexcept
      { return _M_t.end(); }






      const_iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() noexcept
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      const_iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      const_iterator
      cend() const noexcept
      { return _M_t.end(); }






      const_reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }






      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 483 "/usr/include/c++/7/bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))

   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
         std::tuple<const key_type&>(__k),
         std::tuple<>());



 return (*__i).second;
      }


      mapped_type&
      operator[](key_type&& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))
   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
     std::forward_as_tuple(std::move(__k)),
     std::tuple<>());
 return (*__i).second;
      }
# 528 "/usr/include/c++/7/bits/stl_map.h" 3
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
# 566 "/usr/include/c++/7/bits/stl_map.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
# 596 "/usr/include/c++/7/bits/stl_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_unique(__pos,
          std::forward<_Args>(__args)...);
 }
# 794 "/usr/include/c++/7/bits/stl_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }




      std::pair<iterator, bool>
      insert(value_type&& __x)
      { return _M_t._M_insert_unique(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair>::value,
        pair<iterator, bool>>
 insert(_Pair&& __x)
 { return _M_t._M_emplace_unique(std::forward<_Pair>(__x)); }
# 821 "/usr/include/c++/7/bits/stl_map.h" 3
      void
      insert(std::initializer_list<value_type> __list)
      { insert(__list.begin(), __list.end()); }
# 850 "/usr/include/c++/7/bits/stl_map.h" 3
      iterator

      insert(const_iterator __position, const value_type& __x)



      { return _M_t._M_insert_unique_(__position, __x); }




      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_unique_(__position, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair>::value, iterator>
 insert(const_iterator __position, _Pair&& __x)
 {
   return _M_t._M_emplace_hint_unique(__position,
          std::forward<_Pair>(__x));
 }
# 883 "/usr/include/c++/7/bits/stl_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_unique(__first, __last); }
# 1023 "/usr/include/c++/7/bits/stl_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
# 1060 "/usr/include/c++/7/bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 1080 "/usr/include/c++/7/bits/stl_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 1114 "/usr/include/c++/7/bits/stl_map.h" 3
      void
      swap(map& __x)
      noexcept(__is_nothrow_swappable<_Compare>::value)
      { _M_t.swap(__x._M_t); }







      void
      clear() noexcept
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 1161 "/usr/include/c++/7/bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
 { return _M_t._M_find_tr(__x); }
# 1186 "/usr/include/c++/7/bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
 { return _M_t._M_find_tr(__x); }
# 1207 "/usr/include/c++/7/bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }


      template<typename _Kt>
 auto
 count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 { return _M_t._M_count_tr(__x); }
# 1231 "/usr/include/c++/7/bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x)
 -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
 { return iterator(_M_t._M_lower_bound_tr(__x)); }
# 1256 "/usr/include/c++/7/bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x) const
 -> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
 { return const_iterator(_M_t._M_lower_bound_tr(__x)); }
# 1276 "/usr/include/c++/7/bits/stl_map.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x)
 -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 { return iterator(_M_t._M_upper_bound_tr(__x)); }
# 1296 "/usr/include/c++/7/bits/stl_map.h" 3
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x) const
 -> decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))
 { return const_iterator(_M_t._M_upper_bound_tr(__x)); }
# 1325 "/usr/include/c++/7/bits/stl_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x)
 -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
# 1354 "/usr/include/c++/7/bits/stl_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x) const
 -> decltype(pair<const_iterator, const_iterator>(
       _M_t._M_equal_range_tr(__x)))
 {
   return pair<const_iterator, const_iterator>(
       _M_t._M_equal_range_tr(__x));
 }



      template<typename _K1, typename _T1, typename _C1, typename _A1>
 friend bool
 operator==(const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
 friend bool
 operator<(const map<_K1, _T1, _C1, _A1>&,
    const map<_K1, _T1, _C1, _A1>&);
    };
# 1392 "/usr/include/c++/7/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
        const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 1409 "/usr/include/c++/7/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
       const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
        const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
       const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
        const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
        const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


# 1476 "/usr/include/c++/7/bits/stl_map.h" 3
}
# 62 "/usr/include/c++/7/map" 2 3
# 1 "/usr/include/c++/7/bits/stl_multimap.h" 1 3
# 64 "/usr/include/c++/7/bits/stl_multimap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    class map;
# 95 "/usr/include/c++/7/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:
# 119 "/usr/include/c++/7/bits/stl_multimap.h" 3
    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<value_type>::other _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;

    public:


      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
# 174 "/usr/include/c++/7/bits/stl_multimap.h" 3
      multimap() = default;







      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
# 196 "/usr/include/c++/7/bits/stl_multimap.h" 3
      multimap(const multimap&) = default;
# 205 "/usr/include/c++/7/bits/stl_multimap.h" 3
      multimap(multimap&&) = default;
# 217 "/usr/include/c++/7/bits/stl_multimap.h" 3
      multimap(initializer_list<value_type> __l,
        const _Compare& __comp = _Compare(),
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }


      explicit
      multimap(const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }


      multimap(const multimap& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }


      multimap(multimap&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }


      multimap(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }


      template<typename _InputIterator>
 multimap(_InputIterator __first, _InputIterator __last,
   const allocator_type& __a)
 : _M_t(_Compare(), _Pair_alloc_type(__a))
 { _M_t._M_insert_equal(__first, __last); }
# 260 "/usr/include/c++/7/bits/stl_multimap.h" 3
      template<typename _InputIterator>
 multimap(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_equal(__first, __last); }
# 276 "/usr/include/c++/7/bits/stl_multimap.h" 3
      template<typename _InputIterator>
 multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
 { _M_t._M_insert_equal(__first, __last); }







      ~multimap() = default;
# 305 "/usr/include/c++/7/bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap&) = default;


      multimap&
      operator=(multimap&&) = default;
# 323 "/usr/include/c++/7/bits/stl_multimap.h" 3
      multimap&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_equal(__l.begin(), __l.end());
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin() noexcept
      { return _M_t.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() noexcept
      { return _M_t.end(); }






      const_iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() noexcept
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      const_iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      const_iterator
      cend() const noexcept
      { return _M_t.end(); }






      const_reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }




      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 481 "/usr/include/c++/7/bits/stl_multimap.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }
# 508 "/usr/include/c++/7/bits/stl_multimap.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_equal(__pos,
         std::forward<_Args>(__args)...);
 }
# 530 "/usr/include/c++/7/bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }




      iterator
      insert(value_type&& __x)
      { return _M_t._M_insert_equal(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair>::value, iterator>
 insert(_Pair&& __x)
 { return _M_t._M_emplace_equal(std::forward<_Pair>(__x)); }
# 569 "/usr/include/c++/7/bits/stl_multimap.h" 3
      iterator

      insert(const_iterator __position, const value_type& __x)



      { return _M_t._M_insert_equal_(__position, __x); }




      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_equal_(__position, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(const_iterator __position, _Pair&& __x)
 {
   return _M_t._M_emplace_hint_equal(__position,
         std::forward<_Pair>(__x));
 }
# 603 "/usr/include/c++/7/bits/stl_multimap.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_equal(__first, __last); }
# 616 "/usr/include/c++/7/bits/stl_multimap.h" 3
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
# 693 "/usr/include/c++/7/bits/stl_multimap.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
# 730 "/usr/include/c++/7/bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 751 "/usr/include/c++/7/bits/stl_multimap.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 788 "/usr/include/c++/7/bits/stl_multimap.h" 3
      void
      swap(multimap& __x)
      noexcept(__is_nothrow_swappable<_Compare>::value)
      { _M_t.swap(__x._M_t); }







      void
      clear() noexcept
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 834 "/usr/include/c++/7/bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
 { return _M_t._M_find_tr(__x); }
# 858 "/usr/include/c++/7/bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
 { return _M_t._M_find_tr(__x); }
# 876 "/usr/include/c++/7/bits/stl_multimap.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }


      template<typename _Kt>
 auto
 count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 { return _M_t._M_count_tr(__x); }
# 900 "/usr/include/c++/7/bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x)
 -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
 { return iterator(_M_t._M_lower_bound_tr(__x)); }
# 925 "/usr/include/c++/7/bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x) const
 -> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
 { return const_iterator(_M_t._M_lower_bound_tr(__x)); }
# 945 "/usr/include/c++/7/bits/stl_multimap.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x)
 -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 { return iterator(_M_t._M_upper_bound_tr(__x)); }
# 965 "/usr/include/c++/7/bits/stl_multimap.h" 3
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x) const
 -> decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))
 { return const_iterator(_M_t._M_upper_bound_tr(__x)); }
# 992 "/usr/include/c++/7/bits/stl_multimap.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x)
 -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
# 1019 "/usr/include/c++/7/bits/stl_multimap.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x) const
 -> decltype(pair<const_iterator, const_iterator>(
       _M_t._M_equal_range_tr(__x)))
 {
   return pair<const_iterator, const_iterator>(
       _M_t._M_equal_range_tr(__x));
 }



      template<typename _K1, typename _T1, typename _C1, typename _A1>
 friend bool
 operator==(const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
 friend bool
 operator<(const multimap<_K1, _T1, _C1, _A1>&,
    const multimap<_K1, _T1, _C1, _A1>&);
  };
# 1057 "/usr/include/c++/7/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 1074 "/usr/include/c++/7/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
  multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


# 1141 "/usr/include/c++/7/bits/stl_multimap.h" 3
}
# 63 "/usr/include/c++/7/map" 2 3
# 11 "/usr/local/include/coin/CoinPackedVectorBase.hpp" 2 3



class CoinPackedVector;
# 23 "/usr/local/include/coin/CoinPackedVectorBase.hpp" 3
class CoinPackedVectorBase {

public:



   virtual int getNumElements() const = 0;

   virtual const int * getIndices() const = 0;

   virtual const double * getElements() const = 0;
# 51 "/usr/local/include/coin/CoinPackedVectorBase.hpp" 3
   void setTestForDuplicateIndex(bool test) const;
# 60 "/usr/local/include/coin/CoinPackedVectorBase.hpp" 3
   void setTestForDuplicateIndexWhenTrue(bool test) const;


   bool testForDuplicateIndex() const { return testForDuplicateIndex_; }

   inline void setTestsOff() const
   { testForDuplicateIndex_=false; testedDuplicateIndex_=false;}
# 76 "/usr/local/include/coin/CoinPackedVectorBase.hpp" 3
   double * denseVector(int denseSize) const;







   double operator[](int i) const;





   int getMaxIndex() const;

   int getMinIndex() const;


   void duplicateIndex(const char* methodName = __null,
         const char * className = __null) const;



   bool isExistingIndex(int i) const;



   int findIndex(int i) const;







   bool operator==(const CoinPackedVectorBase & rhs) const;

   bool operator!=(const CoinPackedVectorBase & rhs) const;
# 130 "/usr/local/include/coin/CoinPackedVectorBase.hpp" 3
   int compare(const CoinPackedVectorBase& rhs) const;
# 139 "/usr/local/include/coin/CoinPackedVectorBase.hpp" 3
   template <class FloatEqual> bool
   isEquivalent(const CoinPackedVectorBase& rhs, const FloatEqual& eq) const
   {
      if (getNumElements() != rhs.getNumElements())
  return false;

      duplicateIndex("equivalent", "CoinPackedVector");
      rhs.duplicateIndex("equivalent", "CoinPackedVector");

      std::map<int,double> mv;
      const int * inds = getIndices();
      const double * elems = getElements();
      int i;
      for ( i = getNumElements() - 1; i >= 0; --i) {
  mv.insert(std::make_pair(inds[i], elems[i]));
      }

      std::map<int,double> mvRhs;
      inds = rhs.getIndices();
      elems = rhs.getElements();
      for ( i = getNumElements() - 1; i >= 0; --i) {
  mvRhs.insert(std::make_pair(inds[i], elems[i]));
      }

      std::map<int,double>::const_iterator mvI = mv.begin();
      std::map<int,double>::const_iterator mvIlast = mv.end();
      std::map<int,double>::const_iterator mvIrhs = mvRhs.begin();
      while (mvI != mvIlast) {
  if (mvI->first != mvIrhs->first || ! eq(mvI->second, mvIrhs->second))
     return false;
  ++mvI;
  ++mvIrhs;
      }
      return true;
   }

   bool isEquivalent(const CoinPackedVectorBase& rhs) const;






   double dotProduct(const double* dense) const;


   double oneNorm() const;


   double normSquare() const;


   double twoNorm() const;


   double infNorm() const;


   double sum() const;


protected:






   CoinPackedVectorBase();

public:

   virtual ~CoinPackedVectorBase();


private:
# 223 "/usr/local/include/coin/CoinPackedVectorBase.hpp" 3
   CoinPackedVectorBase(const CoinPackedVectorBase&);


   CoinPackedVectorBase& operator=(const CoinPackedVectorBase&);


protected:




   void findMaxMinIndices() const;


   std::set<int> * indexSet(const char* methodName = __null,
       const char * className = __null) const;


   void clearIndexSet() const;
   void clearBase() const;
   void copyMaxMinIndex(const CoinPackedVectorBase & x) const {
      maxIndex_ = x.maxIndex_;
      minIndex_ = x.minIndex_;
   }


private:



   mutable int maxIndex_;

   mutable int minIndex_;



   mutable std::set<int> * indexSetPtr_;


   mutable bool testForDuplicateIndex_;


   mutable bool testedDuplicateIndex_;

};
# 13 "/usr/local/include/coin/CoinPackedMatrix.hpp" 2 3
# 1 "/usr/local/include/coin/CoinShallowPackedVector.hpp" 1 3
# 74 "/usr/local/include/coin/CoinShallowPackedVector.hpp" 3
class CoinShallowPackedVector : public CoinPackedVectorBase {
   friend void CoinShallowPackedVectorUnitTest();

public:




   virtual int getNumElements() const { return nElements_; }

   virtual const int * getIndices() const { return indices_; }

   virtual const double * getElements() const { return elements_; }





   void clear();

   CoinShallowPackedVector& operator=(const CoinShallowPackedVector & x);

   CoinShallowPackedVector& operator=(const CoinPackedVectorBase & x);

   void setVector(int size, const int * indices, const double * elements,
    bool testForDuplicateIndex = true);





   CoinShallowPackedVector(bool testForDuplicateIndex = true);
# 114 "/usr/local/include/coin/CoinShallowPackedVector.hpp" 3
   CoinShallowPackedVector(int size,
     const int * indices, const double * elements,
     bool testForDuplicateIndex = true);

   CoinShallowPackedVector(const CoinPackedVectorBase &);

   CoinShallowPackedVector(const CoinShallowPackedVector &);

   virtual ~CoinShallowPackedVector() {}

   void print();


private:



   const int * indices_;

   const double * elements_;

   int nElements_;

};







void
CoinShallowPackedVectorUnitTest();
# 14 "/usr/local/include/coin/CoinPackedMatrix.hpp" 2 3
# 79 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
class CoinPackedMatrix {
   friend void CoinPackedMatrixUnitTest();

public:






    inline double getExtraGap() const { return extraGap_; }

    inline double getExtraMajor() const { return extraMajor_; }



    void reserve(const int newMaxMajorDim, const CoinBigIndex newMaxSize,
   bool create=false);

    void clear();


    inline bool isColOrdered() const { return colOrdered_; }


    inline bool hasGaps() const { return (size_<start_[majorDim_]) ; }


    inline CoinBigIndex getNumElements() const { return size_; }


    inline int getNumCols() const
    { return colOrdered_ ? majorDim_ : minorDim_; }


    inline int getNumRows() const
    { return colOrdered_ ? minorDim_ : majorDim_; }
# 124 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
    inline const double * getElements() const { return element_; }
# 134 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
    inline const int * getIndices() const { return index_; }





    inline int getSizeVectorStarts() const
    { return ((majorDim_ > 0)?(majorDim_+1):(0)) ; }





    inline int getSizeVectorLengths() const { return majorDim_; }






    inline const CoinBigIndex * getVectorStarts() const { return start_; }





    inline const int * getVectorLengths() const { return length_; }



    CoinBigIndex getVectorFirst(const int i) const {

      if (i < 0 || i >= majorDim_)
 throw CoinError("bad index", "vectorFirst", "CoinPackedMatrix");

      return start_[i];
    }


    CoinBigIndex getVectorLast(const int i) const {

      if (i < 0 || i >= majorDim_)
 throw CoinError("bad index", "vectorLast", "CoinPackedMatrix");

      return start_[i] + length_[i];
    }

    inline int getVectorSize(const int i) const {

      if (i < 0 || i >= majorDim_)
 throw CoinError("bad index", "vectorSize", "CoinPackedMatrix");

      return length_[i];
    }


    const CoinShallowPackedVector getVector(int i) const {

      if (i < 0 || i >= majorDim_)
 throw CoinError("bad index", "vector", "CoinPackedMatrix");

      return CoinShallowPackedVector(length_[i],
          index_ + start_[i],
          element_ + start_[i],
          false);
    }
# 211 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
    int * getMajorIndices() const;
# 225 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
    void setDimensions(int numrows, int numcols);


    void setExtraGap(const double newGap);

    void setExtraMajor(const double newMajor);







    void appendCol(const CoinPackedVectorBase& vec);







    void appendCol(const int vecsize,
       const int *vecind, const double *vecelem);







    void appendCols(const int numcols,
      const CoinPackedVectorBase * const * cols);






    int appendCols(const int numcols,
      const CoinBigIndex * columnStarts, const int * row,
                   const double * element, int numberRows=-1);







    void appendRow(const CoinPackedVectorBase& vec);







    void appendRow(const int vecsize,
      const int *vecind, const double *vecelem);







    void appendRows(const int numrows,
      const CoinPackedVectorBase * const * rows);






    int appendRows(const int numrows,
      const CoinBigIndex * rowStarts, const int * column,
                   const double * element, int numberColumns=-1);





    void rightAppendPackedMatrix(const CoinPackedMatrix& matrix);




    void bottomAppendPackedMatrix(const CoinPackedMatrix& matrix);


    void deleteCols(const int numDel, const int * indDel);

    void deleteRows(const int numDel, const int * indDel);




    void replaceVector(const int index,
         const int numReplace, const double * newElements);




    void modifyCoefficient(int row, int column, double newElement,
      bool keepZero=false);



    double getCoefficient(int row, int column) const;






    int compress(double threshold);




    int eliminateDuplicates(double threshold);

    void orderMatrix();







    int cleanMatrix(double threshold=1.0e-20);







    void removeGaps(double removeValue=-1.0);




    void submatrixOf(const CoinPackedMatrix& matrix,
       const int numMajor, const int * indMajor);



    void submatrixOfWithDuplicates(const CoinPackedMatrix& matrix,
       const int numMajor, const int * indMajor);
# 385 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
    void copyOf(const CoinPackedMatrix& rhs);



    void copyOf(const bool colordered,
         const int minor, const int major, const CoinBigIndex numels,
         const double * elem, const int * ind,
         const CoinBigIndex * start, const int * len,
         const double extraMajor=0.0, const double extraGap=0.0);



    void copyReuseArrays(const CoinPackedMatrix& rhs);
# 406 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
    void reverseOrderedCopyOf(const CoinPackedMatrix& rhs);
# 416 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
    void assignMatrix(const bool colordered,
        const int minor, const int major,
        const CoinBigIndex numels,
        double *& elem, int *& ind,
        CoinBigIndex *& start, int *& len,
        const int maxmajor = -1, const CoinBigIndex maxsize = -1);





    CoinPackedMatrix & operator=(const CoinPackedMatrix& rhs);







    void reverseOrdering();
# 446 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
    void transpose();


    void swap(CoinPackedMatrix& matrix);
# 459 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
    void times(const double * x, double * y) const;



    void times(const CoinPackedVectorBase& x, double * y) const;




    void transposeTimes(const double * x, double * y) const;



    void transposeTimes(const CoinPackedVectorBase& x, double * y) const;
# 492 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
      int * countOrthoLength() const;


      void countOrthoLength(int * counts) const;


      inline int getMajorDim() const { return majorDim_; }


      inline void setMajorDim(int value) { majorDim_ = value; }


      inline int getMinorDim() const { return minorDim_; }


      inline void setMinorDim(int value) { minorDim_ = value; }



      inline int getMaxMajorDim() const { return maxMajorDim_; }



      void dumpMatrix(const char* fname = __null) const;


      void printMatrixElement(const int row_val, const int col_val) const;
# 533 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
      void appendMajorVector(const CoinPackedVectorBase& vec);


      void appendMajorVector(const int vecsize, const int *vecind,
        const double *vecelem);


      void appendMajorVectors(const int numvecs,
         const CoinPackedVectorBase * const * vecs);


      void appendMinorVector(const CoinPackedVectorBase& vec);


      void appendMinorVector(const int vecsize, const int *vecind,
        const double *vecelem);


      void appendMinorVectors(const int numvecs,
         const CoinPackedVectorBase * const * vecs);
# 566 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
    void appendMinorFast(const int number,
      const CoinBigIndex * starts, const int * index,
                    const double * element);
# 585 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
      void majorAppendSameOrdered(const CoinPackedMatrix& matrix);




      void minorAppendSameOrdered(const CoinPackedMatrix& matrix);





      void majorAppendOrthoOrdered(const CoinPackedMatrix& matrix);





      void minorAppendOrthoOrdered(const CoinPackedMatrix& matrix);







      void deleteMajorVectors(const int numDel, const int * indDel);


      void deleteMinorVectors(const int numDel, const int * indDel);
# 623 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
      void timesMajor(const double * x, double * y) const;




      void timesMajor(const CoinPackedVectorBase& x, double * y) const;





      void timesMinor(const double * x, double * y) const;




      void timesMinor(const CoinPackedVectorBase& x, double * y) const;
# 655 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
   template <class FloatEqual> bool
   isEquivalent(const CoinPackedMatrix& rhs, const FloatEqual& eq) const
   {

      if ((isColOrdered() ^ rhs.isColOrdered()) ||
   (getNumCols() != rhs.getNumCols()) ||
   (getNumRows() != rhs.getNumRows()) ||
   (getNumElements() != rhs.getNumElements()))
  return false;

      for (int i=getMajorDim()-1; i >= 0; --i) {
        CoinShallowPackedVector pv = getVector(i);
        CoinShallowPackedVector rhsPv = rhs.getVector(i);
        if ( !pv.isEquivalent(rhsPv,eq) )
          return false;
      }
      return true;
   }







  bool isEquivalent2(const CoinPackedMatrix& rhs) const;
# 696 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
   bool isEquivalent(const CoinPackedMatrix& rhs) const;
# 709 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
    inline double * getMutableElements() const { return element_; }





    inline int * getMutableIndices() const { return index_; }



    inline CoinBigIndex * getMutableVectorStarts() const { return start_; }

    inline int * getMutableVectorLengths() const { return length_; }

    inline void setNumElements(CoinBigIndex value)
    { size_ = value;}




    inline void nullElementArray() {element_=__null;}





    inline void nullStartArray() {start_=__null;}





    inline void nullLengthArray() {length_=__null;}





    inline void nullIndexArray() {index_=__null;}






   CoinPackedMatrix();


   CoinPackedMatrix(const bool colordered,
     const double extraMajor, const double extraGap);

   CoinPackedMatrix(const bool colordered,
     const int minor, const int major, const CoinBigIndex numels,
     const double * elem, const int * ind,
     const CoinBigIndex * start, const int * len,
     const double extraMajor, const double extraGap);

   CoinPackedMatrix(const bool colordered,
     const int minor, const int major, const CoinBigIndex numels,
     const double * elem, const int * ind,
     const CoinBigIndex * start, const int * len);
# 781 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
   CoinPackedMatrix(const bool colordered,
     const int * rowIndices,
     const int * colIndices,
     const double * elements,
     CoinBigIndex numels );


   CoinPackedMatrix(const CoinPackedMatrix& m);
# 804 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
  CoinPackedMatrix(const CoinPackedMatrix &m,
       int extraForMajor, int extraElements,
     bool reverseOrdering = false) ;



  CoinPackedMatrix (const CoinPackedMatrix & wholeModel,
      int numberRows, const int * whichRows,
      int numberColumns, const int * whichColumns);


   virtual ~CoinPackedMatrix();
# 841 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
    int verifyMtx(int verbosity = 1, bool zeroesAreError = false) const ;



protected:
   void gutsOfDestructor();
   void gutsOfCopyOf(const bool colordered,
       const int minor, const int major, const CoinBigIndex numels,
       const double * elem, const int * ind,
       const CoinBigIndex * start, const int * len,
       const double extraMajor=0.0, const double extraGap=0.0);

   void gutsOfCopyOfNoGaps(const bool colordered,
       const int minor, const int major,
       const double * elem, const int * ind,
                           const CoinBigIndex * start);
   void gutsOfOpEqual(const bool colordered,
        const int minor, const int major, const CoinBigIndex numels,
        const double * elem, const int * ind,
        const CoinBigIndex * start, const int * len);
   void resizeForAddingMajorVectors(const int numVec, const int * lengthVec);
   void resizeForAddingMinorVectors(const int * addedEntries);
# 873 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
    int appendMajor(const int number,
      const CoinBigIndex * starts, const int * index,
                    const double * element, int numberOther=-1);
# 885 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
    int appendMinor(const int number,
      const CoinBigIndex * starts, const int * index,
                    const double * element, int numberOther=-1);

private:
   inline CoinBigIndex getLastStart() const {
      return majorDim_ == 0 ? 0 : start_[majorDim_];
   }


protected:




   bool colOrdered_;




   double extraGap_;



   double extraMajor_;



   double *element_;


   int *index_;

   CoinBigIndex *start_;

   int *length_;


   int majorDim_;

   int minorDim_;

   CoinBigIndex size_;


   int maxMajorDim_;

   CoinBigIndex maxSize_;

};
# 944 "/usr/local/include/coin/CoinPackedMatrix.hpp" 3
void
CoinPackedMatrixUnitTest();
# 13 "/usr/local/include/coin/ClpMatrixBase.hpp" 2 3
class CoinIndexedVector;
class ClpSimplex;
class ClpModel;
# 30 "/usr/local/include/coin/ClpMatrixBase.hpp" 3
class ClpMatrixBase {

public:



     virtual CoinPackedMatrix * getPackedMatrix() const = 0;

     virtual bool isColOrdered() const = 0;

     virtual CoinBigIndex getNumElements() const = 0;

     virtual int getNumCols() const = 0;

     virtual int getNumRows() const = 0;





     virtual const double * getElements() const = 0;





     virtual const int * getIndices() const = 0;

     virtual const CoinBigIndex * getVectorStarts() const = 0;

     virtual const int * getVectorLengths() const = 0 ;

     virtual int getVectorLength(int index) const ;

     virtual void deleteCols(const int numDel, const int * indDel) = 0;

     virtual void deleteRows(const int numDel, const int * indDel) = 0;


     virtual void appendCols(int number, const CoinPackedVectorBase * const * columns);

     virtual void appendRows(int number, const CoinPackedVectorBase * const * rows);




     virtual void modifyCoefficient(int row, int column, double newElement,
                                    bool keepZero = false);




     virtual int appendMatrix(int number, int type,
                              const CoinBigIndex * starts, const int * index,
                              const double * element, int numberOther = -1);



     virtual ClpMatrixBase * reverseOrderedCopy() const {
          return __null;
     }


     virtual CoinBigIndex countBasis(const int * whichColumn,
                                     int & numberColumnBasic) = 0;

     virtual void fillBasis(ClpSimplex * model,
                            const int * whichColumn,
                            int & numberColumnBasic,
                            int * row, int * start,
                            int * rowCount, int * columnCount,
                            CoinFactorizationDouble * element) = 0;



     virtual int scale(ClpModel * , const ClpSimplex * = __null) const {
          return 1;
     }


     virtual void scaleRowCopy(ClpModel * ) const { }

     virtual bool canGetRowCopy() const {
          return true;
     }



     inline virtual ClpMatrixBase * scaledColumnCopy(ClpModel * ) const {
          return this->clone();
     }
# 132 "/usr/local/include/coin/ClpMatrixBase.hpp" 3
     virtual bool allElementsInRange(ClpModel * ,
                                     double , double ,
                                     int = 15) {
          return true;
     }





     virtual void setDimensions(int numrows, int numcols);



     virtual void rangeOfElements(double & smallestNegative, double & largestNegative,
                                  double & smallestPositive, double & largestPositive);



     virtual void unpack(const ClpSimplex * model, CoinIndexedVector * rowArray,
                         int column) const = 0;




     virtual void unpackPacked(ClpSimplex * model,
                               CoinIndexedVector * rowArray,
                               int column) const = 0;




     virtual int refresh(ClpSimplex * ) {
          return 0;
     }


     virtual void reallyScale(const double * rowScale, const double * columnScale);





     virtual CoinBigIndex * dubiousWeights(const ClpSimplex * model, int * inputWeights) const;


     virtual void add(const ClpSimplex * model, CoinIndexedVector * rowArray,
                      int column, double multiplier) const = 0;

     virtual void add(const ClpSimplex * model, double * array,
                      int column, double multiplier) const = 0;

     virtual void releasePackedMatrix() const = 0;

     virtual bool canDoPartialPricing() const;

     virtual int hiddenRows() const;

     virtual void partialPricing(ClpSimplex * model, double start, double end,
                                 int & bestSequence, int & numberWanted);
# 201 "/usr/local/include/coin/ClpMatrixBase.hpp" 3
     virtual int extendUpdated(ClpSimplex * model, CoinIndexedVector * update, int mode);






     virtual void primalExpanded(ClpSimplex * model, int mode);
# 218 "/usr/local/include/coin/ClpMatrixBase.hpp" 3
     virtual void dualExpanded(ClpSimplex * model, CoinIndexedVector * array,
                               double * other, int mode);
# 239 "/usr/local/include/coin/ClpMatrixBase.hpp" 3
     virtual int generalExpanded(ClpSimplex * model, int mode, int & number);



     virtual int updatePivot(ClpSimplex * model, double oldInValue, double oldOutValue);



     virtual void createVariable(ClpSimplex * model, int & bestSequence);


     virtual int checkFeasible(ClpSimplex * model, double & sum) const ;

     double reducedCost(ClpSimplex * model, int sequence) const;

     virtual void correctSequence(const ClpSimplex * model, int & sequenceIn, int & sequenceOut) ;
# 265 "/usr/local/include/coin/ClpMatrixBase.hpp" 3
     virtual void times(double scalar,
                        const double * x, double * y) const = 0;



     virtual void times(double scalar,
                        const double * x, double * y,
                        const double * rowScale,
                        const double * columnScale) const;



     virtual void transposeTimes(double scalar,
                                 const double * x, double * y) const = 0;



     virtual void transposeTimes(double scalar,
                                 const double * x, double * y,
                                 const double * rowScale,
                                 const double * columnScale,
                                 double * spare = __null) const;
# 298 "/usr/local/include/coin/ClpMatrixBase.hpp" 3
     virtual void transposeTimes(const ClpSimplex * model, double scalar,
                                 const CoinIndexedVector * x,
                                 CoinIndexedVector * y,
                                 CoinIndexedVector * z) const = 0;




     virtual void subsetTransposeTimes(const ClpSimplex * model,
                                       const CoinIndexedVector * x,
                                       const CoinIndexedVector * y,
                                       CoinIndexedVector * z) const = 0;


     virtual bool canCombine(const ClpSimplex * ,
                             const CoinIndexedVector * ) const {
          return false;
     }

     virtual void transposeTimes2(const ClpSimplex * model,
                                  const CoinIndexedVector * pi1, CoinIndexedVector * dj1,
                                  const CoinIndexedVector * pi2,
                                  CoinIndexedVector * spare,
                                  double referenceIn, double devex,

                                  unsigned int * reference,
                                  double * weights, double scaleFactor);

     virtual void subsetTimes2(const ClpSimplex * model,
                               CoinIndexedVector * dj1,
                               const CoinIndexedVector * pi2, CoinIndexedVector * dj2,
                               double referenceIn, double devex,

                               unsigned int * reference,
                               double * weights, double scaleFactor);




     virtual void listTransposeTimes(const ClpSimplex * model,
                                     double * x,
                                     int * y,
                                     int number,
                                     double * z) const;




     virtual ClpMatrixBase * clone() const = 0;




     virtual ClpMatrixBase * subsetClone (
          int numberRows, const int * whichRows,
          int numberColumns, const int * whichColumns) const;

     virtual void backToBasics() {}






     inline int type() const {
          return type_;
     }

     void setType(int newtype) {
          type_ = newtype;
     }

     void useEffectiveRhs(ClpSimplex * model);



     virtual double * rhsOffset(ClpSimplex * model, bool forceRefresh = false,
                                bool check = false);

     inline int lastRefresh() const {
          return lastRefresh_;
     }

     inline int refreshFrequency() const {
          return refreshFrequency_;
     }
     inline void setRefreshFrequency(int value) {
          refreshFrequency_ = value;
     }

     inline bool skipDualCheck() const {
          return skipDualCheck_;
     }
     inline void setSkipDualCheck(bool yes) {
          skipDualCheck_ = yes;
     }


     inline int minimumObjectsScan() const {
          return minimumObjectsScan_;
     }
     inline void setMinimumObjectsScan(int value) {
          minimumObjectsScan_ = value;
     }

     inline int minimumGoodReducedCosts() const {
          return minimumGoodReducedCosts_;
     }
     inline void setMinimumGoodReducedCosts(int value) {
          minimumGoodReducedCosts_ = value;
     }

     inline double startFraction() const {
          return startFraction_;
     }
     inline void setStartFraction(double value) {
          startFraction_ = value;
     }

     inline double endFraction() const {
          return endFraction_;
     }
     inline void setEndFraction(double value) {
          endFraction_ = value;
     }

     inline double savedBestDj() const {
          return savedBestDj_;
     }
     inline void setSavedBestDj(double value) {
          savedBestDj_ = value;
     }

     inline int originalWanted() const {
          return originalWanted_;
     }
     inline void setOriginalWanted(int value) {
          originalWanted_ = value;
     }

     inline int currentWanted() const {
          return currentWanted_;
     }
     inline void setCurrentWanted(int value) {
          currentWanted_ = value;
     }

     inline int savedBestSequence() const {
          return savedBestSequence_;
     }
     inline void setSavedBestSequence(int value) {
          savedBestSequence_ = value;
     }



protected:






     ClpMatrixBase();

public:
     virtual ~ClpMatrixBase();
protected:

     ClpMatrixBase(const ClpMatrixBase&);

     ClpMatrixBase& operator=(const ClpMatrixBase&);



protected:






     double * rhsOffset_;

     double startFraction_;

     double endFraction_;

     double savedBestDj_;

     int originalWanted_;

     int currentWanted_;

     int savedBestSequence_;

     int type_;

     int lastRefresh_;

     int refreshFrequency_;

     int minimumObjectsScan_;

     int minimumGoodReducedCosts_;

     int trueSequenceIn_;

     int trueSequenceOut_;

     bool skipDualCheck_;

};
# 12 "/usr/local/include/coin/ClpPackedMatrix.hpp" 2 3
# 28 "/usr/local/include/coin/ClpPackedMatrix.hpp" 3
class ClpPackedMatrix2;
class ClpPackedMatrix3;
class ClpPackedMatrix : public ClpMatrixBase {

public:



     virtual CoinPackedMatrix * getPackedMatrix() const {
          return matrix_;
     }

     virtual bool isColOrdered() const {
          return matrix_->isColOrdered();
     }

     virtual CoinBigIndex getNumElements() const {
          return matrix_->getNumElements();
     }

     virtual int getNumCols() const {
          return matrix_->getNumCols();
     }

     virtual int getNumRows() const {
          return matrix_->getNumRows();
     }





     virtual const double * getElements() const {
          return matrix_->getElements();
     }

     inline double * getMutableElements() const {
          return matrix_->getMutableElements();
     }





     virtual const int * getIndices() const {
          return matrix_->getIndices();
     }

     virtual const CoinBigIndex * getVectorStarts() const {
          return matrix_->getVectorStarts();
     }

     virtual const int * getVectorLengths() const {
          return matrix_->getVectorLengths();
     }

     virtual int getVectorLength(int index) const {
          return matrix_->getVectorSize(index);
     }


     virtual void deleteCols(const int numDel, const int * indDel);

     virtual void deleteRows(const int numDel, const int * indDel);


     virtual void appendCols(int number, const CoinPackedVectorBase * const * columns);

     virtual void appendRows(int number, const CoinPackedVectorBase * const * rows);





     virtual int appendMatrix(int number, int type,
                              const CoinBigIndex * starts, const int * index,
                              const double * element, int numberOther = -1);




     virtual void replaceVector(const int index,
                                const int numReplace, const double * newElements) {
          matrix_->replaceVector(index, numReplace, newElements);
     }



     virtual void modifyCoefficient(int row, int column, double newElement,
                                    bool keepZero = false) {
          matrix_->modifyCoefficient(row, column, newElement, keepZero);
     }

     virtual ClpMatrixBase * reverseOrderedCopy() const;

     virtual CoinBigIndex countBasis(const int * whichColumn,
                                     int & numberColumnBasic);

     virtual void fillBasis(ClpSimplex * model,
                            const int * whichColumn,
                            int & numberColumnBasic,
                            int * row, int * start,
                            int * rowCount, int * columnCount,
                            CoinFactorizationDouble * element);


     virtual int scale(ClpModel * model, const ClpSimplex * baseModel = __null) const ;


     virtual void scaleRowCopy(ClpModel * model) const ;

     void createScaledMatrix(ClpSimplex * model) const;



     virtual ClpMatrixBase * scaledColumnCopy(ClpModel * model) const ;
# 154 "/usr/local/include/coin/ClpPackedMatrix.hpp" 3
     virtual bool allElementsInRange(ClpModel * model,
                                     double smallest, double largest,
                                     int check = 15);



     virtual void rangeOfElements(double & smallestNegative, double & largestNegative,
                                  double & smallestPositive, double & largestPositive);



     virtual void unpack(const ClpSimplex * model, CoinIndexedVector * rowArray,
                         int column) const ;




     virtual void unpackPacked(ClpSimplex * model,
                               CoinIndexedVector * rowArray,
                               int column) const;


     virtual void add(const ClpSimplex * model, CoinIndexedVector * rowArray,
                      int column, double multiplier) const ;

     virtual void add(const ClpSimplex * model, double * array,
                      int column, double multiplier) const;

     virtual void releasePackedMatrix() const { }




     virtual CoinBigIndex * dubiousWeights(const ClpSimplex * model, int * inputWeights) const;

     virtual bool canDoPartialPricing() const;

     virtual void partialPricing(ClpSimplex * model, double start, double end,
                                 int & bestSequence, int & numberWanted);

     virtual int refresh(ClpSimplex * model);

     virtual void reallyScale(const double * rowScale, const double * columnScale);





     virtual void setDimensions(int numrows, int numcols);







     virtual void times(double scalar,
                        const double * x, double * y) const;

     virtual void times(double scalar,
                        const double * x, double * y,
                        const double * rowScale,
                        const double * columnScale) const;



     virtual void transposeTimes(double scalar,
                                 const double * x, double * y) const;

     virtual void transposeTimes(double scalar,
                                 const double * x, double * y,
                                 const double * rowScale,
                                 const double * columnScale,
                                 double * spare = __null) const;




     void transposeTimesSubset( int number,
                                const int * which,
                                const double * pi, double * y,
                                const double * rowScale,
                                const double * columnScale,
                                double * spare = __null) const;




     virtual void transposeTimes(const ClpSimplex * model, double scalar,
                                 const CoinIndexedVector * x,
                                 CoinIndexedVector * y,
                                 CoinIndexedVector * z) const;




     void transposeTimesByColumn(const ClpSimplex * model, double scalar,
                                 const CoinIndexedVector * x,
                                 CoinIndexedVector * y,
                                 CoinIndexedVector * z) const;





     virtual void transposeTimesByRow(const ClpSimplex * model, double scalar,
                                      const CoinIndexedVector * x,
                                      CoinIndexedVector * y,
                                      CoinIndexedVector * z) const;



     virtual void subsetTransposeTimes(const ClpSimplex * model,
                                       const CoinIndexedVector * x,
                                       const CoinIndexedVector * y,
                                       CoinIndexedVector * z) const;


     virtual bool canCombine(const ClpSimplex * model,
                             const CoinIndexedVector * pi) const;

     virtual void transposeTimes2(const ClpSimplex * model,
                                  const CoinIndexedVector * pi1, CoinIndexedVector * dj1,
                                  const CoinIndexedVector * pi2,
                                  CoinIndexedVector * spare,
                                  double referenceIn, double devex,

                                  unsigned int * reference,
                                  double * weights, double scaleFactor);

     virtual void subsetTimes2(const ClpSimplex * model,
                               CoinIndexedVector * dj1,
                               const CoinIndexedVector * pi2, CoinIndexedVector * dj2,
                               double referenceIn, double devex,

                               unsigned int * reference,
                               double * weights, double scaleFactor);

     void useEffectiveRhs(ClpSimplex * model);
# 305 "/usr/local/include/coin/ClpPackedMatrix.hpp" 3
     inline CoinPackedMatrix * matrix() const {
          return matrix_;
     }



     inline void setMatrixNull() {
          matrix_ = __null;
     }

     inline void makeSpecialColumnCopy() {
          flags_ |= 16;
     }

     void releaseSpecialColumnCopy();

     inline bool zeros() const {
          return ((flags_ & 1) != 0);
     }

     inline bool wantsSpecialColumnCopy() const {
          return ((flags_ & 16) != 0);
     }

     inline int flags() const {
          return flags_;
     }

     inline void checkGaps() {
          flags_ = (matrix_->hasGaps()) ? (flags_ | 2) : (flags_ & (~2));
     }

     inline int numberActiveColumns() const
     { return numberActiveColumns_;}

     inline void setNumberActiveColumns(int value)
     { numberActiveColumns_ = value;}






     ClpPackedMatrix();

     virtual ~ClpPackedMatrix();





     ClpPackedMatrix(const ClpPackedMatrix&);

     ClpPackedMatrix(const CoinPackedMatrix&);


     ClpPackedMatrix (const ClpPackedMatrix & wholeModel,
                      int numberRows, const int * whichRows,
                      int numberColumns, const int * whichColumns);
     ClpPackedMatrix (const CoinPackedMatrix & wholeModel,
                      int numberRows, const int * whichRows,
                      int numberColumns, const int * whichColumns);


     ClpPackedMatrix(CoinPackedMatrix * matrix);

     ClpPackedMatrix& operator=(const ClpPackedMatrix&);

     virtual ClpMatrixBase * clone() const ;

     virtual void copy(const ClpPackedMatrix * from);


     virtual ClpMatrixBase * subsetClone (
          int numberRows, const int * whichRows,
          int numberColumns, const int * whichColumns) const ;

     void specialRowCopy(ClpSimplex * model, const ClpMatrixBase * rowCopy);

     void specialColumnCopy(ClpSimplex * model);

     virtual void correctSequence(const ClpSimplex * model, int & sequenceIn, int & sequenceOut) ;

private:

     int gutsOfTransposeTimesUnscaled(const double * pi,
                                      int * index,
                                      double * array,
                                      const double tolerance) const;

     int gutsOfTransposeTimesScaled(const double * pi,
                                    const double * columnScale,
                                    int * index,
                                    double * array,
                                    const double tolerance) const;

     int gutsOfTransposeTimesUnscaled(const double * pi,
                                      int * index,
                                      double * array,
                                      const unsigned char * status,
                                      const double tolerance) const;


     int gutsOfTransposeTimesUnscaled(const double * pi,
                                      int * index,
                                      double * array,
                                      const unsigned char * status,
                                      int * spareIndex,
                                      double * spareArray,
                                      const double * reducedCost,
                                      double & upperTheta,
                                      double & bestPossible,
                                      double acceptablePivot,
                                      double dualTolerance,
                                      int & numberRemaining,
                                      const double zeroTolerance) const;

     int gutsOfTransposeTimesScaled(const double * pi,
                                    const double * columnScale,
                                    int * index,
                                    double * array,
                                    const unsigned char * status,
                                    const double tolerance) const;

     int gutsOfTransposeTimesByRowGEK(const CoinIndexedVector * piVector,
                                      int * index,
                                      double * output,
                                      int numberColumns,
                                      const double tolerance,
                                      const double scalar) const;

     int gutsOfTransposeTimesByRowGE3(const CoinIndexedVector * piVector,
                                      int * index,
                                      double * output,
                                      double * array2,
                                      const double tolerance,
                                      const double scalar) const;

     int gutsOfTransposeTimesByRowGE3a(const CoinIndexedVector * piVector,
                                      int * index,
                                      double * output,
                                      int * lookup,
                                      char * marked,
                                      const double tolerance,
                                      const double scalar) const;

     void gutsOfTransposeTimesByRowEQ2(const CoinIndexedVector * piVector, CoinIndexedVector * output,
                                       CoinIndexedVector * spareVector, const double tolerance, const double scalar) const;

     void gutsOfTransposeTimesByRowEQ1(const CoinIndexedVector * piVector, CoinIndexedVector * output,
                                       const double tolerance, const double scalar) const;

     void clearCopies();


protected:

     void checkFlags(int type) const;




     CoinPackedMatrix * matrix_;

     int numberActiveColumns_;







     mutable int flags_;

     ClpPackedMatrix2 * rowCopy_;

     ClpPackedMatrix3 * columnCopy_;

};
# 509 "/usr/local/include/coin/ClpPackedMatrix.hpp" 3
class ClpPackedMatrix2 {

public:





     void transposeTimes(const ClpSimplex * model,
                         const CoinPackedMatrix * rowCopy,
                         const CoinIndexedVector * x,
                         CoinIndexedVector * spareArray,
                         CoinIndexedVector * z) const;

     inline bool usefulInfo() const {
          return rowStart_ != __null;
     }






     ClpPackedMatrix2();

     ClpPackedMatrix2(ClpSimplex * model, const CoinPackedMatrix * rowCopy);

     virtual ~ClpPackedMatrix2();





     ClpPackedMatrix2(const ClpPackedMatrix2&);
     ClpPackedMatrix2& operator=(const ClpPackedMatrix2&);



protected:




     int numberBlocks_;

     int numberRows_;

     int * offset_;

     mutable unsigned short * count_;

     mutable CoinBigIndex * rowStart_;

     unsigned short * column_;

     double * work_;





};
typedef struct {
     CoinBigIndex startElements_;
     int startIndices_;
     int numberInBlock_;
     int numberPrice_;
     int numberElements_;
} blockStruct;
class ClpPackedMatrix3 {

public:





     void transposeTimes(const ClpSimplex * model,
                         const double * pi,
                         CoinIndexedVector * output) const;

     void transposeTimes2(const ClpSimplex * model,
                          const double * pi, CoinIndexedVector * dj1,
                          const double * piWeight,
                          double referenceIn, double devex,

                          unsigned int * reference,
                          double * weights, double scaleFactor);






     ClpPackedMatrix3();

     ClpPackedMatrix3(ClpSimplex * model, const CoinPackedMatrix * columnCopy);

     virtual ~ClpPackedMatrix3();





     ClpPackedMatrix3(const ClpPackedMatrix3&);
     ClpPackedMatrix3& operator=(const ClpPackedMatrix3&);




     void sortBlocks(const ClpSimplex * model);

     void swapOne(const ClpSimplex * model, const ClpPackedMatrix * matrix,
                  int iColumn);



protected:




     int numberBlocks_;

     int numberColumns_;

     int * column_;

     CoinBigIndex * start_;

     int * row_;

     double * element_;

     blockStruct * block_;

};
# 20 "/usr/local/include/coin/ClpModel.hpp" 2 3
# 1 "/usr/local/include/coin/CoinMessageHandler.hpp" 1 3
# 13 "/usr/local/include/coin/CoinMessageHandler.hpp" 3
# 1 "/usr/include/c++/7/cstdio" 1 3
# 39 "/usr/include/c++/7/cstdio" 3
       
# 40 "/usr/include/c++/7/cstdio" 3
# 14 "/usr/local/include/coin/CoinMessageHandler.hpp" 2 3
# 58 "/usr/local/include/coin/CoinMessageHandler.hpp" 3
class CoinOneMessage {

public:



  CoinOneMessage();

  CoinOneMessage(int externalNumber, char detail,
  const char * message);

  ~CoinOneMessage();

  CoinOneMessage(const CoinOneMessage&);

  CoinOneMessage& operator=(const CoinOneMessage&);





  void replaceMessage(const char * message);





  inline int externalNumber() const
  {return externalNumber_;}





  inline void setExternalNumber(int number)
  {externalNumber_=number;}

  inline char severity() const
  {return severity_;}

  inline void setDetail(int level)
  {detail_=static_cast<char> (level);}

  inline int detail() const
  {return detail_;}

  inline char * message() const
  {return message_;}





    int externalNumber_;

    char detail_;

    char severity_;

  mutable char message_[400];

};
# 128 "/usr/local/include/coin/CoinMessageHandler.hpp" 3
class CoinMessages {

public:





  enum Language {
    us_en = 0,
    uk_en,
    it
  };




  CoinMessages(int numberMessages=0);

  ~CoinMessages();

  CoinMessages(const CoinMessages&);

  CoinMessages& operator=(const CoinMessages&);
# 161 "/usr/local/include/coin/CoinMessageHandler.hpp" 3
  void addMessage(int messageNumber, const CoinOneMessage & message);





  void replaceMessage(int messageNumber, const char * message);

  inline Language language() const
  {return language_;}

  void setLanguage(Language newlanguage)
  {language_ = newlanguage;}

  void setDetailMessage(int newLevel, int messageNumber);







  void setDetailMessages(int newLevel, int numberMessages,
    int * messageNumbers);

  void setDetailMessages(int newLevel, int low, int high);


  inline int getClass() const
  { return class_;}

  void toCompact();

  void fromCompact();





  int numberMessages_;

  Language language_;

  char source_[5];

  int class_;



  int lengthMessages_;

  CoinOneMessage ** message_;

};


enum CoinMessageMarker {
  CoinMessageEol = 0,
  CoinMessageNewline = 1
};
# 327 "/usr/local/include/coin/CoinMessageHandler.hpp" 3
class CoinMessageHandler {

friend bool CoinMessageHandlerUnitTest () ;

public:




  virtual int print() ;


  virtual void checkSeverity() ;





  CoinMessageHandler();

  CoinMessageHandler(FILE *fp);

  virtual ~CoinMessageHandler();

  CoinMessageHandler(const CoinMessageHandler&);

  CoinMessageHandler& operator=(const CoinMessageHandler&);

  virtual CoinMessageHandler * clone() const;




  inline int detail(int messageNumber, const CoinMessages &normalMessage) const
  { return normalMessage.message_[messageNumber]->detail();}

  inline int logLevel() const
          { return logLevel_;}
# 382 "/usr/local/include/coin/CoinMessageHandler.hpp" 3
  void setLogLevel(int value);

  inline int logLevel(int which) const
  { return logLevels_[which];}




  void setLogLevel(int which, int value);


  void setPrecision(unsigned int new_precision);

  inline int precision() { return (g_precision_) ; }


  void setPrefix(bool yesNo);

  bool prefix() const;





  inline double doubleValue(int position) const
  { return doubleValue_[position];}




  inline int numberDoubleFields() const
  {return static_cast<int>(doubleValue_.size());}





  inline int intValue(int position) const
  { return longValue_[position];}




  inline int numberIntFields() const
  {return static_cast<int>(longValue_.size());}





  inline char charValue(int position) const
  { return charValue_[position];}




  inline int numberCharFields() const
  {return static_cast<int>(charValue_.size());}





  inline std::string stringValue(int position) const
  { return stringValue_[position];}




  inline int numberStringFields() const
  {return static_cast<int>(stringValue_.size());}


  inline CoinOneMessage currentMessage() const
  {return currentMessage_;}

  inline std::string currentSource() const
  {return source_;}

  inline const char * messageBuffer() const
  {return messageBuffer_;}

  inline int highestNumber() const
  {return highestNumber_;}

  inline FILE * filePointer() const
  { return fp_;}

  inline void setFilePointer(FILE * fp)
  { fp_ = fp;}
# 482 "/usr/local/include/coin/CoinMessageHandler.hpp" 3
  CoinMessageHandler &message(int messageNumber,
         const CoinMessages &messages) ;
# 498 "/usr/local/include/coin/CoinMessageHandler.hpp" 3
  CoinMessageHandler & message(int detail = -1) ;
# 512 "/usr/local/include/coin/CoinMessageHandler.hpp" 3
  CoinMessageHandler &message(int externalNumber, const char *source,
         const char *msg,
         char severity, int detail = -1) ;





  CoinMessageHandler & operator<< (int intvalue);
# 539 "/usr/local/include/coin/CoinMessageHandler.hpp" 3
  CoinMessageHandler & operator<< (double doublevalue);




  CoinMessageHandler & operator<< (const std::string& stringvalue);




  CoinMessageHandler & operator<< (char charvalue);




  CoinMessageHandler & operator<< (const char *stringvalue);




  CoinMessageHandler & operator<< (CoinMessageMarker);




  int finish();
# 574 "/usr/local/include/coin/CoinMessageHandler.hpp" 3
  CoinMessageHandler & printing(bool onOff);
# 589 "/usr/local/include/coin/CoinMessageHandler.hpp" 3
protected:



  std::vector<double> doubleValue_;
  std::vector<int> longValue_;
  std::vector<char> charValue_;
  std::vector<std::string> stringValue_;

  int logLevel_;

  int logLevels_[4];

  int prefix_;

  CoinOneMessage currentMessage_;

  int internalNumber_;

  char * format_;

  char messageBuffer_[1000];

  char * messageOut_;

  std::string source_;
# 623 "/usr/local/include/coin/CoinMessageHandler.hpp" 3
  int printStatus_;

  int highestNumber_;

  FILE * fp_;

  char g_format_[8];

  int g_precision_ ;


private:


  void gutsOfCopy(const CoinMessageHandler &rhs) ;





  char *nextPerCent(char *start, const bool initial = false) ;





  int internalPrint() ;


  void calcPrintStatus(int msglvl, int msgclass) ;


};







bool
CoinMessageHandlerUnitTest();
# 21 "/usr/local/include/coin/ClpModel.hpp" 2 3
# 1 "/usr/local/include/coin/CoinHelperFunctions.hpp" 1 3
# 17 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4
extern "C" {
# 205 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 206 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 210 "/usr/include/unistd.h" 2 3 4
# 229 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 230 "/usr/include/unistd.h" 2 3 4
# 277 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 290 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
# 337 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 348 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 379 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 407 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
# 435 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 447 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 472 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
# 514 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 613 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();


extern __pid_t getpgrp (void) throw ();


extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 663 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();






extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw () ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw () ;




extern int seteuid (__uid_t __uid) throw () ;






extern int setgid (__gid_t __gid) throw () ;




extern int setregid (__gid_t __rgid, __gid_t __egid) throw () ;




extern int setegid (__gid_t __gid) throw () ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw () ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw () ;






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();




extern int ttyslot (void) throw ();




extern int link (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) throw () __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern "C" {







extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw () __attribute__ ((__nonnull__ (2, 3)));

}
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4

extern "C" {
# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
}
# 873 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) throw ();






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
# 994 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1006 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1017 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) throw () ;
# 1027 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
# 1038 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
# 1059 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1082 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1092 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1110 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);







extern char *crypt (const char *__key, const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__glibc_block, int __edflag)
     throw () __attribute__ ((__nonnull__ (1)));






extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
# 1167 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length) ;







}
# 18 "/usr/local/include/coin/CoinHelperFunctions.hpp" 2 3



# 1 "/usr/include/c++/7/cstdlib" 1 3
# 39 "/usr/include/c++/7/cstdlib" 3
       
# 40 "/usr/include/c++/7/cstdlib" 3
# 22 "/usr/local/include/coin/CoinHelperFunctions.hpp" 2 3
# 1 "/usr/include/c++/7/cstdio" 1 3
# 39 "/usr/include/c++/7/cstdio" 3
       
# 40 "/usr/include/c++/7/cstdio" 3
# 23 "/usr/local/include/coin/CoinHelperFunctions.hpp" 2 3
# 43 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
template <class T> inline void
CoinCopyN(register const T* from, const int size, register T* to)
{
    if (size == 0 || from == to)
 return;


    if (size < 0)
 throw CoinError("trying to copy negative number of entries",
   "CoinCopyN", "");


    register int n = (size + 7) / 8;
    if (to > from) {
 register const T* downfrom = from + size;
 register T* downto = to + size;

 switch (size % 8) {
 case 0: do{ *--downto = *--downfrom;
 case 7: *--downto = *--downfrom;
 case 6: *--downto = *--downfrom;
 case 5: *--downto = *--downfrom;
 case 4: *--downto = *--downfrom;
 case 3: *--downto = *--downfrom;
 case 2: *--downto = *--downfrom;
 case 1: *--downto = *--downfrom;
 }while(--n>0);
 }
    } else {

 --from;
 --to;
 switch (size % 8) {
 case 0: do{ *++to = *++from;
 case 7: *++to = *++from;
 case 6: *++to = *++from;
 case 5: *++to = *++from;
 case 4: *++to = *++from;
 case 3: *++to = *++from;
 case 2: *++to = *++from;
 case 1: *++to = *++from;
 }while(--n>0);
 }
    }
}
# 101 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
template <class T> inline void
CoinCopy(register const T* first, register const T* last, register T* to)
{
    CoinCopyN(first, static_cast<int>(last-first), to);
}
# 116 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
template <class T> inline void
CoinDisjointCopyN(register const T* from, const int size, register T* to)
{

    if (size == 0 || from == to)
 return;


    if (size < 0)
 throw CoinError("trying to copy negative number of entries",
   "CoinDisjointCopyN", "");
# 138 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
    for (register int n = size / 8; n > 0; --n, from += 8, to += 8) {
 to[0] = from[0];
 to[1] = from[1];
 to[2] = from[2];
 to[3] = from[3];
 to[4] = from[4];
 to[5] = from[5];
 to[6] = from[6];
 to[7] = from[7];
    }
    switch (size % 8) {
    case 7: to[6] = from[6];
    case 6: to[5] = from[5];
    case 5: to[4] = from[4];
    case 4: to[3] = from[3];
    case 3: to[2] = from[2];
    case 2: to[1] = from[1];
    case 1: to[0] = from[0];
    case 0: break;
    }



}







template <class T> inline void
CoinDisjointCopy(register const T* first, register const T* last,
   register T* to)
{
    CoinDisjointCopyN(first, static_cast<int>(last - first), to);
}







template <class T> inline T*
CoinCopyOfArray( const T * array, const int size)
{
    if (array) {
 T * arrayNew = new T[size];
 std::memcpy(arrayNew,array,size*sizeof(T));
 return arrayNew;
    } else {
 return __null;
    }
}






template <class T> inline T*
CoinCopyOfArrayPartial( const T * array, const int size,const int copySize)
{
    if (array||size) {
 T * arrayNew = new T[size];
 (static_cast <bool> (copySize<=size) ? void (0) : __assert_fail ("copySize<=size", "/usr/local/include/coin/CoinHelperFunctions.hpp", 204, __extension__ __PRETTY_FUNCTION__));
 std::memcpy(arrayNew,array,copySize*sizeof(T));
 return arrayNew;
    } else {
 return __null;
    }
}





template <class T> inline T*
CoinCopyOfArray( const T * array, const int size, T value)
{
    T * arrayNew = new T[size];
    if (array) {
        std::memcpy(arrayNew,array,size*sizeof(T));
    } else {
 int i;
 for (i=0;i<size;i++)
     arrayNew[i] = value;
    }
    return arrayNew;
}






template <class T> inline T*
CoinCopyOfArrayOrZero( const T * array , const int size)
{
    T * arrayNew = new T[size];
    if (array) {
      std::memcpy(arrayNew,array,size*sizeof(T));
    } else {
      std::memset(arrayNew,0,size*sizeof(T));
    }
    return arrayNew;
}
# 258 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
template <class T> inline void
CoinMemcpyN(register const T* from, const int size, register T* to)
{
# 281 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
    if (size == 0 || from == to)
 return;


    if (size < 0)
 throw CoinError("trying to copy negative number of entries",
   "CoinMemcpyN", "");
# 299 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
    for (register int n = size / 8; n > 0; --n, from += 8, to += 8) {
 to[0] = from[0];
 to[1] = from[1];
 to[2] = from[2];
 to[3] = from[3];
 to[4] = from[4];
 to[5] = from[5];
 to[6] = from[6];
 to[7] = from[7];
    }
    switch (size % 8) {
    case 7: to[6] = from[6];
    case 6: to[5] = from[5];
    case 5: to[4] = from[4];
    case 4: to[3] = from[3];
    case 3: to[2] = from[2];
    case 2: to[1] = from[1];
    case 1: to[0] = from[0];
    case 0: break;
    }




}
# 345 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
template <class T> inline void
CoinMemcpy(register const T* first, register const T* last,
    register T* to)
{
    CoinMemcpyN(first, static_cast<int>(last - first), to);
}
# 360 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
template <class T> inline void
CoinFillN(register T* to, const int size, register const T value)
{
    if (size == 0)
 return;


    if (size < 0)
 throw CoinError("trying to fill negative number of entries",
   "CoinFillN", "");


    for (register int n = size / 8; n > 0; --n, to += 8) {
 to[0] = value;
 to[1] = value;
 to[2] = value;
 to[3] = value;
 to[4] = value;
 to[5] = value;
 to[6] = value;
 to[7] = value;
    }
    switch (size % 8) {
    case 7: to[6] = value;
    case 6: to[5] = value;
    case 5: to[4] = value;
    case 4: to[3] = value;
    case 3: to[2] = value;
    case 2: to[1] = value;
    case 1: to[0] = value;
    case 0: break;
    }
# 408 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
}






template <class T> inline void
CoinFill(register T* first, register T* last, const T value)
{
    CoinFillN(first, last - first, value);
}
# 429 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
template <class T> inline void
CoinZeroN(register T* to, const int size)
{
# 442 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
    if (size == 0)
 return;


    if (size < 0)
 throw CoinError("trying to fill negative number of entries",
   "CoinZeroN", "");


    for (register int n = size / 8; n > 0; --n, to += 8) {
 to[0] = 0;
 to[1] = 0;
 to[2] = 0;
 to[3] = 0;
 to[4] = 0;
 to[5] = 0;
 to[6] = 0;
 to[7] = 0;
    }
    switch (size % 8) {
    case 7: to[6] = 0;
    case 6: to[5] = 0;
    case 5: to[4] = 0;
    case 4: to[3] = 0;
    case 3: to[2] = 0;
    case 2: to[1] = 0;
    case 1: to[0] = 0;
    case 0: break;
    }
# 488 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
}

inline void
CoinCheckDoubleZero(double * to, const int size)
{
    int n=0;
    for (int j=0;j<size;j++) {
 if (to[j])
     n++;
    }
    if (n) {
 printf("array of length %d should be zero has %d nonzero\n",size,n);
    }
}

inline void
CoinCheckIntZero(int * to, const int size)
{
    int n=0;
    for (int j=0;j<size;j++) {
 if (to[j])
     n++;
    }
    if (n) {
 printf("array of length %d should be zero has %d nonzero\n",size,n);
    }
}






template <class T> inline void
CoinZero(register T* first, register T* last)
{
    CoinZeroN(first, last - first);
}




inline char * CoinStrdup(const char * name)
{
  char* dup = __null;
  if (name) {
    const int len = static_cast<int>(strlen(name));
    dup = static_cast<char*>(malloc(len+1));
    CoinMemcpyN(name, len, dup);
    dup[len] = 0;
  }
  return dup;
}






template <class T> inline T
CoinMax(register const T x1, register const T x2)
{
    return (x1 > x2) ? x1 : x2;
}






template <class T> inline T
CoinMin(register const T x1, register const T x2)
{
    return (x1 < x2) ? x1 : x2;
}






template <class T> inline T
CoinAbs(const T value)
{
    return value<0 ? -value : value;
}






template <class T> inline bool
CoinIsSorted(register const T* first, const int size)
{
    if (size == 0)
 return true;


    if (size < 0)
 throw CoinError("negative number of entries", "CoinIsSorted", "");



    const int size1 = size - 1;
    for (register int n = size1 / 8; n > 0; --n, first += 8) {
 if (first[8] < first[7]) return false;
 if (first[7] < first[6]) return false;
 if (first[6] < first[5]) return false;
 if (first[5] < first[4]) return false;
 if (first[4] < first[3]) return false;
 if (first[3] < first[2]) return false;
 if (first[2] < first[1]) return false;
 if (first[1] < first[0]) return false;
    }

    switch (size1 % 8) {
    case 7: if (first[7] < first[6]) return false;
    case 6: if (first[6] < first[5]) return false;
    case 5: if (first[5] < first[4]) return false;
    case 4: if (first[4] < first[3]) return false;
    case 3: if (first[3] < first[2]) return false;
    case 2: if (first[2] < first[1]) return false;
    case 1: if (first[1] < first[0]) return false;
    case 0: break;
    }







    return true;
}






template <class T> inline bool
CoinIsSorted(register const T* first, register const T* last)
{
    return CoinIsSorted(first, static_cast<int>(last - first));
}






template <class T> inline void
CoinIotaN(register T* first, const int size, register T init)
{
    if (size == 0)
 return;


    if (size < 0)
 throw CoinError("negative number of entries", "CoinIotaN", "");


    for (register int n = size / 8; n > 0; --n, first += 8, init += 8) {
 first[0] = init;
 first[1] = init + 1;
 first[2] = init + 2;
 first[3] = init + 3;
 first[4] = init + 4;
 first[5] = init + 5;
 first[6] = init + 6;
 first[7] = init + 7;
    }
    switch (size % 8) {
    case 7: first[6] = init + 6;
    case 6: first[5] = init + 5;
    case 5: first[4] = init + 4;
    case 4: first[3] = init + 3;
    case 3: first[2] = init + 2;
    case 2: first[1] = init + 1;
    case 1: first[0] = init;
    case 0: break;
    }
# 688 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
}






template <class T> inline void
CoinIota(T* first, const T* last, T init)
{
    CoinIotaN(first, last-first, init);
}
# 708 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
template <class T> inline T *
CoinDeleteEntriesFromArray(register T * arrayFirst, register T * arrayLast,
      const int * firstDelPos, const int * lastDelPos)
{
    int delNum = static_cast<int>(lastDelPos - firstDelPos);
    if (delNum == 0)
 return arrayLast;

    if (delNum < 0)
 throw CoinError("trying to delete negative number of entries",
   "CoinDeleteEntriesFromArray", "");

    int * delSortedPos = __null;
    if (! (CoinIsSorted(firstDelPos, lastDelPos) &&
    std::adjacent_find(firstDelPos, lastDelPos) == lastDelPos)) {

 delSortedPos = new int[delNum];
 CoinDisjointCopy(firstDelPos, lastDelPos, delSortedPos);
 std::sort(delSortedPos, delSortedPos + delNum);
 delNum = static_cast<int>(std::unique(delSortedPos,
      delSortedPos+delNum) - delSortedPos);
    }
    const int * delSorted = delSortedPos ? delSortedPos : firstDelPos;

    const int last = delNum - 1;
    int size = delSorted[0];
    for (int i = 0; i < last; ++i) {
 const int copyFirst = delSorted[i] + 1;
 const int copyLast = delSorted[i+1];
 CoinCopy(arrayFirst + copyFirst, arrayFirst + copyLast,
   arrayFirst + size);
 size += copyLast - copyFirst;
    }
    const int copyFirst = delSorted[last] + 1;
    const int copyLast = static_cast<int>(arrayLast - arrayFirst);
    CoinCopy(arrayFirst + copyFirst, arrayFirst + copyLast,
      arrayFirst + size);
    size += copyLast - copyFirst;

    if (delSortedPos)
 delete[] delSortedPos;

    return arrayFirst + size;
}
# 773 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
inline double CoinDrand48 (bool isSeed = false, unsigned int seed = 1)
{
  static unsigned int last = 123456;
  if (isSeed) {
    last = seed;
  } else {
    last = 1664525*last+1013904223;
    return ((static_cast<double> (last))/4294967296.0);
  }
  return (0.0);
}


inline void CoinSeedRandom(int iseed)
{
  CoinDrand48(true, iseed);
}
# 815 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
inline char CoinFindDirSeparator()
{
    int size = 1000;
    char* buf = 0;
    while (true) {
 buf = new char[size];
 if (getcwd(buf, size))
     break;
 delete[] buf;
 buf = 0;
 size = 2*size;
    }


    char dirsep = buf[0] == '/' ? '/' : '\\';
    delete[] buf;
    return dirsep;
}


inline int CoinStrNCaseCmp(const char* s0, const char* s1,
      const size_t len)
{
    for (size_t i = 0; i < len; ++i) {
 if (s0[i] == 0) {
     return s1[i] == 0 ? 0 : -1;
 }
 if (s1[i] == 0) {
     return 1;
 }
 const int c0 = std::tolower(s0[i]);
 const int c1 = std::tolower(s1[i]);
 if (c0 < c1)
     return -1;
 if (c0 > c1)
     return 1;
    }
    return 0;
}




template <class T> inline void CoinSwap (T &x, T &y)
{
    T t = x;
    x = y;
    y = t;
}







template <class T> inline int
CoinToFile( const T* array, CoinBigIndex size, FILE * fp)
{
    CoinBigIndex numberWritten;
    if (array&&size) {
 numberWritten =
     static_cast<CoinBigIndex>(fwrite(&size,sizeof(int),1,fp));
 if (numberWritten!=1)
     return 1;
 numberWritten =
     static_cast<CoinBigIndex>(fwrite(array,sizeof(T),size_t(size),fp));
 if (numberWritten!=size)
     return 1;
    } else {
 size = 0;
 numberWritten =
     static_cast<CoinBigIndex>(fwrite(&size,sizeof(int),1,fp));
 if (numberWritten!=1)
     return 1;
    }
    return 0;
}
# 902 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
template <class T> inline int
CoinFromFile( T* &array, CoinBigIndex size, FILE * fp, CoinBigIndex & newSize)
{
    CoinBigIndex numberRead;
    numberRead =
        static_cast<CoinBigIndex>(fread(&newSize,sizeof(int),1,fp));
    if (numberRead!=1)
 return 1;
    int returnCode=0;
    if (size!=newSize&&(newSize||array))
 returnCode=2;
    if (newSize) {
 array = new T [newSize];
 numberRead =
     static_cast<CoinBigIndex>(fread(array,sizeof(T),newSize,fp));
 if (numberRead!=newSize)
     returnCode=1;
    } else {
 array = __null;
    }
    return returnCode;
}
# 944 "/usr/local/include/coin/CoinHelperFunctions.hpp" 3
inline int
CoinStrlenAsInt(const char * string)
{
    return static_cast<int>(strlen(string));
}




class CoinThreadRandom {
public:




  CoinThreadRandom()
  { seed_=12345678;}

  CoinThreadRandom(int seed)
  {
    seed_ = seed;
  }

  ~CoinThreadRandom() {}

  CoinThreadRandom(const CoinThreadRandom & rhs)
  { seed_ = rhs.seed_;}

  CoinThreadRandom& operator=(const CoinThreadRandom & rhs)
  {
    if (this != &rhs) {
      seed_ = rhs.seed_;
    }
    return *this;
  }







  inline void setSeed(int seed)
  {
    seed_ = seed;
  }

  inline unsigned int getSeed() const
  {
    return seed_;
  }

  inline double randomDouble() const
  {
    double retVal;
    seed_ = 1664525*(seed_)+1013904223;
    retVal = ((static_cast<double> (seed_))/4294967296.0);
    return retVal;
  }

  inline void randomize(int n=0)
  {
    if (!n)
      n=seed_ & 255;
    for (int i=0;i<n;i++)
      randomDouble();
  }



protected:




  mutable unsigned int seed_;

};
# 22 "/usr/local/include/coin/ClpModel.hpp" 2 3

# 1 "/usr/local/include/coin/CoinFinite.hpp" 1 3
# 17 "/usr/local/include/coin/CoinFinite.hpp" 3
const double COIN_DBL_MIN = std::numeric_limits<double>::min();
const double COIN_DBL_MAX = std::numeric_limits<double>::max();
const int COIN_INT_MAX = std::numeric_limits<int>::max();
const double COIN_INT_MAX_AS_DOUBLE = std::numeric_limits<int>::max();
# 29 "/usr/local/include/coin/CoinFinite.hpp" 3
extern bool CoinFinite(double val);


extern bool CoinIsnan(double val);
# 24 "/usr/local/include/coin/ClpModel.hpp" 2 3
# 1 "/usr/local/include/coin/ClpParameters.hpp" 1 3
# 12 "/usr/local/include/coin/ClpParameters.hpp" 3
enum ClpIntParam {


     ClpMaxNumIteration = 0,


     ClpMaxNumIterationHotStart,
# 37 "/usr/local/include/coin/ClpParameters.hpp" 3
     ClpNameDiscipline,


     ClpLastIntParam
};

enum ClpDblParam {



     ClpDualObjectiveLimit,



     ClpPrimalObjectiveLimit,


     ClpDualTolerance,


     ClpPrimalTolerance,


     ClpObjOffset,

     ClpMaxSeconds,

     ClpPresolveTolerance,


     ClpLastDblParam
};


enum ClpStrParam {


     ClpProbName = 0,


     ClpLastStrParam
};


template <class T> inline void
ClpDisjointCopyN( const T * array, const int size, T * newArray)
{
     memcpy(reinterpret_cast<void *> (newArray), array, size * sizeof(T));
}

template <class T> inline void
ClpFillN( T * array, const int size, T value)
{
     int i;
     for (i = 0; i < size; i++)
          array[i] = value;
}

template <class T> inline T*
ClpCopyOfArray( const T * array, const int size, T value)
{
     T * arrayNew = new T[size];
     if (array)
          ClpDisjointCopyN(array, size, arrayNew);
     else
          ClpFillN ( arrayNew, size, value);
     return arrayNew;
}


template <class T> inline T*
ClpCopyOfArray( const T * array, const int size)
{
     if (array) {
          T * arrayNew = new T[size];
          ClpDisjointCopyN(array, size, arrayNew);
          return arrayNew;
     } else {
          return __null;
     }
}

typedef struct {
     int typeStruct;
     int typeCall;
     void * data;
} ClpTrustedData;
# 25 "/usr/local/include/coin/ClpModel.hpp" 2 3
# 1 "/usr/local/include/coin/ClpObjective.hpp" 1 3
# 11 "/usr/local/include/coin/ClpObjective.hpp" 3
class ClpSimplex;
class ClpModel;






class ClpObjective {

public:
# 32 "/usr/local/include/coin/ClpObjective.hpp" 3
     virtual double * gradient(const ClpSimplex * model,
                               const double * solution,
                               double & offset, bool refresh,
                               int includeLinear = 2) = 0;


     virtual double reducedGradient(ClpSimplex * model, double * region,
                                    bool useFeasibleCosts) = 0;






     virtual double stepLength(ClpSimplex * model,
                               const double * solution,
                               const double * change,
                               double maximumTheta,
                               double & currentObj,
                               double & predictedObj,
                               double & thetaObj) = 0;

     virtual double objectiveValue(const ClpSimplex * model, const double * solution) const = 0;

     virtual void resize(int newNumberColumns) = 0;

     virtual void deleteSome(int numberToDelete, const int * which) = 0;

     virtual void reallyScale(const double * columnScale) = 0;



     virtual int markNonlinear(char * which);

     virtual void newXValues() {}






     ClpObjective();


     ClpObjective(const ClpObjective &);


     ClpObjective & operator=(const ClpObjective& rhs);


     virtual ~ClpObjective ();


     virtual ClpObjective * clone() const = 0;




     virtual ClpObjective * subsetClone (int numberColumns,
                                         const int * whichColumns) const;






     inline int type() const {
          return type_;
     }

     inline void setType(int value) {
          type_ = value;
     }

     inline int activated() const {
          return activated_;
     }

     inline void setActivated(int value) {
          activated_ = value;
     }


     inline double nonlinearOffset () const {
          return offset_;
     }




protected:



     double offset_;

     int type_;

     int activated_;

};
# 26 "/usr/local/include/coin/ClpModel.hpp" 2 3
class ClpEventHandler;
# 36 "/usr/local/include/coin/ClpModel.hpp" 3
class CoinBuild;
class CoinModel;
class ClpModel {

public:







     ClpModel (bool emptyMessages = false );





     ClpModel(const ClpModel & rhs, int scalingMode = -1);

     ClpModel & operator=(const ClpModel & rhs);




     ClpModel (const ClpModel * wholeModel,
               int numberRows, const int * whichRows,
               int numberColumns, const int * whichColumns,
               bool dropNames = true, bool dropIntegers = true);

     ~ClpModel ( );
# 82 "/usr/local/include/coin/ClpModel.hpp" 3
     void loadProblem ( const ClpMatrixBase& matrix,
                         const double* collb, const double* colub,
                         const double* obj,
                         const double* rowlb, const double* rowub,
                         const double * rowObjective = __null);
     void loadProblem ( const CoinPackedMatrix& matrix,
                         const double* collb, const double* colub,
                         const double* obj,
                         const double* rowlb, const double* rowub,
                         const double * rowObjective = __null);



     void loadProblem ( const int numcols, const int numrows,
                         const CoinBigIndex* start, const int* index,
                         const double* value,
                         const double* collb, const double* colub,
                         const double* obj,
                         const double* rowlb, const double* rowub,
                         const double * rowObjective = __null);





     int loadProblem ( CoinModel & modelObject, bool tryPlusMinusOne = false);

     void loadProblem ( const int numcols, const int numrows,
                         const CoinBigIndex* start, const int* index,
                         const double* value, const int * length,
                         const double* collb, const double* colub,
                         const double* obj,
                         const double* rowlb, const double* rowub,
                         const double * rowObjective = __null);

     void loadQuadraticObjective(const int numberColumns,
                                 const CoinBigIndex * start,
                                 const int * column, const double * element);
     void loadQuadraticObjective ( const CoinPackedMatrix& matrix);

     void deleteQuadraticObjective();

     void setRowObjective(const double * rowObjective);

     int readMps(const char *filename,
                 bool keepNames = false,
                 bool ignoreErrors = false);

     int readGMPL(const char *filename, const char * dataName,
                  bool keepNames = false);

     void copyInIntegerInformation(const char * information);

     void deleteIntegerInformation();

     void setContinuous(int index);

     void setInteger(int index);

     bool isInteger(int index) const;

     void resize (int newNumberRows, int newNumberColumns);

     void deleteRows(int number, const int * which);

     void addRow(int numberInRow, const int * columns,
                 const double * elements, double rowLower = -COIN_DBL_MAX,
                 double rowUpper = COIN_DBL_MAX);

     void addRows(int number, const double * rowLower,
                  const double * rowUpper,
                  const CoinBigIndex * rowStarts, const int * columns,
                  const double * elements);

     void addRows(int number, const double * rowLower,
                  const double * rowUpper,
                  const CoinBigIndex * rowStarts, const int * rowLengths,
                  const int * columns,
                  const double * elements);

     void addRows(int number, const double * rowLower,
                  const double * rowUpper,
                  const CoinPackedVectorBase * const * rows);






     int addRows(const CoinBuild & buildObject, bool tryPlusMinusOne = false,
                 bool checkDuplicates = true);
# 181 "/usr/local/include/coin/ClpModel.hpp" 3
     int addRows(CoinModel & modelObject, bool tryPlusMinusOne = false,
                 bool checkDuplicates = true);


     void deleteColumns(int number, const int * which);

     void deleteRowsAndColumns(int numberRows, const int * whichRows,
          int numberColumns, const int * whichColumns);

     void addColumn(int numberInColumn,
                    const int * rows,
                    const double * elements,
                    double columnLower = 0.0,
                    double columnUpper = COIN_DBL_MAX,
                    double objective = 0.0);

     void addColumns(int number, const double * columnLower,
                     const double * columnUpper,
                     const double * objective,
                     const CoinBigIndex * columnStarts, const int * rows,
                     const double * elements);
     void addColumns(int number, const double * columnLower,
                     const double * columnUpper,
                     const double * objective,
                     const CoinBigIndex * columnStarts, const int * columnLengths,
                     const int * rows,
                     const double * elements);

     void addColumns(int number, const double * columnLower,
                     const double * columnUpper,
                     const double * objective,
                     const CoinPackedVectorBase * const * columns);






     int addColumns(const CoinBuild & buildObject, bool tryPlusMinusOne = false,
                    bool checkDuplicates = true);







     int addColumns(CoinModel & modelObject, bool tryPlusMinusOne = false,
                    bool checkDuplicates = true);

     inline void modifyCoefficient(int row, int column, double newElement,
                                   bool keepZero = false) {
          matrix_->modifyCoefficient(row, column, newElement, keepZero);
     }

     void chgRowLower(const double * rowLower);

     void chgRowUpper(const double * rowUpper);

     void chgColumnLower(const double * columnLower);

     void chgColumnUpper(const double * columnUpper);

     void chgObjCoefficients(const double * objIn);



     void borrowModel(ClpModel & otherModel);


     void returnModel(ClpModel & otherModel);


     void createEmptyMatrix();







     int cleanMatrix(double threshold = 1.0e-20);

     void copy(const ClpMatrixBase * from, ClpMatrixBase * & to);


     void dropNames();

     void copyNames(const std::vector<std::string> & rowNames,
                    const std::vector<std::string> & columnNames);

     void copyRowNames(const std::vector<std::string> & rowNames, int first, int last);

     void copyColumnNames(const std::vector<std::string> & columnNames, int first, int last);

     void copyRowNames(const char * const * rowNames, int first, int last);

     void copyColumnNames(const char * const * columnNames, int first, int last);

     void setRowName(int rowIndex, std::string & name) ;

     void setColumnName(int colIndex, std::string & name) ;
# 291 "/usr/local/include/coin/ClpModel.hpp" 3
     int findNetwork(char * rotate, double fractionNeeded = 0.75);


     CoinModel * createCoinModel() const;
# 308 "/usr/local/include/coin/ClpModel.hpp" 3
     int writeMps(const char *filename,
                  int formatType = 0, int numberAcross = 2,
                  double objSense = 0.0) const ;




     inline int numberRows() const {
          return numberRows_;
     }
     inline int getNumRows() const {
          return numberRows_;
     }

     inline int getNumCols() const {
          return numberColumns_;
     }
     inline int numberColumns() const {
          return numberColumns_;
     }

     inline double primalTolerance() const {
          return dblParam_[ClpPrimalTolerance];
     }
     void setPrimalTolerance( double value) ;

     inline double dualTolerance() const {
          return dblParam_[ClpDualTolerance];
     }
     void setDualTolerance( double value) ;

     inline double primalObjectiveLimit() const {
          return dblParam_[ClpPrimalObjectiveLimit];
     }
     void setPrimalObjectiveLimit(double value);

     inline double dualObjectiveLimit() const {
          return dblParam_[ClpDualObjectiveLimit];
     }
     void setDualObjectiveLimit(double value);

     inline double objectiveOffset() const {
          return dblParam_[ClpObjOffset];
     }
     void setObjectiveOffset(double value);

     inline double presolveTolerance() const {
          return dblParam_[ClpPresolveTolerance];
     }

     inline const std::string & problemName() const {
          return strParam_[ClpProbName];
     }


     inline int numberIterations() const {
          return numberIterations_;
     }
     inline int getIterationCount() const {
          return numberIterations_;
     }
     inline void setNumberIterations(int numberIterationsNew) {
          numberIterations_ = numberIterationsNew;
     }

     inline int solveType() const {
          return solveType_;
     }
     inline void setSolveType(int type) {
          solveType_ = type;
     }

     inline int maximumIterations() const {
          return intParam_[ClpMaxNumIteration];
     }
     void setMaximumIterations(int value);

     inline double maximumSeconds() const {
          return dblParam_[ClpMaxSeconds];
     }
     void setMaximumSeconds(double value);

     bool hitMaximumIterations() const;
# 400 "/usr/local/include/coin/ClpModel.hpp" 3
     inline int status() const {
          return problemStatus_;
     }
     inline int problemStatus() const {
          return problemStatus_;
     }

     inline void setProblemStatus(int problemStatusNew) {
          problemStatus_ = problemStatusNew;
     }
# 424 "/usr/local/include/coin/ClpModel.hpp" 3
     inline int secondaryStatus() const {
          return secondaryStatus_;
     }
     inline void setSecondaryStatus(int newstatus) {
          secondaryStatus_ = newstatus;
     }

     inline bool isAbandoned() const {
          return problemStatus_ == 4;
     }

     inline bool isProvenOptimal() const {
          return problemStatus_ == 0;
     }

     inline bool isProvenPrimalInfeasible() const {
          return problemStatus_ == 1;
     }

     inline bool isProvenDualInfeasible() const {
          return problemStatus_ == 2;
     }

     bool isPrimalObjectiveLimitReached() const ;

     bool isDualObjectiveLimitReached() const ;

     inline bool isIterationLimitReached() const {
          return problemStatus_ == 3;
     }

     inline double optimizationDirection() const {
          return optimizationDirection_;
     }
     inline double getObjSense() const {
          return optimizationDirection_;
     }
     void setOptimizationDirection(double value);

     inline double * primalRowSolution() const {
          return rowActivity_;
     }
     inline const double * getRowActivity() const {
          return rowActivity_;
     }

     inline double * primalColumnSolution() const {
          return columnActivity_;
     }
     inline const double * getColSolution() const {
          return columnActivity_;
     }
     inline void setColSolution(const double * input) {
          memcpy(columnActivity_, input, numberColumns_ * sizeof(double));
     }

     inline double * dualRowSolution() const {
          return dual_;
     }
     inline const double * getRowPrice() const {
          return dual_;
     }

     inline double * dualColumnSolution() const {
          return reducedCost_;
     }
     inline const double * getReducedCost() const {
          return reducedCost_;
     }

     inline double* rowLower() const {
          return rowLower_;
     }
     inline const double* getRowLower() const {
          return rowLower_;
     }

     inline double* rowUpper() const {
          return rowUpper_;
     }
     inline const double* getRowUpper() const {
          return rowUpper_;
     }




     void setObjectiveCoefficient( int elementIndex, double elementValue );

     inline void setObjCoeff( int elementIndex, double elementValue ) {
          setObjectiveCoefficient( elementIndex, elementValue);
     }



     void setColumnLower( int elementIndex, double elementValue );



     void setColumnUpper( int elementIndex, double elementValue );


     void setColumnBounds( int elementIndex,
                           double lower, double upper );
# 537 "/usr/local/include/coin/ClpModel.hpp" 3
     void setColumnSetBounds(const int* indexFirst,
                             const int* indexLast,
                             const double* boundList);



     inline void setColLower( int elementIndex, double elementValue ) {
          setColumnLower(elementIndex, elementValue);
     }


     inline void setColUpper( int elementIndex, double elementValue ) {
          setColumnUpper(elementIndex, elementValue);
     }


     inline void setColBounds( int elementIndex,
                               double lower, double upper ) {
          setColumnBounds(elementIndex, lower, upper);
     }







     inline void setColSetBounds(const int* indexFirst,
                                 const int* indexLast,
                                 const double* boundList) {
          setColumnSetBounds(indexFirst, indexLast, boundList);
     }



     void setRowLower( int elementIndex, double elementValue );



     void setRowUpper( int elementIndex, double elementValue ) ;


     void setRowBounds( int elementIndex,
                        double lower, double upper ) ;







     void setRowSetBounds(const int* indexFirst,
                          const int* indexLast,
                          const double* boundList);



     inline const double * rowScale() const {
          return rowScale_;
     }
     inline const double * columnScale() const {
          return columnScale_;
     }
     inline const double * inverseRowScale() const {
          return inverseRowScale_;
     }
     inline const double * inverseColumnScale() const {
          return inverseColumnScale_;
     }
     inline double * mutableRowScale() const {
          return rowScale_;
     }
     inline double * mutableColumnScale() const {
          return columnScale_;
     }
     inline double * mutableInverseRowScale() const {
          return inverseRowScale_;
     }
     inline double * mutableInverseColumnScale() const {
          return inverseColumnScale_;
     }
     inline double * swapRowScale(double * newScale) {
          double * oldScale = rowScale_;
   rowScale_ = newScale;
          return oldScale;
     }
     void setRowScale(double * scale) ;
     void setColumnScale(double * scale);

     inline double objectiveScale() const {
          return objectiveScale_;
     }
     inline void setObjectiveScale(double value) {
          objectiveScale_ = value;
     }

     inline double rhsScale() const {
          return rhsScale_;
     }
     inline void setRhsScale(double value) {
          rhsScale_ = value;
     }

     void scaling(int mode = 1);


     void unscale();

     inline int scalingFlag() const {
          return scalingFlag_;
     }

     inline double * objective() const {
          if (objective_) {
               double offset;
               return objective_->gradient(__null, __null, offset, false);
          } else {
               return __null;
          }
     }
     inline double * objective(const double * solution, double & offset, bool refresh = true) const {
          offset = 0.0;
          if (objective_) {
               return objective_->gradient(__null, solution, offset, refresh);
          } else {
               return __null;
          }
     }
     inline const double * getObjCoefficients() const {
          if (objective_) {
               double offset;
               return objective_->gradient(__null, __null, offset, false);
          } else {
               return __null;
          }
     }

     inline double * rowObjective() const {
          return rowObjective_;
     }
     inline const double * getRowObjCoefficients() const {
          return rowObjective_;
     }

     inline double * columnLower() const {
          return columnLower_;
     }
     inline const double * getColLower() const {
          return columnLower_;
     }

     inline double * columnUpper() const {
          return columnUpper_;
     }
     inline const double * getColUpper() const {
          return columnUpper_;
     }

     inline CoinPackedMatrix * matrix() const {
          if ( matrix_ == __null ) return __null;
          else return matrix_->getPackedMatrix();
     }

     inline int getNumElements() const {
          return matrix_->getNumElements();
     }


     inline double getSmallElementValue() const {
          return smallElement_;
     }
     inline void setSmallElementValue(double value) {
          smallElement_ = value;
     }

     inline ClpMatrixBase * rowCopy() const {
          return rowCopy_;
     }

     void setNewRowCopy(ClpMatrixBase * newCopy);

     inline ClpMatrixBase * clpMatrix() const {
          return matrix_;
     }

     inline ClpPackedMatrix * clpScaledMatrix() const {
          return scaledMatrix_;
     }

     inline void setClpScaledMatrix(ClpPackedMatrix * scaledMatrix) {
          delete scaledMatrix_;
          scaledMatrix_ = scaledMatrix;
     }

     inline ClpPackedMatrix * swapScaledMatrix(ClpPackedMatrix * scaledMatrix) {
          ClpPackedMatrix * oldMatrix = scaledMatrix_;
          scaledMatrix_ = scaledMatrix;
   return oldMatrix;
     }





     void replaceMatrix(ClpMatrixBase * matrix, bool deleteCurrent = false);





     inline void replaceMatrix(CoinPackedMatrix * newmatrix,
                               bool deleteCurrent = false) {
          replaceMatrix(new ClpPackedMatrix(newmatrix), deleteCurrent);
     }

     inline double objectiveValue() const {
          return objectiveValue_ * optimizationDirection_ - dblParam_[ClpObjOffset];
     }
     inline void setObjectiveValue(double value) {
          objectiveValue_ = (value + dblParam_[ClpObjOffset]) / optimizationDirection_;
     }
     inline double getObjValue() const {
          return objectiveValue_ * optimizationDirection_ - dblParam_[ClpObjOffset];
     }

     inline char * integerInformation() const {
          return integerType_;
     }


     double * infeasibilityRay(bool fullRay=false) const;
     double * unboundedRay() const;

     inline double * ray() const
     { return ray_;}

     inline bool rayExists() const {
         return (ray_!=__null);
     }

     inline void deleteRay() {
         delete [] ray_;
         ray_=__null;
     }

  inline const double * internalRay() const {
   return ray_;
  }

     inline bool statusExists() const {
          return (status_ != __null);
     }

     inline unsigned char * statusArray() const {
          return status_;
     }


     unsigned char * statusCopy() const;

     void copyinStatus(const unsigned char * statusArray);


     inline void setUserPointer (void * pointer) {
          userPointer_ = pointer;
     }
     inline void * getUserPointer () const {
          return userPointer_;
     }

     inline void setTrustedUserPointer (ClpTrustedData * pointer) {
          trustedUserPointer_ = pointer;
     }
     inline ClpTrustedData * getTrustedUserPointer () const {
          return trustedUserPointer_;
     }

     inline int whatsChanged() const {
          return whatsChanged_;
     }
     inline void setWhatsChanged(int value) {
          whatsChanged_ = value;
     }

     inline int numberThreads() const {
          return numberThreads_;
     }
     inline void setNumberThreads(int value) {
          numberThreads_ = value;
     }




     void passInMessageHandler(CoinMessageHandler * handler);

     CoinMessageHandler * pushMessageHandler(CoinMessageHandler * handler,
                                             bool & oldDefault);

     void popMessageHandler(CoinMessageHandler * oldHandler, bool oldDefault);

     void newLanguage(CoinMessages::Language language);
     inline void setLanguage(CoinMessages::Language language) {
          newLanguage(language);
     }

     void setDefaultMessageHandler();

     inline CoinMessageHandler * messageHandler() const {
          return handler_;
     }

     inline CoinMessages messages() const {
          return messages_;
     }

     inline CoinMessages * messagesPointer() {
          return & messages_;
     }

     inline CoinMessages coinMessages() const {
          return coinMessages_;
     }

     inline CoinMessages * coinMessagesPointer() {
          return & coinMessages_;
     }
# 872 "/usr/local/include/coin/ClpModel.hpp" 3
     inline void setLogLevel(int value) {
          handler_->setLogLevel(value);
     }
     inline int logLevel() const {
          return handler_->logLevel();
     }

     inline bool defaultHandler() const {
          return defaultHandler_;
     }

     void passInEventHandler(const ClpEventHandler * eventHandler);

     inline ClpEventHandler * eventHandler() const {
          return eventHandler_;
     }

     inline CoinThreadRandom * randomNumberGenerator() {
          return &randomNumberGenerator_;
     }

     inline CoinThreadRandom & mutableRandomNumberGenerator() {
          return randomNumberGenerator_;
     }

     inline void setRandomSeed(int value) {
          randomNumberGenerator_.setSeed(value);
     }

     inline int lengthNames() const {
          return lengthNames_;
     }


     inline void setLengthNames(int value) {
          lengthNames_ = value;
     }

     inline const std::vector<std::string> * rowNames() const {
          return &rowNames_;
     }
     inline const std::string& rowName(int iRow) const {
          return rowNames_[iRow];
     }

     std::string getRowName(int iRow) const;

     inline const std::vector<std::string> * columnNames() const {
          return &columnNames_;
     }
     inline const std::string& columnName(int iColumn) const {
          return columnNames_[iColumn];
     }

     std::string getColumnName(int iColumn) const;


     inline ClpObjective * objectiveAsObject() const {
          return objective_;
     }
     void setObjective(ClpObjective * objective);
     inline void setObjectivePointer(ClpObjective * newobjective) {
          objective_ = newobjective;
     }


     int emptyProblem(int * infeasNumber = __null, double * infeasSum = __null, bool printMessage = true);
# 950 "/usr/local/include/coin/ClpModel.hpp" 3
     void times(double scalar,
                const double * x, double * y) const;



     void transposeTimes(double scalar,
                         const double * x, double * y) const ;
# 979 "/usr/local/include/coin/ClpModel.hpp" 3
     bool setIntParam(ClpIntParam key, int value) ;

     bool setDblParam(ClpDblParam key, double value) ;


     bool setStrParam(ClpStrParam key, const std::string & value);


     inline bool getIntParam(ClpIntParam key, int& value) const {
          if (key < ClpLastIntParam) {
               value = intParam_[key];
               return true;
          } else {
               return false;
          }
     }

     inline bool getDblParam(ClpDblParam key, double& value) const {
          if (key < ClpLastDblParam) {
               value = dblParam_[key];
               return true;
          } else {
               return false;
          }
     }


     inline bool getStrParam(ClpStrParam key, std::string& value) const {
          if (key < ClpLastStrParam) {
               value = strParam_[key];
               return true;
          } else {
               return false;
          }
     }


     void generateCpp( FILE * fp);
# 1050 "/usr/local/include/coin/ClpModel.hpp" 3
     inline unsigned int specialOptions() const {
          return specialOptions_;
     }
     void setSpecialOptions(unsigned int value);

     inline bool inCbcBranchAndBound() const {
          return (specialOptions_ & 0x01000000) != 0;
     }




protected:

     void gutsOfDelete(int type);



     void gutsOfCopy(const ClpModel & rhs, int trueCopy = 1);

     void getRowBound(int iRow, double& lower, double& upper) const;

     void gutsOfLoadModel ( int numberRows, int numberColumns,
                            const double* collb, const double* colub,
                            const double* obj,
                            const double* rowlb, const double* rowub,
                            const double * rowObjective = __null);

     void gutsOfScaling();

     inline double rawObjectiveValue() const {
          return objectiveValue_;
     }

     inline bool permanentArrays() const {
          return (specialOptions_ & 65536) != 0;
     }

     void startPermanentArrays();

     void stopPermanentArrays();

     const char * const * rowNamesAsChar() const;

     const char * const * columnNamesAsChar() const;

     void deleteNamesAsChar(const char * const * names, int number) const;

     void onStopped();




protected:




     double optimizationDirection_;

     double dblParam_[ClpLastDblParam];

     double objectiveValue_;

     double smallElement_;

     double objectiveScale_;

     double rhsScale_;

     int numberRows_;

     int numberColumns_;

     double * rowActivity_;

     double * columnActivity_;

     double * dual_;

     double * reducedCost_;

     double* rowLower_;

     double* rowUpper_;

     ClpObjective * objective_;

     double * rowObjective_;

     double * columnLower_;

     double * columnUpper_;

     ClpMatrixBase * matrix_;

     ClpMatrixBase * rowCopy_;

     ClpPackedMatrix * scaledMatrix_;

     double * ray_;

     double * rowScale_;

     double * columnScale_;

     double * inverseRowScale_;

     double * inverseColumnScale_;


     int scalingFlag_;







     unsigned char * status_;

     char * integerType_;

     void * userPointer_;

     ClpTrustedData * trustedUserPointer_;

     int intParam_[ClpLastIntParam];

     int numberIterations_;

     int solveType_;
# 1210 "/usr/local/include/coin/ClpModel.hpp" 3
     unsigned int whatsChanged_;

     int problemStatus_;

     int secondaryStatus_;

     int lengthNames_;

     int numberThreads_;



     unsigned int specialOptions_;

     CoinMessageHandler * handler_;

     bool defaultHandler_;

     CoinThreadRandom randomNumberGenerator_;

     ClpEventHandler * eventHandler_;


     std::vector<std::string> rowNames_;

     std::vector<std::string> columnNames_;


     CoinMessages messages_;

     CoinMessages coinMessages_;

     int maximumColumns_;

     int maximumRows_;

     int maximumInternalColumns_;

     int maximumInternalRows_;

     CoinPackedMatrix baseMatrix_;

     CoinPackedMatrix baseRowCopy_;

     double * savedRowScale_;

     double * savedColumnScale_;


     std::string strParam_[ClpLastStrParam];


};


class ClpDataSave {

public:




     ClpDataSave ( );


     ClpDataSave(const ClpDataSave &);

     ClpDataSave & operator=(const ClpDataSave & rhs);

     ~ClpDataSave ( );




public:



     double dualBound_;
     double infeasibilityCost_;
     double pivotTolerance_;
     double zeroFactorizationTolerance_;
     double zeroSimplexTolerance_;
     double acceptablePivot_;
     double objectiveScale_;
     int sparseThreshold_;
     int perturbation_;
     int forceFactorization_;
     int scalingFlag_;
     unsigned int specialOptions_;

};
# 17 "/usr/local/include/coin/ClpSimplex.hpp" 2 3

# 1 "/usr/local/include/coin/ClpSolve.hpp" 1 3
# 20 "/usr/local/include/coin/ClpSolve.hpp" 3
class ClpSolve {

public:


     enum SolveType {
          useDual = 0,
          usePrimal,
          usePrimalorSprint,
          useBarrier,
          useBarrierNoCross,
          automatic,
          notImplemented
     };
     enum PresolveType {
          presolveOn = 0,
          presolveOff,
          presolveNumber,
          presolveNumberCost
     };




     ClpSolve ( );

     ClpSolve ( SolveType method, PresolveType presolveType,
                int numberPasses, int options[6],
                int extraInfo[6], int independentOptions[3]);

     void generateCpp(FILE * fp);

     ClpSolve(const ClpSolve &);

     ClpSolve & operator=(const ClpSolve & rhs);

     ~ClpSolve ( );
# 103 "/usr/local/include/coin/ClpSolve.hpp" 3
     void setSpecialOption(int which, int value, int extraInfo = -1);
     int getSpecialOption(int which) const;


     void setSolveType(SolveType method, int extraInfo = -1);
     SolveType getSolveType();


     void setPresolveType(PresolveType amount, int extraInfo = -1);
     PresolveType getPresolveType();
     int getPresolvePasses() const;

     int getExtraInfo(int which) const;


     void setInfeasibleReturn(bool trueFalse);
     inline bool infeasibleReturn() const {
          return independentOptions_[0] != 0;
     }

     inline bool doDual() const {
          return (independentOptions_[1] & 1) == 0;
     }
     inline void setDoDual(bool doDual_) {
          if (doDual_) independentOptions_[1] &= ~1;
          else independentOptions_[1] |= 1;
     }

     inline bool doSingleton() const {
          return (independentOptions_[1] & 2) == 0;
     }
     inline void setDoSingleton(bool doSingleton_) {
          if (doSingleton_) independentOptions_[1] &= ~2;
          else independentOptions_[1] |= 2;
     }

     inline bool doDoubleton() const {
          return (independentOptions_[1] & 4) == 0;
     }
     inline void setDoDoubleton(bool doDoubleton_) {
          if (doDoubleton_) independentOptions_[1] &= ~4;
          else independentOptions_[1] |= 4;
     }

     inline bool doTripleton() const {
          return (independentOptions_[1] & 8) == 0;
     }
     inline void setDoTripleton(bool doTripleton_) {
          if (doTripleton_) independentOptions_[1] &= ~8;
          else independentOptions_[1] |= 8;
     }

     inline bool doTighten() const {
          return (independentOptions_[1] & 16) == 0;
     }
     inline void setDoTighten(bool doTighten_) {
          if (doTighten_) independentOptions_[1] &= ~16;
          else independentOptions_[1] |= 16;
     }

     inline bool doForcing() const {
          return (independentOptions_[1] & 32) == 0;
     }
     inline void setDoForcing(bool doForcing_) {
          if (doForcing_) independentOptions_[1] &= ~32;
          else independentOptions_[1] |= 32;
     }

     inline bool doImpliedFree() const {
          return (independentOptions_[1] & 64) == 0;
     }
     inline void setDoImpliedFree(bool doImpliedfree) {
          if (doImpliedfree) independentOptions_[1] &= ~64;
          else independentOptions_[1] |= 64;
     }

     inline bool doDupcol() const {
          return (independentOptions_[1] & 128) == 0;
     }
     inline void setDoDupcol(bool doDupcol_) {
          if (doDupcol_) independentOptions_[1] &= ~128;
          else independentOptions_[1] |= 128;
     }

     inline bool doDuprow() const {
          return (independentOptions_[1] & 256) == 0;
     }
     inline void setDoDuprow(bool doDuprow_) {
          if (doDuprow_) independentOptions_[1] &= ~256;
          else independentOptions_[1] |= 256;
     }

     inline bool doSingletonColumn() const {
          return (independentOptions_[1] & 512) == 0;
     }
     inline void setDoSingletonColumn(bool doSingleton_) {
          if (doSingleton_) independentOptions_[1] &= ~512;
          else independentOptions_[1] |= 512;
     }

     inline bool doKillSmall() const {
          return (independentOptions_[1] & 1024) == 0;
     }
     inline void setDoKillSmall(bool doKill) {
          if (doKill) independentOptions_[1] &= ~1024;
          else independentOptions_[1] |= 1024;
     }

     inline int presolveActions() const {
          return independentOptions_[1] & 0xffff;
     }
     inline void setPresolveActions(int action) {
          independentOptions_[1] = (independentOptions_[1] & 0xffff0000) | (action & 0xffff);
     }

     inline int substitution() const {
          return independentOptions_[2];
     }
     inline void setSubstitution(int value) {
          independentOptions_[2] = value;
     }



private:





     SolveType method_;

     PresolveType presolveType_;

     int numberPasses_;

     int options_[7];

     int extraInfo_[7];





     int independentOptions_[3];

};


class ClpSimplexProgress {

public:





     ClpSimplexProgress ( );


     ClpSimplexProgress ( ClpSimplex * model );


     ClpSimplexProgress(const ClpSimplexProgress &);


     ClpSimplexProgress & operator=(const ClpSimplexProgress & rhs);

     ~ClpSimplexProgress ( );

     void reset();

     void fillFromModel ( ClpSimplex * model );
# 284 "/usr/local/include/coin/ClpSolve.hpp" 3
     int looping ( );

     void startCheck();

     int cycle(int in, int out, int wayIn, int wayOut);


     double lastObjective(int back = 1) const;

     void setInfeasibility(double value);

     double lastInfeasibility(int back = 1) const;

     void modifyObjective(double value);

     int lastIterationNumber(int back = 1) const;

     void clearIterationNumbers();

     inline void newOddState() {
          oddState_ = - oddState_ - 1;
     }
     inline void endOddState() {
          oddState_ = abs(oddState_);
     }
     inline void clearOddState() {
          oddState_ = 0;
     }
     inline int oddState() const {
          return oddState_;
     }

     inline int badTimes() const {
          return numberBadTimes_;
     }
     inline void clearBadTimes() {
          numberBadTimes_ = 0;
     }

     inline int reallyBadTimes() const {
          return numberReallyBadTimes_;
     }
     inline void incrementReallyBadTimes() {
          numberReallyBadTimes_++;
     }

     inline int timesFlagged() const {
          return numberTimesFlagged_;
     }
     inline void clearTimesFlagged() {
          numberTimesFlagged_ = 0;
     }
     inline void incrementTimesFlagged() {
          numberTimesFlagged_++;
     }







     double objective_[5];

     double infeasibility_[5];

     double realInfeasibility_[5];
# 364 "/usr/local/include/coin/ClpSolve.hpp" 3
     double initialWeight_;



     int in_[12];
     int out_[12];
     char way_[12];

     ClpSimplex * model_;

     int numberInfeasibilities_[5];

     int iterationNumber_[5];







     int numberTimes_;

     int numberBadTimes_;

     int numberReallyBadTimes_;

     int numberTimesFlagged_;

     int oddState_;

};

# 1 "/usr/local/include/coin/ClpConfig.h" 1 3
# 397 "/usr/local/include/coin/ClpSolve.hpp" 2 3
# 19 "/usr/local/include/coin/ClpSimplex.hpp" 2 3
# 1 "/usr/local/include/coin/ClpConfig.h" 1 3
# 20 "/usr/local/include/coin/ClpSimplex.hpp" 2 3
class ClpDualRowPivot;
class ClpPrimalColumnPivot;
class ClpFactorization;
class CoinIndexedVector;
class ClpNonLinearCost;
class ClpNodeStuff;
class CoinStructuredModel;
class OsiClpSolverInterface;
class CoinWarmStartBasis;
class ClpDisasterHandler;
class ClpConstraint;
# 55 "/usr/local/include/coin/ClpSimplex.hpp" 3
class ClpSimplex : public ClpModel {
     friend void ClpSimplexUnitTest(const std::string & mpsDir);

public:




     enum Status {
          isFree = 0x00,
          basic = 0x01,
          atUpperBound = 0x02,
          atLowerBound = 0x03,
          superBasic = 0x04,
          isFixed = 0x05
     };

     enum FakeBound {
          noFake = 0x00,
          lowerFake = 0x01,
          upperFake = 0x02,
          bothFake = 0x03
     };




     ClpSimplex (bool emptyMessages = false );





     ClpSimplex(const ClpSimplex & rhs, int scalingMode = -1);




     ClpSimplex(const ClpModel & rhs, int scalingMode = -1);






     ClpSimplex (const ClpModel * wholeModel,
                 int numberRows, const int * whichRows,
                 int numberColumns, const int * whichColumns,
                 bool dropNames = true, bool dropIntegers = true,
                 bool fixOthers = false);






     ClpSimplex (const ClpSimplex * wholeModel,
                 int numberRows, const int * whichRows,
                 int numberColumns, const int * whichColumns,
                 bool dropNames = true, bool dropIntegers = true,
                 bool fixOthers = false);



     ClpSimplex (ClpSimplex * wholeModel,
                 int numberColumns, const int * whichColumns);


     void originalModel(ClpSimplex * miniModel);
  inline int abcState() const
  { return abcState_;}
  inline void setAbcState(int state)
  { abcState_=state;}
# 143 "/usr/local/include/coin/ClpSimplex.hpp" 3
     void setPersistenceFlag(int value);

     void makeBaseModel();

     void deleteBaseModel();

     inline ClpSimplex * baseModel() const {
          return baseModel_;
     }



     void setToBaseModel(ClpSimplex * model = __null);

     ClpSimplex & operator=(const ClpSimplex & rhs);

     ~ClpSimplex ( );
# 172 "/usr/local/include/coin/ClpSimplex.hpp" 3
     void loadProblem ( const ClpMatrixBase& matrix,
                         const double* collb, const double* colub,
                         const double* obj,
                         const double* rowlb, const double* rowub,
                         const double * rowObjective = __null);
     void loadProblem ( const CoinPackedMatrix& matrix,
                         const double* collb, const double* colub,
                         const double* obj,
                         const double* rowlb, const double* rowub,
                         const double * rowObjective = __null);



     void loadProblem ( const int numcols, const int numrows,
                         const CoinBigIndex* start, const int* index,
                         const double* value,
                         const double* collb, const double* colub,
                         const double* obj,
                         const double* rowlb, const double* rowub,
                         const double * rowObjective = __null);

     void loadProblem ( const int numcols, const int numrows,
                         const CoinBigIndex* start, const int* index,
                         const double* value, const int * length,
                         const double* collb, const double* colub,
                         const double* obj,
                         const double* rowlb, const double* rowub,
                         const double * rowObjective = __null);




     int loadProblem ( CoinModel & modelObject, bool keepSolution = false);

     int readMps(const char *filename,
                 bool keepNames = false,
                 bool ignoreErrors = false);

     int readGMPL(const char *filename, const char * dataName,
                  bool keepNames = false);


     int readLp(const char *filename, const double epsilon = 1e-5);




     void borrowModel(ClpModel & otherModel);
     void borrowModel(ClpSimplex & otherModel);

     void passInEventHandler(const ClpEventHandler * eventHandler);

     void getbackSolution(const ClpSimplex & smallModel, const int * whichRow, const int * whichColumn);
# 233 "/usr/local/include/coin/ClpSimplex.hpp" 3
     int loadNonLinear(void * info, int & numberConstraints,
                       ClpConstraint ** & constraints);
# 248 "/usr/local/include/coin/ClpSimplex.hpp" 3
     int initialSolve(ClpSolve & options);

     int initialSolve();

     int initialDualSolve();

     int initialPrimalSolve();

     int initialBarrierSolve();

     int initialBarrierNoCrossSolve();
# 269 "/usr/local/include/coin/ClpSimplex.hpp" 3
     int dual(int ifValuesPass = 0, int startFinishOptions = 0);

     int dualDebug(int ifValuesPass = 0, int startFinishOptions = 0);
# 282 "/usr/local/include/coin/ClpSimplex.hpp" 3
     int primal(int ifValuesPass = 0, int startFinishOptions = 0);





     int nonlinearSLP(int numberPasses, double deltaTolerance);





     int nonlinearSLP(int numberConstraints, ClpConstraint ** constraints,
                      int numberPasses, double deltaTolerance);


     int barrier(bool crossover = true);


     int reducedGradient(int phase = 0);

     int solve(CoinStructuredModel * model);
# 317 "/usr/local/include/coin/ClpSimplex.hpp" 3
     int loadProblem ( CoinStructuredModel & modelObject,
                        bool originalOrder = true, bool keepSolution = false);
# 333 "/usr/local/include/coin/ClpSimplex.hpp" 3
     int cleanup(int cleanupScaling);
# 354 "/usr/local/include/coin/ClpSimplex.hpp" 3
     int dualRanging(int numberCheck, const int * which,
                     double * costIncrease, int * sequenceIncrease,
                     double * costDecrease, int * sequenceDecrease,
                     double * valueIncrease = __null, double * valueDecrease = __null);
# 372 "/usr/local/include/coin/ClpSimplex.hpp" 3
     int primalRanging(int numberCheck, const int * which,
                       double * valueIncrease, int * sequenceIncrease,
                       double * valueDecrease, int * sequenceDecrease);
# 384 "/usr/local/include/coin/ClpSimplex.hpp" 3
     int modifyCoefficientsAndPivot(int number,
     const int * which,
     const CoinBigIndex * start,
     const int * row,
     const double * newCoefficient,
     const unsigned char * newStatus=__null,
     const double * newLower=__null,
     const double * newUpper=__null,
     const double * newObjective=__null);







     int outDuplicateRows(int numberLook,int * whichRows, bool noOverlaps=false, double tolerance=-1.0,
     double cleanUp=0.0);


     double moveTowardsPrimalFeasible();


     void removeSuperBasicSlacks(int threshold=0);
# 420 "/usr/local/include/coin/ClpSimplex.hpp" 3
     ClpSimplex * miniPresolve(char * rowType, char * columnType,void ** info);

     void miniPostsolve(const ClpSimplex * presolvedModel,void * info);
# 437 "/usr/local/include/coin/ClpSimplex.hpp" 3
     int writeBasis(const char *filename,
                    bool writeValues = false,
                    int formatType = 0) const;


     int readBasis(const char *filename);

     CoinWarmStartBasis * getBasis() const;

     void setFactorization( ClpFactorization & factorization);

     ClpFactorization * swapFactorization( ClpFactorization * factorization);

     void copyFactorization( ClpFactorization & factorization);
# 460 "/usr/local/include/coin/ClpSimplex.hpp" 3
     int tightenPrimalBounds(double factor = 0.0, int doTight = 0, bool tightIntegers = false);
# 477 "/usr/local/include/coin/ClpSimplex.hpp" 3
     int crash(double gap, int pivot);

     void setDualRowPivotAlgorithm(ClpDualRowPivot & choice);

     void setPrimalColumnPivotAlgorithm(ClpPrimalColumnPivot & choice);
# 490 "/usr/local/include/coin/ClpSimplex.hpp" 3
     int strongBranching(int numberVariables, const int * variables,
                         double * newLower, double * newUpper,
                         double ** outputSolution,
                         int * outputStatus, int * outputIterations,
                         bool stopOnFirstInfeasible = true,
                         bool alwaysFinish = false,
                         int startFinishOptions = 0);

     int fathom(void * stuff);





     int fathomMany(void * stuff);

     double doubleCheck();

     int startFastDual2(ClpNodeStuff * stuff);

     int fastDual2(ClpNodeStuff * stuff);

     void stopFastDual2(ClpNodeStuff * stuff);






     ClpSimplex * fastCrunch(ClpNodeStuff * stuff, int mode);
# 529 "/usr/local/include/coin/ClpSimplex.hpp" 3
     int pivot();






     int primalPivotResult();






     int dualPivotResultPart1();



  int pivotResultPart2(int algorithm,int state);
# 560 "/usr/local/include/coin/ClpSimplex.hpp" 3
     int startup(int ifValuesPass, int startFinishOptions = 0);
     void finish(int startFinishOptions = 0);


     bool statusOfProblem(bool initial = false);

     void defaultFactorizationFrequency();

     void copyEnabledStuff(const ClpSimplex * rhs);





     inline bool primalFeasible() const {
          return (numberPrimalInfeasibilities_ == 0);
     }

     inline bool dualFeasible() const {
          return (numberDualInfeasibilities_ == 0);
     }

     inline ClpFactorization * factorization() const {
          return factorization_;
     }

     bool sparseFactorization() const;
     void setSparseFactorization(bool value);

     int factorizationFrequency() const;
     void setFactorizationFrequency(int value);

     inline double dualBound() const {
          return dualBound_;
     }
     void setDualBound(double value);

     inline double infeasibilityCost() const {
          return infeasibilityCost_;
     }
     void setInfeasibilityCost(double value);
# 617 "/usr/local/include/coin/ClpSimplex.hpp" 3
     inline int perturbation() const {
          return perturbation_;
     }
     void setPerturbation(int value);

     inline int algorithm() const {
          return algorithm_;
     }

     inline void setAlgorithm(int value) {
          algorithm_ = value;
     }

     bool isObjectiveLimitTestValid() const ;

     inline double sumDualInfeasibilities() const {
          return sumDualInfeasibilities_;
     }
     inline void setSumDualInfeasibilities(double value) {
          sumDualInfeasibilities_ = value;
     }

     inline double sumOfRelaxedDualInfeasibilities() const {
          return sumOfRelaxedDualInfeasibilities_;
     }
     inline void setSumOfRelaxedDualInfeasibilities(double value) {
          sumOfRelaxedDualInfeasibilities_ = value;
     }

     inline int numberDualInfeasibilities() const {
          return numberDualInfeasibilities_;
     }
     inline void setNumberDualInfeasibilities(int value) {
          numberDualInfeasibilities_ = value;
     }

     inline int numberDualInfeasibilitiesWithoutFree() const {
          return numberDualInfeasibilitiesWithoutFree_;
     }

     inline double sumPrimalInfeasibilities() const {
          return sumPrimalInfeasibilities_;
     }
     inline void setSumPrimalInfeasibilities(double value) {
          sumPrimalInfeasibilities_ = value;
     }

     inline double sumOfRelaxedPrimalInfeasibilities() const {
          return sumOfRelaxedPrimalInfeasibilities_;
     }
     inline void setSumOfRelaxedPrimalInfeasibilities(double value) {
          sumOfRelaxedPrimalInfeasibilities_ = value;
     }

     inline int numberPrimalInfeasibilities() const {
          return numberPrimalInfeasibilities_;
     }
     inline void setNumberPrimalInfeasibilities(int value) {
          numberPrimalInfeasibilities_ = value;
     }






     int saveModel(const char * fileName);


     int restoreModel(const char * fileName);
# 695 "/usr/local/include/coin/ClpSimplex.hpp" 3
     void checkSolution(int setToBounds = 0);


     void checkSolutionInternal();

     void checkUnscaledSolution();

     inline CoinIndexedVector * rowArray(int index) const {
          return rowArray_[index];
     }

     inline CoinIndexedVector * columnArray(int index) const {
          return columnArray_[index];
     }
# 717 "/usr/local/include/coin/ClpSimplex.hpp" 3
     int getSolution ( const double * rowActivities,
                        const double * columnActivities);



     int getSolution ();






     int createPiecewiseLinearCosts(const int * starts,
                                    const double * lower, const double * gradient);

     inline ClpDualRowPivot * dualRowPivot() const {
          return dualRowPivot_;
     }

     inline ClpPrimalColumnPivot * primalColumnPivot() const {
          return primalColumnPivot_;
     }

     inline bool goodAccuracy() const {
          return (largestPrimalError_ < 1.0e-7 && largestDualError_ < 1.0e-7);
     }

     void returnModel(ClpSimplex & otherModel);







     int internalFactorize(int solveType);

     ClpDataSave saveData() ;

     void restoreData(ClpDataSave saved);

     void cleanStatus();

     int factorize();


     void computeDuals(double * givenDjs);

     void computePrimals ( const double * rowActivities,
                            const double * columnActivities);

     void add(double * array,
              int column, double multiplier) const;





     void unpack(CoinIndexedVector * rowArray) const ;





     void unpack(CoinIndexedVector * rowArray, int sequence) const;






     void unpackPacked(CoinIndexedVector * rowArray) ;






     void unpackPacked(CoinIndexedVector * rowArray, int sequence);

protected:





     int housekeeping(double objectiveChange);


     void checkPrimalSolution(const double * rowActivities = __null,
                              const double * columnActivies = __null);


     void checkDualSolution();

     void checkBothSolutions();




     double scaleObjective(double value);

     int solveDW(CoinStructuredModel * model);

     int solveBenders(CoinStructuredModel * model);
public:
# 833 "/usr/local/include/coin/ClpSimplex.hpp" 3
     void setValuesPassAction(double incomingInfeasibility,
                              double allowedInfeasibility);


     int cleanFactorization(int ifValuesPass);



public:

     inline double alphaAccuracy() const {
          return alphaAccuracy_;
     }
     inline void setAlphaAccuracy(double value) {
          alphaAccuracy_ = value;
     }
public:





     inline void setDisasterHandler(ClpDisasterHandler * handler) {
          disasterArea_ = handler;
     }

     inline ClpDisasterHandler * disasterHandler() const {
          return disasterArea_;
     }

     inline double largeValue() const {
          return largeValue_;
     }
     void setLargeValue( double value) ;

     inline double largestPrimalError() const {
          return largestPrimalError_;
     }

     inline double largestDualError() const {
          return largestDualError_;
     }

     inline void setLargestPrimalError(double value) {
          largestPrimalError_ = value;
     }

     inline void setLargestDualError(double value) {
          largestDualError_ = value;
     }

     inline double zeroTolerance() const {
          return zeroTolerance_;
     }

     inline void setZeroTolerance( double value) {
          zeroTolerance_ = value;
     }

     inline int * pivotVariable() const {
          return pivotVariable_;
     }

     inline bool automaticScaling() const {
          return automaticScale_ != 0;
     }
     inline void setAutomaticScaling(bool onOff) {
          automaticScale_ = onOff ? 1 : 0;
     }

     inline double currentDualTolerance() const {
          return dualTolerance_;
     }
     inline void setCurrentDualTolerance(double value) {
          dualTolerance_ = value;
     }

     inline double currentPrimalTolerance() const {
          return primalTolerance_;
     }
     inline void setCurrentPrimalTolerance(double value) {
          primalTolerance_ = value;
     }

     inline int numberRefinements() const {
          return numberRefinements_;
     }
     void setNumberRefinements( int value) ;

     inline double alpha() const {
          return alpha_;
     }
     inline void setAlpha(double value) {
          alpha_ = value;
     }

     inline double dualIn() const {
          return dualIn_;
     }

     inline void setDualIn(double value) {
          dualIn_ = value;
     }

     inline int pivotRow() const {
          return pivotRow_;
     }
     inline void setPivotRow(int value) {
          pivotRow_ = value;
     }

     double valueIncomingDual() const;



protected:






     int gutsOfSolution ( double * givenDuals,
                          const double * givenPrimals,
                          bool valuesPass = false);

     void gutsOfDelete(int type);

     void gutsOfCopy(const ClpSimplex & rhs);
# 973 "/usr/local/include/coin/ClpSimplex.hpp" 3
     bool createRim(int what, bool makeRowCopy = false, int startFinishOptions = 0);

     void createRim1(bool initial);

     void createRim4(bool initial);

     void createRim5(bool initial);




     void deleteRim(int getRidOfFactorizationData = 2);

     bool sanityCheck();

public:




     inline double * solutionRegion(int section) const {
          if (!section) return rowActivityWork_;
          else return columnActivityWork_;
     }
     inline double * djRegion(int section) const {
          if (!section) return rowReducedCost_;
          else return reducedCostWork_;
     }
     inline double * lowerRegion(int section) const {
          if (!section) return rowLowerWork_;
          else return columnLowerWork_;
     }
     inline double * upperRegion(int section) const {
          if (!section) return rowUpperWork_;
          else return columnUpperWork_;
     }
     inline double * costRegion(int section) const {
          if (!section) return rowObjectiveWork_;
          else return objectiveWork_;
     }

     inline double * solutionRegion() const {
          return solution_;
     }
     inline double * djRegion() const {
          return dj_;
     }
     inline double * lowerRegion() const {
          return lower_;
     }
     inline double * upperRegion() const {
          return upper_;
     }
     inline double * costRegion() const {
          return cost_;
     }
     inline Status getStatus(int sequence) const {
          return static_cast<Status> (status_[sequence] & 7);
     }
     inline void setStatus(int sequence, Status newstatus) {
          unsigned char & st_byte = status_[sequence];
          st_byte = static_cast<unsigned char>(st_byte & ~7);
          st_byte = static_cast<unsigned char>(st_byte | newstatus);
     }

     bool startPermanentArrays();




     void setInitialDenseFactorization(bool onOff);
     bool initialDenseFactorization() const;

     inline int sequenceIn() const {
          return sequenceIn_;
     }
     inline int sequenceOut() const {
          return sequenceOut_;
     }

     inline void setSequenceIn(int sequence) {
          sequenceIn_ = sequence;
     }
     inline void setSequenceOut(int sequence) {
          sequenceOut_ = sequence;
     }

     inline int directionIn() const {
          return directionIn_;
     }
     inline int directionOut() const {
          return directionOut_;
     }

     inline void setDirectionIn(int direction) {
          directionIn_ = direction;
     }
     inline void setDirectionOut(int direction) {
          directionOut_ = direction;
     }

     inline double valueOut() const {
          return valueOut_;
     }

     inline void setValueOut(double value) {
          valueOut_ = value;
     }

     inline double dualOut() const {
          return dualOut_;
     }

     inline void setDualOut(double value) {
          dualOut_ = value;
     }

     inline void setLowerOut(double value) {
          lowerOut_ = value;
     }

     inline void setUpperOut(double value) {
          upperOut_ = value;
     }

     inline void setTheta(double value) {
          theta_ = value;
     }

     inline int isColumn(int sequence) const {
          return sequence < numberColumns_ ? 1 : 0;
     }

     inline int sequenceWithin(int sequence) const {
          return sequence < numberColumns_ ? sequence : sequence - numberColumns_;
     }

     inline double solution(int sequence) {
          return solution_[sequence];
     }

     inline double & solutionAddress(int sequence) {
          return solution_[sequence];
     }
     inline double reducedCost(int sequence) {
          return dj_[sequence];
     }
     inline double & reducedCostAddress(int sequence) {
          return dj_[sequence];
     }
     inline double lower(int sequence) {
          return lower_[sequence];
     }

     inline double & lowerAddress(int sequence) {
          return lower_[sequence];
     }
     inline double upper(int sequence) {
          return upper_[sequence];
     }

     inline double & upperAddress(int sequence) {
          return upper_[sequence];
     }
     inline double cost(int sequence) {
          return cost_[sequence];
     }

     inline double & costAddress(int sequence) {
          return cost_[sequence];
     }

     inline double originalLower(int iSequence) const {
          if (iSequence < numberColumns_) return columnLower_[iSequence];
          else
               return rowLower_[iSequence-numberColumns_];
     }

     inline double originalUpper(int iSequence) const {
          if (iSequence < numberColumns_) return columnUpper_[iSequence];
          else
               return rowUpper_[iSequence-numberColumns_];
     }

     inline double theta() const {
          return theta_;
     }


     inline double bestPossibleImprovement() const {
          return bestPossibleImprovement_;
     }

     inline ClpNonLinearCost * nonLinearCost() const {
          return nonLinearCost_;
     }
# 1188 "/usr/local/include/coin/ClpSimplex.hpp" 3
     inline int moreSpecialOptions() const {
          return moreSpecialOptions_;
     }
# 1211 "/usr/local/include/coin/ClpSimplex.hpp" 3
     inline void setMoreSpecialOptions(int value) {
          moreSpecialOptions_ = value;
     }



     inline void setFakeBound(int sequence, FakeBound fakeBound) {
          unsigned char & st_byte = status_[sequence];
          st_byte = static_cast<unsigned char>(st_byte & ~24);
          st_byte = static_cast<unsigned char>(st_byte | (fakeBound << 3));
     }
     inline FakeBound getFakeBound(int sequence) const {
          return static_cast<FakeBound> ((status_[sequence] >> 3) & 3);
     }
     inline void setRowStatus(int sequence, Status newstatus) {
          unsigned char & st_byte = status_[sequence+numberColumns_];
          st_byte = static_cast<unsigned char>(st_byte & ~7);
          st_byte = static_cast<unsigned char>(st_byte | newstatus);
     }
     inline Status getRowStatus(int sequence) const {
          return static_cast<Status> (status_[sequence+numberColumns_] & 7);
     }
     inline void setColumnStatus(int sequence, Status newstatus) {
          unsigned char & st_byte = status_[sequence];
          st_byte = static_cast<unsigned char>(st_byte & ~7);
          st_byte = static_cast<unsigned char>(st_byte | newstatus);
     }
     inline Status getColumnStatus(int sequence) const {
          return static_cast<Status> (status_[sequence] & 7);
     }
     inline void setPivoted( int sequence) {
          status_[sequence] = static_cast<unsigned char>(status_[sequence] | 32);
     }
     inline void clearPivoted( int sequence) {
          status_[sequence] = static_cast<unsigned char>(status_[sequence] & ~32);
     }
     inline bool pivoted(int sequence) const {
          return (((status_[sequence] >> 5) & 1) != 0);
     }

     void setFlagged( int sequence);
     inline void clearFlagged( int sequence) {
          status_[sequence] = static_cast<unsigned char>(status_[sequence] & ~64);
     }
     inline bool flagged(int sequence) const {
          return ((status_[sequence] & 64) != 0);
     }

     inline void setActive( int iRow) {
          status_[iRow] = static_cast<unsigned char>(status_[iRow] | 128);
     }
     inline void clearActive( int iRow) {
          status_[iRow] = static_cast<unsigned char>(status_[iRow] & ~128);
     }
     inline bool active(int iRow) const {
          return ((status_[iRow] & 128) != 0);
     }


     void createStatus() ;


     void allSlackBasis(bool resetSolution = false);


     inline int lastBadIteration() const {
          return lastBadIteration_;
     }

     inline void setLastBadIteration(int value) {
          lastBadIteration_=value;
     }

     inline int progressFlag() const {
          return (progressFlag_ & 3);
     }

     inline ClpSimplexProgress * progress()
     { return &progress_;}

     inline int forceFactorization() const {
          return forceFactorization_ ;
     }

     inline void forceFactorization(int value) {
          forceFactorization_ = value;
     }

     inline double rawObjectiveValue() const {
          return objectiveValue_;
     }

     void computeObjectiveValue(bool useWorkingSolution = false);

     double computeInternalObjectiveValue();


     double * infeasibilityRay(bool fullRay=false) const;



     inline int numberExtraRows() const {
          return numberExtraRows_;
     }


     inline int maximumBasic() const {
          return maximumBasic_;
     }

     inline int baseIteration() const {
          return baseIteration_;
     }

     void generateCpp( FILE * fp, bool defaultFactor = false);

     ClpFactorization * getEmptyFactorization();

     void setEmptyFactorization();

     void moveInfo(const ClpSimplex & rhs, bool justStatus = false);







     void getBInvARow(int row, double* z, double * slack = __null);


     void getBInvRow(int row, double* z);


     void getBInvACol(int col, double* vec);


     void getBInvCol(int col, double* vec);





     void getBasics(int* index);






     void setObjectiveCoefficient( int elementIndex, double elementValue );

     inline void setObjCoeff( int elementIndex, double elementValue ) {
          setObjectiveCoefficient( elementIndex, elementValue);
     }



     void setColumnLower( int elementIndex, double elementValue );



     void setColumnUpper( int elementIndex, double elementValue );


     void setColumnBounds( int elementIndex,
                           double lower, double upper );
# 1387 "/usr/local/include/coin/ClpSimplex.hpp" 3
     void setColumnSetBounds(const int* indexFirst,
                             const int* indexLast,
                             const double* boundList);



     inline void setColLower( int elementIndex, double elementValue ) {
          setColumnLower(elementIndex, elementValue);
     }


     inline void setColUpper( int elementIndex, double elementValue ) {
          setColumnUpper(elementIndex, elementValue);
     }


     inline void setColBounds( int elementIndex,
                               double newlower, double newupper ) {
          setColumnBounds(elementIndex, newlower, newupper);
     }







     inline void setColSetBounds(const int* indexFirst,
                                 const int* indexLast,
                                 const double* boundList) {
          setColumnSetBounds(indexFirst, indexLast, boundList);
     }



     void setRowLower( int elementIndex, double elementValue );



     void setRowUpper( int elementIndex, double elementValue ) ;


     void setRowBounds( int elementIndex,
                        double lower, double upper ) ;







     void setRowSetBounds(const int* indexFirst,
                          const int* indexLast,
                          const double* boundList);

     void resize (int newNumberRows, int newNumberColumns);




protected:
# 1457 "/usr/local/include/coin/ClpSimplex.hpp" 3
     double bestPossibleImprovement_;

     double zeroTolerance_;

     int columnPrimalSequence_;

     int rowPrimalSequence_;

     double bestObjectiveValue_;

     int moreSpecialOptions_;

     int baseIteration_;

     double primalToleranceToGetOptimal_;

     double largeValue_;

     double largestPrimalError_;

     double largestDualError_;

     double alphaAccuracy_;

     double dualBound_;

     double alpha_;

     double theta_;

     double lowerIn_;

     double valueIn_;

     double upperIn_;

     double dualIn_;

     double lowerOut_;

     double valueOut_;

     double upperOut_;

     double dualOut_;

     double dualTolerance_;

     double primalTolerance_;

     double sumDualInfeasibilities_;

     double sumPrimalInfeasibilities_;

     double infeasibilityCost_;

     double sumOfRelaxedDualInfeasibilities_;

     double sumOfRelaxedPrimalInfeasibilities_;

     double acceptablePivot_;

     double * lower_;

     double * rowLowerWork_;

     double * columnLowerWork_;

     double * upper_;

     double * rowUpperWork_;

     double * columnUpperWork_;

     double * cost_;

     double * rowObjectiveWork_;

     double * objectiveWork_;

     CoinIndexedVector * rowArray_[6];

     CoinIndexedVector * columnArray_[6];

     int sequenceIn_;

     int directionIn_;

     int sequenceOut_;

     int directionOut_;

     int pivotRow_;

     int lastGoodIteration_;

     double * dj_;

     double * rowReducedCost_;

     double * reducedCostWork_;

     double * solution_;

     double * rowActivityWork_;

     double * columnActivityWork_;

     int numberDualInfeasibilities_;

     int numberDualInfeasibilitiesWithoutFree_;

     int numberPrimalInfeasibilities_;

     int numberRefinements_;

     ClpDualRowPivot * dualRowPivot_;

     ClpPrimalColumnPivot * primalColumnPivot_;

     int * pivotVariable_;

     ClpFactorization * factorization_;

     double * savedSolution_;

     int numberTimesOptimal_;

     ClpDisasterHandler * disasterArea_;

     int changeMade_;

     int algorithm_;


     int forceFactorization_;







     int perturbation_;

     unsigned char * saveStatus_;




     ClpNonLinearCost * nonLinearCost_;

     int lastBadIteration_;

     int lastFlaggedIteration_;

     int numberFake_;

     int numberChanged_;

     int progressFlag_;

     int firstFree_;



     int numberExtraRows_;


     int maximumBasic_;

     int dontFactorizePivots_;
# 1638 "/usr/local/include/coin/ClpSimplex.hpp" 3
     double incomingInfeasibility_;
     double allowedInfeasibility_;

     int automaticScale_;

     int maximumPerturbationSize_;

     double * perturbationArray_;

     ClpSimplex * baseModel_;

     ClpSimplexProgress progress_;
# 1658 "/usr/local/include/coin/ClpSimplex.hpp" 3
  int abcState_;
public:

     mutable int spareIntArray_[4];

     mutable double spareDoubleArray_[4];
protected:

     friend class OsiClpSolverInterface;

};
# 1678 "/usr/local/include/coin/ClpSimplex.hpp" 3
void
ClpSimplexUnitTest(const std::string & mpsDir);
# 38 "/usr/local/include/ibex/ibex_LinearSolver.h" 2 3
# 51 "/usr/local/include/ibex/ibex_LinearSolver.h" 3
namespace ibex {

class LinearSolver {


private:

 int nb_ctrs;

 int nb_vars;
 int nb_rows;

 double obj_value;

 double epsilon;

 double * primal_solution;
 double * dual_solution;
 int status_prim;
 int status_dual;
# 94 "/usr/local/include/ibex/ibex_LinearSolver.h" 3
 ClpSimplex *myclp;
 int * _which;
 int * _col1Index;



public:

 static const double default_eps;
 static const double default_max_bound;


    static const int default_max_time_out;


    static const int default_max_iter;



 static const Interval default_limit_diam_box;

 typedef enum {OPTIMAL=1, INFEASIBLE=2, INFEASIBLE_NOTPROVED=3, UNKNOWN=0, TIME_OUT=-1, MAX_ITER=-2} Status_Sol;

 typedef enum {MINIMIZE, MAXIMIZE} Sense;

 LinearSolver(int nb_vars, int nb_ctr, int max_iter= default_max_iter,
   int max_time_out= default_max_time_out, double eps=default_eps);

 ~LinearSolver();

 Status_Sol solve();

 void writeFile(const char* name="save_LP.lp");




 Status_Sol run_simplex(const IntervalVector &box, Sense sense, int var, Interval & obj, double bound);




 void NeumaierShcherbina_postprocessing(int var, Interval & obj, const IntervalVector& box, Sense sense);




 bool NeumaierShcherbina_infeasibilitytest( const IntervalVector& box);



 int getNbRows() const;

 double getObjValue() const;

 void getCoefConstraint(Matrix& A);

 void getCoefConstraint_trans(Matrix& A_trans);

 void getB(IntervalVector& B);

 void getPrimalSol(Vector & prim);

 void getDualSol(Vector & dual);

 void getInfeasibleDir(Vector & sol);

 double getEpsilon() const;




 void cleanConst();

 void cleanAll();

 void setMaxIter(int max);

 void setMaxTimeOut(int time);

 void setSense(Sense s);

 void setVarObj(int var, double coef);

 void initBoundVar(IntervalVector bounds);

 void setBoundVar(int var, Interval bound);

 void setEpsilon(double eps);

 void addConstraint(Vector & row, CmpOp sign, double rhs );



};


std::ostream& operator<<(std::ostream& os, const LinearSolver::Status_Sol x);


}
# 16 "/usr/local/include/ibex/ibex_LinearRelax.h" 2 3

namespace ibex {







class LinearRelax {
public:






 LinearRelax(const System& sys);




 LinearRelax(int nb_ctr, int nb_var, int goal_var=-1);

 virtual ~LinearRelax();
# 50 "/usr/local/include/ibex/ibex_LinearRelax.h" 3
 virtual int linearization(const IntervalVector& box, LinearSolver& lp_solver)=0;






 virtual int inlinearization(const IntervalVector& box, LinearSolver& lp_solver)=0;






 virtual bool goal_linearization(const IntervalVector& box, LinearSolver& lp_solver)=0;






 bool isInner(const IntervalVector& box, const System& sys, int j);




 int nb_var() const;




 int nb_ctr() const;




 int goal_var() const;

private:
 int _nb_ctr;
 int _nb_var;
 int _goal_var;

};




inline int LinearRelax::nb_var() const {
 return _nb_var;
}

inline int LinearRelax::nb_ctr() const {
 return _nb_ctr;
}

inline int LinearRelax::goal_var() const {
 return _goal_var;
}


}
# 16 "/usr/local/include/ibex/ibex_CtcPolytopeHull.h" 2 3


namespace ibex {







class CtcPolytopeHull : public Ctc {
public:







 typedef enum { ONLY_Y, ALL_BOX } ctc_mode;
# 48 "/usr/local/include/ibex/ibex_CtcPolytopeHull.h" 3
 CtcPolytopeHull(LinearRelax& lr, ctc_mode cmode=ALL_BOX, int max_iter=LinearSolver::default_max_iter,
   int time_out=LinearSolver::default_max_time_out, double eps=LinearSolver::default_eps,
   Interval limit_diam=LinearSolver::default_limit_diam_box);
# 61 "/usr/local/include/ibex/ibex_CtcPolytopeHull.h" 3
 CtcPolytopeHull(const Matrix& A, const Vector& b, int max_iter=LinearSolver::default_max_iter,
   int time_out=LinearSolver::default_max_time_out, double eps=LinearSolver::default_eps,
   Interval limit_diam=LinearSolver::default_limit_diam_box);

 virtual void contract(IntervalVector& box);

 virtual ~CtcPolytopeHull();

protected:





 bool choose_next_variable(IntervalVector &box, int & nexti, int & infnexti, int* inf_bound, int* sup_bound);




 void optimizer(IntervalVector &box);







 LinearRelax& lr;





 const int goal_var;





 const ctc_mode cmode;




 const Interval limit_diam_box;





 LinearSolver *mylinearsolver;

private:
 bool own_lr;

};

}
# 53 "/usr/local/include/ibex/ibex.h" 2 3

# 1 "/usr/local/include/ibex/ibex_CtcQInter.h" 1 3
# 18 "/usr/local/include/ibex/ibex_CtcQInter.h" 3
namespace ibex {






class CtcQInter : public Ctc {
public:





 CtcQInter(const Array<Ctc>& list, int q);




 virtual void contract(IntervalVector& box);




 Array<Ctc> list;





 int q;

protected:
 IntervalMatrix boxes;
};

class CtcQInter2 : public Ctc {
public:





 CtcQInter2(const Array<Ctc>& list, int q);




 virtual void contract(IntervalVector& box);




 Array<Ctc> list;





 int q;

protected:
 IntervalMatrix boxes;
};

class CtcQInterProjF : public Ctc {
public:





 CtcQInterProjF(const Array<Ctc>& list, int q);




 virtual void contract(IntervalVector& box);




 Array<Ctc> list;





 int q;

protected:
 IntervalMatrix boxes;
};

class CtcQInterCoreF : public Ctc {
public:





 CtcQInterCoreF(const Array<Ctc>& list, int q);




 virtual void contract(IntervalVector& box);




 Array<Ctc> list;





 int q;

protected:
 IntervalMatrix boxes;
};

}
# 55 "/usr/local/include/ibex/ibex.h" 2 3

# 1 "/usr/local/include/ibex/ibex_CtcUnion.h" 1 3
# 16 "/usr/local/include/ibex/ibex_CtcUnion.h" 3
# 1 "/usr/local/include/ibex/ibex_NormalizedSystem.h" 1 3
# 16 "/usr/local/include/ibex/ibex_NormalizedSystem.h" 3
namespace ibex {
# 36 "/usr/local/include/ibex/ibex_NormalizedSystem.h" 3
class NormalizedSystem : public System {
public:







 NormalizedSystem(const System& sys, double eps=0);




 virtual ~NormalizedSystem();




 int original_index(int i) const;

protected:
 int* _orig_index;
};




inline int NormalizedSystem::original_index(int i) const {
 (static_cast <bool> (i<nb_ctr) ? void (0) : __assert_fail ("i<nb_ctr", "/usr/local/include/ibex/ibex_NormalizedSystem.h", 65, __extension__ __PRETTY_FUNCTION__));
 return _orig_index[i];
}

}
# 17 "/usr/local/include/ibex/ibex_CtcUnion.h" 2 3

namespace ibex {







class CtcUnion : public Ctc {
public:




 CtcUnion(const Array<Ctc>& list);




 CtcUnion(const System& sys);




 CtcUnion(Ctc& c1, Ctc& c2);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12, Ctc& c13);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12, Ctc& c13, Ctc& c14);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12, Ctc& c13, Ctc& c14, Ctc& c15);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12, Ctc& c13, Ctc& c14, Ctc& c15, Ctc& c16);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12, Ctc& c13, Ctc& c14, Ctc& c15, Ctc& c16, Ctc& c17);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12, Ctc& c13, Ctc& c14, Ctc& c15, Ctc& c16, Ctc& c17, Ctc& c18);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12, Ctc& c13, Ctc& c14, Ctc& c15, Ctc& c16, Ctc& c17, Ctc& c18, Ctc& c19);




 CtcUnion(Ctc& c1, Ctc& c2, Ctc& c3, Ctc& c4, Ctc& c5, Ctc& c6, Ctc& c7, Ctc& c8, Ctc& c9, Ctc& c10, Ctc& c11, Ctc& c12, Ctc& c13, Ctc& c14, Ctc& c15, Ctc& c16, Ctc& c17, Ctc& c18, Ctc& c19, Ctc& c20);




 ~CtcUnion();




 virtual void contract(IntervalVector& box);




 Array<Ctc> list;

private:

 NormalizedSystem* own_sys;
};

}
# 57 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Affine2Eval.h" 1 3
# 18 "/usr/local/include/ibex/ibex_Affine2Eval.h" 3
namespace ibex {






class Affine2Eval : public FwdAlgorithm {

public:



 Domain& eval(const Function& f, const IntervalVector& box) const;




 Affine2Domain& eval(const Function& f, const Affine2Vector& box) const;




 ExprLabel& eval_label(const Function& f, const IntervalVector& box) const;




 ExprLabel& eval_label(const Function& f, const Affine2Vector& box) const;




 ExprLabel& eval_label(const Function& f, ExprLabel** d) const;




 Domain& eval(const Function& f , ExprLabel** d) const;

 void index_fwd(const ExprIndex&, const ExprLabel& x, ExprLabel& y);
 void vector_fwd(const ExprVector&, const ExprLabel** compL, ExprLabel& y);
 void cst_fwd(const ExprConstant&, ExprLabel& y);
 void symbol_fwd(const ExprSymbol&, ExprLabel& y);
 void apply_fwd(const ExprApply&, ExprLabel** x, ExprLabel& y);
 void chi_fwd(const ExprChi&, const ExprLabel& x1, const ExprLabel& x2, const ExprLabel& x3, ExprLabel& y);
 void add_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void mul_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void sub_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void div_fwd(const ExprDiv&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void max_fwd(const ExprMax&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void min_fwd(const ExprMin&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void atan2_fwd(const ExprAtan2&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void minus_fwd(const ExprMinus&, const ExprLabel& x, ExprLabel& y);
 void trans_V_fwd(const ExprTrans&, const ExprLabel& x, ExprLabel& y);
 void trans_M_fwd(const ExprTrans&, const ExprLabel& x, ExprLabel& y);
 void sign_fwd(const ExprSign&, const ExprLabel& x, ExprLabel& y);
 void abs_fwd(const ExprAbs&, const ExprLabel& x, ExprLabel& y);
 void power_fwd(const ExprPower& p, const ExprLabel& x, ExprLabel& y);
 void sqr_fwd(const ExprSqr&, const ExprLabel& x, ExprLabel& y);
 void sqrt_fwd(const ExprSqrt&, const ExprLabel& x, ExprLabel& y);
 void exp_fwd(const ExprExp&, const ExprLabel& x, ExprLabel& y);
 void log_fwd(const ExprLog&, const ExprLabel& x, ExprLabel& y);
 void cos_fwd(const ExprCos&, const ExprLabel& x, ExprLabel& y);
 void sin_fwd(const ExprSin&, const ExprLabel& x, ExprLabel& y);
 void tan_fwd(const ExprTan&, const ExprLabel& x, ExprLabel& y);
 void cosh_fwd(const ExprCosh&, const ExprLabel& x, ExprLabel& y);
 void sinh_fwd(const ExprSinh&, const ExprLabel& x, ExprLabel& y);
 void tanh_fwd(const ExprTanh&, const ExprLabel& x, ExprLabel& y);
 void acos_fwd(const ExprAcos&, const ExprLabel& x, ExprLabel& y);
 void asin_fwd(const ExprAsin&, const ExprLabel& x, ExprLabel& y);
 void atan_fwd(const ExprAtan&, const ExprLabel& x, ExprLabel& y);
 void acosh_fwd(const ExprAcosh&, const ExprLabel& x, ExprLabel& y);
 void asinh_fwd(const ExprAsinh&, const ExprLabel& x, ExprLabel& y);
 void atanh_fwd(const ExprAtanh&, const ExprLabel& x, ExprLabel& y);

 void add_V_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void add_M_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void mul_SV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void mul_SM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void mul_VV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void mul_MV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void mul_VM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void mul_MM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void sub_V_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void sub_M_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);

};





inline Domain& Affine2Eval::eval(const Function& f, ExprLabel** e) const {
 return *eval_label(f,e).d;
}

inline Domain& Affine2Eval::eval(const Function& f,const IntervalVector& box) const {
 return *(eval_label(f,box)).d;
}

inline Affine2Domain& Affine2Eval::eval(const Function& f,const Affine2Vector& box) const {
 return *(eval_label(f,box)).af2;
}

inline void Affine2Eval::index_fwd(const ExprIndex& , const ExprLabel& , ExprLabel& ) { }

inline void Affine2Eval::symbol_fwd(const ExprSymbol& , ExprLabel& ) { }

inline void Affine2Eval::cst_fwd(const ExprConstant& c, ExprLabel& y) {
 switch (c.type()) {
 case Dim::SCALAR: {
  y.af2->i() = Affine2(c.get_value());
  y.d->i() = c.get_value();
  break;
 }
 case Dim::ROW_VECTOR:
 case Dim::COL_VECTOR: {
  y.af2->v() = Affine2Vector(c.get_vector_value(),false);
  y.d->v() = c.get_vector_value();
  break;
 }
 case Dim::MATRIX: {
  y.af2->m() = Affine2Matrix(c.get_matrix_value());
  y.d->m() = c.get_matrix_value();
  break;
 }
 case Dim::MATRIX_ARRAY: {
  (static_cast <bool> (false) ? void (0) : __assert_fail ("false", "/usr/local/include/ibex/ibex_Affine2Eval.h", 146, __extension__ __PRETTY_FUNCTION__));
  break;
 }
 }
}

inline void Affine2Eval::apply_fwd(const ExprApply& a, ExprLabel** x, ExprLabel& y) {
 ExprLabel& tmp = eval_label(a.func,x);
 *y.af2 = *tmp.af2;
 *y.d = *tmp.d;
}
inline void Affine2Eval::chi_fwd(const ExprChi&, const ExprLabel& x1, const ExprLabel& x2, const ExprLabel& x3, ExprLabel& y) {
 y.af2->i()=chi(x1.d->i(),x2.af2->i(),x3.af2->i());
 y.d->i() =chi(x1.d->i(),x2.d->i(),x3.d->i());
}
inline void Affine2Eval::add_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af2->i()=x1.af2->i()+x2.af2->i();
 y.d->i()=(y.af2->i().itv() & (x1.d->i()+x2.d->i()));
}
inline void Affine2Eval::mul_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af2->i()=x1.af2->i()*x2.af2->i();
 y.d->i()=(y.af2->i().itv() & (x1.d->i()*x2.d->i()));
}
inline void Affine2Eval::sub_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af2->i()=x1.af2->i()-x2.af2->i();
 y.d->i()=(y.af2->i().itv() & (x1.d->i()-x2.d->i()));
}
inline void Affine2Eval::div_fwd(const ExprDiv&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af2->i()=x1.af2->i()*inv(x2.af2->i(),x2.d->i());
 y.d->i()=(y.af2->i().itv() & (x1.d->i()/x2.d->i()));
}
inline void Affine2Eval::max_fwd(const ExprMax&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.d->i()= max(x1.d->i(),x2.d->i());
 y.af2->i() = Affine2(y.d->i());
}
inline void Affine2Eval::min_fwd(const ExprMin&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.d->i() = min(x1.d->i(),x2.d->i());
 y.af2->i()= Affine2( y.d->i());
}
inline void Affine2Eval::atan2_fwd(const ExprAtan2&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.d->i() = atan2(x1.d->i(),x2.d->i());
 y.af2->i()= Affine2(y.d->i());
}
inline void Affine2Eval::minus_fwd(const ExprMinus&, const ExprLabel& x, ExprLabel& y) {
 y.af2->i()=-x.af2->i();
 y.d->i()=(y.af2->i().itv() & (-x.d->i()));
}
inline void Affine2Eval::sign_fwd(const ExprSign&, const ExprLabel& x, ExprLabel& y) {
 y.af2->i()=sign(x.af2->i(),x.d->i());
 y.d->i()=(y.af2->i().itv() & sign(x.d->i()));
}
inline void Affine2Eval::abs_fwd(const ExprAbs&, const ExprLabel& x, ExprLabel& y) {
 y.af2->i()=abs(x.af2->i(),x.d->i());
 y.d->i()=(y.af2->i().itv() & abs(x.d->i()));
}
inline void Affine2Eval::power_fwd(const ExprPower& p, const ExprLabel& x, ExprLabel& y) {
 y.af2->i()=pow(x.af2->i(),p.expon,x.d->i());
 y.d->i()=(y.af2->i().itv() & pow(x.d->i(),p.expon));
}
inline void Affine2Eval::sqr_fwd(const ExprSqr&, const ExprLabel& x, ExprLabel& y) {
 y.af2->i()=sqr(x.af2->i(),x.d->i());
 y.d->i()=(y.af2->i().itv() & sqr(x.d->i()));
}
inline void Affine2Eval::sqrt_fwd(const ExprSqrt&, const ExprLabel& x, ExprLabel& y) {
 y.af2->i()=sqrt(x.af2->i(),x.d->i());
 y.d->i()=(y.af2->i().itv() & sqrt(x.d->i()));
}
inline void Affine2Eval::exp_fwd(const ExprExp&, const ExprLabel& x, ExprLabel& y) {
 y.af2->i()=exp(x.af2->i(),x.d->i());
 y.d->i()=(y.af2->i().itv() & exp(x.d->i()));
}
inline void Affine2Eval::log_fwd(const ExprLog&, const ExprLabel& x, ExprLabel& y) {
 y.af2->i()=log(x.af2->i(),x.d->i());
 y.d->i()=(y.af2->i().itv() & log(x.d->i()));
}
inline void Affine2Eval::cos_fwd(const ExprCos&, const ExprLabel& x, ExprLabel& y) {
 y.af2->i()=cos(x.af2->i(),x.d->i());
 y.d->i()=(y.af2->i().itv() & cos(x.d->i()));
}
inline void Affine2Eval::sin_fwd(const ExprSin&, const ExprLabel& x, ExprLabel& y) {
 y.af2->i()=sin(x.af2->i(),x.d->i());
 y.d->i()=(y.af2->i().itv() & sin(x.d->i()));
}
inline void Affine2Eval::tan_fwd(const ExprTan&, const ExprLabel& x, ExprLabel& y) {
 y.af2->i()=tan(x.af2->i(),x.d->i());
 y.d->i()=(y.af2->i().itv() & tan(x.d->i()));
}
inline void Affine2Eval::cosh_fwd(const ExprCosh&, const ExprLabel& x, ExprLabel& y) {
 y.af2->i()=cosh(x.af2->i(),x.d->i());
 y.d->i()=(y.af2->i().itv() & cosh(x.d->i()));
}
inline void Affine2Eval::sinh_fwd(const ExprSinh&, const ExprLabel& x, ExprLabel& y) {
 y.af2->i()=sinh(x.af2->i(),x.d->i());
 y.d->i()=(y.af2->i().itv() & sinh(x.d->i()));
}
inline void Affine2Eval::tanh_fwd(const ExprTanh&, const ExprLabel& x, ExprLabel& y) {
 y.af2->i()=tanh(x.af2->i(),x.d->i());
 y.d->i()=(y.af2->i().itv() & tanh(x.d->i()));
}
inline void Affine2Eval::acos_fwd(const ExprAcos&, const ExprLabel& x, ExprLabel& y) {
 y.af2->i()=acos(x.af2->i(),x.d->i());
 y.d->i()=(y.af2->i().itv() & acos(x.d->i()));
}
inline void Affine2Eval::asin_fwd(const ExprAsin&, const ExprLabel& x, ExprLabel& y) {
 y.af2->i()=asin(x.af2->i(),x.d->i());
 y.d->i()=(y.af2->i().itv() & asin(x.d->i()));
}
inline void Affine2Eval::atan_fwd(const ExprAtan&, const ExprLabel& x, ExprLabel& y) {
 y.af2->i()=atan(x.af2->i(),x.d->i());
 y.d->i()=(y.af2->i().itv() & atan(x.d->i()));
}
inline void Affine2Eval::acosh_fwd(const ExprAcosh&, const ExprLabel& x, ExprLabel& y) {
 y.d->i()=acosh(x.d->i());
 y.af2->i()= Affine2(y.d->i());
}
inline void Affine2Eval::asinh_fwd(const ExprAsinh&, const ExprLabel& x, ExprLabel& y) {
 y.d->i()=asinh(x.d->i());
 y.af2->i()= Affine2(y.d->i());
}
inline void Affine2Eval::atanh_fwd(const ExprAtanh&, const ExprLabel& x, ExprLabel& y) {
 y.d->i()=atanh(x.d->i());
 y.af2->i()= Affine2(y.d->i());
}



inline void Affine2Eval::trans_V_fwd(const ExprTrans&, const ExprLabel& x, ExprLabel& y) {
 y.af2->v()=x.af2->v();
 y.d->v()=x.d->v();
}
inline void Affine2Eval::trans_M_fwd(const ExprTrans&, const ExprLabel& x, ExprLabel& y) {
 y.af2->m()=x.af2->m().transpose();
 y.d->m()=x.d->m().transpose();
}
inline void Affine2Eval::add_V_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af2->v()=x1.af2->v()+x2.af2->v();
 y.d->v()=(y.af2->v().itv() & (x1.d->v()+x2.d->v()));
}
inline void Affine2Eval::add_M_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af2->m()=x1.af2->m()+x2.af2->m();
 y.d->m()=(y.af2->m().itv());
 y.d->m() &= (x1.d->m()+x2.d->m());
}
inline void Affine2Eval::mul_SV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af2->v()=x1.af2->i()*x2.af2->v();
 y.d->v()=(y.af2->v().itv() & (x1.d->i()*x2.d->v()));
}
inline void Affine2Eval::mul_SM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af2->m()=x1.af2->i()*x2.af2->m();
 y.d->m()=(y.af2->m().itv());
 y.d->m() &= (x1.d->i()*x2.d->m());
}
inline void Affine2Eval::mul_VV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af2->i()=x1.af2->v()*x2.af2->v();
 y.d->i()=(y.af2->i().itv() & (x1.d->v()*x2.d->v()));
}
inline void Affine2Eval::mul_MV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af2->v()=x1.af2->m()*x2.af2->v();
 y.d->v()=(y.af2->v().itv() & (x1.d->m()*x2.d->v()));
}
inline void Affine2Eval::mul_VM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af2->v()=x1.af2->v()*x2.af2->m();
 y.d->v()=(y.af2->v().itv() & (x1.d->v()*x2.d->m()));
}
inline void Affine2Eval::mul_MM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af2->m()=x1.af2->m()*x2.af2->m();
 y.d->m()=(y.af2->m().itv()) ;
 y.d->m() &= (x1.d->m()*x2.d->m());
}
inline void Affine2Eval::sub_V_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af2->v()=x1.af2->v()-x2.af2->v();
 y.d->v()=(y.af2->v().itv() & (x1.d->v()-x2.d->v()));
}
inline void Affine2Eval::sub_M_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af2->m()=x1.af2->m()-x2.af2->m();
 y.d->m() = y.af2->m().itv();
 y.d->m() &= (x1.d->m()-x2.d->m());
}

}
# 58 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_AffineLinEval.h" 1 3
# 18 "/usr/local/include/ibex/ibex_AffineLinEval.h" 3
namespace ibex {






class AffineLinEval : public FwdAlgorithm {

public:



 Domain& eval(const Function& f, const IntervalVector& box) const;




 AffineLinDomain& eval(const Function& f, const AffineLinVector& box) const;




 ExprLabel& eval_label(const Function& f, const IntervalVector& box) const;




 ExprLabel& eval_label(const Function& f, const AffineLinVector& box) const;




 ExprLabel& eval_label(const Function& f, ExprLabel** d) const;




 Domain& eval(const Function& f , ExprLabel** d) const;

 void index_fwd(const ExprIndex&, const ExprLabel& x, ExprLabel& y);
 void vector_fwd(const ExprVector&, const ExprLabel** compL, ExprLabel& y);
 void cst_fwd(const ExprConstant&, ExprLabel& y);
 void symbol_fwd(const ExprSymbol&, ExprLabel& y);
 void apply_fwd(const ExprApply&, ExprLabel** x, ExprLabel& y);
 void chi_fwd(const ExprChi&, const ExprLabel& x1, const ExprLabel& x2, const ExprLabel& x3, ExprLabel& y);
 void add_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void mul_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void sub_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void div_fwd(const ExprDiv&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void max_fwd(const ExprMax&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void min_fwd(const ExprMin&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void atan2_fwd(const ExprAtan2&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void minus_fwd(const ExprMinus&, const ExprLabel& x, ExprLabel& y);
 void trans_V_fwd(const ExprTrans&, const ExprLabel& x, ExprLabel& y);
 void trans_M_fwd(const ExprTrans&, const ExprLabel& x, ExprLabel& y);
 void sign_fwd(const ExprSign&, const ExprLabel& x, ExprLabel& y);
 void abs_fwd(const ExprAbs&, const ExprLabel& x, ExprLabel& y);
 void power_fwd(const ExprPower& p, const ExprLabel& x, ExprLabel& y);
 void sqr_fwd(const ExprSqr&, const ExprLabel& x, ExprLabel& y);
 void sqrt_fwd(const ExprSqrt&, const ExprLabel& x, ExprLabel& y);
 void exp_fwd(const ExprExp&, const ExprLabel& x, ExprLabel& y);
 void log_fwd(const ExprLog&, const ExprLabel& x, ExprLabel& y);
 void cos_fwd(const ExprCos&, const ExprLabel& x, ExprLabel& y);
 void sin_fwd(const ExprSin&, const ExprLabel& x, ExprLabel& y);
 void tan_fwd(const ExprTan&, const ExprLabel& x, ExprLabel& y);
 void cosh_fwd(const ExprCosh&, const ExprLabel& x, ExprLabel& y);
 void sinh_fwd(const ExprSinh&, const ExprLabel& x, ExprLabel& y);
 void tanh_fwd(const ExprTanh&, const ExprLabel& x, ExprLabel& y);
 void acos_fwd(const ExprAcos&, const ExprLabel& x, ExprLabel& y);
 void asin_fwd(const ExprAsin&, const ExprLabel& x, ExprLabel& y);
 void atan_fwd(const ExprAtan&, const ExprLabel& x, ExprLabel& y);
 void acosh_fwd(const ExprAcosh&, const ExprLabel& x, ExprLabel& y);
 void asinh_fwd(const ExprAsinh&, const ExprLabel& x, ExprLabel& y);
 void atanh_fwd(const ExprAtanh&, const ExprLabel& x, ExprLabel& y);

 void add_V_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void add_M_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void mul_SV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void mul_SM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void mul_VV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void mul_MV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void mul_VM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void mul_MM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void sub_V_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 void sub_M_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);

};





inline Domain& AffineLinEval::eval(const Function& f, ExprLabel** e) const {
 return *eval_label(f,e).d;
}

inline Domain& AffineLinEval::eval(const Function& f,const IntervalVector& box) const {
 return *(eval_label(f,box)).d;
}

inline AffineLinDomain& AffineLinEval::eval(const Function& f,const AffineLinVector& box) const {
 return *(eval_label(f,box)).af_lin;
}

inline void AffineLinEval::index_fwd(const ExprIndex& , const ExprLabel& , ExprLabel& ) { }

inline void AffineLinEval::symbol_fwd(const ExprSymbol& , ExprLabel& ) { }

inline void AffineLinEval::cst_fwd(const ExprConstant& c, ExprLabel& y) {
 switch (c.type()) {
 case Dim::SCALAR: {
  y.af_lin->i() = AffineLin(c.get_value());
  y.d->i() = c.get_value();
  break;
 }
 case Dim::ROW_VECTOR:
 case Dim::COL_VECTOR: {
  y.af_lin->v() = AffineLinVector(c.get_vector_value(),false);
  y.d->v() = c.get_vector_value();
  break;
 }
 case Dim::MATRIX: {
  y.af_lin->m() = AffineLinMatrix(c.get_matrix_value());
  y.d->m() = c.get_matrix_value();
  break;
 }
 case Dim::MATRIX_ARRAY: {
  (static_cast <bool> (false) ? void (0) : __assert_fail ("false", "/usr/local/include/ibex/ibex_AffineLinEval.h", 146, __extension__ __PRETTY_FUNCTION__));
  break;
 }
 }
}

inline void AffineLinEval::apply_fwd(const ExprApply& a, ExprLabel** x, ExprLabel& y) {
 ExprLabel& tmp = eval_label(a.func,x);
 *y.af_lin = *tmp.af_lin;
 *y.d = *tmp.d;
}
inline void AffineLinEval::chi_fwd(const ExprChi&, const ExprLabel& x1, const ExprLabel& x2, const ExprLabel& x3, ExprLabel& y) {
 y.af_lin->i()=chi(x1.d->i(),x2.af_lin->i(),x3.af_lin->i());
 y.d->i() =chi(x1.d->i(),x2.d->i(),x3.d->i());
}
inline void AffineLinEval::add_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af_lin->i()=x1.af_lin->i()+x2.af_lin->i();
 y.d->i()=(y.af_lin->i().itv() & (x1.d->i()+x2.d->i()));
}
inline void AffineLinEval::mul_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af_lin->i()=x1.af_lin->i()*x2.af_lin->i();
 y.d->i()=(y.af_lin->i().itv() & (x1.d->i()*x2.d->i()));
}
inline void AffineLinEval::sub_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af_lin->i()=x1.af_lin->i()-x2.af_lin->i();
 y.d->i()=(y.af_lin->i().itv() & (x1.d->i()-x2.d->i()));
}
inline void AffineLinEval::div_fwd(const ExprDiv&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af_lin->i()=x1.af_lin->i()*inv(x2.af_lin->i(),x2.d->i());
 y.d->i()=(y.af_lin->i().itv() & (x1.d->i()/x2.d->i()));
}
inline void AffineLinEval::max_fwd(const ExprMax&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.d->i()= max(x1.d->i(),x2.d->i());
 y.af_lin->i() = AffineLin(y.d->i());
}
inline void AffineLinEval::min_fwd(const ExprMin&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.d->i() = min(x1.d->i(),x2.d->i());
 y.af_lin->i()= AffineLin( y.d->i());
}
inline void AffineLinEval::atan2_fwd(const ExprAtan2&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.d->i() = atan2(x1.d->i(),x2.d->i());
 y.af_lin->i()= AffineLin(y.d->i());
}
inline void AffineLinEval::minus_fwd(const ExprMinus&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->i()=-x.af_lin->i();
 y.d->i()=(y.af_lin->i().itv() & (-x.d->i()));
}
inline void AffineLinEval::sign_fwd(const ExprSign&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->i()=sign(x.af_lin->i(),x.d->i());
 y.d->i()=(y.af_lin->i().itv() & sign(x.d->i()));
}
inline void AffineLinEval::abs_fwd(const ExprAbs&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->i()=abs(x.af_lin->i(),x.d->i());
 y.d->i()=(y.af_lin->i().itv() & abs(x.d->i()));
}
inline void AffineLinEval::power_fwd(const ExprPower& p, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->i()=pow(x.af_lin->i(),p.expon,x.d->i());
 y.d->i()=(y.af_lin->i().itv() & pow(x.d->i(),p.expon));
}
inline void AffineLinEval::sqr_fwd(const ExprSqr&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->i()=sqr(x.af_lin->i(),x.d->i());
 y.d->i()=(y.af_lin->i().itv() & sqr(x.d->i()));
}
inline void AffineLinEval::sqrt_fwd(const ExprSqrt&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->i()=sqrt(x.af_lin->i(),x.d->i());
 y.d->i()=(y.af_lin->i().itv() & sqrt(x.d->i()));
}
inline void AffineLinEval::exp_fwd(const ExprExp&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->i()=exp(x.af_lin->i(),x.d->i());
 y.d->i()=(y.af_lin->i().itv() & exp(x.d->i()));
}
inline void AffineLinEval::log_fwd(const ExprLog&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->i()=log(x.af_lin->i(),x.d->i());
 y.d->i()=(y.af_lin->i().itv() & log(x.d->i()));
}
inline void AffineLinEval::cos_fwd(const ExprCos&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->i()=cos(x.af_lin->i(),x.d->i());
 y.d->i()=(y.af_lin->i().itv() & cos(x.d->i()));
}
inline void AffineLinEval::sin_fwd(const ExprSin&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->i()=sin(x.af_lin->i(),x.d->i());
 y.d->i()=(y.af_lin->i().itv() & sin(x.d->i()));
}
inline void AffineLinEval::tan_fwd(const ExprTan&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->i()=tan(x.af_lin->i(),x.d->i());
 y.d->i()=(y.af_lin->i().itv() & tan(x.d->i()));
}
inline void AffineLinEval::cosh_fwd(const ExprCosh&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->i()=cosh(x.af_lin->i(),x.d->i());
 y.d->i()=(y.af_lin->i().itv() & cosh(x.d->i()));
}
inline void AffineLinEval::sinh_fwd(const ExprSinh&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->i()=sinh(x.af_lin->i(),x.d->i());
 y.d->i()=(y.af_lin->i().itv() & sinh(x.d->i()));
}
inline void AffineLinEval::tanh_fwd(const ExprTanh&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->i()=tanh(x.af_lin->i(),x.d->i());
 y.d->i()=(y.af_lin->i().itv() & tanh(x.d->i()));
}
inline void AffineLinEval::acos_fwd(const ExprAcos&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->i()=acos(x.af_lin->i(),x.d->i());
 y.d->i()=(y.af_lin->i().itv() & acos(x.d->i()));
}
inline void AffineLinEval::asin_fwd(const ExprAsin&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->i()=asin(x.af_lin->i(),x.d->i());
 y.d->i()=(y.af_lin->i().itv() & asin(x.d->i()));
}
inline void AffineLinEval::atan_fwd(const ExprAtan&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->i()=atan(x.af_lin->i(),x.d->i());
 y.d->i()=(y.af_lin->i().itv() & atan(x.d->i()));
}
inline void AffineLinEval::acosh_fwd(const ExprAcosh&, const ExprLabel& x, ExprLabel& y) {
 y.d->i()=acosh(x.d->i());
 y.af_lin->i()= AffineLin(y.d->i());
}
inline void AffineLinEval::asinh_fwd(const ExprAsinh&, const ExprLabel& x, ExprLabel& y) {
 y.d->i()=asinh(x.d->i());
 y.af_lin->i()= AffineLin(y.d->i());
}
inline void AffineLinEval::atanh_fwd(const ExprAtanh&, const ExprLabel& x, ExprLabel& y) {
 y.d->i()=atanh(x.d->i());
 y.af_lin->i()= AffineLin(y.d->i());
}



inline void AffineLinEval::trans_V_fwd(const ExprTrans&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->v()=x.af_lin->v();
 y.d->v()=x.d->v();
}
inline void AffineLinEval::trans_M_fwd(const ExprTrans&, const ExprLabel& x, ExprLabel& y) {
 y.af_lin->m()=x.af_lin->m().transpose();
 y.d->m()=x.d->m().transpose();
}
inline void AffineLinEval::add_V_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af_lin->v()=x1.af_lin->v()+x2.af_lin->v();
 y.d->v()=(y.af_lin->v().itv() & (x1.d->v()+x2.d->v()));
}
inline void AffineLinEval::add_M_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af_lin->m()=x1.af_lin->m()+x2.af_lin->m();
 y.d->m()=(y.af_lin->m().itv());
 y.d->m() &= (x1.d->m()+x2.d->m());
}
inline void AffineLinEval::mul_SV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af_lin->v()=x1.af_lin->i()*x2.af_lin->v();
 y.d->v()=(y.af_lin->v().itv() & (x1.d->i()*x2.d->v()));
}
inline void AffineLinEval::mul_SM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af_lin->m()=x1.af_lin->i()*x2.af_lin->m();
 y.d->m()=(y.af_lin->m().itv());
 y.d->m() &= (x1.d->i()*x2.d->m());
}
inline void AffineLinEval::mul_VV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af_lin->i()=x1.af_lin->v()*x2.af_lin->v();
 y.d->i()=(y.af_lin->i().itv() & (x1.d->v()*x2.d->v()));
}
inline void AffineLinEval::mul_MV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af_lin->v()=x1.af_lin->m()*x2.af_lin->v();
 y.d->v()=(y.af_lin->v().itv() & (x1.d->m()*x2.d->v()));
}
inline void AffineLinEval::mul_VM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af_lin->v()=x1.af_lin->v()*x2.af_lin->m();
 y.d->v()=(y.af_lin->v().itv() & (x1.d->v()*x2.d->m()));
}
inline void AffineLinEval::mul_MM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af_lin->m()=x1.af_lin->m()*x2.af_lin->m();
 y.d->m()=(y.af_lin->m().itv()) ;
 y.d->m() &= (x1.d->m()*x2.d->m());
}
inline void AffineLinEval::sub_V_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af_lin->v()=x1.af_lin->v()-x2.af_lin->v();
 y.d->v()=(y.af_lin->v().itv() & (x1.d->v()-x2.d->v()));
}
inline void AffineLinEval::sub_M_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
 y.af_lin->m()=x1.af_lin->m()-x2.af_lin->m();
 y.d->m() = y.af_lin->m().itv();
 y.d->m() &= (x1.d->m()-x2.d->m());
}

}
# 59 "/usr/local/include/ibex/ibex.h" 2 3



# 1 "/usr/local/include/ibex/ibex_Eval.h" 1 3
# 18 "/usr/local/include/ibex/ibex_Eval.h" 3
namespace ibex {
# 28 "/usr/local/include/ibex/ibex_Eval.h" 3
class Eval : public FwdAlgorithm {

public:



 Domain& eval(const Function&, const Array<const Domain>& d) const;




 Domain& eval(const Function&, const Array<Domain>& d) const;




 Domain& eval(const Function&, const IntervalVector& box) const;




 Domain& eval(const Function&, ExprLabel** d) const;

protected:





 class EmptyBoxException { };

public:
 inline void index_fwd(const ExprIndex&, const ExprLabel& x, ExprLabel& y);
        void vector_fwd(const ExprVector&, const ExprLabel** compL, ExprLabel& y);
 inline void cst_fwd(const ExprConstant&, ExprLabel& y);
 inline void symbol_fwd(const ExprSymbol&, ExprLabel& y);
 inline void apply_fwd(const ExprApply&, ExprLabel** x, ExprLabel& y);
 inline void chi_fwd(const ExprChi&, const ExprLabel& x1, const ExprLabel& x2, const ExprLabel& x3, ExprLabel& y);
 inline void add_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 inline void mul_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 inline void sub_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 inline void div_fwd(const ExprDiv&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 inline void max_fwd(const ExprMax&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 inline void min_fwd(const ExprMin&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 inline void atan2_fwd(const ExprAtan2&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 inline void minus_fwd(const ExprMinus&, const ExprLabel& x, ExprLabel& y);
 inline void trans_V_fwd(const ExprTrans&, const ExprLabel& x, ExprLabel& y);
 inline void trans_M_fwd(const ExprTrans&, const ExprLabel& x, ExprLabel& y);
 inline void sign_fwd(const ExprSign&, const ExprLabel& x, ExprLabel& y);
 inline void abs_fwd(const ExprAbs&, const ExprLabel& x, ExprLabel& y);
 inline void power_fwd(const ExprPower& p, const ExprLabel& x, ExprLabel& y);
 inline void sqr_fwd(const ExprSqr&, const ExprLabel& x, ExprLabel& y);
 inline void sqrt_fwd(const ExprSqrt&, const ExprLabel& x, ExprLabel& y);
 inline void exp_fwd(const ExprExp&, const ExprLabel& x, ExprLabel& y);
 inline void log_fwd(const ExprLog&, const ExprLabel& x, ExprLabel& y);
 inline void cos_fwd(const ExprCos&, const ExprLabel& x, ExprLabel& y);
 inline void sin_fwd(const ExprSin&, const ExprLabel& x, ExprLabel& y);
 inline void tan_fwd(const ExprTan&, const ExprLabel& x, ExprLabel& y);
 inline void cosh_fwd(const ExprCosh&, const ExprLabel& x, ExprLabel& y);
 inline void sinh_fwd(const ExprSinh&, const ExprLabel& x, ExprLabel& y);
 inline void tanh_fwd(const ExprTanh&, const ExprLabel& x, ExprLabel& y);
 inline void acos_fwd(const ExprAcos&, const ExprLabel& x, ExprLabel& y);
 inline void asin_fwd(const ExprAsin&, const ExprLabel& x, ExprLabel& y);
 inline void atan_fwd(const ExprAtan&, const ExprLabel& x, ExprLabel& y);
 inline void acosh_fwd(const ExprAcosh&, const ExprLabel& x, ExprLabel& y);
 inline void asinh_fwd(const ExprAsinh&, const ExprLabel& x, ExprLabel& y);
 inline void atanh_fwd(const ExprAtanh&, const ExprLabel& x, ExprLabel& y);

 inline void add_V_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 inline void add_M_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 inline void mul_SV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 inline void mul_SM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 inline void mul_VV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 inline void mul_MV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 inline void mul_VM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 inline void mul_MM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 inline void sub_V_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
 inline void sub_M_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);

};





inline void Eval::index_fwd(const ExprIndex& , const ExprLabel& , ExprLabel& ) { }

inline void Eval::symbol_fwd(const ExprSymbol& , ExprLabel& ) { }

inline void Eval::cst_fwd(const ExprConstant& c, ExprLabel& y) {
 switch (c.type()) {
 case Dim::SCALAR: y.d->i() = c.get_value(); break;
 case Dim::ROW_VECTOR:
 case Dim::COL_VECTOR: y.d->v() = c.get_vector_value(); break;
 case Dim::MATRIX: y.d->m() = c.get_matrix_value(); break;
 case Dim::MATRIX_ARRAY: (static_cast <bool> (false) ? void (0) : __assert_fail ("false", "/usr/local/include/ibex/ibex_Eval.h", 123, __extension__ __PRETTY_FUNCTION__)); break;
 }
}
inline void Eval::apply_fwd(const ExprApply& a, ExprLabel** x, ExprLabel& y) { *y.d = eval(a.func,x); }
inline void Eval::chi_fwd(const ExprChi&, const ExprLabel& x1, const ExprLabel& x2, const ExprLabel& x3, ExprLabel& y) { y.d->i() = chi(x1.d->i(),x2.d->i(),x3.d->i()); }
inline void Eval::add_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) { y.d->i()=x1.d->i()+x2.d->i(); }
inline void Eval::mul_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) { y.d->i()=x1.d->i()*x2.d->i(); }
inline void Eval::sub_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) { y.d->i()=x1.d->i()-x2.d->i(); }
inline void Eval::div_fwd(const ExprDiv&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) { y.d->i()=x1.d->i()/x2.d->i(); }
inline void Eval::max_fwd(const ExprMax&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) { y.d->i()=max(x1.d->i(),x2.d->i()); }
inline void Eval::min_fwd(const ExprMin&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) { y.d->i()=min(x1.d->i(),x2.d->i()); }
inline void Eval::atan2_fwd(const ExprAtan2&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) { y.d->i()=atan2(x1.d->i(),x2.d->i()); }

inline void Eval::minus_fwd(const ExprMinus&, const ExprLabel& x, ExprLabel& y) { y.d->i()=-x.d->i(); }
inline void Eval::sign_fwd(const ExprSign&, const ExprLabel& x, ExprLabel& y) { y.d->i()=sign(x.d->i()); }
inline void Eval::abs_fwd(const ExprAbs&, const ExprLabel& x, ExprLabel& y) { y.d->i()=abs(x.d->i()); }
inline void Eval::power_fwd(const ExprPower& p, const ExprLabel& x, ExprLabel& y) { y.d->i()=pow(x.d->i(),p.expon); }
inline void Eval::sqr_fwd(const ExprSqr&, const ExprLabel& x, ExprLabel& y) { y.d->i()=sqr(x.d->i()); }
inline void Eval::sqrt_fwd(const ExprSqrt&, const ExprLabel& x, ExprLabel& y) { if ((y.d->i()=sqrt(x.d->i())).is_empty()) throw EmptyBoxException(); }
inline void Eval::exp_fwd(const ExprExp&, const ExprLabel& x, ExprLabel& y) { y.d->i()=exp(x.d->i()); }
inline void Eval::log_fwd(const ExprLog&, const ExprLabel& x, ExprLabel& y) { if ((y.d->i()=log(x.d->i())).is_empty()) throw EmptyBoxException(); }
inline void Eval::cos_fwd(const ExprCos&, const ExprLabel& x, ExprLabel& y) { y.d->i()=cos(x.d->i()); }
inline void Eval::sin_fwd(const ExprSin&, const ExprLabel& x, ExprLabel& y) { y.d->i()=sin(x.d->i()); }
inline void Eval::tan_fwd(const ExprTan&, const ExprLabel& x, ExprLabel& y) { if ((y.d->i()=tan(x.d->i())).is_empty()) throw EmptyBoxException(); }
inline void Eval::cosh_fwd(const ExprCosh&, const ExprLabel& x, ExprLabel& y) { y.d->i()=cosh(x.d->i()); }
inline void Eval::sinh_fwd(const ExprSinh&, const ExprLabel& x, ExprLabel& y) { y.d->i()=sinh(x.d->i()); }
inline void Eval::tanh_fwd(const ExprTanh&, const ExprLabel& x, ExprLabel& y) { y.d->i()=tanh(x.d->i()); }
inline void Eval::acos_fwd(const ExprAcos&, const ExprLabel& x, ExprLabel& y) { if ((y.d->i()=acos(x.d->i())).is_empty()) throw EmptyBoxException(); }
inline void Eval::asin_fwd(const ExprAsin&, const ExprLabel& x, ExprLabel& y) { if ((y.d->i()=asin(x.d->i())).is_empty()) throw EmptyBoxException(); }
inline void Eval::atan_fwd(const ExprAtan&, const ExprLabel& x, ExprLabel& y) { y.d->i()=atan(x.d->i()); }
inline void Eval::acosh_fwd(const ExprAcosh&, const ExprLabel& x, ExprLabel& y) { if ((y.d->i()=acosh(x.d->i())).is_empty()) throw EmptyBoxException(); }
inline void Eval::asinh_fwd(const ExprAsinh&, const ExprLabel& x, ExprLabel& y) { y.d->i()=asinh(x.d->i()); }
inline void Eval::atanh_fwd(const ExprAtanh&, const ExprLabel& x, ExprLabel& y) { if ((y.d->i()=atanh(x.d->i())).is_empty()) throw EmptyBoxException(); }

inline void Eval::trans_V_fwd(const ExprTrans&, const ExprLabel& x, ExprLabel& y) { y.d->v()=x.d->v(); }
inline void Eval::trans_M_fwd(const ExprTrans&, const ExprLabel& x, ExprLabel& y) { y.d->m()=x.d->m().transpose(); }
inline void Eval::add_V_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) { y.d->v()=x1.d->v()+x2.d->v(); }
inline void Eval::add_M_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) { y.d->m()=x1.d->m()+x2.d->m(); }
inline void Eval::mul_SV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) { y.d->v()=x1.d->i()*x2.d->v(); }
inline void Eval::mul_SM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) { y.d->m()=x1.d->i()*x2.d->m(); }
inline void Eval::mul_VV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) { y.d->i()=x1.d->v()*x2.d->v(); }
inline void Eval::mul_MV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) { y.d->v()=x1.d->m()*x2.d->v(); }
inline void Eval::mul_VM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) { y.d->v()=x1.d->v()*x2.d->m(); }
inline void Eval::mul_MM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) { y.d->m()=x1.d->m()*x2.d->m(); }
inline void Eval::sub_V_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) { y.d->v()=x1.d->v()-x2.d->v(); }
inline void Eval::sub_M_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) { y.d->m()=x1.d->m()-x2.d->m(); }

}
# 63 "/usr/local/include/ibex/ibex.h" 2 3


# 1 "/usr/local/include/ibex/ibex_Gradient.h" 1 3
# 18 "/usr/local/include/ibex/ibex_Gradient.h" 3
namespace ibex {





class Gradient : public FwdAlgorithm, public BwdAlgorithm {

public:



 void gradient(const Function&, const Array<Domain>& d, IntervalVector& g) const;




 void gradient(const Function& f, const IntervalVector& box, IntervalVector& g) const;




 void jacobian(const Function& f, const Array<Domain>& d, IntervalMatrix& J) const;

 inline void index_fwd(const ExprIndex& , const ExprLabel& , ExprLabel& ) { }
        void vector_fwd(const ExprVector& v, const ExprLabel** s, ExprLabel& y);
        void cst_fwd(const ExprConstant&, ExprLabel& y) { y.g->clear(); }
        void symbol_fwd(const ExprSymbol&, ExprLabel& y) { y.g->clear(); }
        void apply_fwd(const ExprApply&, ExprLabel**, ExprLabel& y) { y.g->clear(); }
 inline void chi_fwd(const ExprChi&, const ExprLabel&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void add_fwd(const ExprAdd&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void mul_fwd(const ExprMul&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void sub_fwd(const ExprSub&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void div_fwd(const ExprDiv&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void max_fwd(const ExprMax&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void min_fwd(const ExprMin&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void atan2_fwd(const ExprAtan2&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void minus_fwd(const ExprMinus&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void trans_V_fwd(const ExprTrans&, const ExprLabel&, ExprLabel& y) { y.g->v().clear(); }
 inline void trans_M_fwd(const ExprTrans&, const ExprLabel&, ExprLabel& y) { y.g->m().clear(); }
 inline void sign_fwd(const ExprSign&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void abs_fwd(const ExprAbs&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void power_fwd(const ExprPower& , const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void sqr_fwd(const ExprSqr&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void sqrt_fwd(const ExprSqrt&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void exp_fwd(const ExprExp&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void log_fwd(const ExprLog&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void cos_fwd(const ExprCos&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void sin_fwd(const ExprSin&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void tan_fwd(const ExprTan&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void cosh_fwd(const ExprCosh&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void sinh_fwd(const ExprSinh&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void tanh_fwd(const ExprTanh&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void acos_fwd(const ExprAcos&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void asin_fwd(const ExprAsin&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void atan_fwd(const ExprAtan&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void acosh_fwd(const ExprAcosh&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void asinh_fwd(const ExprAsinh&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void atanh_fwd(const ExprAtanh&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }

 inline void add_V_fwd(const ExprAdd&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->v().clear(); }
 inline void add_M_fwd(const ExprAdd&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->m().clear(); }
 inline void mul_SV_fwd(const ExprMul&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->v().clear(); }
 inline void mul_SM_fwd(const ExprMul&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->m().clear(); }
 inline void mul_VV_fwd(const ExprMul&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->i()=0; }
 inline void mul_MV_fwd(const ExprMul&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->v().clear(); }
 inline void mul_VM_fwd(const ExprMul&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->v().clear(); }
 inline void mul_MM_fwd(const ExprMul&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->m().clear(); }
 inline void sub_V_fwd(const ExprSub&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->v().clear(); }
 inline void sub_M_fwd(const ExprSub&, const ExprLabel&, const ExprLabel&, ExprLabel& y) { y.g->m().clear(); }


        void index_bwd (const ExprIndex&, ExprLabel& , const ExprLabel& ) { }
        void vector_bwd(const ExprVector&, ExprLabel** x, const ExprLabel& y);
 inline void symbol_bwd(const ExprSymbol&, const ExprLabel& ) { }
 inline void cst_bwd (const ExprConstant&, const ExprLabel& ) { }
        void apply_bwd (const ExprApply&, ExprLabel** x, const ExprLabel& y);
        void chi_bwd (const ExprChi&, ExprLabel& x1, ExprLabel& x2, ExprLabel& x3, const ExprLabel& y);
 inline void add_bwd (const ExprAdd&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { x1.g->i() += y.g->i(); x2.g->i() += y.g->i(); }
 inline void mul_bwd (const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { x1.g->i() += y.g->i() * x2.d->i(); x2.g->i() += y.g->i() * x1.d->i(); }
 inline void sub_bwd (const ExprSub&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { x1.g->i() += y.g->i(); x2.g->i() += -y.g->i(); }
 inline void div_bwd (const ExprDiv&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { x1.g->i() += y.g->i() / x2.d->i(); x2.g->i() += y.g->i()*(-x1.d->i())/sqr(x2.d->i()); }
        void max_bwd (const ExprMax&, ExprLabel& , ExprLabel& , const ExprLabel& );
        void min_bwd (const ExprMin&, ExprLabel& , ExprLabel& , const ExprLabel& );
        void atan2_bwd (const ExprAtan2& , ExprLabel& , ExprLabel& , const ExprLabel& );
 inline void minus_bwd (const ExprMinus& , ExprLabel& x, const ExprLabel& y) { x.g->i() += -1.0*y.g->i(); }
        inline void trans_V_bwd(const ExprTrans&, ExprLabel& , const ExprLabel& ) {
                                                                                                                      }
        inline void trans_M_bwd(const ExprTrans&, ExprLabel& x, const ExprLabel& y) { x.g->m() += y.g->m().transpose(); }
        void sign_bwd (const ExprSign&, ExprLabel& x, const ExprLabel& y);
        void abs_bwd (const ExprAbs&, ExprLabel& x, const ExprLabel& y);
 inline void power_bwd(const ExprPower& e, ExprLabel& x, const ExprLabel& y) { x.g->i() += y.g->i() * e.expon * pow(x.d->i(), e.expon-1); }
 inline void sqr_bwd (const ExprSqr& , ExprLabel& x, const ExprLabel& y) { x.g->i() += y.g->i() * 2.0 * x.d->i(); }
 inline void sqrt_bwd (const ExprSqrt& , ExprLabel& x, const ExprLabel& y) { x.g->i() += y.g->i() * 0.5 / sqrt(x.d->i()); }
 inline void exp_bwd (const ExprExp& , ExprLabel& x, const ExprLabel& y) { x.g->i() += y.g->i() * exp(x.d->i()); }
 inline void log_bwd (const ExprLog& , ExprLabel& x, const ExprLabel& y) { x.g->i() += y.g->i() / x.d->i(); }
 inline void cos_bwd (const ExprCos& , ExprLabel& x, const ExprLabel& y) { x.g->i() += y.g->i() * -sin(x.d->i()); }
 inline void sin_bwd (const ExprSin& , ExprLabel& x, const ExprLabel& y) { x.g->i() += y.g->i() * cos(x.d->i()); }
 inline void tan_bwd (const ExprTan& , ExprLabel& x, const ExprLabel& y) { x.g->i() += y.g->i() * (1.0 + sqr(tan(x.d->i()))); }
 inline void cosh_bwd (const ExprCosh& , ExprLabel& x, const ExprLabel& y) { x.g->i() += y.g->i() * sinh(x.d->i()); }
 inline void sinh_bwd (const ExprSinh& , ExprLabel& x, const ExprLabel& y) { x.g->i() += y.g->i() * cosh(x.d->i()); }
 inline void tanh_bwd (const ExprTanh& , ExprLabel& x, const ExprLabel& y) { x.g->i() += y.g->i() * (1.0 - sqr(tanh(x.d->i()))); }
 inline void acos_bwd (const ExprAcos& , ExprLabel& x, const ExprLabel& y) { x.g->i() += y.g->i() * -1.0 / sqrt(1.0-sqr(x.d->i())); }
 inline void asin_bwd (const ExprAsin& , ExprLabel& x, const ExprLabel& y) { x.g->i() += y.g->i() * 1.0 / sqrt(1.0-sqr(x.d->i())); }
 inline void atan_bwd (const ExprAtan& , ExprLabel& x, const ExprLabel& y) { x.g->i() += y.g->i() * 1.0 / (1.0+sqr(x.d->i())); }
 inline void acosh_bwd (const ExprAcosh& , ExprLabel& x, const ExprLabel& y) { x.g->i() += y.g->i() * 1.0 / sqrt(sqr(x.d->i()) -1.0); }
 inline void asinh_bwd (const ExprAsinh& , ExprLabel& x, const ExprLabel& y) { x.g->i() += y.g->i() * 1.0 / sqrt(1.0+sqr(x.d->i())); }
 inline void atanh_bwd (const ExprAtanh& , ExprLabel& x, const ExprLabel& y) { x.g->i() += y.g->i() * 1.0 / (1.0-sqr(x.d->i())); }

 inline void add_V_bwd (const ExprAdd&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { x1.g->v() += y.g->v(); x2.g->v() += y.g->v(); }
 inline void add_M_bwd (const ExprAdd&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { x1.g->m() += y.g->m(); x2.g->m() += y.g->m(); }
 inline void mul_SV_bwd(const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { x1.g->i() += y.g->v()*x2.d->v(); x2.g->v() += x1.d->i()*y.g->v(); }
 inline void mul_SM_bwd(const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { for (int i=0; i<y.d->m().nb_rows(); i++) x1.g->i()+=y.g->m()[i]*x2.d->m()[i]; x2.g->m() += x1.d->i()*y.g->m(); }
 inline void mul_VV_bwd(const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { x1.g->v() += y.g->i()*x2.d->v(); x2.g->v() += y.g->i()*x1.d->v(); }
 inline void mul_MV_bwd(const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { x1.g->m() += outer_product(y.g->v(),x2.d->v()); x2.g->v() += x1.d->m().transpose()*y.g->v(); }
 inline void mul_MM_bwd(const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { x1.g->m() += y.g->m()*x2.d->m().transpose(); x2.g->m() += x1.d->m().transpose()*y.g->m(); }
 inline void mul_VM_bwd(const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { x1.g->v() += x2.d->m()*y.g->v(); x2.g->m() += outer_product(x1.d->v(),y.g->v()); }
 inline void sub_V_bwd (const ExprSub&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { x1.g->v() += y.g->v(); x2.g->v() -= y.g->v(); }
 inline void sub_M_bwd (const ExprSub&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { x1.g->m() += y.g->m(); x2.g->m() -= y.g->m(); }
};

}
# 66 "/usr/local/include/ibex/ibex.h" 2 3

# 1 "/usr/local/include/ibex/ibex_InHC4Revise.h" 1 3
# 18 "/usr/local/include/ibex/ibex_InHC4Revise.h" 3
namespace ibex {

class InHC4Revise : public BwdAlgorithm {
public:
 void ibwd(const Function& f, const Domain& y, IntervalVector& x);

 void ibwd(const Function& f, const Domain& y, IntervalVector& x, const IntervalVector& xin);

protected:




 class EmptyBoxException { };

public:
 inline void index_bwd (const ExprIndex&, ExprLabel& , const ExprLabel& ) { }
 void vector_bwd(const ExprVector&, ExprLabel** , const ExprLabel& ) { not_implemented("Inner projection of \"vector\""); }

 inline void symbol_bwd(const ExprSymbol& , const ExprLabel& ) { }
 inline void cst_bwd (const ExprConstant& c, const ExprLabel& y) { if (*(y.d)!=c.get()) throw EmptyBoxException(); }
 inline void apply_bwd (const ExprApply& a, ExprLabel** x, const ExprLabel& y) { if (!ibwd(a.func, *y.d, x)) throw EmptyBoxException(); }
 inline void chi_bwd (const ExprChi&,ExprLabel& ,ExprLabel& ,ExprLabel& ,const ExprLabel& ) { not_implemented("Inner projection of \"chi\""); }
 inline void add_bwd (const ExprAdd&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!ibwd_add(y.d->i(),x1.d->i(),x2.d->i(),x1.p->i(),x2.p->i())) throw EmptyBoxException(); }
 inline void add_V_bwd (const ExprAdd&, ExprLabel& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"add_V\""); }
 inline void add_M_bwd (const ExprAdd&, ExprLabel& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"add_M\""); }
 inline void mul_bwd (const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!ibwd_mul(y.d->i(),x1.d->i(),x2.d->i(),x1.p->i(),x2.p->i())) throw EmptyBoxException(); }
 inline void mul_SV_bwd(const ExprMul&, ExprLabel& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"mul_SV\""); }
 inline void mul_SM_bwd(const ExprMul&, ExprLabel& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"mul_SM\""); }
 inline void mul_VV_bwd(const ExprMul&, ExprLabel& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"mul_VV\""); }
 inline void mul_MV_bwd(const ExprMul&, ExprLabel& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"mul_MV\""); }
 inline void mul_VM_bwd(const ExprMul&, ExprLabel& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"mul_VM\""); }
 inline void mul_MM_bwd(const ExprMul&, ExprLabel& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"mul_MM\""); }
 inline void sub_bwd (const ExprSub&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!ibwd_sub(y.d->i(),x1.d->i(),x2.d->i(),x1.p->i(),x2.p->i())) throw EmptyBoxException(); }
 inline void sub_V_bwd (const ExprSub&, ExprLabel& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"sub_V\""); }
 inline void sub_M_bwd (const ExprSub&, ExprLabel& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"sub_M\""); }
 inline void div_bwd (const ExprDiv&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!ibwd_div(y.d->i(),x1.d->i(),x2.d->i(),x1.p->i(),x2.p->i())) throw EmptyBoxException(); }
 inline void max_bwd (const ExprMax&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!ibwd_max(y.d->i(),x1.d->i(),x2.d->i(),x1.p->i(),x2.p->i())) throw EmptyBoxException(); }
 inline void min_bwd (const ExprMin&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) { if (!ibwd_min(y.d->i(),x1.d->i(),x2.d->i(),x1.p->i(),x2.p->i())) throw EmptyBoxException(); }
 inline void atan2_bwd (const ExprAtan2&, ExprLabel& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"atan2\""); }
 inline void minus_bwd (const ExprMinus& , ExprLabel& x, const ExprLabel& y) { if (!ibwd_minus(y.d->i(),x.d->i())) throw EmptyBoxException(); }
    inline void trans_V_bwd(const ExprTrans& ,ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"transpose\""); }
    inline void trans_M_bwd(const ExprTrans& ,ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"transpose\""); }
 inline void sign_bwd (const ExprSign& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"sign\""); }
 inline void abs_bwd (const ExprAbs& , ExprLabel& x, const ExprLabel& y) { if (!ibwd_abs(y.d->i(),x.d->i())) throw EmptyBoxException(); }
 inline void power_bwd (const ExprPower& e, ExprLabel& x, const ExprLabel& y) { if (!ibwd_pow(y.d->i(),x.d->i(),e.expon, x.p->i())) throw EmptyBoxException(); }
 inline void sqr_bwd (const ExprSqr& , ExprLabel& x, const ExprLabel& y) { if (!ibwd_sqr(y.d->i(),x.d->i(),x.p->i())) throw EmptyBoxException(); }
 inline void sqrt_bwd (const ExprSqrt& , ExprLabel& x, const ExprLabel& y) { if (!ibwd_sqrt(y.d->i(),x.d->i())) throw EmptyBoxException(); }
 inline void exp_bwd (const ExprExp& , ExprLabel& x, const ExprLabel& y) { if (!ibwd_exp(y.d->i(),x.d->i())) throw EmptyBoxException(); }
 inline void log_bwd (const ExprLog& , ExprLabel& x, const ExprLabel& y) { if (!ibwd_log(y.d->i(),x.d->i())) throw EmptyBoxException(); }
 inline void cos_bwd (const ExprCos& , ExprLabel& x, const ExprLabel& y) { if (!ibwd_cos(y.d->i(),x.d->i(),x.p->i())) throw EmptyBoxException(); }
 inline void sin_bwd (const ExprSin& , ExprLabel& x, const ExprLabel& y) { if (!ibwd_sin(y.d->i(),x.d->i(),x.p->i())) throw EmptyBoxException();}
 inline void tan_bwd (const ExprTan& , ExprLabel& x, const ExprLabel& y) { if (!ibwd_tan(y.d->i(),x.d->i(),x.p->i())) throw EmptyBoxException(); }
 inline void cosh_bwd (const ExprCosh& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"cosh\""); }
 inline void sinh_bwd (const ExprSinh& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"sinh\""); }
 inline void tanh_bwd (const ExprTanh& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"tanh\""); }
 inline void acos_bwd (const ExprAcos& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"acos\""); }
 inline void asin_bwd (const ExprAsin& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"asin\""); }
 inline void atan_bwd (const ExprAtan& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"atan\""); }
 inline void acosh_bwd (const ExprAcosh& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"acosh\""); }
 inline void asinh_bwd (const ExprAsinh& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"asinh\""); }
 inline void atanh_bwd (const ExprAtanh& , ExprLabel& , const ExprLabel& ) { not_implemented("Inner projection of \"atanh\""); }

protected:
 bool ibwd(const Function& f, const Domain& y, ExprLabel** x);
};

}
# 68 "/usr/local/include/ibex/ibex.h" 2 3


# 1 "/usr/local/include/ibex/ibex_univ_taylor_aff.h" 1 3
# 28 "/usr/local/include/ibex/ibex_univ_taylor_aff.h" 3
using namespace std;

namespace ibex{

class Univ_Taylor_Aff : public FwdAlgorithm, public BwdAlgorithm
{
private:



    unsigned int _max_order;




    const ExprSymbol * _t;

public:






    Univ_Taylor_Aff(unsigned int max_order, const ExprSymbol * t){
 _max_order = max_order;
        _t = t;
    }

    virtual ~Univ_Taylor_Aff() {};

    inline const ExprSymbol * get_symbol() {
        return _t;
    }

    inline unsigned int get_max_order() {
        return _max_order;
    }
    inline void set_max_order(unsigned int max_order) {
        _max_order = max_order;
    }




    void compute_taylor_aff(const Function& f, std::vector<Affine2Domain>& taylor_comps);

    void print_taylor_comps(std::vector<Affine2Domain> *);







    inline void index_fwd(const ExprIndex&, const ExprLabel& x, ExprLabel& y);

    void vector_fwd(const ExprVector&, const ExprLabel** compL, ExprLabel& y) {
      cout << __func__ << endl;
    }




    inline void cst_fwd(const ExprConstant&, ExprLabel& y);



    inline void symbol_fwd(const ExprSymbol&, ExprLabel& y);

    inline void apply_fwd(const ExprApply&, ExprLabel** x, ExprLabel& y);
    inline void chi_fwd(const ExprChi&, const ExprLabel& x1, const ExprLabel& x2, const ExprLabel& x3, ExprLabel& y);




    inline void add_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);




    inline void mul_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);




    inline void sub_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
    inline void div_fwd(const ExprDiv&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
    inline void max_fwd(const ExprMax&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
    inline void min_fwd(const ExprMin&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
    inline void atan2_fwd(const ExprAtan2&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
    inline void minus_fwd(const ExprMinus&, const ExprLabel& x, ExprLabel& y);
    inline void trans_V_fwd(const ExprTrans&, const ExprLabel& x, ExprLabel& y);
    inline void trans_M_fwd(const ExprTrans&, const ExprLabel& x, ExprLabel& y);
    inline void sign_fwd(const ExprSign&, const ExprLabel& x, ExprLabel& y);
    inline void abs_fwd(const ExprAbs&, const ExprLabel& x, ExprLabel& y);
    inline void power_fwd(const ExprPower& p, const ExprLabel& x, ExprLabel& y);
    inline void sqr_fwd(const ExprSqr&, const ExprLabel& x, ExprLabel& y);
    inline void sqrt_fwd(const ExprSqrt&, const ExprLabel& x, ExprLabel& y);
    inline void exp_fwd(const ExprExp&, const ExprLabel& x, ExprLabel& y);
    inline void log_fwd(const ExprLog&, const ExprLabel& x, ExprLabel& y);
    inline void cos_fwd(const ExprCos&, const ExprLabel& x, ExprLabel& y);
    inline void sin_fwd(const ExprSin&, const ExprLabel& x, ExprLabel& y);
    inline void tan_fwd(const ExprTan&, const ExprLabel& x, ExprLabel& y);
    inline void cosh_fwd(const ExprCosh&, const ExprLabel& x, ExprLabel& y);
    inline void sinh_fwd(const ExprSinh&, const ExprLabel& x, ExprLabel& y);
    inline void tanh_fwd(const ExprTanh&, const ExprLabel& x, ExprLabel& y);
    inline void acos_fwd(const ExprAcos&, const ExprLabel& x, ExprLabel& y);
    inline void asin_fwd(const ExprAsin&, const ExprLabel& x, ExprLabel& y);
    inline void atan_fwd(const ExprAtan&, const ExprLabel& x, ExprLabel& y);
    inline void acosh_fwd(const ExprAcosh&, const ExprLabel& x, ExprLabel& y);
    inline void asinh_fwd(const ExprAsinh&, const ExprLabel& x, ExprLabel& y);
    inline void atanh_fwd(const ExprAtanh&, const ExprLabel& x, ExprLabel& y);




    inline void add_V_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
    inline void add_M_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
    inline void mul_SV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
    inline void mul_SM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
    inline void mul_VV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
    inline void mul_MV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
    inline void mul_VM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
    inline void mul_MM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
    inline void sub_V_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);
    inline void sub_M_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y);


            void index_bwd (const ExprIndex&, ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear();x.taylor_comps_aff->clear(); }
        void vector_bwd(const ExprVector& v, ExprLabel** compL, const ExprLabel& y){
   y.taylor_comps_aff->clear();
   for (int i = 0; i<v.length(); i++)
     compL[i]->taylor_comps_aff->clear();
       }
 inline void symbol_bwd(const ExprSymbol& x, const ExprLabel& y){y.taylor_comps_aff->clear();}
 inline void cst_bwd (const ExprConstant&, const ExprLabel& y){y.taylor_comps_aff->clear(); }
        void apply_bwd (const ExprApply& a, ExprLabel** x, const ExprLabel& y){
   y.taylor_comps_aff->clear();
   for (int i = 0; i < a.nb_args; i++)
     x[i]->taylor_comps_aff->clear();

       }
        void chi_bwd (const ExprChi&, ExprLabel& x1, ExprLabel& x2, ExprLabel& x3, const ExprLabel& y){y.taylor_comps_aff->clear();x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear();x3.taylor_comps_aff->clear(); }
 inline void add_bwd (const ExprAdd&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) {y.taylor_comps_aff->clear();x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear(); }
 inline void mul_bwd (const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) {y.taylor_comps_aff->clear();x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear(); }
 inline void sub_bwd (const ExprSub&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) {y.taylor_comps_aff->clear();x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear(); }
 inline void div_bwd (const ExprDiv&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) {y.taylor_comps_aff->clear();x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear(); }
        void max_bwd (const ExprMax&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y){y.taylor_comps_aff->clear();x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear(); }
        void min_bwd (const ExprMin&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y){y.taylor_comps_aff->clear();x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear(); }
        void atan2_bwd (const ExprAtan2& , ExprLabel& x1, ExprLabel& x2, const ExprLabel& y){y.taylor_comps_aff->clear();x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear(); }
 inline void minus_bwd (const ExprMinus& , ExprLabel& x, const ExprLabel& y){y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
        inline void trans_V_bwd(const ExprTrans&, ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
        inline void trans_M_bwd(const ExprTrans&, ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
        void sign_bwd (const ExprSign&, ExprLabel& x, const ExprLabel& y){y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
        void abs_bwd (const ExprAbs&, ExprLabel& x, const ExprLabel& y){y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
 inline void power_bwd(const ExprPower& e, ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
 inline void sqr_bwd (const ExprSqr& , ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
 inline void sqrt_bwd (const ExprSqrt& , ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
 inline void exp_bwd (const ExprExp& , ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
 inline void log_bwd (const ExprLog& , ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
 inline void cos_bwd (const ExprCos& , ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
 inline void sin_bwd (const ExprSin& , ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
 inline void tan_bwd (const ExprTan& , ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
 inline void cosh_bwd (const ExprCosh& , ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
 inline void sinh_bwd (const ExprSinh& , ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
 inline void tanh_bwd (const ExprTanh& , ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
 inline void acos_bwd (const ExprAcos& , ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
 inline void asin_bwd (const ExprAsin& , ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
 inline void atan_bwd (const ExprAtan& , ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
 inline void acosh_bwd (const ExprAcosh& , ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
 inline void asinh_bwd (const ExprAsinh& , ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}
 inline void atanh_bwd (const ExprAtanh& , ExprLabel& x, const ExprLabel& y) {y.taylor_comps_aff->clear(); x.taylor_comps_aff->clear();}

 inline void add_V_bwd (const ExprAdd&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) {y.taylor_comps_aff->clear(); x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear();}
 inline void add_M_bwd (const ExprAdd&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) {y.taylor_comps_aff->clear(); x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear();}
 inline void mul_SV_bwd(const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) {y.taylor_comps_aff->clear(); x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear();}
 inline void mul_SM_bwd(const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) {y.taylor_comps_aff->clear(); x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear();}
 inline void mul_VV_bwd(const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) {y.taylor_comps_aff->clear(); x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear();}
 inline void mul_MV_bwd(const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) {y.taylor_comps_aff->clear(); x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear();}
 inline void mul_MM_bwd(const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) {y.taylor_comps_aff->clear(); x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear();}
 inline void mul_VM_bwd(const ExprMul&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) {y.taylor_comps_aff->clear(); x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear();}
 inline void sub_V_bwd (const ExprSub&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) {y.taylor_comps_aff->clear(); x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear();}
 inline void sub_M_bwd (const ExprSub&, ExprLabel& x1, ExprLabel& x2, const ExprLabel& y) {y.taylor_comps_aff->clear(); x1.taylor_comps_aff->clear();x2.taylor_comps_aff->clear();}


};

inline void Univ_Taylor_Aff::index_fwd(const ExprIndex& ind, const ExprLabel& x, ExprLabel& y) {






    int index = ind.index;
    unsigned int i;
    if (x.af2->dim.is_scalar())
        y.af2->i() = x.af2->i();
    else
        y.af2->i() = x.af2->v().operator[](index);
    for (i = 0; i < x.taylor_comps_aff->size(); i++) {
        Affine2Domain af2(Dim::scalar());
        if (x.taylor_comps_aff->operator[](i).dim.is_scalar())
            af2.i() = x.taylor_comps_aff->operator[](i).i();
        else
            af2.i() = x.taylor_comps_aff->operator[](i).v()[index];
        y.taylor_comps_aff->push_back(af2);
    }






}


inline void Univ_Taylor_Aff::cst_fwd(const ExprConstant& c, ExprLabel& y) {
# 260 "/usr/local/include/ibex/ibex_univ_taylor_aff.h" 3
    if (y.taylor_comps_aff->size() == 0) {
        y.taylor_comps_aff->push_back(*c.deco.af2);
        if (c.deco.taylor_comps_aff) {
            for (unsigned int i = 1; i < c.deco.taylor_comps_aff->size(); i++) {
                y.taylor_comps_aff->push_back(c.deco.taylor_comps_aff->operator[](i));
            }
        }
    }
# 276 "/usr/local/include/ibex/ibex_univ_taylor_aff.h" 3
}

inline void Univ_Taylor_Aff::symbol_fwd(const ExprSymbol& x, ExprLabel& y) {






    if (y.taylor_comps_aff->size() == 0) {
        y.taylor_comps_aff->push_back(*x.deco.af2);
        if (strcmp(_t->name,x.name)==0) {
            Affine2Domain af2(x.deco.af2->dim);
            if (af2.dim.is_scalar())
                af2.i() = 1;
            else
                af2.v().init(1.0);
            y.taylor_comps_aff->push_back(af2);
        }
    }







}


inline void Univ_Taylor_Aff::apply_fwd(const ExprApply&appl, ExprLabel** x, ExprLabel& y) {





    for (int j = 0; j < appl.nb_args; j++) {
        for (unsigned int i = 0; i < x[j]->taylor_comps_aff->size(); i++) {
            Affine2Domain af2(x[j]->taylor_comps_aff->operator[](i).dim);
            if (af2.dim.is_scalar())
                af2.i() = x[j]->taylor_comps_aff->operator[](i).i();
            else
                af2.v() = x[j]->taylor_comps_aff->operator[](i).v();
            appl.func.args()[j].deco.taylor_comps_aff->push_back(af2);
        }
    }

    compute_taylor_aff(appl.func, *y.taylor_comps_aff);






}

inline void Univ_Taylor_Aff::chi_fwd(const ExprChi&, const ExprLabel& x1, const ExprLabel& x2, const ExprLabel& x3, ExprLabel& y) {
    cerr << __func__ << endl;
}


inline void Univ_Taylor_Aff::add_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {





    unsigned int i = 0;
    while (i < x1.taylor_comps_aff->size() && i < x2.taylor_comps_aff->size()) {
        Affine2Domain af2(x2.af2->dim);
        af2.i() = x1.taylor_comps_aff->operator[](i).i() + x2.taylor_comps_aff->operator[](i).i();
        y.taylor_comps_aff->push_back(af2);
 i++;

    }
    while (i < x1.taylor_comps_aff->size()) {
        Affine2Domain af2(x1.af2->dim);
        af2.i() = 0;
        af2.i() = x1.taylor_comps_aff->operator[](i).i();
        y.taylor_comps_aff->push_back(af2);
 i++;
    }
    while (i < x2.taylor_comps_aff->size()) {
        Affine2Domain af2(x2.af2->dim);
        af2.i()=0;
        af2.i() = x2.taylor_comps_aff->operator[](i).i();
        y.taylor_comps_aff->push_back(af2);
        i++;
    }






}


inline void Univ_Taylor_Aff::mul_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
# 386 "/usr/local/include/ibex/ibex_univ_taylor_aff.h" 3
    Affine2Domain y0(x2.af2->dim);
    y0.i() = x1.taylor_comps_aff->operator[](0).i()*x2.taylor_comps_aff->operator[](0).i();
    y.taylor_comps_aff->push_back(y0);

    unsigned int k = 1;
    while (k <= _max_order && k < (x1.taylor_comps_aff->size() + x2.taylor_comps_aff->size() - 1)) {

        Affine2Domain yk(x2.af2->dim);
        yk.i()= 0;
        unsigned int j = 0;
        while(j <= k && j < x1.taylor_comps_aff->size()) {

            if (k-j < x2.taylor_comps_aff->size()) {
                yk.i() += x1.taylor_comps_aff->operator[](j).i()*x2.taylor_comps_aff->operator[](k-j).i();
            } else {
     }
            j++;
        }
        y.taylor_comps_aff->push_back(yk);
        k++;
    }





}


inline void Univ_Taylor_Aff::sub_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {





    unsigned int i = 0;
    while (i < x1.taylor_comps_aff->size() && i < x2.taylor_comps_aff->size()) {
        Affine2Domain af2(x2.af2->dim);
        af2.i() = x1.taylor_comps_aff->operator[](i).i() - x2.taylor_comps_aff->operator[](i).i();
        y.taylor_comps_aff->push_back(af2);
 i++;
    }
    while (i < x1.taylor_comps_aff->size()) {
        Affine2Domain af2(x1.af2->dim);
        af2.i() = x1.taylor_comps_aff->operator[](i).i();
        y.taylor_comps_aff->push_back(af2);
        i++;
    }
    while (i < x2.taylor_comps_aff->size()) {
        Affine2Domain af2(x2.af2->dim);
        af2.i()=0;
        af2.i() = - x2.taylor_comps_aff->operator[](i).i();
        y.taylor_comps_aff->push_back(af2);
        i++;
    }





}

inline void Univ_Taylor_Aff::div_fwd(const ExprDiv&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {






    Affine2Domain y0(x1.af2->dim);
    y0.i() = x1.taylor_comps_aff->operator[](0).i() / x2.taylor_comps_aff->operator[](0).i();
    y.taylor_comps_aff->push_back(y0);
    unsigned int k = 1;
    Affine2Domain coeff(y0.dim);
    coeff.i() = 1.0 / ( x2.taylor_comps_aff->operator[](0).i() );

    while (k <= _max_order) {
        Affine2Domain yk(x1.af2->dim);
        yk.i() = coeff.i();
        Affine2Domain accu(x1.af2->dim);
        accu.i() = 0;
        unsigned int j;
        for (j = 0; j < k; j++) {
            if ((k-j) < x2.taylor_comps_aff->size()) {
                accu.i() += y.taylor_comps_aff->operator[](j).i()*x2.taylor_comps_aff->operator[](k-j).i();
            }
        }
        if (k < x1.taylor_comps_aff->size()) {
            yk.i() *= (x1.taylor_comps_aff->operator[](k).i() - accu.i());
        } else {
            yk.i() *= 0.0 - accu.i();
        }
        y.taylor_comps_aff->push_back(yk);
 k++;
    }






}

inline void Univ_Taylor_Aff::minus_fwd(const ExprMinus&, const ExprLabel& x, ExprLabel& y) {





    unsigned int i = 0;
    while (i < x.taylor_comps_aff->size()) {
        Affine2Domain af2(x.af2->dim);
        af2.i() = - x.taylor_comps_aff->operator[](i).i();
        y.taylor_comps_aff->push_back(af2);
        i++;
    }





}


inline void Univ_Taylor_Aff::power_fwd(const ExprPower& p, const ExprLabel& x, ExprLabel& y) {






    Affine2Domain y0(x.af2->dim);
    y0.i() = 1;
    for (int i = 0; i < p.expon; i++) y0.i() *= x.taylor_comps_aff->operator[](0).i();
    y.taylor_comps_aff->push_back(y0);
    Affine2Domain coeff(y0.dim);
    coeff.i() = 1.0 / ( x.taylor_comps_aff->operator[](0).i() );
    unsigned int k = 1;

    while (k <= _max_order) {
        Affine2Domain yk(x.af2->dim);
        yk.i() = coeff.i();
        Affine2Domain accu1(x.af2->dim);
        accu1.i() = 0;
        unsigned int j;
        for (j = 1; j <= k && j < x.taylor_comps_aff->size() ; j++) {
            accu1.i() += y.taylor_comps_aff->operator[](k-j).i() * j * x.taylor_comps_aff->operator[](j).i();
        }
        accu1.i() *= p.expon;

        for (j = 1; j < k ; j++) {
            if (k-j < x.taylor_comps_aff->size())
                accu1.i() -= x.taylor_comps_aff->operator[](k-j).i() * j * y.taylor_comps_aff->operator[](j).i();
        }
        yk.i() *= accu1.i();
        yk.i() = yk.i() / k;
        y.taylor_comps_aff->push_back(yk);
 k++;
    }





}

inline void Univ_Taylor_Aff::sqr_fwd(const ExprSqr&, const ExprLabel& x, ExprLabel& y) {






    Affine2Domain y0(x.af2->dim);
    y0.i() = sqr(x.taylor_comps_aff->operator[](0).i());
    y.taylor_comps_aff->push_back(y0);
    unsigned int k = 1;
    while (k <= _max_order && k < (2*x.taylor_comps_aff->size() - 1)) {

        Affine2Domain yk(x.af2->dim);
        yk.i()= 0;
        unsigned int j = 0;
        while(j <= k && j < x.taylor_comps_aff->size()) {
            if (k-j < x.taylor_comps_aff->size()) {
                yk.i() += x.taylor_comps_aff->operator[](j).i()*x.taylor_comps_aff->operator[](k-j).i();
            }
            j++;
        }
        y.taylor_comps_aff->push_back(yk);
        k++;
    }





}

inline void Univ_Taylor_Aff::sqrt_fwd(const ExprSqrt&, const ExprLabel& x, ExprLabel& y) {





    Affine2Domain y0(x.af2->dim);
    y0.i() = sqrt(x.taylor_comps_aff->operator[](0).i());
    y.taylor_comps_aff->push_back(y0);

    unsigned int k = 1;
    Affine2Domain coeff(y0.dim);
    coeff.i() = 1.0 / ( 2 * y0.i() );
    while (k <= _max_order) {
        Affine2Domain yk(x.af2->dim);
        yk.i() = coeff.i();
        Affine2Domain accu(x.af2->dim);
        accu.i() = 0;
        unsigned int j;
        if (k > 1) {
            for (j = 1; j < k; j++) {
                accu.i() += y.taylor_comps_aff->operator[](j).i()*y.taylor_comps_aff->operator[](k-j).i();
            }
        }
        if (k < x.taylor_comps_aff->size()) {
            yk.i() *= x.taylor_comps_aff->operator[](k).i() - accu.i();
        } else {
            yk.i() *= 0.0 - accu.i();
        }
        y.taylor_comps_aff->push_back(yk);
 k++;
    }





}

inline void Univ_Taylor_Aff::exp_fwd(const ExprExp&, const ExprLabel& x, ExprLabel& y) {






    Affine2Domain y0(x.af2->dim);
    y0.i() = exp(x.taylor_comps_aff->operator[](0).i());
    y.taylor_comps_aff->push_back(y0);
    unsigned int k = 1;
    while (k <= _max_order) {
        Affine2Domain yk(x.af2->dim);
        yk.i() = 0;
        unsigned int j;
        for (j = 1; j <= k && j < x.taylor_comps_aff->size() ; j++) {
            yk.i() += y.taylor_comps_aff->operator[](k-j).i() * j * x.taylor_comps_aff->operator[](j).i();
        }
        yk.i() = yk.i() / k;
        y.taylor_comps_aff->push_back(yk);
        k++;
    }





}

inline void Univ_Taylor_Aff::log_fwd(const ExprLog&, const ExprLabel& x, ExprLabel& y) {






    Affine2Domain y0(x.af2->dim);
    y0.i() = log(x.taylor_comps_aff->operator[](0).i());
    y.taylor_comps_aff->push_back(y0);



    Affine2Domain coeff(y0.dim);
    coeff.i() = 1.0 / ( x.taylor_comps_aff->operator[](0).i() );

    unsigned int k = 1;
    while (k <= _max_order) {
        Affine2Domain yk(x.af2->dim);
        yk.i() = coeff.i();


        Affine2Domain accu(x.af2->dim);
        accu.i() = 0;
        unsigned int j;
        for (j = 1; j < k ; j++) {
            if (k-j < x.taylor_comps_aff->size())
                accu.i() += x.taylor_comps_aff->operator[](k-j).i() * j * y.taylor_comps_aff->operator[](j).i();
        }
        if (k < x.taylor_comps_aff->size()) {
            yk.i() *= (k*x.taylor_comps_aff->operator[](k).i() - accu.i())/j;
        } else {
            yk.i() *= (0.0 - accu.i())/j;
        }
        y.taylor_comps_aff->push_back(yk);
 k++;
    }






}

inline void Univ_Taylor_Aff::cos_fwd(const ExprCos&, const ExprLabel& x, ExprLabel& y) {





    std::vector<Affine2Domain> sin_tayl;
    Affine2Domain s0(x.af2->dim);
    s0.i() = sin(x.taylor_comps_aff->operator[](0).i());
    sin_tayl.push_back(s0);
    Affine2Domain c0(x.af2->dim);
    c0.i() = cos(x.taylor_comps_aff->operator[](0).i());
    y.taylor_comps_aff->push_back(c0);
    for (unsigned int k = 1; k <= _max_order; k++) {
        unsigned int j;
        Affine2Domain ck(x.af2->dim);
        ck.i() = 0;
        for (j = 1; j <= k && j < x.taylor_comps_aff->size(); j++) {
            ck.i() -= j * x.taylor_comps_aff->operator[](j).i() * sin_tayl[k-j].i();
        }
        ck.i() = ck.i() / k;
        y.taylor_comps_aff->push_back(ck);
        Affine2Domain sk(x.af2->dim);
        sk.i() = 0;
        for (j = 1; j <= k && j < x.taylor_comps_aff->size(); j++) {
            sk.i() += j * x.taylor_comps_aff->operator[](j).i() * y.taylor_comps_aff->operator[](k-j).i();
        }
        sk.i() = sk.i() / k;
        sin_tayl.push_back(sk);
    }






}


inline void Univ_Taylor_Aff::sin_fwd(const ExprSin&, const ExprLabel& x, ExprLabel& y) {





    std::vector<Affine2Domain> cos_tayl;
    Affine2Domain s0(x.af2->dim);
    s0.i() = sin(x.taylor_comps_aff->operator[](0).i());
    y.taylor_comps_aff->push_back(s0);
    Affine2Domain c0(x.af2->dim);
    c0.i() = cos(x.taylor_comps_aff->operator[](0).i());
    cos_tayl.push_back(c0);
    for (unsigned int k = 1; k <= _max_order; k++) {
        unsigned int j;
        Affine2Domain ck(x.af2->dim);
        ck.i() = 0;
        for (j = 1; j <= k && j < x.taylor_comps_aff->size(); j++) {
            ck.i() -= j * x.taylor_comps_aff->operator[](j).i() * y.taylor_comps_aff->operator[](k-j).i();
        }
        ck.i() = ck.i() / k;
        cos_tayl.push_back(ck);
        Affine2Domain sk(x.af2->dim);
        sk.i() = 0;
        for (j = 1; j <= k && j < x.taylor_comps_aff->size(); j++) {
            sk.i() += j * x.taylor_comps_aff->operator[](j).i() * cos_tayl[k-j].i();
        }
        sk.i() = sk.i() / k;
        y.taylor_comps_aff->push_back(sk);
    }






}

inline void Univ_Taylor_Aff::add_V_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {





    unsigned int i = 0;
    while (i < x1.taylor_comps_aff->size() && i < x2.taylor_comps_aff->size()) {
        Affine2Domain af2(x2.af2->dim);
        af2.v() = x1.taylor_comps_aff->operator[](i).v() + x2.taylor_comps_aff->operator[](i).v();
        y.taylor_comps_aff->push_back(af2);
        i++;
    }
    while (i < x1.taylor_comps_aff->size()) {
        Affine2Domain af2(x1.af2->dim);
        af2.v() = x1.taylor_comps_aff->operator[](i).v();
        y.taylor_comps_aff->push_back(af2);
        i++;

    }
    while (i < x2.taylor_comps_aff->size()) {
        Affine2Domain af2(x2.af2->dim);
        af2.v().clear();
        af2.v() = x2.taylor_comps_aff->operator[](i).v();
        y.taylor_comps_aff->push_back(af2);
        i++;
    }






}

inline void Univ_Taylor_Aff::add_M_fwd(const ExprAdd&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
    cerr << __func__ << endl;
}

inline void Univ_Taylor_Aff::mul_SV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
# 822 "/usr/local/include/ibex/ibex_univ_taylor_aff.h" 3
    Affine2Domain y0(x2.af2->dim);
    y0.v() = x1.taylor_comps_aff->operator[](0).i()*x2.taylor_comps_aff->operator[](0).v();
    y.taylor_comps_aff->push_back(y0);
    unsigned int k = 1;
    while (k <= _max_order && k < (x1.taylor_comps_aff->size() + x2.taylor_comps_aff->size() - 1)) {

        Affine2Domain yk(x2.af2->dim);
        yk.v().clear();
        unsigned int j = 0;
        while(j <= k && j < x1.taylor_comps_aff->size()) {
     if (k-j < x2.taylor_comps_aff->size()) {
         yk.v() += x1.taylor_comps_aff->operator[](j).i()*x2.taylor_comps_aff->operator[](k-j).v();
            }
            j++;
        }
        y.taylor_comps_aff->push_back(yk);
        k++;
    }





}

inline void Univ_Taylor_Aff::max_fwd(const ExprMax&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
    cerr << __func__ << endl;
}
inline void Univ_Taylor_Aff::min_fwd(const ExprMin&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
    cerr << __func__ << endl;
}
inline void Univ_Taylor_Aff::atan2_fwd(const ExprAtan2&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
    cerr << __func__ << endl;
}

inline void Univ_Taylor_Aff::trans_V_fwd(const ExprTrans&, const ExprLabel& x, ExprLabel& y) {
    cerr << __func__ << endl;
}
inline void Univ_Taylor_Aff::trans_M_fwd(const ExprTrans&, const ExprLabel& x, ExprLabel& y) {
    cerr << __func__ << endl;
}
inline void Univ_Taylor_Aff::sign_fwd(const ExprSign&, const ExprLabel& x, ExprLabel& y) {
    cerr << __func__ << endl;
}
inline void Univ_Taylor_Aff::abs_fwd(const ExprAbs&, const ExprLabel& x, ExprLabel& y) {
    cerr << __func__ << endl;
}

inline void Univ_Taylor_Aff::tan_fwd(const ExprTan&, const ExprLabel& x, ExprLabel& y) {
    cerr << __func__ << endl;
}
inline void Univ_Taylor_Aff::cosh_fwd(const ExprCosh&, const ExprLabel& x, ExprLabel& y) {
    cerr << __func__ << endl;
}
inline void Univ_Taylor_Aff::sinh_fwd(const ExprSinh&, const ExprLabel& x, ExprLabel& y) {
    cerr << __func__ << endl;
}
inline void Univ_Taylor_Aff::tanh_fwd(const ExprTanh&, const ExprLabel& x, ExprLabel& y) {
    cerr << __func__ << endl;
}
inline void Univ_Taylor_Aff::acos_fwd(const ExprAcos&, const ExprLabel& x, ExprLabel& y) {
    cerr << __func__ << endl;
}
inline void Univ_Taylor_Aff::asin_fwd(const ExprAsin&, const ExprLabel& x, ExprLabel& y) {
    cerr << __func__ << endl;
}
inline void Univ_Taylor_Aff::atan_fwd(const ExprAtan&, const ExprLabel& x, ExprLabel& y) {
    cerr << __func__ << endl;
}
inline void Univ_Taylor_Aff::acosh_fwd(const ExprAcosh&, const ExprLabel& x, ExprLabel& y) {
    cerr << __func__ << endl;
}
inline void Univ_Taylor_Aff::asinh_fwd(const ExprAsinh&, const ExprLabel& x, ExprLabel& y) {
    cerr << __func__ << endl;
}
inline void Univ_Taylor_Aff::atanh_fwd(const ExprAtanh&, const ExprLabel& x, ExprLabel& y) {
    cerr << __func__ << endl;
}

inline void Univ_Taylor_Aff::mul_SM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
    cout << __func__ << endl;
}
inline void Univ_Taylor_Aff::mul_VV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
    cout << __func__ << endl;
}
inline void Univ_Taylor_Aff::mul_MV_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
    cout << __func__ << endl;
}
inline void Univ_Taylor_Aff::mul_VM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
    cout << __func__ << endl;
}
inline void Univ_Taylor_Aff::mul_MM_fwd(const ExprMul&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
    cout << __func__ << endl;
}
inline void Univ_Taylor_Aff::sub_V_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
    cout << __func__ << endl;
}
inline void Univ_Taylor_Aff::sub_M_fwd(const ExprSub&, const ExprLabel& x1, const ExprLabel& x2, ExprLabel& y) {
    cout << __func__ << endl;
}



}
# 71 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtcSegment.h" 1 3
# 17 "/usr/local/include/ibex/ibex_CtcSegment.h" 3
namespace ibex {






class CtcSegment : public Ctc {

public:
# 35 "/usr/local/include/ibex/ibex_CtcSegment.h" 3
 CtcSegment(double ax, double ay, double bx, double by);
# 46 "/usr/local/include/ibex/ibex_CtcSegment.h" 3
 CtcSegment();




 virtual void contract(IntervalVector& box);




 ~CtcSegment();

protected:


 IntervalVector X_with_params;



 NumConstraint *ncf, *ncg;


 CtcFwdBwd *ctc_f, *ctc_g;

private:

 void init();
};

}
# 72 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_PdcInPolygon.h" 1 3
# 16 "/usr/local/include/ibex/ibex_PdcInPolygon.h" 3
namespace ibex {
# 52 "/usr/local/include/ibex/ibex_PdcInPolygon.h" 3
class PdcInPolygon : public Pdc {
public:
# 66 "/usr/local/include/ibex/ibex_PdcInPolygon.h" 3
 PdcInPolygon(std::vector<double>& ax, std::vector<double>& ay, std::vector<double>& bx, std::vector<double>& by);




 virtual BoolInterval test(const IntervalVector& box);

protected:



 std::vector<double>& ax;
    std::vector<double>& ay;
    std::vector<double>& bx;
    std::vector<double>& by;
};

}
# 73 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_SepPolygon.h" 1 3
# 14 "/usr/local/include/ibex/ibex_SepPolygon.h" 3
# 1 "/usr/local/include/ibex/ibex_SepBoundaryCtc.h" 1 3
# 13 "/usr/local/include/ibex/ibex_SepBoundaryCtc.h" 3
# 1 "/usr/local/include/ibex/ibex_Sep.h" 1 3
# 20 "/usr/local/include/ibex/ibex_Sep.h" 3
# 1 "/usr/local/include/ibex/ibex_SetInterval.h" 1 3
# 15 "/usr/local/include/ibex/ibex_SetInterval.h" 3
namespace ibex {
# 27 "/usr/local/include/ibex/ibex_SetInterval.h" 3
class SetInterval : private Set {

public:
# 39 "/usr/local/include/ibex/ibex_SetInterval.h" 3
 SetInterval(const IntervalVector& box, BoolInterval status=MAYBE);






 SetInterval(const char* filename);




 ~SetInterval();






 bool is_empty() const;




 void save(const char* filename);




 void visit(SetVisitor& visitor) const;







 class NoSet {

 };

 friend class Sep;
};

std::ostream& operator<<(std::ostream& os, const Set& set);

}
# 21 "/usr/local/include/ibex/ibex_Sep.h" 2 3

namespace ibex {
# 55 "/usr/local/include/ibex/ibex_Sep.h" 3
class Sep {

public:

 Sep();
# 71 "/usr/local/include/ibex/ibex_Sep.h" 3
    virtual void separate(IntervalVector& x_in, IntervalVector& x_out) = 0;
# 86 "/usr/local/include/ibex/ibex_Sep.h" 3
 void contract(Set& set, double eps);
# 101 "/usr/local/include/ibex/ibex_Sep.h" 3
 void contract(SetInterval& iset, double eps, BoolInterval status1=YES, BoolInterval status2=NO);




    virtual ~Sep();



    BoolInterval status1() const;



    BoolInterval status2() const;

private:

    BoolInterval _status1;
    BoolInterval _status2;
};





inline Sep::~Sep() { }

inline BoolInterval Sep::status1() const { return _status1; }

inline BoolInterval Sep::status2() const { return _status2; }

}
# 14 "/usr/local/include/ibex/ibex_SepBoundaryCtc.h" 2 3




namespace ibex {
# 41 "/usr/local/include/ibex/ibex_SepBoundaryCtc.h" 3
class SepBoundaryCtc : public Sep {

public:




 SepBoundaryCtc(Ctc& ctc_boundary, Pdc& is_inside);






 virtual void separate(IntervalVector& x_in, IntervalVector& x_out);

protected:






 static const int NB_SAMPLES;


 Ctc& ctc_boundary;


 Pdc& is_inside;

};

}
# 15 "/usr/local/include/ibex/ibex_SepPolygon.h" 2 3



namespace ibex {
# 62 "/usr/local/include/ibex/ibex_SepPolygon.h" 3
class SepPolygon : public SepBoundaryCtc {

public:
# 82 "/usr/local/include/ibex/ibex_SepPolygon.h" 3
    SepPolygon(std::vector<double>& ax, std::vector<double>& ay, std::vector<double>& bx, std::vector<double>& by);




   ~SepPolygon();

};

}
# 74 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_edfrechet.h" 1 3
# 21 "/usr/local/include/ibex/ibex_edfrechet.h" 3
const int ORDER_MAX=20;

namespace ibex{

  typedef std::map<std::vector<int>,Function*> function_map;

  typedef struct memo {int step; Affine2 value;} memo;
  typedef std::map<std::vector<int>,memo> value_map;


  template<typename T>
    std::ostream& operator<< (std::ostream& out, const std::vector<T> v) {
    int last = v.size() - 1;
    out << "[";
    for(int i = 0; i < last; i++)
        out << v[i] << ", ";
    out << v[last] << "]";
    return out;
}


class edfrechet
{
  public:

    int _global_step;

    void inc_global_step(){
      _global_step++;
    };

    edfrechet(int _order, Function* _func, int _nbvar){

      m_order = _order;
      std::vector<int> vec;

      _global_step=1;

      memo zero = {0,Affine2(0)};


      for (int j=0;j<_nbvar;j++)
      {
   std::vector<int> temp(1,j);

   std::pair<std::vector<int>,Function*> elnt(temp,&_func->operator[](j));
   tab_derivatives[0].insert(elnt);


   std::pair<std::vector<int>,memo> elnt2(temp,zero);
   tab_values[0].insert(elnt2);

      }
      for (int i=1;i <= m_order;i++)
      {
 compute_derivatives(i,_nbvar);
      }




    };


    ~edfrechet(){

    }


    Interval eval_frechet(int order, std::vector<int> key, IntervalVector y){



      return tab_derivatives[order][key]->eval(y);
    };


   Affine2 eval_frechet(int order, std::vector<int> key, Affine2Vector y){

      memo temp = tab_values[order][key];

      Affine2 temp2;

      if (temp.step < _global_step)
      {

   temp2 = tab_derivatives[order][key]->eval_affine2(y);
   tab_values[order][key].value = temp2;
   tab_values[order][key].step = _global_step;
      }
      else
      {
 temp2 = temp.value;
      }
      return temp2;
    };

    void print(){
      for (int j=0;j<m_order;j++)
      {
 function_map mymap = tab_derivatives[j];

 std::cout << "order : " << j << std::endl;

   for (function_map::iterator it=mymap.begin(); it!=mymap.end(); ++it)
   {
       std::cout << " " << it->first << ":" << *(it->second) << " ; ";
   }

   std::cout << std::endl;
 }
 std::cout << std::endl;
      };


  private:

    int m_order;
    function_map tab_derivatives[ORDER_MAX];
    value_map tab_values[ORDER_MAX];



    void compute_derivatives(int order,const Function* function,int nbvar,std::vector<int> key)
    {
      for (int j=0;j<nbvar;j++)
      {
   std::vector<int> temp = key;
   temp.push_back(j);
   function_map temp_map = tab_derivatives[order];
   std::pair<std::vector<int>,Function*> elnt(temp,&function->operator[](j));
   temp_map.insert(elnt);
   tab_derivatives[order] = temp_map;

   if (order >= m_order)
   {
       return;
   }
   else
   {
     compute_derivatives(order+1,&(function->operator[](j).diff()),nbvar,temp);
   }
      }

    };


    void compute_derivatives(int order,int nbvar)
    {
      (static_cast <bool> (order > 0) ? void (0) : __assert_fail ("order > 0", "/usr/local/include/ibex/ibex_edfrechet.h", 170, __extension__ __PRETTY_FUNCTION__));
      function_map temp_map = tab_derivatives[order-1];

      function_map::iterator it = temp_map.begin();

      for (;it!=temp_map.end();++it)
      {
 std::vector<int> temp_key = it->first;
 Function* temp_func = it->second;

 const Function& temp_func2 = temp_func->diff();
 for (int j=0;j<nbvar;j++)
 {
     std::vector<int> temp_key2 = temp_key;
     temp_key2.push_back(j);


     std::pair<std::vector<int>,Function*> elnt(temp_key2,&(temp_func2.operator[](j)));
     tab_derivatives[order].insert(elnt);

     memo zero = {0,Affine2(0)};
     std::pair<std::vector<int>,memo> elnt2(temp_key2,zero);
     tab_values[order].insert(elnt2);

 }

      }

    };

};


}
# 75 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_edtree_frechet.h" 1 3
# 19 "/usr/local/include/ibex/ibex_edtree_frechet.h" 3
namespace ibex{

class edtree_frechet
{
public:

  int nbvar;
  int order;
  Function* func;

  edfrechet* edfr;

  edtree_frechet(int _order,Function* _func,int _nbvar){


      nbvar=_nbvar;
      order=_order;
      func = _func;
      edfr = new edfrechet(order,func,nbvar);

  };

  ~edtree_frechet(){
    delete edfr;
  }


  Affine2 get_derivatives(int order, Affine2Vector y, int j);
  Affine2 lteImplicitRadau3 (int j, Affine2Vector y);
  Affine2 lteExplicitRK4 (int j, Affine2Vector y);
  Affine2 lteImplicitLobbato3a4 (int j, Affine2Vector y);
  Affine2 lteImplicitEuler (int j, Affine2Vector y);
  Affine2 lteImplicitMidpoint (int j, Affine2Vector y);
  Affine2 lteImplicitLobbato3c4 (int j, Affine2Vector y);
  Affine2 lteExplicitHeun (int j, Affine2Vector y);
  Affine2 lteImplicitRadau2a5 (int j, Affine2Vector y);
  Affine2 lteImplicitGauss4 (int j, Affine2Vector y);
  Affine2 lteexplicitkutta3 (int j, Affine2Vector y);
  Affine2 lteImplicitGauss6 (int j, Affine2Vector y);
};


}
# 76 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_integrate.h" 1 3
# 17 "/usr/local/include/ibex/ibex_integrate.h" 3
static double dynibex_hmin = 1e-6;
static double dynibex_hmax = 0.9;

const int ordre_max = 7;

# 1 "/usr/local/include/ibex/ibex_wdag_aff.h" 1 3
# 23 "/usr/local/include/ibex/ibex_wdag_aff.h" 3
# 1 "/usr/local/include/ibex/ibex_vertex_wdag_aff.h" 1 3
# 16 "/usr/local/include/ibex/ibex_vertex_wdag_aff.h" 3
# 1 "/usr/local/include/ibex/ibex_rootedtree.h" 1 3
# 23 "/usr/local/include/ibex/ibex_rootedtree.h" 3
using namespace std;

typedef std::vector<int> my_list_t;

namespace ibex {






class rootedTree
{
private:

    my_list_t *_adjacency_list;

public:

    rootedTree();
    rootedTree(const rootedTree& other);


    ~rootedTree();



    inline my_list_t get_adjacency_list() {
        return *_adjacency_list;
    };




    void add(int);




    inline int get(int i) const {
        return _adjacency_list->at(i);
    };

    inline void clear(){
      _adjacency_list->clear();
    }




    bool operator<(const rootedTree &) const;




    bool operator==(rootedTree &);




    int number_of_children(int);




    int get_child(int, int);




    list<rootedTree> get_children();




    inline int size()const {
        return this->_adjacency_list->size();
    };





    int set(int, int);

    string to_string();

};


}
# 17 "/usr/local/include/ibex/ibex_vertex_wdag_aff.h" 2 3







using namespace std;

namespace ibex {
class vertex_wDAG_aff
{

private:

    rootedTree * _tree;

    list<pair<vertex_wDAG_aff *, int > > * _list_of_edge;



    int factorial(int x, int accu){
      if (x <= 0)
 return 0;
      else if (x == 1)
 return accu;
      else
 return factorial(x - 1, x * accu);
    }




    inline int factorial(int x) {
        return factorial(x, 1);
    }


    int _order;


    int _symetry;
    unsigned int _density;


    Interval * _alpha;
    Interval * _psi;

    Affine2Vector * _delta;


    unsigned int _flag;







    static inline double sum(const Vector & x);




    static inline double sum(const IntervalVector & x);




    static inline Interval sum(const Affine2Vector & x);




    Interval get_psi(int i, IntervalMatrix * A, IntervalVector * b);




    static void rec_gamma(const Vector & i, const Vector & j, int d, Vector k, int pos, double & result);

    Interval power(Interval a, int b);

public:
    vertex_wDAG_aff();

    ~vertex_wDAG_aff(){
      cout << __func__ << endl;
      if(_alpha)
 delete _alpha;
      if (_psi)
 delete _psi;
      if (_delta)
 delete _delta;
    }

    vertex_wDAG_aff(rootedTree * tree);

    vertex_wDAG_aff(int order, int symetry, int density, Interval * alpha);


    inline unsigned int get_flag() {
        return _flag;
    }
    inline rootedTree * get_tree() {
        return _tree;
    };
    inline list<pair<vertex_wDAG_aff *, int > > * get_list_of_edge() {
        return _list_of_edge;
    };




    int get_order();




    int get_symetry();


    unsigned int get_density();

    Interval * get_alpha();

    Interval * get_psi(IntervalMatrix * A, IntervalVector * b);

    void add_edge(vertex_wDAG_aff * vertex);

    static double binomial(double n, int k);




    static double multinomial(const Vector &, const Vector &);

    Affine2Vector taylor_coeff(Function * f, const Affine2Vector & x, Affine2Vector s, int d, vector<Function *> * list_g_taylor);

    void get_partial_derivative(Function * f, const Affine2Vector & x, Affine2Matrix & S, Vector & i, Vector j, int d, int pos, int d_rest,
    Affine2Vector * _result, vector<Function *> * list_g_taylor);

    static double get_gamma(const Vector & i, const Vector & j, const int&);

    Affine2Vector * get_delta(Function * f, const Affine2Vector & x, unsigned int flag, vector<Function *> * list_g_taylor);

    Affine2Vector * get_lte(Function * f, const Affine2Vector & x);

    void set_list_of_edge(list<pair<vertex_wDAG_aff *, int > > list_of_edge){_list_of_edge = new list<pair<vertex_wDAG_aff *, int > >(list_of_edge);};
};



double vertex_wDAG_aff::sum(const Vector & x) {

    int i;
    double result = 0.0;
    for (i = 0; i < x.size(); i++)
        result += x[i];

    return result;
}

double vertex_wDAG_aff::sum(const IntervalVector & x) {
    int i;
    double result = 0.0;
    for (i = 0; i < x.size(); i++)
        result += x[i].lb();
    return result;
}

Interval vertex_wDAG_aff::sum(const Affine2Vector & x) {

    int i;
    Interval result = Interval(0.0);
    for (i = 0; i < x.size(); i++)
        result += x[i].itv();
    return result;
}



}
# 24 "/usr/local/include/ibex/ibex_wdag_aff.h" 2 3







using namespace std;

namespace ibex{

class vertex_wDAG_aff;




class wDAG_aff
{

private:
  list<rootedTree> * _list_of_trees;
  list<list<ibex::vertex_wDAG_aff *> > * _list_of_dags;
  int _max_order;
  Function * _f;
  IntervalMatrix * _A;
  IntervalVector * _b;
  bool _filled_in;
  vector<Function *> * _list_g_taylor;
  unsigned int _flag;




  void add_root(vertex_wDAG_aff * root);
public:
  ~wDAG_aff(){

    if (_list_of_trees) delete _list_of_trees;
    if (_list_of_dags) {
      delete _list_of_dags;
    }
    if (_A) delete _A;
    if (_b) delete _b;
  };



  wDAG_aff(Function* f, int order);




  wDAG_aff(Function * f, int order, IntervalMatrix & A, IntervalVector & b);




  inline list<list<vertex_wDAG_aff *> > * get_list_of_dags(){return _list_of_dags;};




  inline int get_order(){return _max_order;};




  std::list< vertex_wDAG_aff* > * get_dag(int order);





  bool is_filled_in(){return _filled_in;};

  void set_filled_in(bool filled_in){_filled_in = filled_in;};





  inline void set_A(IntervalMatrix A){
    _A = new IntervalMatrix(A);
  }




  inline IntervalMatrix * get_A(){return _A;}




  inline void set_b(IntervalVector b){
    _b = new IntervalVector(b);
  }




  inline IntervalVector * get_b(){return _b;}

  inline void set_f(Function * f){
    _f = f;
  }




  Affine2Vector get_derivatives(int order, const Affine2Vector & y_init);




  Affine2Vector get_lte(int order, const Affine2Vector & y_init);




  static list<rootedTree> * generate(const int);



  static void generate_dags(int max_order, list<rootedTree> * list_of_tree,
       list< list<vertex_wDAG_aff *> > * dags, IntervalMatrix * A, IntervalVector * b);

  bool dags_to_file(const std::string &path = "dags.dat");

  bool file_to_dags(int order, list<list<ibex::vertex_wDAG_aff *> > * result, const std::string &path = "dags.dat");
};






}
# 23 "/usr/local/include/ibex/ibex_integrate.h" 2 3

# 1 "/usr/local/include/ibex/ibex_logger.h" 1 3
# 19 "/usr/local/include/ibex/ibex_logger.h" 3
# 1 "/usr/include/c++/7/cstdarg" 1 3
# 39 "/usr/include/c++/7/cstdarg" 3
       
# 40 "/usr/include/c++/7/cstdarg" 3
# 53 "/usr/include/c++/7/cstdarg" 3
namespace std
{
  using ::va_list;
}
# 20 "/usr/local/include/ibex/ibex_logger.h" 2 3



namespace ibex{





class CLogger
{
public:





    void Log(const std::string& sMessage);





    void Log( const char * format, ... );


    void Log_end();


    void inc_rejected_picard();
    void inc_accepted_picard();
    void update_lte_max(double lte);
    void Log_sol(IntervalVector sol);
    void update_step(double step);





    CLogger& operator<<(const std::string& sMessage );




    static CLogger* getLogger();
private:



    CLogger();



    CLogger( const CLogger&){};



    CLogger& operator=(const CLogger& ){ return *this;};



    static const std::string m_sFileName;



    static CLogger* m_pThis;



    static std::ofstream m_Logfile;



    static int nb_rejected_picard;
    static int nb_accepted_picard;
    static double norm_lte_max;
    static double step_min;
    static double step_max;

};

}
# 25 "/usr/local/include/ibex/ibex_integrate.h" 2 3
# 1 "/usr/local/include/ibex/ibex_ivp_ode.h" 1 3
# 17 "/usr/local/include/ibex/ibex_ivp_ode.h" 3
const int MAX_FCT=60;
const double tol_ctc=1e-15;




namespace ibex{

enum Lte_type {AUTODIF, SYMBOLIC, AUTO};

class ivp_ode
{
public:
  ivp_ode(const Function _ydot, double _t0, const IntervalVector _yinit, Lte_type _lte_computation = AUTO){
      nbvar = _yinit.size();
      _dags = __null;
      yinit = new IntervalVector(_yinit);
      yinit_aff = new Affine2Vector(_yinit,true);

      ydot = new Function(_ydot);
      t0 = _t0;
      embedded_ctc = __null;
      if (_lte_computation == AUTO)
 lte_computation = lte_selection();
      else
 lte_computation = _lte_computation;
  };

  ivp_ode(const Function _ydot, double _t0, const Affine2Vector _yinit_aff, Lte_type _lte_computation = AUTO){
      nbvar = _yinit_aff.size();
      _dags = __null;
      yinit = new IntervalVector(_yinit_aff.itv());
      yinit_aff = new Affine2Vector(_yinit_aff);

      ydot = new Function(_ydot);
      t0 = _t0;
      embedded_ctc = __null;
      if (_lte_computation == AUTO)
 lte_computation = lte_selection();
      else
 lte_computation = _lte_computation;
  };



  ivp_ode(const Function _ydot, double _t0, const IntervalVector _yinit, const Array<NumConstraint>& csp, Lte_type _lte_computation = AUTO){
      nbvar = _yinit.size();
      _dags = __null;
      yinit = new IntervalVector(_yinit);
      yinit_aff = new Affine2Vector(_yinit,true);

      ydot = new Function(_ydot);
      t0 = _t0;
      Array<NumConstraint> csp_temp(csp);
      CtcHC4* hc4 = new CtcHC4(csp_temp,tol_ctc);
      Ctc3BCid* cid = new Ctc3BCid(*hc4);
      embedded_ctc = new CtcFixPoint(*cid,tol_ctc);
      if (_lte_computation == AUTO)
 lte_computation = lte_selection();
      else
 lte_computation = _lte_computation;
  };

  ivp_ode(const Function _ydot, double _t0, const Affine2Vector _yinit_aff, const Array<NumConstraint>& csp, Lte_type _lte_computation = AUTO){
      nbvar = _yinit_aff.size();
      _dags = __null;
      yinit = new IntervalVector(_yinit_aff.itv());
      yinit_aff = new Affine2Vector(_yinit_aff);

      ydot = new Function(_ydot);
      t0 = _t0;
      Array<NumConstraint> csp_temp(csp);
      CtcHC4* hc4 = new CtcHC4(csp_temp,tol_ctc);
      Ctc3BCid* cid = new Ctc3BCid(*hc4);
      embedded_ctc = new CtcFixPoint(*cid,tol_ctc);
      if (_lte_computation == AUTO)
 lte_computation = lte_selection();
      else
 lte_computation = _lte_computation;
  };



  void frechet_precomputing(int order)
  {

    edtfr = new edtree_frechet(order,ydot,nbvar);
  }


  IntervalVector compute_derivatives(int ordre, IntervalVector yi){





    (static_cast <bool> (ordre < MAX_FCT) ? void (0) : __assert_fail ("ordre < MAX_FCT", "/usr/local/include/ibex/ibex_ivp_ode.h", 113, __extension__ __PRETTY_FUNCTION__));
    if (ordre == 1)
    {
        IntervalMatrix J(yi.size(), yi.size());
        ydot->hansen_matrix(yi,J);
        return (ydot->eval_vector(yi.mid()) + J*(yi-yi.mid())) & ydot->eval_vector(yi);
    }
    switch (lte_computation){
        case SYMBOLIC:
        {
            IntervalVector der(nbvar);
            for (unsigned int j = 0; j < nbvar; j++)
            der[j]=edtfr->get_derivatives(ordre,Affine2Vector(yi,true),j).itv();
            return der;
        }
        case AUTODIF:
        {
            Affine2Vector result = _dags->get_derivatives(ordre, Affine2Vector(yi, true));
            return result.itv();
        }
        default:
        {
            if (nbvar >= 3)
                lte_computation = AUTODIF;
            else
                lte_computation = SYMBOLIC;
            return compute_derivatives(ordre, yi);
        }
    }
  };



  Affine2Vector computeRK4derivative(Affine2Vector y)
  {
    Affine2Vector rk4_deriv(y.size(),0);

    for (int i=0;i<y.size();i++)
    {
      rk4_deriv[i]=edtfr->lteExplicitRK4(i, y);

    }
    return rk4_deriv;

  }

  Affine2Vector computeGL4derivative_aff(Affine2Vector y)
  {
    Affine2Vector gl4_deriv(y.size());

    for (int i=0;i<y.size();i++)
    {
      gl4_deriv[i]=edtfr->lteImplicitGauss4(i, y);

    }
    return gl4_deriv;
  }

  Affine2Vector computeGL6derivative_aff(Affine2Vector y)
  {
    Affine2Vector gl6_deriv(y.size());

    for (int i=0;i<y.size();i++)
    {
      gl6_deriv[i]=edtfr->lteImplicitGauss6(i, y);

    }
    return gl6_deriv;
  }


  Affine2Vector computeRADAU3derivative(Affine2Vector y)
  {
    Affine2Vector radau3_deriv(y.size(),0);

    for (int i=0;i<y.size();i++)
    {
      radau3_deriv[i]=edtfr->lteImplicitRadau3(i, y);
    }
    return radau3_deriv;

  }

  Affine2Vector computeRADAU5derivative(Affine2Vector y)
    {
      Affine2Vector radau5_deriv(y.size(),0);

      for (int i=0; i<y.size(); i++)
        {
   radau5_deriv[i]=edtfr->lteImplicitRadau2a5(i, y);
        }
      return radau5_deriv;

    }

  Affine2Vector computeLC3derivative(Affine2Vector y)
  {
    Affine2Vector lc3_deriv(y.size(),0);

    for (int i=0;i<y.size();i++)
    {
      lc3_deriv[i]=edtfr->lteImplicitLobbato3c4(i, y);
    }
    return lc3_deriv;

  }


  Affine2Vector computeHEUNderivative(Affine2Vector y)
  {
    Affine2Vector heun_deriv(y.size(),0);

    for (int i=0;i<y.size();i++)
    {
      heun_deriv[i]=edtfr->lteExplicitHeun(i, y);
    }
    return heun_deriv;

  }

  Affine2Vector computeIEULERderivative(Affine2Vector y)
  {
    Affine2Vector ieuler_deriv(y.size(),0);

    for (int i=0;i<y.size();i++)
    {
      ieuler_deriv[i]=edtfr->lteImplicitEuler(i, y);

    }
    return ieuler_deriv;

  }


  Affine2Vector computeIMIDPOINTderivative(Affine2Vector y)
  {
    Affine2Vector imidpoint_deriv(y.size(),0);

    for (int i=0;i<y.size();i++)
    {
      imidpoint_deriv[i]=edtfr->lteImplicitMidpoint(i, y);

    }
    return imidpoint_deriv;

  }

   Affine2Vector computeLA3derivative_aff(Affine2Vector y)
  {
    Affine2Vector la3_deriv(y.size());

    for (int i=0;i<y.size();i++)
    {
      la3_deriv[i]=edtfr->lteImplicitLobbato3a4(i, y);

    }
    return la3_deriv;

  }

  Affine2Vector computeKUTTA3derivative_aff(Affine2Vector y)
  {
    Affine2Vector kutta3_deriv(y.size());

    for (int i=0;i<y.size();i++)
    {
      kutta3_deriv[i]=edtfr->lteexplicitkutta3(i, y);

    }
    return kutta3_deriv;
  }




   Affine2Vector compute_derivatives_aff(int ordre, Affine2Vector yi){
    (static_cast <bool> (ordre < MAX_FCT) ? void (0) : __assert_fail ("ordre < MAX_FCT", "/usr/local/include/ibex/ibex_ivp_ode.h", 289, __extension__ __PRETTY_FUNCTION__));
    switch (lte_computation){
      case SYMBOLIC:
      {
 Affine2Vector der(nbvar);
 edtfr->edfr->inc_global_step();
 for (unsigned int j=0;j<nbvar;j++)
   der[j]=edtfr->get_derivatives(ordre,yi,j);
 return der;
      }
      case AUTODIF:
      {
        return _dags->get_derivatives(ordre, yi);
      }
      case AUTO:
      {
        if (nbvar >= 3)
            lte_computation = AUTODIF;
        else
            lte_computation = SYMBOLIC;
        return compute_derivatives_aff(ordre, yi);
      }
      default:
      {
        lte_computation = AUTODIF;
        return compute_derivatives_aff(ordre, yi);
      }
    }
  };

  IntervalMatrix eval_jacobian_init()
  {
    return ydot->jacobian(*yinit);

  };

  void compute_derivatives(int ordre){
    (static_cast <bool> (ordre < MAX_FCT) ? void (0) : __assert_fail ("ordre < MAX_FCT", "/usr/local/include/ibex/ibex_ivp_ode.h", 326, __extension__ __PRETTY_FUNCTION__));


    for (int i=0;i<=ordre;i++)
    {
 std::cout << "eval "<<i<<"^th diff" << std::endl;
 for (unsigned int j=0;j<nbvar;j++)
     std::cout << edtfr->get_derivatives(i,Affine2Vector(*yinit,true),j).itv() << std::endl;
    }


  };


    void compute_derivatives2(int ordre){
    (static_cast <bool> (ordre < MAX_FCT) ? void (0) : __assert_fail ("ordre < MAX_FCT", "/usr/local/include/ibex/ibex_ivp_ode.h", 341, __extension__ __PRETTY_FUNCTION__));

    for (int i=0;i<=ordre;i++)
    {
 std::cout << "eval "<<i<<"^th diff" << std::endl;
 for (unsigned int j=0;j<nbvar;j++)
     std::cout << edtfr->get_derivatives(i,Affine2Vector(*yinit,true),j) << std::endl;
    }


  };


  ~ivp_ode(){
    delete yinit;
    delete yinit_aff;
    delete ydot;
    if (lte_computation == SYMBOLIC)
      delete edtfr;
    if (lte_computation == AUTODIF)
      delete _dags;

    if (embedded_ctc != __null)
      delete embedded_ctc;
  };


public:
  unsigned int nbvar;
  Function* ydot;
  IntervalVector* yinit;
  Affine2Vector* yinit_aff;
  double t0;
  CtcFixPoint* embedded_ctc;

  Lte_type get_lte_computation(){return lte_computation;};
  void dag_precomputing(int order){
    _dags = new wDAG_aff(ydot, order);
  }

  wDAG_aff * get_dags(){return _dags;}

  void set_Butcher_table(IntervalMatrix A, IntervalVector b){
    if (!_dags->is_filled_in()){
      _dags->set_filled_in(true);
      _dags->set_A(A);
      _dags->set_b(b);
    }
  }

  Lte_type lte_selection(){
    if (nbvar >= 3){
 return ibex::AUTODIF;
    } else {
      return ibex::SYMBOLIC;
    }
  }

  std::string lte_comp_to_string(){
    if (lte_computation == ibex::AUTODIF)
      return "automatic differentiation";
    if (lte_computation == ibex::SYMBOLIC)
      return "symbolic differentiation";
    return "unknown differentiation";
  }

private:
  edtree_frechet* edtfr;
  wDAG_aff * _dags;
  Lte_type lte_computation;


};


}
# 26 "/usr/local/include/ibex/ibex_integrate.h" 2 3



# 1 "/usr/local/include/ibex/ibex_ivp_dae_h1.h" 1 3
# 16 "/usr/local/include/ibex/ibex_ivp_dae_h1.h" 3
# 1 "/usr/local/include/ibex/ibex_Linear.h" 1 3
# 15 "/usr/local/include/ibex/ibex_Linear.h" 3
# 1 "/usr/local/include/ibex/ibex_LinearException.h" 1 3
# 16 "/usr/local/include/ibex/ibex_LinearException.h" 3
namespace ibex {





class LinearException : public Exception { };







class NotSquareMatrixException : public LinearException { };







class SingularMatrixException : public LinearException { };






class NullPivotException : public LinearException { };
# 54 "/usr/local/include/ibex/ibex_LinearException.h" 3
class NotInversePositiveMatrixException : public LinearException { };

}
# 16 "/usr/local/include/ibex/ibex_Linear.h" 2 3



namespace ibex {
# 44 "/usr/local/include/ibex/ibex_Linear.h" 3
void real_LU(const Matrix& A, Matrix& LU, int* p);
# 67 "/usr/local/include/ibex/ibex_Linear.h" 3
void real_LU(const Matrix& A, Matrix& LU, int* pr, int* pc);

void interval_LU(const IntervalMatrix& A, IntervalMatrix& LU, int* p);

void interval_LU(const IntervalMatrix& A, IntervalMatrix& LU, int* pr, int* pc);
# 87 "/usr/local/include/ibex/ibex_Linear.h" 3
void real_inverse(const Matrix& A, Matrix& invA);
# 105 "/usr/local/include/ibex/ibex_Linear.h" 3
void precond(IntervalMatrix& A, IntervalVector& b);
# 121 "/usr/local/include/ibex/ibex_Linear.h" 3
void precond(IntervalMatrix& A);
# 140 "/usr/local/include/ibex/ibex_Linear.h" 3
void gauss_seidel(const IntervalMatrix& A, const IntervalVector& b, IntervalVector& x, double ratio=0.01);
# 161 "/usr/local/include/ibex/ibex_Linear.h" 3
bool inflating_gauss_seidel(const IntervalMatrix& A, const IntervalVector& b, IntervalVector& x, double min_dist=1e-12, double mu_max_divergence=1.0);
# 184 "/usr/local/include/ibex/ibex_Linear.h" 3
void hansen_bliek(const IntervalMatrix& A, const IntervalVector& b, IntervalVector& x);


}
# 17 "/usr/local/include/ibex/ibex_ivp_dae_h1.h" 2 3

namespace ibex{

class ivp_dae_h1
{
public:
  ivp_dae_h1(const Function _ydot, const Function _g, double _t0, const IntervalVector _yinit, IntervalVector _xinit) {

      nbvar = _yinit.size();
      yinit = new IntervalVector(_yinit);
      yinit_aff = new Affine2Vector(_yinit,true);

      ydot = new Function(_ydot);
      t0 = _t0;
      embedded_ctc = __null;
      xinit = new IntervalVector(_xinit);
      xinit_aff = new Affine2Vector(_xinit,true);

      g = new Function(_g);
  };

  ivp_dae_h1(const Function _ydot, const Function _g, double _t0, const Affine2Vector _yinit_aff, const Affine2Vector _xinit_aff) {

      nbvar = _yinit_aff.size();
      yinit = new IntervalVector(_yinit_aff.itv());
      yinit_aff = new Affine2Vector(_yinit_aff);

      ydot = new Function(_ydot);
      t0 = _t0;
      embedded_ctc = __null;
      xinit = new IntervalVector(_xinit_aff.itv());
      xinit_aff = new Affine2Vector(_xinit_aff);

      g = new Function(_g);
  };


  ivp_dae_h1(const Function _ydot, const Function _g, double _t0, const IntervalVector _yinit, IntervalVector _xinit,const Array<NumConstraint>& csp) {

      nbvar = _yinit.size();
      yinit = new IntervalVector(_yinit);
      yinit_aff = new Affine2Vector(_yinit,true);

      ydot = new Function(_ydot);
      t0 = _t0;
      Array<NumConstraint> csp_temp(csp);
      CtcHC4* hc4 = new CtcHC4(csp_temp,tol_ctc);
      Ctc3BCid* cid = new Ctc3BCid(*hc4);
      embedded_ctc = new CtcFixPoint(*cid,tol_ctc);
      xinit = new IntervalVector(_xinit);
      xinit_aff = new Affine2Vector(_xinit,true);

      g = new Function(_g);
  };

  ivp_dae_h1(const Function _ydot, const Function _g, double _t0, const Affine2Vector _yinit_aff, const Affine2Vector _xinit_aff,const Array<NumConstraint>& csp) {

      nbvar = _yinit_aff.size();
      yinit = new IntervalVector(_yinit_aff.itv());
      yinit_aff = new Affine2Vector(_yinit_aff);

      ydot = new Function(_ydot);
      t0 = _t0;
      Array<NumConstraint> csp_temp(csp);
      CtcHC4* hc4 = new CtcHC4(csp_temp,tol_ctc);
      Ctc3BCid* cid = new Ctc3BCid(*hc4);
      embedded_ctc = new CtcFixPoint(*cid,tol_ctc);
      xinit = new IntervalVector(_xinit_aff.itv());
      xinit_aff = new Affine2Vector(_xinit_aff);

      g = new Function(_g);
  };



  void frechet_precomputing(int order)
  {
    edtfr = new edtree_frechet(order,ydot,nbvar);
  }

  Affine2Vector computeRADAU3derivative(Affine2Vector y)
  {
    Affine2Vector radau3_deriv(nbvar,0);

    for (int i=0;i<nbvar;i++)
    {
      radau3_deriv[i]=edtfr->lteImplicitRadau3(i, y);
    }
    return radau3_deriv;

  }

  Affine2Vector compute_derivatives_aff(int ordre, Affine2Vector yi){

    Affine2Vector der(nbvar);

    edtfr->edfr->inc_global_step();

    for (int j=0;j<nbvar;j++)
      der[j]=edtfr->get_derivatives(ordre,yi,j);

    return der;
  };




  Affine2Vector compute_algebraic_function(Affine2Vector si){

    return g->eval_affine2_vector(si);
  };

  IntervalVector compute_algebraic_krawczyk(IntervalVector si){

    int n=si.size()-nbvar;

    IntervalVector si_old(si);
    IntervalVector kr(n);
    do{
 si_old=si;
 IntervalVector xi = si.subvector(nbvar,si.size()-1);
 IntervalVector yi = si.subvector(0,nbvar-1);

 Matrix Id(n,n);
 for (int i=0; i<n; i++)
  for (int j=0; j<n; j++)
  {
   Id[i][j] = i==j;
  }

 kr = xi.mid();


 IntervalMatrix Xinv = g->jacobian(IntervalVector(si.mid()));

 IntervalMatrix Xinv_x = Xinv.submatrix(0, n-1, nbvar, n+nbvar-1);


 Matrix Xinv_x_m = Xinv_x.mid();
 Matrix Xxm(n,n);
 try {
   real_inverse(Xinv_x_m, Xxm);
 }
 catch(SingularMatrixException& e) {
  Xxm=Id;
 }

 IntervalVector si_m(si);
 si_m.put(nbvar,kr);


 IntervalMatrix Y = g->jacobian(IntervalVector(si.mid()));

 IntervalMatrix Y_y = Y.submatrix(0,n-1,0,nbvar-1);

 if (n==1)
   kr += -Xxm*IntervalVector(1,g->eval(si.mid()));
 else
   kr += -Xxm*g->eval_affine2_vector(Affine2Vector(si.mid(),true)).itv();
 kr += (Id-Xxm*Xinv_x)*(xi-xi.mid()) - Xxm*Y_y*(yi-yi.mid());
 xi &= kr;

 si.put(nbvar,xi);

    }while(si.rel_distance(si_old) > 1e-20);

    return kr;
  };



  IntervalVector compute_algebraic_hansen(IntervalVector si){

    int n=si.size()-nbvar;

    IntervalVector si_old(si);
    IntervalVector kr(n);
    do{
 si_old=si;
 IntervalVector xi = si.subvector(nbvar,si.size()-1);
 IntervalVector yi = si.subvector(0,nbvar-1);

 Matrix Id(n,n);
 for (int i=0; i<n; i++)
  for (int j=0; j<n; j++)
  {
   Id[i][j] = i==j;
  }

 kr = xi.mid();

 IntervalMatrix Xinv = g->jacobian(si);

 IntervalMatrix Xinv_x = Xinv.submatrix(0, n-1, nbvar, n+nbvar-1);


 Matrix Xinv_x_m = Xinv_x.mid();
 Matrix Xxm(n,n);
 try {
   real_inverse(Xinv_x_m, Xxm);
 }
 catch(SingularMatrixException& e) {
  Xxm=Id;
 }




 IntervalVector si_m(si);
 si_m.put(nbvar,kr);

 kr-=xi;
 kr*=-1.0;

 std::cout << "xi : " << xi << std::endl;
 gauss_seidel(Xxm*Xinv, -Xxm*g->eval_vector(si_m), kr);

 xi &= kr+xi.mid();
 std::cout << "xi ap gauss : " << xi << std::endl;
 si.put(nbvar,xi);

 kr = xi;

    }while(si.rel_distance(si_old) > 1e-20);

    return kr;
  };


  ~ivp_dae_h1(){
    if (yinit != __null)
      delete yinit;
    if (yinit_aff != __null)
      delete yinit_aff;
    if (ydot != __null)
      delete ydot;
    if (embedded_ctc != __null)
      delete embedded_ctc;
    if (xinit != __null)
      delete xinit;
    if (xinit_aff != __null)
      delete xinit_aff;
    if (g != __null)
      delete g;
    if (edtfr != __null)
      delete edtfr;
  };


public:
  int nbvar;
  Function* ydot;
  Affine2Vector* yinit_aff;
  double t0;
  CtcFixPoint* embedded_ctc;
  Function* g;
  Affine2Vector* xinit_aff;

private:
  IntervalVector* yinit;
  edtree_frechet* edtfr;
  IntervalVector* xinit;


};


}
# 30 "/usr/local/include/ibex/ibex_integrate.h" 2 3
# 1 "/usr/local/include/ibex/ibex_solution_generic.h" 1 3
# 16 "/usr/local/include/ibex/ibex_solution_generic.h" 3
# 1 "/usr/include/c++/7/iomanip" 1 3
# 36 "/usr/include/c++/7/iomanip" 3
       
# 37 "/usr/include/c++/7/iomanip" 3






# 1 "/usr/include/c++/7/locale" 1 3
# 36 "/usr/include/c++/7/locale" 3
       
# 37 "/usr/include/c++/7/locale" 3




# 1 "/usr/include/c++/7/bits/locale_facets_nonio.h" 1 3
# 37 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
       
# 38 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3

# 1 "/usr/include/c++/7/ctime" 1 3
# 39 "/usr/include/c++/7/ctime" 3
       
# 40 "/usr/include/c++/7/ctime" 3
# 58 "/usr/include/c++/7/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 40 "/usr/include/c++/7/bits/locale_facets_nonio.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 52 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {

      static const _CharT* _S_timezones[14];

      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;

      bool _M_allocated;

      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(0), _M_date_era_format(0), _M_time_format(0),
      _M_time_era_format(0), _M_date_time_format(0),
      _M_date_time_era_format(0), _M_am(0), _M_pm(0),
      _M_am_pm_format(0), _M_day1(0), _M_day2(0), _M_day3(0),
      _M_day4(0), _M_day5(0), _M_day6(0), _M_day7(0),
      _M_aday1(0), _M_aday2(0), _M_aday3(0), _M_aday4(0),
      _M_aday5(0), _M_aday6(0), _M_aday7(0), _M_month01(0),
      _M_month02(0), _M_month03(0), _M_month04(0), _M_month05(0),
      _M_month06(0), _M_month07(0), _M_month08(0), _M_month09(0),
      _M_month10(0), _M_month11(0), _M_month12(0), _M_amonth01(0),
      _M_amonth02(0), _M_amonth03(0), _M_amonth04(0),
      _M_amonth05(0), _M_amonth06(0), _M_amonth07(0),
      _M_amonth08(0), _M_amonth09(0), _M_amonth10(0),
      _M_amonth11(0), _M_amonth12(0), _M_allocated(false)
      { }

      ~__timepunct_cache();

    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);

      explicit
      __timepunct_cache(const __timepunct_cache&);
    };

  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {

 }
    }


  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];


  template<>
    const wchar_t*
    __timepunct_cache<wchar_t>::_S_timezones[14];



  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef __timepunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;

    public:

      static locale::id id;

      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
# 206 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);



      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const throw ();

      void
      _M_date_formats(const _CharT** __date) const
      {

 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }

      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }

      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }

      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }

      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const throw ();


  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
     const tm*) const throw ();



}


# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/time_members.h" 1 3
# 37 "/usr/include/x86_64-linux-gnu/c++/7/bits/time_members.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(0), _M_c_locale_timepunct(0),
      _M_name_timepunct(_S_get_c_name())
    { _M_initialize_timepunct(); }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache), _M_c_locale_timepunct(0),
      _M_name_timepunct(_S_get_c_name())
    { _M_initialize_timepunct(); }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(0), _M_c_locale_timepunct(0),
      _M_name_timepunct(0)
    {
      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
 {
   const size_t __len = __builtin_strlen(__s) + 1;
   char* __tmp = new char[__len];
   __builtin_memcpy(__tmp, __s, __len);
   _M_name_timepunct = __tmp;
 }
      else
 _M_name_timepunct = _S_get_c_name();

      try
 { _M_initialize_timepunct(__cloc); }
      catch(...)
 {
   if (_M_name_timepunct != _S_get_c_name())
     delete [] _M_name_timepunct;
   throw;
 }
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }


}
# 345 "/usr/include/c++/7/bits/locale_facets_nonio.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


namespace __cxx11 {
# 365 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 386 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
# 403 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      dateorder
      date_order() const
      { return this->do_date_order(); }
# 427 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
# 452 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
# 480 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
# 509 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
# 535 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }
# 556 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      inline
      iter_type get(iter_type __s, iter_type __end, ios_base& __io,
                    ios_base::iostate& __err, tm* __tm, char __format,
                    char __modifier = 0) const
      {
        return this->do_get(__s, __end, __io, __err, __tm, __format,
                            __modifier);
      }
# 583 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type get(iter_type __s, iter_type __end, ios_base& __io,
                    ios_base::iostate& __err, tm* __tm, const char_type* __fmt,
                    const char_type* __fmtend) const;


    protected:

      virtual
      ~time_get() { }
# 603 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual dateorder
      do_date_order() const;
# 621 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 640 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 659 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
# 678 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
# 697 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 720 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual

      iter_type
      do_get(iter_type __s, iter_type __end, ios_base& __f,
             ios_base::iostate& __err, tm* __tm,
             char __format, char __modifier) const;



      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
          const _CharT** __names, size_t __indexlen,
          ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;


  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }


      explicit
      time_get_byname(const string& __s, size_t __refs = 0)
      : time_get_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~time_get_byname() { }
    };

}
# 794 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 815 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
# 834 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
# 854 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:

      virtual
      ~time_put()
      { }
# 881 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;


  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };


      explicit
      time_put_byname(const string& __s, size_t __refs = 0)
      : time_put_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~time_put_byname() { }
    };
# 926 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;

    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };



    static const char* _S_atoms;



    __attribute__ ((__const__)) static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn) throw ();
  };

  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;




      _CharT _M_atoms[money_base::_S_end];

      bool _M_allocated;

      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(0), _M_curr_symbol_size(0),
      _M_positive_sign(0), _M_positive_sign_size(0),
      _M_negative_sign(0), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }

      ~__moneypunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);

      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };

  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }

namespace __cxx11 {
# 1021 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

    private:
      __cache_type* _M_data;

    public:


      static const bool intl = _Intl;

      static locale::id id;
# 1050 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_moneypunct(); }
# 1063 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
# 1078 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_moneypunct(__cloc, __s); }
# 1092 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1105 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1135 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1148 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
# 1165 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
# 1182 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
# 1198 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      int
      frac_digits() const
      { return this->do_frac_digits(); }
# 1234 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }


    protected:

      virtual
      ~moneypunct();
# 1256 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1268 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1281 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1294 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
# 1307 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
# 1320 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
# 1334 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
# 1348 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
# 1362 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = 0,
    const char* __name = 0);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);


  template<>
    moneypunct<wchar_t, true>::~moneypunct();

  template<>
    moneypunct<wchar_t, false>::~moneypunct();

  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
       const char*);

  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
        const char*);



  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      moneypunct_byname(const string& __s, size_t __refs = 0)
      : moneypunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~moneypunct_byname() { }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;

}

namespace __cxx11 {
# 1465 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1487 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
# 1517 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
# 1548 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:

      virtual
      ~money_get() { }
# 1572 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
# 1584 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;
# 1596 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
# 1618 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:


      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1639 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
# 1659 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
# 1682 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:

      virtual
      ~money_put() { }
# 1717 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
# 1741 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;
# 1753 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;

}





  struct messages_base
  {
    typedef int catalog;
  };

namespace __cxx11 {
# 1796 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;

    public:

      static locale::id id;
# 1824 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      messages(size_t __refs = 0);
# 1838 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
# 1851 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
# 1869 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
# 1887 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
# 1898 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:

      virtual
      ~messages();
# 1918 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
# 1937 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;






      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char*) const
      {

 return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;


  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;



   template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);


      explicit
      messages_byname(const string& __s, size_t __refs = 0)
      : messages_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~messages_byname()
      { }
    };

}


}


# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/messages_members.h" 1 3
# 36 "/usr/include/x86_64-linux-gnu/c++/7/bits/messages_members.h" 3
# 1 "/usr/include/libintl.h" 1 3 4
# 34 "/usr/include/libintl.h" 3 4
extern "C" {




extern char *gettext (const char *__msgid)
     throw () __attribute__ ((__format_arg__ (1)));



extern char *dgettext (const char *__domainname, const char *__msgid)
     throw () __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (const char *__domainname, const char *__msgid)
     throw () __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (const char *__domainname,
   const char *__msgid, int __category)
     throw () __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (const char *__domainname,
     const char *__msgid, int __category)
     throw () __attribute__ ((__format_arg__ (2)));




extern char *ngettext (const char *__msgid1, const char *__msgid2,
         unsigned long int __n)
     throw () __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (const char *__domainname, const char *__msgid1,
   const char *__msgid2, unsigned long int __n)
     throw () __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (const char *__domainname, const char *__msgid1,
    const char *__msgid2, unsigned long int __n,
    int __category)
     throw () __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (const char *__domainname) throw ();



extern char *bindtextdomain (const char *__domainname,
        const char *__dirname) throw ();



extern char *bind_textdomain_codeset (const char *__domainname,
          const char *__codeset) throw ();
# 121 "/usr/include/libintl.h" 3 4
}
# 37 "/usr/include/x86_64-linux-gnu/c++/7/bits/messages_members.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _CharT>
    messages<_CharT>::messages(size_t __refs)
    : facet(__refs), _M_c_locale_messages(_S_get_c_locale()),
      _M_name_messages(_S_get_c_name())
    { }

  template<typename _CharT>
    messages<_CharT>::messages(__c_locale __cloc, const char* __s,
          size_t __refs)
    : facet(__refs), _M_c_locale_messages(0), _M_name_messages(0)
    {
      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
 {
   const size_t __len = __builtin_strlen(__s) + 1;
   char* __tmp = new char[__len];
   __builtin_memcpy(__tmp, __s, __len);
   _M_name_messages = __tmp;
 }
      else
 _M_name_messages = _S_get_c_name();


      _M_c_locale_messages = _S_clone_c_locale(__cloc);
    }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char* __dir) const
    {
      bindtextdomain(__s.c_str(), __dir);
      return this->do_open(__s, __loc);
    }


  template<typename _CharT>
    messages<_CharT>::~messages()
    {
      if (_M_name_messages != _S_get_c_name())
 delete [] _M_name_messages;
      _S_destroy_c_locale(_M_c_locale_messages);
    }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>& __s,
         const locale&) const
    {


      textdomain(__s.c_str());
      return 0;
    }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


  template<typename _CharT>
    messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
    : messages<_CharT>(__refs)
    {
      if (this->_M_name_messages != locale::facet::_S_get_c_name())
 {
   delete [] this->_M_name_messages;
   if (__builtin_strcmp(__s, locale::facet::_S_get_c_name()) != 0)
     {
       const size_t __len = __builtin_strlen(__s) + 1;
       char* __tmp = new char[__len];
       __builtin_memcpy(__tmp, __s, __len);
       this->_M_name_messages = __tmp;
     }
   else
     this->_M_name_messages = locale::facet::_S_get_c_name();
 }

      if (__builtin_strcmp(__s, "C") != 0
   && __builtin_strcmp(__s, "POSIX") != 0)
 {
   this->_S_destroy_c_locale(this->_M_c_locale_messages);
   this->_S_create_c_locale(this->_M_c_locale_messages, __s);
 }
    }


  template<>
    typename messages<char>::catalog
    messages<char>::do_open(const basic_string<char>&,
       const locale&) const;

  template<>
    void
    messages<char>::do_close(catalog) const;


  template<>
    typename messages<wchar_t>::catalog
    messages<wchar_t>::do_open(const basic_string<char>&,
          const locale&) const;

  template<>
    void
    messages<wchar_t>::do_close(catalog) const;



}
# 2009 "/usr/include/c++/7/bits/locale_facets_nonio.h" 2 3




# 1 "/usr/include/c++/7/bits/locale_facets_nonio.tcc" 1 3
# 33 "/usr/include/c++/7/bits/locale_facets_nonio.tcc" 3
       
# 34 "/usr/include/c++/7/bits/locale_facets_nonio.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = 0;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };

  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);

      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();

      char* __grouping = 0;
      _CharT* __curr_symbol = 0;
      _CharT* __positive_sign = 0;
      _CharT* __negative_sign = 0;
      try
 {
   const string& __g = __mp.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __cs = __mp.curr_symbol();
   _M_curr_symbol_size = __cs.size();
   __curr_symbol = new _CharT[_M_curr_symbol_size];
   __cs.copy(__curr_symbol, _M_curr_symbol_size);

   const basic_string<_CharT>& __ps = __mp.positive_sign();
   _M_positive_sign_size = __ps.size();
   __positive_sign = new _CharT[_M_positive_sign_size];
   __ps.copy(__positive_sign, _M_positive_sign_size);

   const basic_string<_CharT>& __ns = __mp.negative_sign();
   _M_negative_sign_size = __ns.size();
   __negative_sign = new _CharT[_M_negative_sign_size];
   __ns.copy(__negative_sign, _M_negative_sign_size);

   _M_pos_format = __mp.pos_format();
   _M_neg_format = __mp.neg_format();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(money_base::_S_atoms,
       money_base::_S_atoms + money_base::_S_end, _M_atoms);

   _M_grouping = __grouping;
   _M_curr_symbol = __curr_symbol;
   _M_positive_sign = __positive_sign;
   _M_negative_sign = __negative_sign;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __curr_symbol;
   delete [] __positive_sign;
   delete [] __negative_sign;
   throw;
 }
    }

namespace __cxx11 {

  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;


 bool __negative = false;

 size_type __sign_size = 0;

 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);

 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);

 int __last_pos = 0;

 int __n = 0;

 bool __testvalid = true;

 bool __testdecfound = false;


 string __res;
 __res.reserve(32);

 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:




  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || (__mandatory_sign
      && (static_cast<part>(__p.field[3])
          == money_base::sign)))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, (void)++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:

  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)


    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:


  for (; __beg != __end; ++__beg)
    {
      const char_type __c = *__beg;
      const char_type* __q = __traits_type::find(__lit_zero,
              10, __c);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (__c == __lc->_M_decimal_point
        && !__testdecfound)
        {
   if (__lc->_M_frac_digits <= 0)
     break;

   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && __c == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {

       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:

  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:

  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }


 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, (void)++__i);

     if (__i != __sign_size)
       __testvalid = false;
   }

 if (__testvalid)
   {

     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }


     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');


     if (__grouping_tmp.size())
       {

  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __err |= ios_base::failbit;
       }


     if (__testdecfound && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }


 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);


 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }
# 367 "/usr/include/c++/7/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __digits) const
    {
      typedef typename string::size_type size_type;

      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   __digits.resize(__len);
   __ctype.widen(__str.data(), __str.data() + __len, &__digits[0]);
 }
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;



 const char_type* __beg = __digits.data();

 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (!(*__beg == __lit[money_base::_S_minus]))
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }


 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {



     string_type __value;
     __value.reserve(2 * __len);



     long __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      __value.assign(2 * __paddec, char_type());
       _CharT* __vend =
        std::__add_grouping(&__value[0], __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.erase(__vend - &__value[0]);
      }
    else
    __value.assign(__beg, __paddec);
       }


     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {

      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }


     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);

     string_type __res;
     __res.reserve(2 * __len);

     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);

     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:



      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:



      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }


     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);


     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)

    __res.append(__width - __len, __fill);
  else

    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }


     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }
# 573 "/usr/include/c++/7/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));


      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);

      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);
 }
# 605 "/usr/include/c++/7/bits/locale_facets_nonio.tcc" 3
      string_type __digits(__len, char_type());
      __ctype.widen(__cs, __cs + __len, &__digits[0]);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }

}




  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);

      ios_base::iostate __tmperr = ios_base::goodbit;
      size_t __i = 0;
      for (; __beg != __end && __i < __len && !__tmperr; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {

       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':

    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __mem, __days1,
       7, __io, __tmperr);
    if (!__tmperr)
      __tm->tm_wday = __mem;
    break;
  case 'A':

    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __mem, __days2,
       7, __io, __tmperr);
    if (!__tmperr)
      __tm->tm_wday = __mem;
    break;
  case 'h':
  case 'b':

    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __mem,
       __months1, 12, __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem;
    break;
  case 'B':

    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __mem,
       __months2, 12, __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem;
    break;
  case 'c':

    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dt[0]);
    break;
  case 'd':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 31, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mday = __mem;
    break;
  case 'e':


    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __mem, 1, 9,
        1, __io, __tmperr);
    else
      __beg = _M_extract_num(__beg, __end, __mem, 10, 31,
        2, __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mday = __mem;
    break;
  case 'D':

    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'H':

    __beg = _M_extract_num(__beg, __end, __mem, 0, 23, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_hour = __mem;
    break;
  case 'I':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_hour = __mem;
    break;
  case 'm':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':

    __beg = _M_extract_num(__beg, __end, __mem, 0, 59, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_min = __mem;
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'R':

    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'S':



    __beg = _M_extract_num(__beg, __end, __mem, 0, 60, 2,



      __io, __tmperr);
    if (!__tmperr)
    __tm->tm_sec = __mem;
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'T':

    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'x':

    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dates[0]);
    break;
  case 'X':

    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':

  case 'Y':




    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_year = __mem < 0 ? __mem + 100 : __mem - 1900;
    break;
  case 'Z':

    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __tmperr);


        if (__beg != __end && !__tmperr && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __tmperr);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __tmperr);
   }
      }
    else
      __tmperr |= ios_base::failbit;
    break;
  default:

    __tmperr |= ios_base::failbit;
  }
     }
   else
     {

       if (__format[__i] == *__beg)
  ++__beg;
       else
  __tmperr |= ios_base::failbit;
     }
 }

      if (__tmperr || __i != __len)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);

      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, (void)++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;

      else if (__len == 4 && __i == 2)
 __member = __value - 100;
      else
 __err |= ios_base::failbit;

      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;





      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }

      while (__nmatches > 1)
 {

   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg;
   ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (!(__name[__pos] == *__beg))
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }

      if (__nmatches == 1)
 {

   ++__beg;
   ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, (void)++__pos;

   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(2 * sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t* __matches_lengths = 0;
      size_t __pos = 0;

      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < 2 * __indexlen; ++__i)
     if (__c == __names[__i][0]
  || __c == __ctype.toupper(__names[__i][0]))
       __matches[__nmatches++] = __i;
 }

      if (__nmatches)
 {
   ++__beg;
   ++__pos;

   __matches_lengths
     = static_cast<size_t*>(__builtin_alloca(sizeof(size_t)
          * __nmatches));
   for (size_t __i = 0; __i < __nmatches; ++__i)
     __matches_lengths[__i]
       = __traits_type::length(__names[__matches[__i]]);
 }

      for (; __beg != __end; ++__beg, (void)++__pos)
 {
   size_t __nskipped = 0;
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < __nmatches;)
     {
       const char_type* __name = __names[__matches[__i]];
       if (__pos >= __matches_lengths[__i])
  ++__nskipped, ++__i;
       else if (!(__name[__pos] == __c))
  {
    --__nmatches;
    __matches[__i] = __matches[__nmatches];
    __matches_lengths[__i] = __matches_lengths[__nmatches];
  }
       else
  ++__i;
     }
   if (__nskipped == __nmatches)
     break;
 }

      if ((__nmatches == 1 && __matches_lengths[0] == __pos)
   || (__nmatches == 2 && (__matches_lengths[0] == __pos
      || __matches_lengths[1] == __pos)))
 __member = (__matches[0] >= __indexlen
      ? __matches[0] - __indexlen : __matches[0]);
      else
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[14];
      __tp._M_days_abbreviated(__days);
      __tp._M_days(__days + 7);
      int __tmpwday;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpwday, __days, 7,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_wday = __tmpwday;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[24];
      __tp._M_months_abbreviated(__months);
      __tp._M_months(__months + 12);
      int __tmpmon;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpmon, __months, 12,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_mon = __tmpmon;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      int __tmpyear;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_num(__beg, __end, __tmpyear, 0, 9999, 4,
        __io, __tmperr);
      if (!__tmperr)
 __tm->tm_year = __tmpyear < 0 ? __tmpyear + 100 : __tmpyear - 1900;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    inline
    _InIter
    time_get<_CharT, _InIter>::
    get(iter_type __s, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm, const char_type* __fmt,
        const char_type* __fmtend) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __err = ios_base::goodbit;
      while (__fmt != __fmtend &&
             __err == ios_base::goodbit)
        {
          if (__s == __end)
            {
              __err = ios_base::eofbit | ios_base::failbit;
              break;
            }
          else if (__ctype.narrow(*__fmt, 0) == '%')
            {
              char __format;
              char __mod = 0;
              if (++__fmt == __fmtend)
                {
                  __err = ios_base::failbit;
                  break;
                }
              const char __c = __ctype.narrow(*__fmt, 0);
              if (__c != 'E' && __c != 'O')
                __format = __c;
              else if (++__fmt != __fmtend)
                {
                  __mod = __c;
                  __format = __ctype.narrow(*__fmt, 0);
                }
              else
                {
                  __err = ios_base::failbit;
                  break;
                }
              __s = this->do_get(__s, __end, __io, __err, __tm, __format,
     __mod);
              ++__fmt;
            }
          else if (__ctype.is(ctype_base::space, *__fmt))
            {
              ++__fmt;
              while (__fmt != __fmtend &&
                     __ctype.is(ctype_base::space, *__fmt))
                ++__fmt;

              while (__s != __end &&
                     __ctype.is(ctype_base::space, *__s))
                ++__s;
            }

          else if (__ctype.tolower(*__s) == __ctype.tolower(*__fmt) ||
                   __ctype.toupper(*__s) == __ctype.toupper(*__fmt))
            {
              ++__s;
              ++__fmt;
            }
          else
            {
              __err = ios_base::failbit;
              break;
            }
        }
      return __s;
    }

  template<typename _CharT, typename _InIter>
    inline
    _InIter
    time_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, tm* __tm,
           char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __err = ios_base::goodbit;

      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
        {
          __fmt[1] = __format;
          __fmt[2] = char_type();
        }
      else
        {
          __fmt[1] = __mod;
          __fmt[2] = __format;
          __fmt[3] = char_type();
        }

      __beg = _M_extract_via_format(__beg, __end, __io, __err, __tm, __fmt);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 128;
      char_type __res[__maxlen];






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }





  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class __cxx11:: money_get<char>;
  extern template class __cxx11:: money_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);


  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class __cxx11:: money_get<wchar_t>;
  extern template class __cxx11:: money_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;

  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);

  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);

  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);

  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);

  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);

  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);

  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);




}
# 2014 "/usr/include/c++/7/bits/locale_facets_nonio.h" 2 3
# 42 "/usr/include/c++/7/locale" 2 3

# 1 "/usr/include/c++/7/bits/locale_conv.h" 1 3
# 38 "/usr/include/c++/7/bits/locale_conv.h" 3
# 1 "/usr/include/c++/7/bits/stringfwd.h" 1 3
# 39 "/usr/include/c++/7/bits/locale_conv.h" 2 3
# 1 "/usr/include/c++/7/bits/allocator.h" 1 3
# 40 "/usr/include/c++/7/bits/locale_conv.h" 2 3
# 1 "/usr/include/c++/7/bits/codecvt.h" 1 3
# 41 "/usr/include/c++/7/bits/locale_conv.h" 2 3
# 1 "/usr/include/c++/7/bits/unique_ptr.h" 1 3
# 41 "/usr/include/c++/7/bits/unique_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{








  template<typename> class auto_ptr;



  template<typename _Tp>
    struct default_delete
    {

      constexpr default_delete() noexcept = default;






      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }


      void
      operator()(_Tp* __ptr) const
      {
 static_assert(!is_void<_Tp>::value,
        "can't delete pointer to incomplete type");
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete __ptr;
      }
    };




  template<typename _Tp>
    struct default_delete<_Tp[]>
    {
    public:

      constexpr default_delete() noexcept = default;
# 101 "/usr/include/c++/7/bits/unique_ptr.h" 3
      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type>
        default_delete(const default_delete<_Up[]>&) noexcept { }


      template<typename _Up>
      typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type
 operator()(_Up* __ptr) const
      {
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete [] __ptr;
      }
    };

  template <typename _Tp, typename _Dp>
    class __uniq_ptr_impl
    {
      template <typename _Up, typename _Ep, typename = void>
 struct _Ptr
 {
   using type = _Up*;
 };

      template <typename _Up, typename _Ep>
 struct
 _Ptr<_Up, _Ep, __void_t<typename remove_reference<_Ep>::type::pointer>>
 {
   using type = typename remove_reference<_Ep>::type::pointer;
 };

    public:
      using _DeleterConstraint = enable_if<
        __and_<__not_<is_pointer<_Dp>>,
        is_default_constructible<_Dp>>::value>;

      using pointer = typename _Ptr<_Tp, _Dp>::type;

      __uniq_ptr_impl() = default;
      __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }

      template<typename _Del>
      __uniq_ptr_impl(pointer __p, _Del&& __d)
 : _M_t(__p, std::forward<_Del>(__d)) { }

      pointer& _M_ptr() { return std::get<0>(_M_t); }
      pointer _M_ptr() const { return std::get<0>(_M_t); }
      _Dp& _M_deleter() { return std::get<1>(_M_t); }
      const _Dp& _M_deleter() const { return std::get<1>(_M_t); }

    private:
      tuple<pointer, _Dp> _M_t;
    };


  template <typename _Tp, typename _Dp = default_delete<_Tp>>
    class unique_ptr
    {
      template <class _Up>
      using _DeleterConstraint =
 typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

      __uniq_ptr_impl<_Tp, _Dp> _M_t;

    public:
      using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
      using element_type = _Tp;
      using deleter_type = _Dp;



      template<typename _Up, typename _Ep>
 using __safe_conversion_up = __and_<
         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
                __not_<is_array<_Up>>,
                __or_<__and_<is_reference<deleter_type>,
                             is_same<deleter_type, _Ep>>,
                      __and_<__not_<is_reference<deleter_type>>,
                             is_convertible<_Ep, deleter_type>>
                >
              >;




      template <typename _Up = _Dp,
  typename = _DeleterConstraint<_Up>>
 constexpr unique_ptr() noexcept
 : _M_t()
 { }







      template <typename _Up = _Dp,
  typename = _DeleterConstraint<_Up>>
 explicit
 unique_ptr(pointer __p) noexcept
 : _M_t(__p)
        { }
# 212 "/usr/include/c++/7/bits/unique_ptr.h" 3
      unique_ptr(pointer __p,
   typename conditional<is_reference<deleter_type>::value,
     deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
# 224 "/usr/include/c++/7/bits/unique_ptr.h" 3
      unique_ptr(pointer __p,
   typename remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!std::is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      template <typename _Up = _Dp,
  typename = _DeleterConstraint<_Up>>
 constexpr unique_ptr(nullptr_t) noexcept : _M_t() { }




      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }







      template<typename _Up, typename _Ep, typename = _Require<
               __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }



      template<typename _Up, typename = _Require<
        is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
 unique_ptr(auto_ptr<_Up>&& __u) noexcept;



      ~unique_ptr() noexcept
      {
 auto& __ptr = _M_t._M_ptr();
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
# 280 "/usr/include/c++/7/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
# 295 "/usr/include/c++/7/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
        typename enable_if< __and_<
          __safe_conversion_up<_Up, _Ep>,
          is_assignable<deleter_type&, _Ep&&>
          >::value,
          unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename add_lvalue_reference<element_type>::type
      operator*() const
      {
 ;
 return *get();
      }


      pointer
      operator->() const noexcept
      {
 ;
 return get();
      }


      pointer
      get() const noexcept
      { return _M_t._M_ptr(); }


      deleter_type&
      get_deleter() noexcept
      { return _M_t._M_deleter(); }


      const deleter_type&
      get_deleter() const noexcept
      { return _M_t._M_deleter(); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 _M_t._M_ptr() = pointer();
 return __p;
      }







      void
      reset(pointer __p = pointer()) noexcept
      {
 using std::swap;
 swap(_M_t._M_ptr(), __p);
 if (__p != pointer())
   get_deleter()(__p);
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
  };





  template<typename _Tp, typename _Dp>
    class unique_ptr<_Tp[], _Dp>
    {
      template <typename _Up>
      using _DeleterConstraint =
 typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

      __uniq_ptr_impl<_Tp, _Dp> _M_t;

      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;

    public:
      using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
      using element_type = _Tp;
      using deleter_type = _Dp;



      template<typename _Up, typename _Ep,
               typename _Up_up = unique_ptr<_Up, _Ep>,
        typename _Up_element_type = typename _Up_up::element_type>
 using __safe_conversion_up = __and_<
          is_array<_Up>,
          is_same<pointer, element_type*>,
          is_same<typename _Up_up::pointer, _Up_element_type*>,
          is_convertible<_Up_element_type(*)[], element_type(*)[]>,
          __or_<__and_<is_reference<deleter_type>, is_same<deleter_type, _Ep>>,
                __and_<__not_<is_reference<deleter_type>>,
                       is_convertible<_Ep, deleter_type>>>
        >;


      template<typename _Up>
        using __safe_conversion_raw = __and_<
          __or_<__or_<is_same<_Up, pointer>,
                      is_same<_Up, nullptr_t>>,
                __and_<is_pointer<_Up>,
                       is_same<pointer, element_type*>,
                       is_convertible<
                         typename remove_pointer<_Up>::type(*)[],
                         element_type(*)[]>
                >
          >
        >;




      template <typename _Up = _Dp,
  typename = _DeleterConstraint<_Up>>
 constexpr unique_ptr() noexcept
 : _M_t()
 { }
# 464 "/usr/include/c++/7/bits/unique_ptr.h" 3
      template<typename _Up,
        typename _Vp = _Dp,
        typename = _DeleterConstraint<_Vp>,
        typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
 explicit
 unique_ptr(_Up __p) noexcept
 : _M_t(__p)
        { }
# 482 "/usr/include/c++/7/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      unique_ptr(_Up __p,
                 typename conditional<is_reference<deleter_type>::value,
                 deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
# 498 "/usr/include/c++/7/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      unique_ptr(_Up __p, typename
   remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }


      template <typename _Up = _Dp,
  typename = _DeleterConstraint<_Up>>
 constexpr unique_ptr(nullptr_t) noexcept : _M_t() { }

      template<typename _Up, typename _Ep,
        typename = _Require<__safe_conversion_up<_Up, _Ep>>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


      ~unique_ptr()
      {
 auto& __ptr = _M_t._M_ptr();
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
# 539 "/usr/include/c++/7/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
# 554 "/usr/include/c++/7/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
 typename
 enable_if<__and_<__safe_conversion_up<_Up, _Ep>,
                         is_assignable<deleter_type&, _Ep&&>
                  >::value,
                  unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename std::add_lvalue_reference<element_type>::type
      operator[](size_t __i) const
      {
 ;
 return get()[__i];
      }


      pointer
      get() const noexcept
      { return _M_t._M_ptr(); }


      deleter_type&
      get_deleter() noexcept
      { return _M_t._M_deleter(); }


      const deleter_type&
      get_deleter() const noexcept
      { return _M_t._M_deleter(); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 _M_t._M_ptr() = pointer();
 return __p;
      }







      template <typename _Up,
                typename = _Require<
                  __or_<is_same<_Up, pointer>,
                        __and_<is_same<pointer, element_type*>,
                               is_pointer<_Up>,
                               is_convertible<
                                 typename remove_pointer<_Up>::type(*)[],
                                 element_type(*)[]
                               >
                        >
                  >
               >>
      void
      reset(_Up __p) noexcept
      {
 pointer __ptr = __p;
 using std::swap;
 swap(_M_t._M_ptr(), __ptr);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
      }

      void reset(nullptr_t = nullptr) noexcept
      {
        reset(pointer());
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
    };

  template<typename _Tp, typename _Dp>
    inline


    typename enable_if<__is_swappable<_Dp>::value>::type



    swap(unique_ptr<_Tp, _Dp>& __x,
  unique_ptr<_Tp, _Dp>& __y) noexcept
    { __x.swap(__y); }


  template<typename _Tp, typename _Dp>
    typename enable_if<!__is_swappable<_Dp>::value>::type
    swap(unique_ptr<_Tp, _Dp>&,
  unique_ptr<_Tp, _Dp>&) = delete;


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() == __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() != __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    {
      typedef typename
 std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                  typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
      return std::less<_CT>()(__x.get(), __y.get());
    }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(nullptr < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    { return (__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(nullptr < __x); }


  template<typename _Tp, typename _Dp>
    struct hash<unique_ptr<_Tp, _Dp>>
    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>,
    private __poison_hash<typename unique_ptr<_Tp, _Dp>::pointer>
    {
      size_t
      operator()(const unique_ptr<_Tp, _Dp>& __u) const noexcept
      {
 typedef unique_ptr<_Tp, _Dp> _UP;
 return std::hash<typename _UP::pointer>()(__u.get());
      }
    };





  template<typename _Tp>
    struct _MakeUniq
    { typedef unique_ptr<_Tp> __single_object; };

  template<typename _Tp>
    struct _MakeUniq<_Tp[]>
    { typedef unique_ptr<_Tp[]> __array; };

  template<typename _Tp, size_t _Bound>
    struct _MakeUniq<_Tp[_Bound]>
    { struct __invalid_type { }; };


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__single_object
    make_unique(_Args&&... __args)
    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }


  template<typename _Tp>
    inline typename _MakeUniq<_Tp>::__array
    make_unique(size_t __num)
    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__invalid_type
    make_unique(_Args&&...) = delete;





}
# 42 "/usr/include/c++/7/bits/locale_conv.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _OutStr, typename _InChar, typename _Codecvt,
    typename _State, typename _Fn>
    bool
    __do_str_codecvt(const _InChar* __first, const _InChar* __last,
       _OutStr& __outstr, const _Codecvt& __cvt, _State& __state,
       size_t& __count, _Fn __fn)
    {
      if (__first == __last)
 {
   __outstr.clear();
   __count = 0;
   return true;
 }

      size_t __outchars = 0;
      auto __next = __first;
      const auto __maxlen = __cvt.max_length() + 1;

      codecvt_base::result __result;
      do
 {
   __outstr.resize(__outstr.size() + (__last - __next) * __maxlen);
   auto __outnext = &__outstr.front() + __outchars;
   auto const __outlast = &__outstr.back() + 1;
   __result = (__cvt.*__fn)(__state, __next, __last, __next,
     __outnext, __outlast, __outnext);
   __outchars = __outnext - &__outstr.front();
 }
      while (__result == codecvt_base::partial && __next != __last
      && (__outstr.size() - __outchars) < __maxlen);

      if (__result == codecvt_base::error)
 {
   __count = __next - __first;
   return false;
 }

      if (__result == codecvt_base::noconv)
 {
   __outstr.assign(__first, __last);
   __count = __last - __first;
 }
      else
 {
   __outstr.resize(__outchars);
   __count = __next - __first;
 }

      return true;
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_in(const char* __first, const char* __last,
       basic_string<_CharT, _Traits, _Alloc>& __outstr,
       const codecvt<_CharT, char, _State>& __cvt,
       _State& __state, size_t& __count)
    {
      using _Codecvt = codecvt<_CharT, char, _State>;
      using _ConvFn
 = codecvt_base::result
   (_Codecvt::*)(_State&, const char*, const char*, const char*&,
   _CharT*, _CharT*, _CharT*&) const;
      _ConvFn __fn = &codecvt<_CharT, char, _State>::in;
      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,
         __count, __fn);
    }

  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_in(const char* __first, const char* __last,
       basic_string<_CharT, _Traits, _Alloc>& __outstr,
       const codecvt<_CharT, char, _State>& __cvt)
    {
      _State __state = {};
      size_t __n;
      return __str_codecvt_in(__first, __last, __outstr, __cvt, __state, __n);
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_out(const _CharT* __first, const _CharT* __last,
        basic_string<char, _Traits, _Alloc>& __outstr,
        const codecvt<_CharT, char, _State>& __cvt,
        _State& __state, size_t& __count)
    {
      using _Codecvt = codecvt<_CharT, char, _State>;
      using _ConvFn
 = codecvt_base::result
   (_Codecvt::*)(_State&, const _CharT*, const _CharT*, const _CharT*&,
   char*, char*, char*&) const;
      _ConvFn __fn = &codecvt<_CharT, char, _State>::out;
      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,
         __count, __fn);
    }

  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_out(const _CharT* __first, const _CharT* __last,
        basic_string<char, _Traits, _Alloc>& __outstr,
        const codecvt<_CharT, char, _State>& __cvt)
    {
      _State __state = {};
      size_t __n;
      return __str_codecvt_out(__first, __last, __outstr, __cvt, __state, __n);
    }



namespace __cxx11 {


  template<typename _Codecvt, typename _Elem = wchar_t,
    typename _Wide_alloc = allocator<_Elem>,
    typename _Byte_alloc = allocator<char>>
    class wstring_convert
    {
    public:
      typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
      typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
      typedef typename _Codecvt::state_type state_type;
      typedef typename wide_string::traits_type::int_type int_type;







      explicit
      wstring_convert(_Codecvt* __pcvt = new _Codecvt()) : _M_cvt(__pcvt)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }
# 198 "/usr/include/c++/7/bits/locale_conv.h" 3
      wstring_convert(_Codecvt* __pcvt, state_type __state)
      : _M_cvt(__pcvt), _M_state(__state), _M_with_cvtstate(true)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }






      explicit
      wstring_convert(const byte_string& __byte_err,
        const wide_string& __wide_err = wide_string())
      : _M_cvt(new _Codecvt),
 _M_byte_err_string(__byte_err), _M_wide_err_string(__wide_err),
 _M_with_strings(true)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }

      ~wstring_convert() = default;



      wstring_convert(const wstring_convert&) = delete;
      wstring_convert& operator=(const wstring_convert&) = delete;


      wide_string
      from_bytes(char __byte)
      {
 char __bytes[2] = { __byte };
 return from_bytes(__bytes, __bytes+1);
      }

      wide_string
      from_bytes(const char* __ptr)
      { return from_bytes(__ptr, __ptr+char_traits<char>::length(__ptr)); }

      wide_string
      from_bytes(const byte_string& __str)
      {
 auto __ptr = __str.data();
 return from_bytes(__ptr, __ptr + __str.size());
      }

      wide_string
      from_bytes(const char* __first, const char* __last)
      {
 if (!_M_with_cvtstate)
   _M_state = state_type();
 wide_string __out{ _M_wide_err_string.get_allocator() };
 if (__str_codecvt_in(__first, __last, __out, *_M_cvt, _M_state,
        _M_count))
   return __out;
 if (_M_with_strings)
   return _M_wide_err_string;
 __throw_range_error("wstring_convert::from_bytes");
      }



      byte_string
      to_bytes(_Elem __wchar)
      {
 _Elem __wchars[2] = { __wchar };
 return to_bytes(__wchars, __wchars+1);
      }

      byte_string
      to_bytes(const _Elem* __ptr)
      {
 return to_bytes(__ptr, __ptr+wide_string::traits_type::length(__ptr));
      }

      byte_string
      to_bytes(const wide_string& __wstr)
      {
 auto __ptr = __wstr.data();
 return to_bytes(__ptr, __ptr + __wstr.size());
      }

      byte_string
      to_bytes(const _Elem* __first, const _Elem* __last)
      {
 if (!_M_with_cvtstate)
   _M_state = state_type();
 byte_string __out{ _M_byte_err_string.get_allocator() };
 if (__str_codecvt_out(__first, __last, __out, *_M_cvt, _M_state,
         _M_count))
   return __out;
 if (_M_with_strings)
   return _M_byte_err_string;
 __throw_range_error("wstring_convert::to_bytes");
      }





      size_t converted() const noexcept { return _M_count; }


      state_type state() const { return _M_state; }

    private:
      unique_ptr<_Codecvt> _M_cvt;
      byte_string _M_byte_err_string;
      wide_string _M_wide_err_string;
      state_type _M_state = state_type();
      size_t _M_count = 0;
      bool _M_with_cvtstate = false;
      bool _M_with_strings = false;
    };

}


  template<typename _Codecvt, typename _Elem = wchar_t,
    typename _Tr = char_traits<_Elem>>
    class wbuffer_convert : public basic_streambuf<_Elem, _Tr>
    {
      typedef basic_streambuf<_Elem, _Tr> _Wide_streambuf;

    public:
      typedef typename _Codecvt::state_type state_type;
# 336 "/usr/include/c++/7/bits/locale_conv.h" 3
      explicit
      wbuffer_convert(streambuf* __bytebuf = 0, _Codecvt* __pcvt = new _Codecvt,
        state_type __state = state_type())
      : _M_buf(__bytebuf), _M_cvt(__pcvt), _M_state(__state)
      {
 if (!_M_cvt)
   __throw_logic_error("wbuffer_convert");

 _M_always_noconv = _M_cvt->always_noconv();

 if (_M_buf)
   {
     this->setp(_M_put_area, _M_put_area + _S_buffer_length);
     this->setg(_M_get_area + _S_putback_length,
         _M_get_area + _S_putback_length,
         _M_get_area + _S_putback_length);
   }
      }

      ~wbuffer_convert() = default;



      wbuffer_convert(const wbuffer_convert&) = delete;
      wbuffer_convert& operator=(const wbuffer_convert&) = delete;

      streambuf* rdbuf() const noexcept { return _M_buf; }

      streambuf*
      rdbuf(streambuf *__bytebuf) noexcept
      {
 auto __prev = _M_buf;
 _M_buf = __bytebuf;
 return __prev;
      }


      state_type state() const noexcept { return _M_state; }

    protected:
      int
      sync()
      { return _M_buf && _M_conv_put() && !_M_buf->pubsync() ? 0 : -1; }

      typename _Wide_streambuf::int_type
      overflow(typename _Wide_streambuf::int_type __out)
      {
 if (!_M_buf || !_M_conv_put())
   return _Tr::eof();
 else if (!_Tr::eq_int_type(__out, _Tr::eof()))
   return this->sputc(__out);
 return _Tr::not_eof(__out);
      }

      typename _Wide_streambuf::int_type
      underflow()
      {
 if (!_M_buf)
   return _Tr::eof();

 if (this->gptr() < this->egptr() || (_M_buf && _M_conv_get()))
   return _Tr::to_int_type(*this->gptr());
 else
   return _Tr::eof();
      }

      streamsize
      xsputn(const typename _Wide_streambuf::char_type* __s, streamsize __n)
      {
 if (!_M_buf || __n == 0)
   return 0;
 streamsize __done = 0;
 do
 {
   auto __nn = std::min<streamsize>(this->epptr() - this->pptr(),
        __n - __done);
   _Tr::copy(this->pptr(), __s + __done, __nn);
   this->pbump(__nn);
   __done += __nn;
 } while (__done < __n && _M_conv_put());
 return __done;
      }

    private:

      bool
      _M_conv_get()
      {
 const streamsize __pb1 = this->gptr() - this->eback();
 const streamsize __pb2 = _S_putback_length;
 const streamsize __npb = std::min(__pb1, __pb2);

 _Tr::move(_M_get_area + _S_putback_length - __npb,
    this->gptr() - __npb, __npb);

 streamsize __nbytes = sizeof(_M_get_buf) - _M_unconv;
 __nbytes = std::min(__nbytes, _M_buf->in_avail());
 if (__nbytes < 1)
   __nbytes = 1;
 __nbytes = _M_buf->sgetn(_M_get_buf + _M_unconv, __nbytes);
 if (__nbytes < 1)
   return false;
 __nbytes += _M_unconv;



 _Elem* __outbuf = _M_get_area + _S_putback_length;
 _Elem* __outnext = __outbuf;
 const char* __bnext = _M_get_buf;

 codecvt_base::result __result;
 if (_M_always_noconv)
   __result = codecvt_base::noconv;
 else
   {
     _Elem* __outend = _M_get_area + _S_buffer_length;

     __result = _M_cvt->in(_M_state,
      __bnext, __bnext + __nbytes, __bnext,
      __outbuf, __outend, __outnext);
   }

 if (__result == codecvt_base::noconv)
   {

     auto __get_buf = reinterpret_cast<const _Elem*>(_M_get_buf);
     _Tr::copy(__outbuf, __get_buf, __nbytes);
     _M_unconv = 0;
     return true;
   }

 if ((_M_unconv = _M_get_buf + __nbytes - __bnext))
   char_traits<char>::move(_M_get_buf, __bnext, _M_unconv);

 this->setg(__outbuf, __outbuf, __outnext);

 return __result != codecvt_base::error;
      }


      bool
      _M_put(...)
      { return false; }

      bool
      _M_put(const char* __p, streamsize __n)
      {
 if (_M_buf->sputn(__p, __n) < __n)
   return false;
 return true;
      }


      bool
      _M_conv_put()
      {
 _Elem* const __first = this->pbase();
 const _Elem* const __last = this->pptr();
 const streamsize __pending = __last - __first;

 if (_M_always_noconv)
   return _M_put(__first, __pending);

 char __outbuf[2 * _S_buffer_length];

 const _Elem* __next = __first;
 const _Elem* __start;
 do
   {
     __start = __next;
     char* __outnext = __outbuf;
     char* const __outlast = __outbuf + sizeof(__outbuf);
     auto __result = _M_cvt->out(_M_state, __next, __last, __next,
     __outnext, __outlast, __outnext);
     if (__result == codecvt_base::error)
       return false;
     else if (__result == codecvt_base::noconv)
       return _M_put(__next, __pending);

     if (!_M_put(__outbuf, __outnext - __outbuf))
       return false;
   }
 while (__next != __last && __next != __start);

 if (__next != __last)
   _Tr::move(__first, __next, __last - __next);

 this->pbump(__first - __next);
 return __next != __first;
      }

      streambuf* _M_buf;
      unique_ptr<_Codecvt> _M_cvt;
      state_type _M_state;

      static const streamsize _S_buffer_length = 32;
      static const streamsize _S_putback_length = 3;
      _Elem _M_put_area[_S_buffer_length];
      _Elem _M_get_area[_S_buffer_length];
      streamsize _M_unconv = 0;
      char _M_get_buf[_S_buffer_length-_S_putback_length];
      bool _M_always_noconv;
    };






}
# 44 "/usr/include/c++/7/locale" 2 3
# 44 "/usr/include/c++/7/iomanip" 2 3

# 1 "/usr/include/c++/7/bits/quoted_string.h" 1 3
# 33 "/usr/include/c++/7/bits/quoted_string.h" 3
       
# 34 "/usr/include/c++/7/bits/quoted_string.h" 3






namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace __detail {
 




    template<typename _String, typename _CharT>
      struct _Quoted_string
      {
 static_assert(is_reference<_String>::value
     || is_pointer<_String>::value,
        "String type must be pointer or reference");

 _Quoted_string(_String __str, _CharT __del, _CharT __esc)
 : _M_string(__str), _M_delim{__del}, _M_escape{__esc}
 { }

 _Quoted_string&
 operator=(_Quoted_string&) = delete;

 _String _M_string;
 _CharT _M_delim;
 _CharT _M_escape;
      };







    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
   const _Quoted_string<const _CharT*, _CharT>& __str)
      {
 std::basic_ostringstream<_CharT, _Traits> __ostr;
 __ostr << __str._M_delim;
 for (const _CharT* __c = __str._M_string; *__c; ++__c)
   {
     if (*__c == __str._M_delim || *__c == __str._M_escape)
       __ostr << __str._M_escape;
     __ostr << *__c;
   }
 __ostr << __str._M_delim;

 return __os << __ostr.str();
      }







    template<typename _CharT, typename _Traits, typename _String>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
   const _Quoted_string<_String, _CharT>& __str)
      {
 std::basic_ostringstream<_CharT, _Traits> __ostr;
 __ostr << __str._M_delim;
 for (auto& __c : __str._M_string)
   {
     if (__c == __str._M_delim || __c == __str._M_escape)
       __ostr << __str._M_escape;
     __ostr << __c;
   }
 __ostr << __str._M_delim;

 return __os << __ostr.str();
      }





    template<typename _CharT, typename _Traits, typename _Alloc>
      std::basic_istream<_CharT, _Traits>&
      operator>>(std::basic_istream<_CharT, _Traits>& __is,
   const _Quoted_string<basic_string<_CharT, _Traits, _Alloc>&,
          _CharT>& __str)
      {
 _CharT __c;
 __is >> __c;
 if (!__is.good())
   return __is;
 if (__c != __str._M_delim)
   {
     __is.unget();
     __is >> __str._M_string;
     return __is;
   }
 __str._M_string.clear();
 std::ios_base::fmtflags __flags
   = __is.flags(__is.flags() & ~std::ios_base::skipws);
 do
   {
     __is >> __c;
     if (!__is.good())
       break;
     if (__c == __str._M_escape)
       {
  __is >> __c;
  if (!__is.good())
    break;
       }
     else if (__c == __str._M_delim)
       break;
     __str._M_string += __c;
   }
 while (true);
 __is.setf(__flags);

 return __is;
      }

 
  }
}
# 46 "/usr/include/c++/7/iomanip" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{





  struct _Resetiosflags { ios_base::fmtflags _M_mask; };
# 65 "/usr/include/c++/7/iomanip" 3
  inline _Resetiosflags
  resetiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Resetiosflags __f)
    {
      __is.setf(ios_base::fmtflags(0), __f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Resetiosflags __f)
    {
      __os.setf(ios_base::fmtflags(0), __f._M_mask);
      return __os;
    }


  struct _Setiosflags { ios_base::fmtflags _M_mask; };
# 95 "/usr/include/c++/7/iomanip" 3
  inline _Setiosflags
  setiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setiosflags __f)
    {
      __is.setf(__f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setiosflags __f)
    {
      __os.setf(__f._M_mask);
      return __os;
    }


  struct _Setbase { int _M_base; };
# 126 "/usr/include/c++/7/iomanip" 3
  inline _Setbase
  setbase(int __base)
  { return { __base }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setbase __f)
    {
      __is.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setbase __f)
    {
      __os.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __os;
    }


  template<typename _CharT>
    struct _Setfill { _CharT _M_c; };
# 163 "/usr/include/c++/7/iomanip" 3
  template<typename _CharT>
    inline _Setfill<_CharT>
    setfill(_CharT __c)
    { return { __c }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setfill<_CharT> __f)
    {
      __is.fill(__f._M_c);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setfill<_CharT> __f)
    {
      __os.fill(__f._M_c);
      return __os;
    }


  struct _Setprecision { int _M_n; };
# 194 "/usr/include/c++/7/iomanip" 3
  inline _Setprecision
  setprecision(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setprecision __f)
    {
      __is.precision(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setprecision __f)
    {
      __os.precision(__f._M_n);
      return __os;
    }


  struct _Setw { int _M_n; };
# 224 "/usr/include/c++/7/iomanip" 3
  inline _Setw
  setw(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setw __f)
    {
      __is.width(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setw __f)
    {
      __os.width(__f._M_n);
      return __os;
    }



  template<typename _MoneyT>
    struct _Get_money { _MoneyT& _M_mon; bool _M_intl; };
# 257 "/usr/include/c++/7/iomanip" 3
  template<typename _MoneyT>
    inline _Get_money<_MoneyT>
    get_money(_MoneyT& __mon, bool __intl = false)
    { return { __mon, __intl }; }

  template<typename _CharT, typename _Traits, typename _MoneyT>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_money<_MoneyT> __f)
    {
      typename basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       typedef istreambuf_iterator<_CharT, _Traits> _Iter;
       typedef money_get<_CharT, _Iter> _MoneyGet;

       const _MoneyGet& __mg = use_facet<_MoneyGet>(__is.getloc());
       __mg.get(_Iter(__is.rdbuf()), _Iter(), __f._M_intl,
         __is, __err, __f._M_mon);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __is._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __is._M_setstate(ios_base::badbit); }
   if (__err)
     __is.setstate(__err);
 }
      return __is;
    }


  template<typename _MoneyT>
    struct _Put_money { const _MoneyT& _M_mon; bool _M_intl; };
# 304 "/usr/include/c++/7/iomanip" 3
  template<typename _MoneyT>
    inline _Put_money<_MoneyT>
    put_money(const _MoneyT& __mon, bool __intl = false)
    { return { __mon, __intl }; }

  template<typename _CharT, typename _Traits, typename _MoneyT>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_money<_MoneyT> __f)
    {
      typename basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       typedef ostreambuf_iterator<_CharT, _Traits> _Iter;
       typedef money_put<_CharT, _Iter> _MoneyPut;

       const _MoneyPut& __mp = use_facet<_MoneyPut>(__os.getloc());
       if (__mp.put(_Iter(__os.rdbuf()), __f._M_intl, __os,
      __os.fill(), __f._M_mon).failed())
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __os._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __os._M_setstate(ios_base::badbit); }
   if (__err)
     __os.setstate(__err);
 }
      return __os;
    }

  template<typename _CharT>
    struct _Put_time
    {
      const std::tm* _M_tmb;
      const _CharT* _M_fmt;
    };
# 356 "/usr/include/c++/7/iomanip" 3
  template<typename _CharT>
    inline _Put_time<_CharT>
    put_time(const std::tm* __tmb, const _CharT* __fmt)
    { return { __tmb, __fmt }; }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_time<_CharT> __f)
    {
      typename basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
      if (__cerb)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              typedef ostreambuf_iterator<_CharT, _Traits> _Iter;
              typedef time_put<_CharT, _Iter> _TimePut;

              const _CharT* const __fmt_end = __f._M_fmt +
                _Traits::length(__f._M_fmt);

              const _TimePut& __mp = use_facet<_TimePut>(__os.getloc());
              if (__mp.put(_Iter(__os.rdbuf()), __os, __os.fill(),
                           __f._M_tmb, __f._M_fmt, __fmt_end).failed())
                __err |= ios_base::badbit;
            }
          catch(__cxxabiv1::__forced_unwind&)
            {
              __os._M_setstate(ios_base::badbit);
              throw;
            }
          catch(...)
            { __os._M_setstate(ios_base::badbit); }
          if (__err)
            __os.setstate(__err);
        }
      return __os;
    }

  template<typename _CharT>
    struct _Get_time
    {
      std::tm* _M_tmb;
      const _CharT* _M_fmt;
    };
# 411 "/usr/include/c++/7/iomanip" 3
  template<typename _CharT>
    inline _Get_time<_CharT>
    get_time(std::tm* __tmb, const _CharT* __fmt)
    { return { __tmb, __fmt }; }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_time<_CharT> __f)
    {
      typename basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
      if (__cerb)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              typedef istreambuf_iterator<_CharT, _Traits> _Iter;
              typedef time_get<_CharT, _Iter> _TimeGet;

              const _CharT* const __fmt_end = __f._M_fmt +
                _Traits::length(__f._M_fmt);

              const _TimeGet& __mg = use_facet<_TimeGet>(__is.getloc());
              __mg.get(_Iter(__is.rdbuf()), _Iter(), __is,
                       __err, __f._M_tmb, __f._M_fmt, __fmt_end);
            }
          catch(__cxxabiv1::__forced_unwind&)
            {
              __is._M_setstate(ios_base::badbit);
              throw;
            }
          catch(...)
            { __is._M_setstate(ios_base::badbit); }
          if (__err)
            __is.setstate(__err);
        }
      return __is;
    }
# 459 "/usr/include/c++/7/iomanip" 3
  template<typename _CharT>
    inline auto
    quoted(const _CharT* __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<const _CharT*, _CharT>(__string, __delim,
            __escape);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline auto
    quoted(const basic_string<_CharT, _Traits, _Alloc>& __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<
   const basic_string<_CharT, _Traits, _Alloc>&, _CharT>(
    __string, __delim, __escape);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline auto
    quoted(basic_string<_CharT, _Traits, _Alloc>& __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<
   basic_string<_CharT, _Traits, _Alloc>&, _CharT>(
    __string, __delim, __escape);
    }
# 496 "/usr/include/c++/7/iomanip" 3
  extern template ostream& operator<<(ostream&, _Setfill<char>);
  extern template ostream& operator<<(ostream&, _Setiosflags);
  extern template ostream& operator<<(ostream&, _Resetiosflags);
  extern template ostream& operator<<(ostream&, _Setbase);
  extern template ostream& operator<<(ostream&, _Setprecision);
  extern template ostream& operator<<(ostream&, _Setw);
  extern template istream& operator>>(istream&, _Setfill<char>);
  extern template istream& operator>>(istream&, _Setiosflags);
  extern template istream& operator>>(istream&, _Resetiosflags);
  extern template istream& operator>>(istream&, _Setbase);
  extern template istream& operator>>(istream&, _Setprecision);
  extern template istream& operator>>(istream&, _Setw);


  extern template wostream& operator<<(wostream&, _Setfill<wchar_t>);
  extern template wostream& operator<<(wostream&, _Setiosflags);
  extern template wostream& operator<<(wostream&, _Resetiosflags);
  extern template wostream& operator<<(wostream&, _Setbase);
  extern template wostream& operator<<(wostream&, _Setprecision);
  extern template wostream& operator<<(wostream&, _Setw);
  extern template wistream& operator>>(wistream&, _Setfill<wchar_t>);
  extern template wistream& operator>>(wistream&, _Setiosflags);
  extern template wistream& operator>>(wistream&, _Resetiosflags);
  extern template wistream& operator>>(wistream&, _Setbase);
  extern template wistream& operator>>(wistream&, _Setprecision);
  extern template wistream& operator>>(wistream&, _Setw);




}
# 17 "/usr/local/include/ibex/ibex_solution_generic.h" 2 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 18 "/usr/local/include/ibex/ibex_solution_generic.h" 2 3
# 1 "/usr/local/include/ibex/ibex_solution.h" 1 3
# 18 "/usr/local/include/ibex/ibex_solution.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 19 "/usr/local/include/ibex/ibex_solution.h" 2 3






namespace ibex{

class solution_j
{
  public:
 IntervalVector* box_j0;
 IntervalVector* box_j1;
 Interval time_j;

 IntervalVector* box_jn;
 IntervalVector* box_jnh;

 Affine2Vector* box_err_aff;

 Affine2Vector* box_jn_aff;
 Affine2Vector* box_jnh_aff;


 double atol;


 double factor;




 IntervalVector picard_euler(IntervalVector y0, ivp_ode* _ode)
 {
   return *box_jn + Interval(0,time_j.diam())*_ode->compute_derivatives_aff(1, Affine2Vector(y0,true)).itv();
 };


 IntervalVector picard_tayl(IntervalVector y0, ivp_ode* _ode, int ordre)
 {
   double h = time_j.diam();
   int n=ordre;
   int fac_i=1;

   Affine2Vector jn = Affine2Vector(*box_jn,true);
   Affine2Vector int_tayl(jn);
   for (int i=1;i<n;i++)
   {
       fac_i = fac_i*i;
       Affine2Vector df = _ode->compute_derivatives_aff(i, jn);
       df*=( 1.0 /fac_i);
       df*=Interval(0,std::pow(h,i));
       int_tayl=int_tayl + df;

   }

   IntervalVector err = _ode->compute_derivatives_aff(n, Affine2Vector(y0,true)).itv();

   fac_i = fac_i*(n);
   err*=(1.0/fac_i);
   err*=Interval(0,std::pow(h,n));

   return int_tayl.itv()+err;
 };


 IntervalVector picard_rk4(IntervalVector y0, ivp_ode* _ode)
 {
   double h = time_j.diam();
   Interval time0h = Interval(0,h);

   Affine2Vector boxj1 = Affine2Vector(*box_jn,true);

   Affine2Vector k1 = _ode->compute_derivatives_aff(1, boxj1);

   Affine2Vector boxj2(k1);
   boxj2*=(0.5*time0h);

   Affine2Vector k2 = _ode->compute_derivatives_aff(1, *box_jn_aff+boxj2);

   Affine2Vector boxj3(k2);
   boxj3*=(0.5*time0h);

   Affine2Vector k3 = _ode->compute_derivatives_aff(1, *box_jn_aff+boxj3);

   Affine2Vector boxj4(k3);
   boxj4*=(time0h);

   Affine2Vector k4 = _ode->compute_derivatives_aff(1, *box_jn_aff+boxj4);

   k2*=(2.0);
   k3*=(2.0);


   Affine2Vector int_rk4 = k1+k2+k3+k4;
   int_rk4*=(time0h/6.0);
   int_rk4+=*box_jn_aff;

 if (_ode->get_lte_computation() == AUTODIF){
     if (!_ode->get_dags()->is_filled_in()){





       ibex::IntervalMatrix A(4, 4, 0.0);
       A[1][0] = 1.0/2;
       A[2][1] = 1.0/2;
       A[3][2] = 1.0;
       Affine2Matrix A_aff(A);
       ibex::IntervalVector b(4);
       b[0] = 1.0/6;
       b[1] = 1.0/3;
       b[2] = 1.0/3;
       b[3] = 1.0/6;
       _ode->set_Butcher_table(A, b);
     }
   Affine2Vector err_aff = _ode->get_dags()->get_lte(5, Affine2Vector(y0,true));
   err_aff*=(pow(time0h,5) / 120);

   IntervalVector err = err_aff.itv();

   return int_rk4.itv()+err;
 } else {
   Affine2Vector err_aff = _ode->computeRK4derivative(Affine2Vector(y0,true));
   err_aff*=(pow(time0h,5) / 120);

   IntervalVector err = err_aff.itv();

   return int_rk4.itv()+err;

 }


 }





 virtual IntervalVector picard(IntervalVector y0, ivp_ode* _ode, int ordre)
 {
   return picard_tayl(y0,_ode,ordre);
 }


 virtual Affine2Vector LTE(IntervalVector y0,ivp_ode* _ode,double h)
 {
     Affine2Vector err_aff = _ode->computeRK4derivative(Affine2Vector(y0,true));
     err_aff*=(std::pow(h,5) / 120);

     return err_aff;
 }


 virtual double factor_stepsize(double test)
 {
   return std::min(1.8,std::max(0.4,0.9*std::pow(1.0/test,0.2)));
 }


 virtual int calcul_jnh(ivp_ode* _ode){


   *box_jnh_aff = remainder_rk4(_ode);

   return 1;
 };





 int calcul_j0(IntervalVector _box_j, ivp_ode* _ode){



   IntervalVector yn_p1 = approx_rk4(*box_jn, time_j.diam(), _ode);
   IntervalVector yn_p0(_box_j);
   yn_p0|=yn_p1;

   double infl = yn_p0.diam().max()*0.1;
   yn_p0.inflate(infl);


   yn_p1 = picard(yn_p0,_ode,3);

   unsigned int iter = 0;
   while ((!yn_p1.is_subset(yn_p0))&&(iter < 8*_ode->nbvar+1))
   {
     iter++;
     yn_p0=yn_p1;




     yn_p1 = picard(yn_p0,_ode,3);
   }




   double h;
   if ((yn_p1).is_subset(yn_p0))
   {

     *box_j0 = yn_p1;


     calcul_j1(_ode);
     yn_p1=*box_j1;

     Affine2Vector err_aff = LTE(yn_p1,_ode, time_j.diam());
     IntervalVector err = err_aff.itv();

     double norm_err = infinite_norm(err);



     double rtol = atol;
     double err_test = atol + infinite_norm(yn_p1)*rtol;

     double test = norm_err/err_test;

     if ((test <= 1.0)||(time_j.diam()<=dynibex_hmin))
     {
       CLogger::getLogger()->inc_accepted_picard();
       CLogger::getLogger()->update_lte_max(norm_err);
       CLogger::getLogger()->update_step(time_j.diam());

       factor = factor_stepsize(test);
       *box_err_aff = err_aff;
       return 1;
     }
     else
     {
       CLogger::getLogger()->inc_rejected_picard();

       h = std::max(dynibex_hmin,time_j.diam()/2.0);
       time_j = Interval(time_j.lb(),time_j.lb()+h);
       return 0;
     }
   }
   else
   {
     CLogger::getLogger()->inc_rejected_picard();

     h = std::max(dynibex_hmin,time_j.diam()/2.0);
     time_j = Interval(time_j.lb(),time_j.lb()+h);
     return 0;
   }
 };



 int calcul_j1(ivp_ode* _ode){



   IntervalVector yn_p1(*box_j0);
   IntervalVector yn_p0(*box_j0);

   do
   {
     yn_p0=yn_p1;


     yn_p1 &= picard(yn_p0,_ode,3);
     if (_ode->embedded_ctc != __null)
     {
       _ode->embedded_ctc->contract(yn_p1);


     }

   } while(yn_p1.rel_distance(yn_p0) > 1e-18);

   *box_j1 = yn_p1;


   return 1;
 };



 double infinite_norm(const IntervalVector _vec)
 {
   double res = std::max(std::abs(_vec[0].lb()),std::abs(_vec[0].ub()));
   for (int i=1;i<_vec.size();i++)
   {
    res = std::max(std::abs(_vec[i].lb()),res);
    res = std::max(std::abs(_vec[i].ub()),res);
   }
   return res;
 };


 void set_atol(double a)
 {
   atol = a;
 }


 void flush()
 {
   *box_err_aff = box_err_aff->itv();
   *box_jn_aff = *box_jn;
   *box_jnh_aff = *box_jnh;
 };



 solution_j(){};

 solution_j(const Affine2Vector _box_jn, double tn, double h, double a)
 {
     box_jn_aff = new Affine2Vector(_box_jn);
     box_jn = new IntervalVector(_box_jn.itv());
     box_j0 = new IntervalVector(*box_jn);
     box_j1 = new IntervalVector(*box_jn);
     box_err_aff = new Affine2Vector(box_jn->size());
     box_jnh = new IntervalVector(*box_jn);


     time_j = Interval(tn-h,tn);
     box_jnh_aff = new Affine2Vector(_box_jn);
     atol = a;
     factor = 1.0;
 }


 solution_j(const Affine2Vector _box_jn, double tn, double h, ivp_ode* _ode,double a, double fac)
 {
   factor = fac;
     atol = a;
   box_jn_aff = new Affine2Vector(_box_jn);

   box_jn = new IntervalVector(_box_jn.itv());

   time_j = Interval(tn,tn+std::min(dynibex_hmax,std::max(dynibex_hmin,h)));


  box_j0 = new IntervalVector(box_jn->size());
  box_j1 = new IntervalVector(box_jn->size());
  box_err_aff = new Affine2Vector(box_jn->size());


   box_jnh = new IntervalVector(_box_jn.size());
   box_jnh_aff = new Affine2Vector(_box_jn.size());

 }

 int compute_oneStep(const Affine2Vector _box_jn, ivp_ode* _ode, bool monotony_active)
 {


  int ok=calcul_j0(*box_jn,_ode);

   unsigned int nb=0;
   while ((ok != 1)&&(nb < 2*_ode->nbvar+1))
   {
        IntervalVector _box(*box_j0);
        ok=calcul_j0(_box, _ode);
        nb++;
   }
  if (ok != 1)
  {
  std::cout << "Step:"<<nb<<" refused !" << std::endl;
  CLogger::getLogger()->Log("Solution at t=%f : ",time_j.lb());
  CLogger::getLogger()->Log_sol(_box_jn.itv());
  CLogger::getLogger()->Log_end();

  time_j = Interval(time_j.lb(),1e8);
  box_j1->init(Interval::ALL_REALS);
  box_jnh->init(Interval::ALL_REALS);
  *box_jnh_aff = *box_jnh;



  }
  else
  {
  if (box_j0->is_unbounded())
  {
    std::cout << "Step:"<<nb<<" refused !" << std::endl;
    CLogger::getLogger()->Log("Solution at t=%f : ",time_j.lb());
    CLogger::getLogger()->Log_sol(_box_jn.itv());
    CLogger::getLogger()->Log_end();

  time_j = Interval(time_j.lb(),1e8);
  box_j1->init(Interval::ALL_REALS);
  box_jnh->init(Interval::ALL_REALS);
  *box_jnh_aff = *box_jnh;


  }
  }


   calcul_jnh(_ode);

   if (monotony_active)
   {

       IntervalVector der = _ode->compute_derivatives_aff(1,Affine2Vector(*box_j1,true)).itv();
       if ((der.lb().min() > 0) || (der.ub().max() < 0))
       {
  IntervalVector jnh_old(box_jnh_aff->itv());
  do
  {
    jnh_old = box_jnh_aff->itv();
    *box_j1 &= (box_jnh_aff->itv() | box_jn_aff->itv());
    *box_err_aff = LTE(*box_j1,_ode, time_j.diam());
    calcul_jnh(_ode);
  } while (jnh_old.rel_distance(box_jnh_aff->itv()) > atol);
       }


   }






   box_jnh_aff->compact();

   *box_jnh = box_jnh_aff->itv();

   if ((box_jnh->is_unbounded()) || (box_jnh->is_empty()))
   {
     std::cout << "Unacceptable solution!" << std::endl;
     CLogger::getLogger()->Log("Solution at t=%f : ",time_j.lb());
     CLogger::getLogger()->Log_sol(_box_jn.itv());
     CLogger::getLogger()->Log_end();

  time_j = Interval(time_j.lb(),1e8);
  box_j1->init(Interval::ALL_REALS);
  box_jnh->init(Interval::ALL_REALS);
  *box_jnh_aff = *box_jnh;


   }
   return 0;
 }



 void print_soljn(){
     std::cout << std::setprecision(20)<< "Solution at t=" << time_j.ub() << " : " << *box_jnh << std::endl;
     std::cout << "affine form : " << *box_jnh_aff << std::endl;
 }



 ~solution_j(){
 }

 void destructor()
 {
   if (box_jn_aff != __null)
     delete box_jn_aff;
   if (box_jn != __null)
     delete box_jn;
   if (box_j0 != __null)
     delete box_j0;
   if (box_j1 != __null)
     delete box_j1;
   if (box_err_aff != __null)
     delete box_err_aff;
   if (box_jnh != __null)
     delete box_jnh;
   if (box_jnh_aff != __null)
     delete box_jnh_aff;
 }


    IntervalVector approx_rk4(const IntervalVector yj, double h, ivp_ode* _ode)
 {
     IntervalVector int_rk4(_ode->nbvar);
     IntervalVector boxj1(yj);

     IntervalVector k1 = _ode->compute_derivatives(1, boxj1);

     IntervalVector boxj2(k1);
     boxj2*=(0.5*h);

     IntervalVector k2 = _ode->compute_derivatives(1, yj+boxj2);

     IntervalVector boxj3(k2);
     boxj3*=(0.5*h);

     IntervalVector k3 = _ode->compute_derivatives(1, yj+boxj3);

     IntervalVector boxj4(k3);
     boxj4*=(h);

     IntervalVector k4 = _ode->compute_derivatives(1, yj+boxj4);

     k2*=(2.0);
     k3*=(2.0);


     int_rk4 = k1+k2+k3+k4;
     int_rk4*=(h/6.0);
     int_rk4 +=(yj);

   return int_rk4;

 };




   Affine2Vector remainder_rk4(ivp_ode* _ode)
   {
     double h=time_j.diam();

     Affine2Vector boxj1(*box_jn_aff);

     Affine2Vector k1 = _ode->compute_derivatives_aff(1, boxj1);

     Affine2Vector boxj2(k1);
     boxj2*=(0.5*h);

     Affine2Vector k2 = _ode->compute_derivatives_aff(1, *box_jn_aff+boxj2);

     Affine2Vector boxj3(k2);
     boxj3*=(0.5*h);

     Affine2Vector k3 = _ode->compute_derivatives_aff(1, *box_jn_aff+boxj3);

     Affine2Vector boxj4(k3);
     boxj4*=(h);

     Affine2Vector k4 = _ode->compute_derivatives_aff(1, *box_jn_aff+boxj4);

     k2*=(2.0);
     k3*=(2.0);


     Affine2Vector int_rk4 = k1+k2+k3+k4;
     int_rk4*=(h/6.0);
     int_rk4+=*box_jn_aff;

     return int_rk4+*box_err_aff;

   };



};
}
# 19 "/usr/local/include/ibex/ibex_solution_generic.h" 2 3
# 1 "/usr/local/include/ibex/ibex_solution_dae.h" 1 3
# 17 "/usr/local/include/ibex/ibex_solution_dae.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 18 "/usr/local/include/ibex/ibex_solution_dae.h" 2 3


namespace ibex{

class solution_j_dae
{
  public:
 IntervalVector* box_j0;
 IntervalVector* box_j1;
 Interval time_j;

 IntervalVector* box_jn;
 IntervalVector* box_jnh;
 IntervalVector* box_xnh;

 Affine2Vector* box_err_aff;

 Affine2Vector* box_jn_aff;
 Affine2Vector* box_xn_aff;

 Affine2Vector* box_jnh_aff;
 Affine2Vector* box_xnh_aff;



 double atol;


 double factor;




 IntervalVector picard_tayl(IntervalVector s0, ivp_dae_h1* _dae, int ordre)
 {
   double h = time_j.diam();
   int n=ordre;
   int fac_i=1;

   Affine2Vector sn(s0,true);

   sn.put(0,*box_jn_aff);
   Affine2Vector int_tayl(*box_jn_aff);

   for (int i=1;i<n;i++)
   {
       fac_i = fac_i*i;
       Affine2Vector df = _dae->compute_derivatives_aff(i, sn);
       df*=( 1.0 /fac_i);
       df*=Interval(0,std::pow(h,i));
       int_tayl=int_tayl + df;

   }

   IntervalVector err = _dae->compute_derivatives_aff(n, Affine2Vector(s0)).itv();

   fac_i = fac_i*(n);
   err*=(1.0/fac_i);
   err*=Interval(0,std::pow(h,n));

   return int_tayl.itv()+err;
 };






 virtual IntervalVector picard(IntervalVector y0, ivp_dae_h1* _dae, int ordre)
 {
   return picard_tayl(y0,_dae,ordre);
 }


 virtual Affine2Vector LTE(IntervalVector y0, ivp_dae_h1* _dae,double h)
 {

     Affine2Vector err_aff = _dae->computeRADAU3derivative(Affine2Vector(y0,true));
     err_aff*=(std::pow(h,4) / 24.0);

     return err_aff;
 }


 virtual double factor_stepsize(double test)
 {
   return std::min(5.0,std::max(0.4,0.7*std::pow(1.0/test,0.25)));
 }


 virtual int calcul_jnh(ivp_dae_h1* _dae){


    IntervalVector sh= IntervalVector(*box_j1);

   IntervalVector sh_old(sh);
   IntervalVector sh_tilde(sh);
   int count=0;

   *box_jnh_aff = remainder_radau3(_dae,sh);

   do{
       sh_old = sh;

       *box_jnh_aff = remainder_radau3_param(_dae,sh_tilde,sh);

       IntervalVector sh_temp(sh);
       sh_temp.put(0,box_jnh_aff->itv());
       sh_temp &= sh;
       if (_dae->embedded_ctc != __null)
       {
    _dae->embedded_ctc->contract(sh_temp);
    if (sh_temp.is_empty())
      sh_temp = sh;
       }
       if (sh_temp.is_empty())
      sh_temp = sh;

       sh &= sh_temp;

       IntervalVector sh_x = sh.subvector(_dae->nbvar,sh.size()-1);

       *box_xnh_aff = contract_algebraic(_dae,sh);

       sh &= sh_old;
       sh_x &= box_xnh_aff->itv();
       sh.put(_dae->nbvar,sh_x);

       count++;
   }while ((sh.rel_distance(sh_old) > 1e-24)&&(count<30));

   return 1;
 };





 int uniqueness(ivp_dae_h1* _dae){






   IntervalVector y0 = box_jn_aff->itv();
   IntervalVector x0 = box_xn_aff->itv();
   std::cout << "Initial values : " << y0 << ", " << x0 << std::endl;
   IntervalVector s0 = IntervalVector(x0.size()+y0.size(),0);
   s0.put(0,y0);
   s0.put(_dae->nbvar,x0);


   IntervalVector x1 = _dae->compute_algebraic_krawczyk(s0);
   if (x1.is_empty())
   {
     std::cout << "Not consistence of initial values !" << std::endl;
     return 0;
   }
   else
   {
       if (x1.is_subset(x0))
       {
  *box_xn_aff = Affine2Vector(x1,true);
  *box_xnh_aff = Affine2Vector(x1,true);
  std::cout << "Consistence of initial values : " << x1 << std::endl;
  return 1;
       }
       else
       {
  std::cout << "Not existence proof of initial values !" << std::endl;
  return 0;
       }
   }
  return 1;
 };




 int picard_krawczyk(IntervalVector y0,IntervalVector x0, ivp_dae_h1* _dae)
 {

   IntervalVector y_old(y0);
   IntervalVector x_old(x0);


   IntervalVector s0 = IntervalVector(x0.size()+y0.size(),0);

   s0.put(0,y0);
   s0.put(_dae->nbvar,x0);

   double infl = std::max(0.1,s0.diam().max()*0.1);
   s0.inflate(infl);

   IntervalVector s1 = IntervalVector(s0);


   y0 = picard_tayl(s0,_dae,3);
   s0.put(0,y0);

   x0 = _dae->compute_algebraic_krawczyk(s0);


   s1.put(0,y0);
   s1.put(_dae->nbvar,x0);

   if (s1.is_empty())
     s1 = s0;


   int iter = 0;
   while ((!s1.is_strict_subset(s0))&&(iter <= 2*_dae->nbvar))
   {

     s0=s1;
     iter++;

     double infl = s0.diam().max()*0.1;


     IntervalVector y1 = picard_tayl(s0,_dae,2);

     if (!y1.is_subset(y0))
       y1.inflate(infl);


     IntervalVector x1 = _dae->compute_algebraic_krawczyk(s0);


     if (!x1.is_subset(x0))
       x1.inflate(infl);


     s1.put(0,y1);
     s1.put(_dae->nbvar,x1);
   }


   *box_j0 = s1;
   double h;
   if (s1.is_strict_subset(s0))
   {



     do{
       s0=s1;
       IntervalVector y1 = picard_tayl(s0,_dae,2);
       s1.put(0,y1);
       IntervalVector x1 = _dae->compute_algebraic_krawczyk(s1);

       s1.put(_dae->nbvar,x1);

       if (_dae->embedded_ctc != __null)
       {
    _dae->embedded_ctc->contract(s1);
    if (s1.is_empty())
      s1=s0;
       }
       if (s1.is_empty())
      s1=s0;


       s1&=s0;
     }while (s1.rel_distance(s0) > 1e-24);



     if (s1.is_empty())
     {
       *box_j0 = s0;
       CLogger::getLogger()->inc_rejected_picard();
       h = std::max(dynibex_hmin,time_j.diam()/2.0);
       time_j = Interval(time_j.lb(),time_j.lb()+h);
       return 0;
     }

     *box_j1 = s1;
     Affine2Vector err_aff = LTE(*box_j1,_dae, time_j.diam());
     IntervalVector err = err_aff.itv();

     double norm_err = infinite_norm(err);



     double rtol = atol;

     IntervalVector y1 = s1.subvector(0,_dae->nbvar-1);
     IntervalVector x1 = s1.subvector(_dae->nbvar,s1.size()-1);

     double err_test = atol + infinite_norm(y1)*rtol;

     double test = norm_err/err_test;




     if ( (test <= 1.0) || (time_j.diam()<=dynibex_hmin))
     {
       CLogger::getLogger()->inc_accepted_picard();
       CLogger::getLogger()->update_lte_max(norm_err);
       CLogger::getLogger()->update_step(time_j.diam());

       factor = factor_stepsize(test);
       *box_err_aff = err_aff;
       return 1;
     }
     else
     {
       CLogger::getLogger()->inc_rejected_picard();

       h = std::max(dynibex_hmin,time_j.diam()/2.0);
       time_j = Interval(time_j.lb(),time_j.lb()+h);
       return 0;
     }
   }
   else
   {
     CLogger::getLogger()->inc_rejected_picard();

     h = std::max(1e-7,time_j.diam()/2.0);
     time_j = Interval(time_j.lb(),time_j.lb()+h);
     return 0;
   }


 }
# 378 "/usr/local/include/ibex/ibex_solution_dae.h" 3
 double infinite_norm(const IntervalVector _vec)
 {
   double res = std::max(std::abs(_vec[0].lb()),std::abs(_vec[0].ub()));
   for (int i=1;i<_vec.size();i++)
   {
    res = std::max(std::abs(_vec[i].lb()),res);
    res = std::max(std::abs(_vec[i].ub()),res);
   }
   return res;
 };


 void set_atol(double a)
 {
   atol = a;
 }


 void flush()
 {
   *box_err_aff = box_err_aff->itv();
   *box_jn_aff = *box_jn;
   *box_jnh_aff = *box_jnh;
   *box_xn_aff = box_xn_aff->itv();
   *box_xnh_aff = box_xnh_aff->itv();
 };



 solution_j_dae(){};

 solution_j_dae(const Affine2Vector _box_jn, const Affine2Vector _box_xn, double tn, double h, double a)
 {
   box_jn_aff = new Affine2Vector(_box_jn);
   box_xn_aff = new Affine2Vector(_box_xn);


   time_j = Interval(tn-h,tn);
   box_jnh_aff = new Affine2Vector(_box_jn);
   box_xnh_aff = new Affine2Vector(_box_xn);

   box_j0 = new IntervalVector(_box_jn.size()+_box_xn.size());
   box_j1 = new IntervalVector(*box_j0);

   box_err_aff = new Affine2Vector(_box_jn.size());

   box_jn = new IntervalVector(_box_jn.itv());
   box_jnh = new IntervalVector(_box_jn);
   box_xnh = new IntervalVector(_box_xn);
   atol = a;
   factor = 1.0;
 }


 solution_j_dae(const Affine2Vector _box_jn, const Affine2Vector _box_xn, double tn, double h, ivp_dae_h1* _dae,double a, double fac)
 {
   factor = fac;
     atol = a;
   time_j = Interval(tn,tn+std::min(dynibex_hmax,std::max(dynibex_hmin,h*fac)));

   box_jn_aff = new Affine2Vector(_box_jn);
   box_xn_aff = new Affine2Vector(_box_xn);

   box_jnh_aff = new Affine2Vector(_box_jn.size());
   box_xnh_aff = new Affine2Vector(_box_xn.size());

   box_j0 = new IntervalVector(_box_jn.size()+_box_xn.size());
   box_j1 = new IntervalVector(*box_j0);

   box_err_aff = new Affine2Vector(_box_jn.size());


   box_jn = new IntervalVector(_box_jn.itv());
   box_jnh = new IntervalVector(_box_jn);
   box_xnh = new IntervalVector(_box_xn);

 }

 int compute_oneStep(const Affine2Vector _box_jn,const Affine2Vector _box_xn, ivp_dae_h1* dae)
 {


   IntervalVector x0 = _box_xn.itv();
   if (x0.is_flat())
     x0.inflate(atol);


   int ok = picard_krawczyk(_box_jn.itv(),x0, dae);
   int nb=0;
   while ((ok != 1)&&(nb < 20*dae->nbvar))
   {
        IntervalVector s1(*box_j0);
        IntervalVector y1 = s1.subvector(0,dae->nbvar-1);
        IntervalVector x1 = s1.subvector(dae->nbvar,s1.size()-1);
        ok=picard_krawczyk(y1,x1, dae);
        nb++;
   }
   if (ok != 1)
   {
  std::cout << "Step:"<<nb<<" refused !" << std::endl;
  CLogger::getLogger()->Log("Solution at t=%f : ",time_j.lb());
  CLogger::getLogger()->Log_sol(_box_jn.itv());
  CLogger::getLogger()->Log_end();
  exit(1);

   }
   else
   {
  if (box_j0->is_unbounded())
  {
    std::cout << "Step:"<<nb<<" refused !" << std::endl;
    CLogger::getLogger()->Log("Solution at t=%f : ",time_j.lb());
    CLogger::getLogger()->Log_sol(_box_jn.itv());
    CLogger::getLogger()->Log_end();
    exit(1);
  }
   }


   calcul_jnh(dae);
   box_jnh_aff->compact();
   *box_jnh = box_jnh_aff->itv();

   box_xnh_aff->compact();
   *box_xnh = box_xnh_aff->itv();
# 528 "/usr/local/include/ibex/ibex_solution_dae.h" 3
   return 1;
 }



 void print_soljn(){
     std::cout << std::setprecision(20)<< "Solution at t=" << time_j.ub() << " : " << *box_jnh << std::endl;
     std::cout << "affine form : " << *box_jnh_aff << std::endl;
 }



 ~solution_j_dae(){
 }

 void destructor()
 {
   if (box_jn_aff != __null)
     delete box_jn_aff;
   if (box_jn != __null)
     delete box_jn;
   if (box_j0 != __null)
     delete box_j0;
   if (box_j1 != __null)
     delete box_j1;
   if (box_err_aff != __null)
     delete box_err_aff;
   if (box_jnh != __null)
     delete box_jnh;
   if (box_jnh_aff != __null)
     delete box_jnh_aff;
   if (box_xnh != __null)
     delete box_xnh;
   if (box_xn_aff != __null)
     delete box_xn_aff;
   if (box_xnh_aff != __null)
     delete box_xnh_aff;
 }

 Affine2Vector contract_algebraic(ivp_dae_h1* _dae, IntervalVector sh)
   {
     IntervalVector sh_old(sh);
     IntervalVector xnh = sh.subvector(_dae->nbvar,sh.size()-1);

     CtcFwdBwd c(*_dae->g);
     CtcFixPoint fix(c);
     fix.contract(sh);

     if (sh.is_empty())
       sh=sh_old;
     xnh &= _dae->compute_algebraic_krawczyk(sh);

     return Affine2Vector(xnh,true);

   }



   Affine2Vector remainder_radau3_param(ivp_dae_h1* _dae, IntervalVector sh, IntervalVector sh_x)
   {
     double h=time_j.diam();
     double tol = 1e-20;

     IntervalVector k1 = _dae->compute_derivatives_aff(1, Affine2Vector(*box_j1,true)).itv();

     IntervalVector k2(k1);


     IntervalVector k1_old(k1);
     IntervalVector k2_old(k2);
     IntervalVector s_temp(sh);
     do
     {
       k1_old=k1;
       k2_old=k2;

       IntervalVector s1(sh);
       s1.put(0,box_jn_aff->itv() + h*((5.0/12.0)*k1 + (-1.0/12.0)*k2));
       k1 &= _dae->compute_derivatives_aff(1,Affine2Vector(s1,true)).itv();


       IntervalVector s2(sh_x);
       s2.put(0,box_jn_aff->itv() + h*((3.0/4.0)*k1 + (1.0/4.0)*k2));
       k2 &= _dae->compute_derivatives_aff(1,Affine2Vector(s2,true)).itv();


     }while ((k1.rel_distance(k1_old) > tol)||(k2.rel_distance(k2_old) > tol));

     Affine2Vector k1_aff = Affine2Vector(k1,true);
     Affine2Vector k2_aff = Affine2Vector(k2,true);


     Affine2Vector s1_aff(sh);
     s1_aff.put(0,*box_jn_aff + h*((5.0/12.0)*k1_aff + (-1.0/12.0)*k2_aff));
     k1_aff = _dae->compute_derivatives_aff(1,s1_aff);


     Affine2Vector s2_aff(sh_x);
     s2_aff.put(0,*box_jn_aff + h*((3.0/4.0)*k1_aff + (1.0/4.0)*k2_aff));
     k2_aff = _dae->compute_derivatives_aff(1,s2_aff);



     s1_aff.put(0,*box_jn_aff + h*((5.0/12.0)*k1_aff + (-1.0/12.0)*k2_aff));
     k1_aff = _dae->compute_derivatives_aff(1,s1_aff);
     s2_aff.put(0,*box_jn_aff + h*((3.0/4.0)*k1_aff + (1.0/4.0)*k2_aff));
     k2_aff = _dae->compute_derivatives_aff(1,s2_aff);


     Affine2Vector radau3=*box_jn_aff + h*( (3.0/4.0)*k1_aff + (1.0/4.0)*k2_aff);

     return radau3+*box_err_aff;

   };


   Affine2Vector remainder_radau3(ivp_dae_h1* _dae, IntervalVector sh)
   {
     double h=time_j.diam();
     double tol = 1e-20;

     IntervalVector k1 = _dae->compute_derivatives_aff(1, Affine2Vector(*box_j1,true)).itv();

     IntervalVector k2(k1);


     IntervalVector k1_old(k1);
     IntervalVector k2_old(k2);

     do
     {
       k1_old=k1;
       k2_old=k2;

       IntervalVector s1(sh);
       s1.put(0,box_jn_aff->itv() + h*((5.0/12.0)*k1 + (-1.0/12.0)*k2));
       k1 &= _dae->compute_derivatives_aff(1,Affine2Vector(s1,true)).itv();

       IntervalVector s2(sh);
       s2.put(0,box_jn_aff->itv() + h*((3.0/4.0)*k1 + (1.0/4.0)*k2));
       k2 &= _dae->compute_derivatives_aff(1,Affine2Vector(s2,true)).itv();


     }while ((k1.rel_distance(k1_old) > tol)||(k2.rel_distance(k2_old) > tol));

     Affine2Vector k1_aff = Affine2Vector(k1,true);
     Affine2Vector k2_aff = Affine2Vector(k2,true);


     Affine2Vector s1_aff(sh);
     s1_aff.put(0,*box_jn_aff + h*((5.0/12.0)*k1_aff + (-1.0/12.0)*k2_aff));
     k1_aff = _dae->compute_derivatives_aff(1,s1_aff);


     Affine2Vector s2_aff(sh);
     s2_aff.put(0,*box_jn_aff + h*((3.0/4.0)*k1_aff + (1.0/4.0)*k2_aff));
     k2_aff = _dae->compute_derivatives_aff(1,s2_aff);

     Affine2Vector radau3=*box_jn_aff + h*( (3.0/4.0)*k1_aff + (1.0/4.0)*k2_aff);

     return radau3+*box_err_aff;

   };





};
}
# 20 "/usr/local/include/ibex/ibex_solution_generic.h" 2 3


namespace ibex{

class solution_g : public solution_j
{
public:
  solution_g(Interval _time_j, IntervalVector* _box_j1, IntervalVector* _box_jn, IntervalVector* _box_jnh,int nb_var)
 {
   time_j=_time_j;
   box_j1 = new IntervalVector(_box_j1->subvector(0,nb_var-1));
   box_jn = new IntervalVector(*_box_jn);
   box_jnh = new IntervalVector(*_box_jnh);

 }
  ~solution_g(){
  }

  void destructor()
  {
    if (box_jn != __null)
      delete box_jn;
    if (box_jnh != __null)
      delete box_jnh;
    if (box_j1 != __null)
      delete box_j1;
  }

};

}
# 31 "/usr/local/include/ibex/ibex_integrate.h" 2 3





# 1 "/usr/local/include/ibex/ibex_solution_RK4.h" 1 3
# 18 "/usr/local/include/ibex/ibex_solution_RK4.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 19 "/usr/local/include/ibex/ibex_solution_RK4.h" 2 3



namespace ibex{

class solution_j_rk4 : public solution_j
{
  public:


 IntervalVector picard(IntervalVector y0, ivp_ode* _ode, int ordre)
 {
   return picard_tayl(y0,_ode,ordre);
 }


 Affine2Vector LTE(IntervalVector y0,ivp_ode* _ode, double h)
 {
   if (_ode->get_lte_computation() == AUTODIF){
     if (!_ode->get_dags()->is_filled_in()){
       ibex::IntervalMatrix A(4, 4, 0.0);
       A[1][0] = Interval(0.5);
       A[2][1] = Interval(0.5);
       A[3][2] = Interval(1.0);
       ibex::IntervalVector b(4);
       b[0] = Interval(1.0)/6;
       b[1] = Interval(1.0)/3;
       b[2] = Interval(1.0)/3;
       b[3] = Interval(1.0)/6;
       _ode->set_Butcher_table(A, b);
     }
     Affine2Vector temp(y0, true);
     Affine2Vector err_aff = _ode->get_dags()->get_lte(5, temp);
     err_aff*=(pow(Interval(h),5) / 120);
     return err_aff;
   } else {
     Affine2Vector err_aff = _ode->computeRK4derivative(Affine2Vector(y0,true));
     err_aff*=(pow(Interval(h),5) / 120);
     return err_aff;
   }
 }


 double factor_stepsize(double test)
 {
   return std::min(1.8,std::max(0.4,0.95*std::pow(1.0/test,0.2)));
 }


 int calcul_jnh(ivp_ode* _ode){

   *box_jnh_aff = remainder_rk4(_ode);
   return 1;
 };



 solution_j_rk4(const Affine2Vector _box_jn, double tn, double h, ivp_ode* _ode,double a, double fac) : solution_j(_box_jn, tn, h, _ode, a, fac)
 {


 }



 ~solution_j_rk4(){

 }



private:


   Affine2Vector remainder_rk4(ivp_ode* _ode)
   {
     double h=time_j.diam();

     Affine2Vector boxj1(*box_jn_aff);
     Affine2Vector k1 = _ode->compute_derivatives_aff(1, boxj1);
     Affine2Vector boxj2(k1);
     boxj2*=(Interval(0.5)*h);


     Affine2Vector k2 = _ode->compute_derivatives_aff(1, *box_jn_aff+boxj2);


     Affine2Vector boxj3(k2);
     boxj3*=(Interval(0.5)*h);


     Affine2Vector k3 = _ode->compute_derivatives_aff(1, *box_jn_aff+boxj3);


     Affine2Vector boxj4(k3);
     boxj4*=(h);


     Affine2Vector k4 = _ode->compute_derivatives_aff(1, *box_jn_aff+boxj4);

     k2*=(2.0);
     k3*=(2.0);


     Affine2Vector int_rk4 = k1+k2+k3+k4;
     int_rk4*=(Interval(h)/6.0);
     int_rk4+=*box_jn_aff;

     return int_rk4+*box_err_aff;

   };



};
}
# 37 "/usr/local/include/ibex/ibex_integrate.h" 2 3
# 1 "/usr/local/include/ibex/ibex_solution_iEULER.h" 1 3
# 18 "/usr/local/include/ibex/ibex_solution_iEULER.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 19 "/usr/local/include/ibex/ibex_solution_iEULER.h" 2 3



namespace ibex{

class solution_j_ieuler : public solution_j
{
  public:



 IntervalVector picard(IntervalVector y0, ivp_ode* _ode, int ordre)
 {
   return picard_euler(y0,_ode);
 }


 Affine2Vector LTE(IntervalVector y0,ivp_ode* _ode, double h)
 {

   if (_ode->get_lte_computation() == AUTODIF){
     if (!_ode->get_dags()->is_filled_in()){
       ibex::IntervalMatrix A(1, 1, 1.0);

       ibex::IntervalVector b(1);
       b[0] = 1.0;
       _ode->set_Butcher_table(A, b);
     }
     Affine2Vector y0_aff = Affine2Vector(y0, true);
     Affine2Vector err_aff = _ode->get_dags()->get_lte(2, y0_aff);
     err_aff*=(pow(Interval(h),2.0) / 2.0);
     return err_aff;
   } else {
     Affine2Vector err_aff = _ode->computeIEULERderivative(Affine2Vector(y0,true));
     err_aff*=(pow(Interval(h),2.0) / 2.0);
     return err_aff;
   }
 }


 double factor_stepsize(double test)
 {
   return std::min(1.8,std::max(0.4,0.9*std::pow(1.0/test,0.5)));
 }


 int calcul_jnh(ivp_ode* _ode){

   *box_jnh_aff = remainder_ieuler(_ode);
   return 1;
 };



 solution_j_ieuler(const Affine2Vector _box_jn, double tn, double h, ivp_ode* _ode,double a, double fac) : solution_j(_box_jn, tn, h, _ode, a, fac)
 {

 }



 ~solution_j_ieuler(){

 }



private:


   Affine2Vector remainder_ieuler(ivp_ode* _ode)
   {
     double h=time_j.diam();
     double tol = 1e-20;
     IntervalVector k1 = _ode->compute_derivatives(1,*box_j1);
     IntervalVector k1_old(k1);

     do
     {

       k1_old=k1;
       k1 &= _ode->compute_derivatives(1,*box_jn + h*k1);


     } while (k1.rel_distance(k1_old) > tol);

     Affine2Vector k1_aff = Affine2Vector(k1,true);

     k1_aff = _ode->compute_derivatives_aff(1,*box_jn_aff + h*k1_aff);

     Affine2Vector ieuler = *box_jn_aff + h*k1_aff;

     return ieuler+*box_err_aff;

   };



};
}
# 38 "/usr/local/include/ibex/ibex_integrate.h" 2 3
# 1 "/usr/local/include/ibex/ibex_solution_iMIDPOINT.h" 1 3
# 18 "/usr/local/include/ibex/ibex_solution_iMIDPOINT.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 19 "/usr/local/include/ibex/ibex_solution_iMIDPOINT.h" 2 3



namespace ibex{

class solution_j_imidpoint : public solution_j
{
  public:




 IntervalVector picard(IntervalVector y0, ivp_ode* _ode, int ordre)
 {
   return picard_euler(y0,_ode);
 }


 Affine2Vector LTE(IntervalVector y0,ivp_ode* _ode, double h)
 {

   if (_ode->get_lte_computation() == AUTODIF){
     if (!_ode->get_dags()->is_filled_in()){
       ibex::IntervalMatrix A(1, 1, Interval(1.)/2);
       ibex::IntervalVector b(1);
       b[0] = Interval(1.0);
       _ode->set_Butcher_table(A, b);
     }

     Affine2Vector err_aff = _ode->get_dags()->get_lte(3, Affine2Vector(y0, true));
     err_aff*=(pow(Interval(h),3) / 6.);
     return err_aff;
   }

   Affine2Vector err_aff = _ode->computeIMIDPOINTderivative(Affine2Vector(y0,true));
   err_aff*=(pow(Interval(h),3) / 6.);

   return err_aff;
 }


 double factor_stepsize(double test)
 {
   return std::min(1.8,std::max(0.4,0.9*std::pow(1.0/test,0.33)));
 }


 int calcul_jnh(ivp_ode* _ode){

   *box_jnh_aff = remainder_imidpoint(_ode);
   return 1;
 };



 solution_j_imidpoint(const Affine2Vector _box_jn, double tn, double h, ivp_ode* _ode,double a, double fac) : solution_j(_box_jn, tn, h, _ode, a, fac)
 {

 }



 ~solution_j_imidpoint(){

 }



private:


   Affine2Vector remainder_imidpoint(ivp_ode* _ode)
   {
     double h=time_j.diam();
     double tol = 1e-20;
     IntervalVector k1 = _ode->compute_derivatives(1,*box_j1);
     IntervalVector k1_old(k1);

     do
     {

       k1_old=k1;
       k1 &= _ode->compute_derivatives(1,*box_jn + Interval(0.5)*h*k1);
     } while (k1.rel_distance(k1_old) > tol);

     Affine2Vector k1_aff = Affine2Vector(k1,true);
     k1_aff = _ode->compute_derivatives_aff(1,*box_jn_aff + Interval(0.5)*h*k1_aff);
     Affine2Vector ieuler = *box_jn_aff + h*k1_aff;

     return ieuler+*box_err_aff;

   };



};
}
# 39 "/usr/local/include/ibex/ibex_integrate.h" 2 3
# 1 "/usr/local/include/ibex/ibex_solution_LA3.h" 1 3
# 18 "/usr/local/include/ibex/ibex_solution_LA3.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 19 "/usr/local/include/ibex/ibex_solution_LA3.h" 2 3



namespace ibex{

class solution_j_la3 : public solution_j
{
  public:


 IntervalVector picard(IntervalVector y0, ivp_ode* _ode, int ordre)
 {
   return picard_tayl(y0,_ode,ordre);
 }


 Affine2Vector LTE(IntervalVector y0,ivp_ode* _ode, double h)
 {
   if (_ode->get_lte_computation() == AUTODIF){
     if (!_ode->get_dags()->is_filled_in()){
  ibex::IntervalMatrix A(3, 3, 0.0);
       A[1][0] = Interval(5.0)/24.;
       A[1][1] = Interval(1.0)/3.;
       A[1][2] = Interval(-1.0)/24.;

       A[2][0] = Interval(1.0)/6.;
       A[2][1] = Interval(2.0)/3.;
       A[2][2] = Interval(1.0)/6.;

       ibex::IntervalVector b(3);
       b[0] = Interval(1.0)/6.;
       b[1] = Interval(2.0)/3.;
       b[2] = Interval(1.0)/6.;
       _ode->set_Butcher_table(A, b);
     }
     Affine2Vector err_aff = _ode->get_dags()->get_lte(5, Affine2Vector(y0, true));
     err_aff*=(pow(Interval(h),5) / 120.0);

     return err_aff;
   } else {
     Affine2Vector err_aff = _ode->computeLA3derivative_aff(Affine2Vector(y0,true));
     err_aff*=(pow(Interval(h),5) / 120.0);

     return err_aff;
   }
 }


 double factor_stepsize(double test)
 {
   return std::min(1.8,std::max(0.4,0.9*std::pow(1.0/test,0.2)));
 }



 int calcul_jnh(ivp_ode* _ode){

   *box_jnh_aff = remainder_la3(_ode);
   return 1;
 };



 solution_j_la3(const Affine2Vector _box_jn, double tn, double h, ivp_ode* _ode,double a, double fac) : solution_j(_box_jn, tn, h, _ode, a, fac)
 {

 }



 ~solution_j_la3(){

 }



private:


   Affine2Vector remainder_la3(ivp_ode* _ode)
   {
     double h=time_j.diam();
     double tol = 1e-20;

     IntervalVector k1 = _ode->compute_derivatives(1,*box_j1);
     IntervalVector k2(k1);
     IntervalVector k3(k1);

     IntervalVector k1_old(k1);
     IntervalVector k2_old(k2);
     IntervalVector k3_old(k3);
     k1 = _ode->compute_derivatives(1,*box_jn);
     k1_old=k1;


     do
     {

       k2_old=k2;
       k3_old=k3;
       k2 &= _ode->compute_derivatives(1,*box_jn + h*((Interval(5.0)/24.0)*k1 + (Interval(1.0)/3.0)*k2 + (-Interval(1.0)/24.0)*k3));
       k3 &= _ode->compute_derivatives(1,*box_jn + h*((Interval(1.0)/6.0)*k1 + (Interval(2.0)/3.0)*k2 + (Interval(1.0)/6.0)*k3));

     }while((k2.rel_distance(k2_old) > tol)||(k3.rel_distance(k3_old) > tol));

     Affine2Vector k1_aff = Affine2Vector(k1,true);
     Affine2Vector k2_aff = Affine2Vector(k2,true);
     Affine2Vector k3_aff = Affine2Vector(k3,true);

     k1_aff = _ode->compute_derivatives_aff(1,*box_jn_aff);
     k2_aff = _ode->compute_derivatives_aff(1,*box_jn_aff + h*((Interval(5.0)/24.0)*k1_aff + (Interval(1.0)/3.0)*k2_aff + (-Interval(1.0)/24.0)*k3_aff));
     k3_aff = _ode->compute_derivatives_aff(1,*box_jn_aff + h*((Interval(1.0)/6.0)*k1_aff + (Interval(2.0)/3.0)*k2_aff + (Interval(1.0)/6.0)*k3_aff));

     Affine2Vector la3=*box_jn_aff + h*( (Interval(1.0)/6.0)*k1_aff + (Interval(2.0)/3.0)*k2_aff + (Interval(1.0)/6.0)*k3_aff);




     return la3+*box_err_aff;

   };



};
}
# 40 "/usr/local/include/ibex/ibex_integrate.h" 2 3
# 1 "/usr/local/include/ibex/ibex_solution_LC3.h" 1 3
# 18 "/usr/local/include/ibex/ibex_solution_LC3.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 19 "/usr/local/include/ibex/ibex_solution_LC3.h" 2 3


namespace ibex{

class solution_j_lc3 : public solution_j
{
  public:



 IntervalVector picard(IntervalVector y0, ivp_ode* _ode, int ordre)
 {
   return picard_tayl(y0,_ode,2);
 }


 Affine2Vector LTE(IntervalVector y0,ivp_ode* _ode, double h)
 {
   if (_ode->get_lte_computation() == AUTODIF){
     if (!_ode->get_dags()->is_filled_in()){
       ibex::IntervalMatrix A(3, 3, 0.0);
       A[0][0] = (1.0)/(6.);
       A[0][1] = (-1.0)/(3.);
       A[0][2] = (1.0)/(6.);

       A[1][0] = (1.0)/(6.);
       A[1][1] = (5.0)/(12.);
       A[1][2] = (-1.0)/(12.);

       A[2][0] = (1.0)/(6.);
       A[2][1] = (2.0)/(3.);
       A[2][2] = (1.0)/(6.);

       ibex::Vector b(3);
       b[0] = (1.0)/(6.);
       b[1] = (2.0)/(3.);
       b[2] = (1.0)/(6.);


       _ode->set_Butcher_table(A, b);
     }
     Affine2Vector err_aff = _ode->get_dags()->get_lte(5, Affine2Vector(y0, true));
     err_aff*=(pow(Interval(h),5) / 120.0);

     return err_aff;
   } else {
     Affine2Vector err_aff = _ode->computeLC3derivative(Affine2Vector(y0,true));
     err_aff*=(pow(Interval(h),5) / 120);
     return err_aff;
   }

 }


 double factor_stepsize(double test)
 {
   return std::min(1.8,std::max(0.4,0.9*std::pow(1.0/test,0.2)));
 }



 int calcul_jnh(ivp_ode* _ode){

   *box_jnh_aff = remainder_lc3(_ode);
   return 1;
 }



 solution_j_lc3(const Affine2Vector _box_jn, double tn, double h, ivp_ode* _ode,double a, double fac) : solution_j(_box_jn, tn, h, _ode, a, fac)
 {

 }



 ~solution_j_lc3(){

 }



private:


   Affine2Vector remainder_lc3(ivp_ode* _ode)
   {
     double h=time_j.diam();
     double tol = 1e-20;

     IntervalVector k1 = _ode->compute_derivatives(1,*box_j1);
     IntervalVector k2(k1);
     IntervalVector k3(k1);

     IntervalVector k1_old(k1);
     IntervalVector k2_old(k2);
     IntervalVector k3_old(k3);


     k1 = _ode->compute_derivatives(1,*box_jn + h*((Interval(1)/6.0)*k1 + (-Interval(1)/3.0)*k2 + (Interval(1)/6.0)*k3));
     int i = 1;
     do
     {

       k1_old=k1;
       k2_old=k2;
       k3_old=k3;
       IntervalVector k1_temp(_ode->compute_derivatives(1,*box_jn + h*((Interval(1)/6.0)*k1 + (-Interval(1)/3.0)*k2 + (Interval(1.)/6.0)*k3)));
       IntervalVector k2_temp(_ode->compute_derivatives(1,*box_jn + h*((Interval(1)/6.0)*k1 + (Interval(5)/12.0)*k2 + (-Interval(1.)/12.0)*k3)));
       IntervalVector k3_temp(_ode->compute_derivatives(1,*box_jn + h*((Interval(1)/6.0)*k1 + (Interval(2)/3.0)*k2 + (Interval(1.)/6.0)*k3)));

       k1 &= k1_temp;
       k2 &= k2_temp;
       k3 &= k3_temp;

       i++;

     }while((k1.rel_distance(k1_old) > tol)||(k2.rel_distance(k2_old) > tol)||(k3.rel_distance(k3_old) > tol));



     Affine2Vector k1_aff(k1,true);
     Affine2Vector k2_aff(k2,true);
     Affine2Vector k3_aff(k3,true);

     k1_aff = _ode->compute_derivatives_aff(1,*box_jn_aff + h*((Interval(1)/6.0)*k1_aff + (-Interval(1.0)/3.0)*k2_aff + (Interval(1.0)/6.0)*k3_aff));

     k2_aff = _ode->compute_derivatives_aff(1,*box_jn_aff + h*((Interval(1)/6.0)*k1_aff + (Interval(5.0)/12.0)*k2_aff + (-Interval(1.0)/12.0)*k3_aff));

     k3_aff = _ode->compute_derivatives_aff(1,*box_jn_aff + h*((Interval(1)/6.0)*k1_aff + (Interval(2.0)/3.0)*k2_aff + (Interval(1.0)/6.0)*k3_aff));

     Affine2Vector lc3=*box_jn_aff + h*( (Interval(1)/6.0)*k1_aff + (Interval(2)/3.0)*k2_aff + (Interval(1)/6.0)*k3_aff);


     return lc3+*box_err_aff;

   };



};
}
# 41 "/usr/local/include/ibex/ibex_integrate.h" 2 3
# 1 "/usr/local/include/ibex/ibex_solution_RADAU3.h" 1 3
# 18 "/usr/local/include/ibex/ibex_solution_RADAU3.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 19 "/usr/local/include/ibex/ibex_solution_RADAU3.h" 2 3


namespace ibex{

class solution_j_radau3 : public solution_j
{
  public:



 IntervalVector picard(IntervalVector y0, ivp_ode* _ode, int ordre)
 {
   return picard_tayl(y0,_ode,ordre);
 }


 Affine2Vector LTE(IntervalVector y0,ivp_ode* _ode, double h)
 {
   if (_ode->get_lte_computation() == AUTODIF){
     if (!_ode->get_dags()->is_filled_in()){

       ibex::IntervalMatrix A(2, 2, 0.0);
       A[0][0] = Interval(5.0)/(12.);
       A[0][1] = Interval(-1.0)/(12.);
       A[1][0] = Interval(3.0)/(4.0);
       A[1][1] = Interval(1.0)/(4.0);
       ibex::IntervalVector b(2);
       b[0] = Interval(3.0)/(4.0);
       b[1] = Interval(1.0)/(4.0);

       _ode->set_Butcher_table(A, b);
     }
     Affine2Vector y0_aff = Affine2Vector(y0);
     Affine2Vector err_aff = _ode->get_dags()->get_lte(4, y0_aff);
     err_aff*=(pow(Interval(h),4) / 24);
     return err_aff;
   } else {
     Affine2Vector err_aff = _ode->computeRADAU3derivative(Affine2Vector(y0,true));
     err_aff*=(pow(Interval(h),4) / 24);

     return err_aff;
   }
 }


 double factor_stepsize(double test)
 {
   return std::min(1.8,std::max(0.4,0.9*std::pow(1.0/test,0.25)));
 }



 int calcul_jnh(ivp_ode* _ode){

   *box_jnh_aff = remainder_radau3(_ode);
   return 1;
 };



 solution_j_radau3(const Affine2Vector _box_jn, double tn, double h, ivp_ode* _ode,double a, double fac) : solution_j(_box_jn, tn, h, _ode, a, fac)
 {

 }



 ~solution_j_radau3(){
 }



private:


   Affine2Vector remainder_radau3(ivp_ode* _ode)
   {
     double h=time_j.diam();
     double tol = 1e-20;

     IntervalVector k1 = _ode->compute_derivatives(1,*box_j1);
     IntervalVector k2(k1);


     IntervalVector k1_old(k1);
     IntervalVector k2_old(k2);

     do
     {
       k1_old=k1;
       k2_old=k2;

       k1 &= _ode->compute_derivatives(1,*box_jn + h*((Interval(5.0)/12.0)*k1 + (-Interval(1.0)/12.0)*k2));
       k2 &= _ode->compute_derivatives(1,*box_jn + h*((Interval(3.0)/4.0)*k1 + (Interval(1.0)/4.0)*k2));


     }while ((k1.rel_distance(k1_old) > tol)||(k2.rel_distance(k2_old) > tol));

     Affine2Vector k1_aff = Affine2Vector(k1,true);
     Affine2Vector k2_aff = Affine2Vector(k2,true);

     k1_aff = _ode->compute_derivatives_aff(1,*box_jn_aff + h*((Interval(5.0)/12.0)*k1_aff + (-Interval(1.0)/12.0)*k2_aff));

     k2_aff = _ode->compute_derivatives_aff(1,*box_jn_aff + h*((Interval(3.0)/4.0)*k1_aff + (Interval(1.0)/4.0)*k2_aff));

     Affine2Vector radau3=*box_jn_aff + h*( (Interval(3.0)/4.0)*k1_aff + (Interval(1.0)/4.0)*k2_aff);

     return radau3+*box_err_aff;

   };



};
}
# 42 "/usr/local/include/ibex/ibex_integrate.h" 2 3
# 1 "/usr/local/include/ibex/ibex_solution_RADAU5.h" 1 3
# 17 "/usr/local/include/ibex/ibex_solution_RADAU5.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 18 "/usr/local/include/ibex/ibex_solution_RADAU5.h" 2 3


namespace ibex{

  class solution_j_radau5 : public solution_j
  {
  public:



    IntervalVector picard(IntervalVector y0, ivp_ode* _ode, int ordre)
    {


      return picard_tayl(y0,_ode, ordre);
    }


    Affine2Vector LTE(IntervalVector y0,ivp_ode* _ode, double h)
    {
        if (_ode->get_lte_computation() == AUTODIF){
            if (!_ode->get_dags()->is_filled_in()){
                ibex::IntervalMatrix A(3, 3, 0.0);
                Interval racine = ibex::sqrt(Interval(6., 6.));
# 77 "/usr/local/include/ibex/ibex_solution_RADAU5.h" 3
                Interval a11(0.19681547722366038E0, 0.19681547722366044E0);
                Interval a12(-0.65535425850198448E-1, -0.65535425850198337E-1);
                Interval a13(0.23770974348220147E-1, 0.23770974348220158E-1);
                Interval a21(0.39442431473908718E0, 0.39442431473908740E0);
                Interval a22(0.29207341166522843E0, 0.29207341166522854E0);
                Interval a23(-0.41548752125997943E-1, -0.41548752125997922E-1);
                Interval a31(0.37640306270046725E0, 0.37640306270046731E0);
                Interval a32(0.51248582618842153E0, 0.51248582618842164E0);
                Interval a33(0.11111111111111110E0, 0.11111111111111112E0);


                Interval b1(0.37640306270046725E0, 0.37640306270046731E0);
                Interval b2(0.51248582618842153E0, 0.51248582618842164E0);
                Interval b3(0.11111111111111110E0, 0.11111111111111112E0);

                A[0][0] = a11;
                A[0][1] = a12;
                A[0][2] = a13;

                A[1][0] = a21;
                A[1][1] = a22;
                A[1][2] = a23;

                A[2][0] = a31;
                A[2][1] = a32;
                A[2][2] = a33;

                ibex::IntervalVector b(3);
                b[0] = b1;
                b[1] = b2;
                b[2] = b3;


                _ode->set_Butcher_table(A, b);
            }
            Affine2Vector y0_aff = Affine2Vector(y0, true);
            Affine2Vector err_aff = _ode->get_dags()->get_lte(6, y0_aff);


            err_aff*=(pow(Interval(h),6) / 720.0);
            return err_aff;
        } else {
            Affine2Vector err_aff = _ode->computeRADAU5derivative(Affine2Vector(y0,true));
            err_aff*=(pow(Interval(h),6) / 720.0);
            return err_aff;
        }

    }


    double factor_stepsize(double test)
    {
      return std::min(1.8,std::max(0.4,0.9*std::pow(1.0/test,1.0/6.0)));
    }



    int calcul_jnh(ivp_ode* _ode){

      *box_jnh_aff = remainder_radau5(_ode);
      return 1;
    };



  solution_j_radau5(const Affine2Vector _box_jn, double tn, double h, ivp_ode* _ode,double a, double fac) : solution_j(_box_jn, tn, h, _ode, a, fac)
      {

      }



    ~solution_j_radau5(){
    }



  private:


    Affine2Vector remainder_radau5(ivp_ode* _ode)
    {
      double h=time_j.diam();
      double tol = 1e-20;

      IntervalVector k1 = _ode->compute_derivatives(1,*box_j1);
      IntervalVector k2(k1);
      IntervalVector k3(k1);

      IntervalVector k1_old(k1);
      IntervalVector k2_old(k2);
      IntervalVector k3_old(k3);

      Interval a11(0.19681547722366038E0, 0.19681547722366044E0);
      Interval a12(-0.65535425850198448E-1, -0.65535425850198337E-1);
      Interval a13(0.23770974348220147E-1, 0.23770974348220158E-1);
      Interval a21(0.39442431473908718E0, 0.39442431473908740E0);
      Interval a22(0.29207341166522843E0, 0.29207341166522854E0);
      Interval a23(-0.41548752125997943E-1, -0.41548752125997922E-1);
      Interval a31(0.37640306270046725E0, 0.37640306270046731E0);
      Interval a32(0.51248582618842153E0, 0.51248582618842164E0);
      Interval a33(0.11111111111111110E0, 0.11111111111111112E0);


      Interval b1(0.37640306270046725E0, 0.37640306270046731E0);
      Interval b2(0.51248582618842153E0, 0.51248582618842164E0);
      Interval b3(0.11111111111111110E0, 0.11111111111111112E0);

      do
 {
   k1_old=k1;
   k2_old=k2;
   k3_old=k3;

   k1 &= _ode->compute_derivatives(1,*box_jn + h*(a11*k1 + a12*k2 + a13*k3));
   k2 &= _ode->compute_derivatives(1,*box_jn + h*(a21*k1 + a22*k2 + a23*k3));
   k3 &= _ode->compute_derivatives(1,*box_jn + h*(a31*k1 + a32*k2 + a33*k3));


 }while ((k1.rel_distance(k1_old) > tol)||(k2.rel_distance(k2_old) > tol)||(k3.rel_distance(k3_old) > tol));

      Affine2Vector k1_aff(k1,true);
      Affine2Vector k2_aff(k2,true);
      Affine2Vector k3_aff(k3,true);

      k1_aff = _ode->compute_derivatives_aff(1,*box_jn_aff + h*(a11*k1_aff + a12*k2_aff + a13*k3_aff));
      k2_aff = _ode->compute_derivatives_aff(1,*box_jn_aff + h*(a21*k1_aff + a22*k2_aff + a23*k3_aff));
      k3_aff = _ode->compute_derivatives_aff(1,*box_jn_aff + h*(a31*k1_aff + a32*k2_aff + a33*k3_aff));

      Affine2Vector radau5=*box_jn_aff + h*(b1*k1_aff + b2*k2_aff + b3*k3_aff);

      return radau5+*box_err_aff;

    };



  };
}
# 43 "/usr/local/include/ibex/ibex_integrate.h" 2 3
# 1 "/usr/local/include/ibex/ibex_solution_TAYLOR4.h" 1 3
# 18 "/usr/local/include/ibex/ibex_solution_TAYLOR4.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 19 "/usr/local/include/ibex/ibex_solution_TAYLOR4.h" 2 3


namespace ibex{

class solution_j_tayl4 : public solution_j
{
  public:



 IntervalVector picard(IntervalVector y0, ivp_ode* _ode, int ordre)
 {
   return picard_tayl(y0,_ode,ordre);
 }


 Affine2Vector LTE(IntervalVector y0,ivp_ode* _ode, double h)
 {
     Affine2Vector y0aff = Affine2Vector(y0);

     Affine2Vector err_aff = _ode->compute_derivatives_aff(5,Affine2Vector(y0,true));

     err_aff*=(pow(Interval(h),5) / 120);

     return err_aff;
 }


 double factor_stepsize(double test)
 {
   return std::min(1.8,std::max(0.4,0.9*std::pow(1.0/test,0.2)));
 }


 int calcul_jnh(ivp_ode* _ode){

   *box_jnh_aff = remainder_taylor4(_ode);
   return 1;
 };



 solution_j_tayl4(const Affine2Vector _box_jn, double tn, double h, ivp_ode* _ode,double a, double fac) : solution_j(_box_jn, tn, h, _ode, a, fac)
 {


 }



 ~solution_j_tayl4(){

 }



private:


   Affine2Vector remainder_taylor4(ivp_ode* _ode)
   {
     double h=time_j.diam();


     Affine2Vector tayl4(*box_jn_aff);
     int n=5;
     int fac_i=1;
     for (int i=1;i<n;i++)
     {
  fac_i = fac_i*i;
  Affine2Vector df = _ode->compute_derivatives_aff(i, *box_jn_aff);
  df*=(1.0 /fac_i);
  df*=pow(h,i);

  tayl4+=df;

     }


     return tayl4+*box_err_aff;

   };



};
}
# 44 "/usr/local/include/ibex/ibex_integrate.h" 2 3
# 1 "/usr/local/include/ibex/ibex_solution_HEUN.h" 1 3
# 18 "/usr/local/include/ibex/ibex_solution_HEUN.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 19 "/usr/local/include/ibex/ibex_solution_HEUN.h" 2 3


namespace ibex{

class solution_j_heun : public solution_j
{
  public:



 IntervalVector picard(IntervalVector y0, ivp_ode* _ode, int ordre)
 {
   return picard_tayl(y0,_ode,2);
 }


 Affine2Vector LTE(IntervalVector y0,ivp_ode* _ode, double h)
 {
   if (_ode->get_lte_computation() == AUTODIF){
     if (!_ode->get_dags()->is_filled_in()){
       ibex::IntervalMatrix A(2, 2, 0.0);
       A[1][0] = Interval(1.0);
       ibex::IntervalVector b(2);
       b[0] = Interval(0.5);
       b[1] = Interval(0.5);

       _ode->set_Butcher_table(A, b);
     }
     Affine2Vector y0_aff = Affine2Vector(y0);
     Affine2Vector err_aff = _ode->get_dags()->get_lte(3, y0_aff);
     err_aff*=(pow(Interval(h),3) / 6.0);
     return err_aff;
   } else {
     Affine2Vector err_aff = _ode->computeHEUNderivative(Affine2Vector(y0,true));
     err_aff*=(pow(Interval(h),3) / 6.0);
     return err_aff;
   }
 }


 double factor_stepsize(double test)
 {
   return std::min(1.8,std::max(0.4,0.9*std::pow(1.0/test,0.33)));
 }



 int calcul_jnh(ivp_ode* _ode){

   *box_jnh_aff = remainder_heun(_ode);
   return 1;
 };



 solution_j_heun(const Affine2Vector _box_jn, double tn, double h, ivp_ode* _ode,double a, double fac) : solution_j(_box_jn, tn, h, _ode, a, fac)
 {

 }



 ~solution_j_heun(){

 }



private:


   Affine2Vector remainder_heun(ivp_ode* _ode)
   {
     double h=time_j.diam();

     Affine2Vector k1 = _ode->compute_derivatives_aff(1, *box_jn_aff);
     Affine2Vector k2 = _ode->compute_derivatives_aff(1, *box_jn_aff+h*k1);

     Affine2Vector heun = k1+k2;
     heun*=(Interval(h)/2.0);
     heun+=*box_jn_aff;

     return heun+*box_err_aff;

   };



};
}
# 45 "/usr/local/include/ibex/ibex_integrate.h" 2 3
# 1 "/usr/local/include/ibex/ibex_solution_GL4.h" 1 3
# 18 "/usr/local/include/ibex/ibex_solution_GL4.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 19 "/usr/local/include/ibex/ibex_solution_GL4.h" 2 3



namespace ibex{

class solution_j_gauss4 : public solution_j
{
  public:



 IntervalVector picard(IntervalVector y0, ivp_ode* _ode, int ordre)
 {
   return picard_tayl(y0,_ode,2);
 }


 Affine2Vector LTE(IntervalVector y0,ivp_ode* _ode, double h)
 {
        if (_ode->get_lte_computation() == AUTODIF){
            if (!_ode->get_dags()->is_filled_in()){
                ibex::IntervalMatrix A(2, 2, 0.);
                A[0][0] = Interval(0.25000000000000000E0, 0.25000000000000000E0);
                A[0][1] = Interval(-0.38675134594812977E-1, -0.38675134594812810E-1);
                A[1][0] = Interval(0.53867513459481264E0, 0.53867513459481309E0);
                A[1][1] = Interval(0.25000000000000000E0, 0.25000000000000000E0);
                ibex::IntervalVector b(2);
                b[0] = Interval(.5);
                b[1] = Interval(.5);
                _ode->set_Butcher_table(A, b);
            }

            Affine2Vector err_aff = _ode->get_dags()->get_lte(5, Affine2Vector(y0, true));
            err_aff*=(pow(Interval(h),5) / 120);
            return err_aff;
        }
     Affine2Vector err_aff = _ode->computeGL4derivative_aff(Affine2Vector(y0,true));
     err_aff*=(pow(Interval(h),5) / 120);
     return err_aff;

 }


 double factor_stepsize(double test)
 {
   return std::min(1.8,std::max(0.4,0.9*std::pow(1.0/test,0.2)));
 }



 int calcul_jnh(ivp_ode* _ode){

   *box_jnh_aff = remainder_gl4(_ode);
   return 1;
 };



 solution_j_gauss4(const Affine2Vector _box_jn, double tn, double h, ivp_ode* _ode,double a, double fac) : solution_j(_box_jn, tn, h, _ode, a, fac)
 {

 }



 ~solution_j_gauss4(){

 }



private:


   Affine2Vector remainder_gl4(ivp_ode* _ode)
   {
     double h=time_j.diam();
     double tol = 1e-20;

     IntervalVector k1 = _ode->compute_derivatives(1,*box_j1);
     IntervalVector k2(k1);


     IntervalVector k1_old(k1);
     IntervalVector k2_old(k2);



     do
     {

       k1_old=k1;
       k2_old=k2;



       k1 &= _ode->compute_derivatives(1,*box_jn + h*((Interval(0.25000000000000000E0, 0.25000000000000000E0))*k1 + (Interval(-0.38675134594812977E-1, -0.38675134594812810E-1))*k2 ));
       k2 &= _ode->compute_derivatives(1,*box_jn + h*((Interval(0.53867513459481264E0, 0.53867513459481309E0))*k1 + (Interval(0.25000000000000000E0, 0.25000000000000000E0))*k2 ));


     }while((k1.rel_distance(k1_old) > tol)||(k2.rel_distance(k2_old) > tol));



     Affine2Vector k1_aff(k1,true);
     Affine2Vector k2_aff(k2,true);


     k1_aff = _ode->compute_derivatives_aff(1,*box_jn_aff + h*((Interval(0.25000000000000000E0, 0.25000000000000000E0))*k1_aff + (Interval(-0.38675134594812977E-1, -0.38675134594812810E-1))*k2_aff));

     k2_aff = _ode->compute_derivatives_aff(1,*box_jn_aff + h*((Interval(0.53867513459481264E0, 0.53867513459481309E0))*k1_aff + (Interval(0.25000000000000000E0, 0.25000000000000000E0))*k2_aff));



     Affine2Vector gl4=*box_jn_aff + h*( (Interval(0.50000000000000000E0, 0.50000000000000000E0))*k1_aff + (Interval(0.50000000000000000E0, 0.50000000000000000E0))*k2_aff);


     return gl4+*box_err_aff;

   };



};
}
# 46 "/usr/local/include/ibex/ibex_integrate.h" 2 3
# 1 "/usr/local/include/ibex/ibex_solution_kutta3.h" 1 3
# 16 "/usr/local/include/ibex/ibex_solution_kutta3.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 17 "/usr/local/include/ibex/ibex_solution_kutta3.h" 2 3



namespace ibex{

class solution_j_kutta3 : public solution_j
{
  public:


 IntervalVector picard(IntervalVector y0, ivp_ode* _ode, int ordre)
 {
   return picard_tayl(y0,_ode,ordre);
 }


 Affine2Vector LTE(IntervalVector y0,ivp_ode* _ode, double h)
 {
        if (_ode->get_lte_computation() == AUTODIF){
            if (!_ode->get_dags()->is_filled_in()){
                ibex::IntervalMatrix A(3, 3, 0.);
                A[1][0] = Interval(0.5);
                A[2][0] = Interval(-1.0);
                A[2][1] = Interval(2.0);
                ibex::IntervalVector b(3);
                b[0] = Interval(1.)/6;
                b[1] = Interval(2.)/3;
                b[2] = Interval(1.)/6;
                _ode->set_Butcher_table(A, b);
            }

            Affine2Vector err_aff = _ode->get_dags()->get_lte(4, Affine2Vector(y0, true));
            err_aff*=(pow(Interval(h),4) / 24.0);
            return err_aff;
        }

     Affine2Vector err_aff = _ode->computeKUTTA3derivative_aff(Affine2Vector(y0,true));
     err_aff*=(pow(Interval(h),4) / 24.0);

     return err_aff;
 }


 double factor_stepsize(double test)
 {
   return std::min(1.8,std::max(0.4,0.95*std::pow(1.0/test,0.25)));
 }



 int calcul_jnh(ivp_ode* _ode){

   *box_jnh_aff = remainder_kutta3(_ode);
   return 1;
 };



 solution_j_kutta3(const Affine2Vector _box_jn, double tn, double h, ivp_ode* _ode,double a, double fac) : solution_j(_box_jn, tn, h, _ode, a, fac)
 {

 }



 ~solution_j_kutta3(){

 }



private:


   Affine2Vector remainder_kutta3(ivp_ode* _ode)
   {
     double h=time_j.diam();
     Affine2Vector boxj1(*box_jn_aff);

     Affine2Vector k1 = _ode->compute_derivatives_aff(1, boxj1);

     Affine2Vector boxj2(k1);
     boxj2*=(Interval(0.5)*h);
     Affine2Vector k2 = _ode->compute_derivatives_aff(1, *box_jn_aff+boxj2);

     Affine2Vector boxj3(-k1+2*k2);
     boxj3*=h;

     Affine2Vector k3 = _ode->compute_derivatives_aff(1, *box_jn_aff+boxj3);
     Affine2Vector kutta3 = Interval(1.0)/6.0*k1 + Interval(2.0)/3.0*k2 + Interval(1.0)/6.0*k3;
     kutta3*=h;
     kutta3+=*box_jn_aff;



     return kutta3+*box_err_aff;

   };



};
}
# 47 "/usr/local/include/ibex/ibex_integrate.h" 2 3
# 1 "/usr/local/include/ibex/ibex_solution_GL6.h" 1 3
# 17 "/usr/local/include/ibex/ibex_solution_GL6.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 18 "/usr/local/include/ibex/ibex_solution_GL6.h" 2 3



namespace ibex{

class solution_j_gauss6 : public solution_j
{
  public:



 IntervalVector picard(IntervalVector y0, ivp_ode* _ode, int ordre)
 {
   return picard_tayl(y0,_ode,ordre);
 }


 Affine2Vector LTE(IntervalVector y0,ivp_ode* _ode, double h)
 {
   if (_ode->get_lte_computation() == AUTODIF){

            if (!_ode->get_dags()->is_filled_in()){
     Interval sqrt15 = ibex::sqrt(Interval(15.0));
     Interval five36 = Interval(5.0) / 36.0;

     Interval two9 = Interval(2.0) / 9.0;
     Interval four9 = Interval (4.0) / 9.0;
     Interval five18 = Interval (5.0) / 18.0;
     Interval half = Interval(0.5);

     ibex::IntervalMatrix A(3, 3, 0.);
     A[0][0] = five36;
     A[0][1] = two9 - (sqrt15 / 15.0);
     A[0][2] = five36 - (sqrt15 / 30.0);

     A[1][0] = five36 + (sqrt15 / 24.0);
     A[1][1] = two9;
     A[1][2] = five36 - (sqrt15 / 24.0);

     A[2][0] = five36 + (sqrt15 / 30.0);
     A[2][1] = two9 + (sqrt15 / 15.0);
     A[2][2] = five36;

     ibex::IntervalVector b(3);
     b[0] = five18;
     b[1] = four9;
     b[2] = five18;

     _ode->set_Butcher_table(A, b);
            }

            Affine2Vector err_aff = _ode->get_dags()->get_lte(7, Affine2Vector(y0, true));
            err_aff*=(pow(Interval(h),7) / 5040.0);
            return err_aff;
        }

   Affine2Vector err_aff = _ode->computeGL6derivative_aff(Affine2Vector(y0,true));
     err_aff*=(pow(Interval(h),7) / 5040.0);

     return err_aff;
 }


 double factor_stepsize(double test)
 {
   return std::min(1.8,std::max(0.4,0.9*std::pow(1.0/test,1.0/7.0)));
 }



 int calcul_jnh(ivp_ode* _ode){

   *box_jnh_aff = remainder_gauss6(_ode);
   return 1;
 };



 solution_j_gauss6(const Affine2Vector _box_jn, double tn, double h, ivp_ode* _ode,double a, double fac) : solution_j(_box_jn, tn, h, _ode, a, fac)
 {

 }



 ~solution_j_gauss6(){
 }



private:


   Affine2Vector remainder_gauss6(ivp_ode* _ode)
   {
     double h=time_j.diam();
     double tol = 1e-20;

     IntervalVector k1 = _ode->compute_derivatives(1,*box_j1);
     IntervalVector k2(k1);
     IntervalVector k3(k1);

     IntervalVector k1_old(k1);
     IntervalVector k2_old(k2);
     IntervalVector k3_old(k3);

     Interval sqrt15 = ibex::sqrt(Interval(15.0));
     Interval five36 = Interval(5.0) / 36.0;

     Interval two9 = Interval(2.0) / 9.0;
     Interval four9 = Interval (4.0) / 9.0;
     Interval five18 = Interval (5.0) / 18.0;
     Interval half = Interval(0.5);

     Interval a11= five36;
     Interval a12 = two9 - (sqrt15 / 15.0);
     Interval a13 = five36 - (sqrt15 / 30.0);
     Interval a21= five36 + (sqrt15 / 24.0);
     Interval a22 = two9;
     Interval a23= five36 - (sqrt15 / 24.0);
     Interval a31= five36 + (sqrt15 / 30.0);
     Interval a32= two9 + (sqrt15 / 15.0);
     Interval a33= five36;


     Interval b1= five18;
     Interval b2= four9;
     Interval b3= five18;

     do
     {
       k1_old=k1;
       k2_old=k2;
       k3_old=k3;

       k1 &= _ode->compute_derivatives(1,*box_jn + h*(a11*k1 + a12*k2 + a13*k3));
       k2 &= _ode->compute_derivatives(1,*box_jn + h*(a21*k1 + a22*k2 + a23*k3));
       k3 &= _ode->compute_derivatives(1,*box_jn + h*(a31*k1 + a32*k2 + a33*k3));


     }while ((k1.rel_distance(k1_old) > atol)||(k2.rel_distance(k2_old) > atol)||(k3.rel_distance(k3_old) > atol));

     Affine2Vector k1_aff(k1,true);
     Affine2Vector k2_aff(k2,true);
     Affine2Vector k3_aff(k3,true);

     k1_aff = _ode->compute_derivatives_aff(1,*box_jn_aff + h*(a11*k1_aff + a12*k2_aff + a13*k3_aff));
     k2_aff = _ode->compute_derivatives_aff(1,*box_jn_aff + h*(a21*k1_aff + a22*k2_aff + a23*k3_aff));
     k3_aff = _ode->compute_derivatives_aff(1,*box_jn_aff + h*(a31*k1_aff + a32*k2_aff + a33*k3_aff));

     Affine2Vector gauss6=*box_jn_aff + h*(b1*k1_aff + b2*k2_aff + b3*k3_aff);

     return gauss6+*box_err_aff;

   };



};
}
# 48 "/usr/local/include/ibex/ibex_integrate.h" 2 3

# 1 "/usr/local/include/ibex/ibex_simulation.h" 1 3
# 20 "/usr/local/include/ibex/ibex_simulation.h" 3
# 1 "/usr/local/include/ibex/ibex_integrate.h" 1 3
# 21 "/usr/local/include/ibex/ibex_simulation.h" 2 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 22 "/usr/local/include/ibex/ibex_simulation.h" 2 3





namespace ibex{


  enum Method {IEULER,IMIDPOINT,RADAU3,HEUN,TAYLOR4,LA3,LC3,RK4,RADAU3_DAE, RADAU5, GL4, GL6, KUTTA3};

  class simulation
  {
  public:
    double time_T;
    int process;
    double atol;
    int test;
    Method meth;
    int nb_var;
    bool failed;

    bool monotony_active;


    std::list<solution_j> list_solution_j;
    ivp_ode* embedded_ode;

    std::list<solution_j_dae> list_solution_j_dae;
    ivp_dae_h1* embedded_dae;


    std::list<solution_g> list_solution_g;


    Affine2Vector* last_aff;



    void active_monotony()
    {
      monotony_active=true;
    }

    void inactive_monotony()
    {
      monotony_active=false;
    }


    static double getHmin () {
      return dynibex_hmin;
    }

    static void setHmin (double _hmin) {
      (static_cast <bool> (_hmin > 0.0) ? void (0) : __assert_fail ("_hmin > 0.0", "/usr/local/include/ibex/ibex_simulation.h", 76, __extension__ __PRETTY_FUNCTION__));
      dynibex_hmin = _hmin;
    }

    static double getHmax () {
      return dynibex_hmax;
    }

    static void setHmax (double _hmax) {
      (static_cast <bool> (_hmax > 0.0) ? void (0) : __assert_fail ("_hmax > 0.0", "/usr/local/include/ibex/ibex_simulation.h", 85, __extension__ __PRETTY_FUNCTION__));
      dynibex_hmax = _hmax;
    }


    void sol_to_generic(std::list<solution_j> list_sol)
    {
      std::list<solution_j>::iterator iterator_list;
      for(iterator_list=list_sol.begin();iterator_list!=list_sol.end();iterator_list++)
 {
   solution_g sol_temp(iterator_list->time_j, iterator_list->box_j1, iterator_list->box_jn, iterator_list->box_jnh, nb_var);
   list_solution_g.push_back(sol_temp);
   iterator_list->destructor();
 }
    }

    void sol_to_generic(std::list<solution_j_dae> list_sol)
    {
      std::list<solution_j_dae>::iterator iterator_list;
      for(iterator_list=list_sol.begin();iterator_list!=list_sol.end();iterator_list++)
 {
   solution_g sol_temp(iterator_list->time_j, iterator_list->box_j1, iterator_list->box_jn, iterator_list->box_jnh,nb_var);
   list_solution_g.push_back(sol_temp);
   iterator_list->destructor();
 }
    }

    int run_simulation(){
      double tn ;
      solution_j sol_temp;
      solution_j_dae sol_temp_dae;
      double fac;
      double newh;
      do
 {

   if (!list_solution_j.empty())
     {
       sol_temp = list_solution_j.back();

       tn = sol_temp.time_j.ub();
       fac = sol_temp.factor;
       newh = std::abs(sol_temp.time_j.diam())*fac;
     }
   else
     {
       sol_temp_dae = list_solution_j_dae.back();

       tn = sol_temp_dae.time_j.ub();
       fac = sol_temp_dae.factor;
       newh = std::abs(sol_temp_dae.time_j.diam())*fac;
     }



   if (tn < time_T)
     {
       double delta_t = time_T-tn;

       if (delta_t < newh) newh = delta_t;

       switch(meth)
  {
  case IEULER:
    {
      solution_j_ieuler u_j(*sol_temp.box_jnh_aff,tn,newh, embedded_ode,atol,fac);
      u_j.compute_oneStep(*sol_temp.box_jnh_aff,embedded_ode,monotony_active);
      sol_temp.flush();
      list_solution_j.push_back(u_j);
      break;
    }
  case IMIDPOINT:
    {
      solution_j_imidpoint u_j(*sol_temp.box_jnh_aff,tn,newh, embedded_ode,atol,fac);
      u_j.compute_oneStep(*sol_temp.box_jnh_aff,embedded_ode,monotony_active);
      sol_temp.flush();
      list_solution_j.push_back(u_j);
      break;
    }
  case RADAU3:
    {
      solution_j_radau3 u_j(*sol_temp.box_jnh_aff,tn,newh, embedded_ode,atol,fac);
      u_j.compute_oneStep(*sol_temp.box_jnh_aff,embedded_ode,monotony_active);
      sol_temp.flush();
      list_solution_j.push_back(u_j);
      break;
    }
  case HEUN:
    {
      solution_j_heun u_j(*sol_temp.box_jnh_aff,tn,newh, embedded_ode,atol,fac);
      u_j.compute_oneStep(*sol_temp.box_jnh_aff,embedded_ode,monotony_active);
      sol_temp.flush();
      list_solution_j.push_back(u_j);
      break;
    }
  case TAYLOR4:
    {
      solution_j_tayl4 u_j(*sol_temp.box_jnh_aff,tn,newh, embedded_ode,atol,fac);
      u_j.compute_oneStep(*sol_temp.box_jnh_aff,embedded_ode,monotony_active);
      sol_temp.flush();
      list_solution_j.push_back(u_j);
      break;
    }
  case KUTTA3:
    {
      solution_j_kutta3 u_j(*sol_temp.box_jnh_aff,tn,newh, embedded_ode,atol,fac);
      u_j.compute_oneStep(*sol_temp.box_jnh_aff,embedded_ode,monotony_active);
      sol_temp.flush();
      list_solution_j.push_back(u_j);
      break;
    }
  case LA3:
    {
      solution_j_la3 u_j(*sol_temp.box_jnh_aff,tn,newh, embedded_ode,atol,fac);
      u_j.compute_oneStep(*sol_temp.box_jnh_aff,embedded_ode,monotony_active);
      sol_temp.flush();
      list_solution_j.push_back(u_j);
      break;
    }
  case LC3:
    {
      solution_j_lc3 u_j(*sol_temp.box_jnh_aff,tn,newh, embedded_ode,atol,fac);
      u_j.compute_oneStep(*sol_temp.box_jnh_aff,embedded_ode,monotony_active);
      sol_temp.flush();
      list_solution_j.push_back(u_j);
      break;
    }
  case RK4:
    {
      solution_j_rk4 u_j(*sol_temp.box_jnh_aff,tn,newh, embedded_ode,atol,fac);
      u_j.compute_oneStep(*sol_temp.box_jnh_aff,embedded_ode,monotony_active);
      sol_temp.flush();
      list_solution_j.push_back(u_j);
      break;
    }
  case GL4:
    {
      solution_j_gauss4 u_j(*sol_temp.box_jnh_aff,tn,newh, embedded_ode,atol,fac);
      u_j.compute_oneStep(*sol_temp.box_jnh_aff,embedded_ode,monotony_active);
      sol_temp.flush();
      list_solution_j.push_back(u_j);
      break;
    }
  case GL6:
    {
      solution_j_gauss6 u_j(*sol_temp.box_jnh_aff,tn,newh, embedded_ode,atol,fac);
      u_j.compute_oneStep(*sol_temp.box_jnh_aff,embedded_ode,monotony_active);
      sol_temp.flush();
      list_solution_j.push_back(u_j);
      break;
    }
  case RADAU3_DAE:
    {
      solution_j_dae u_j(*sol_temp_dae.box_jnh_aff,*sol_temp_dae.box_xnh_aff, tn,newh, embedded_dae,atol,fac);
      u_j.compute_oneStep(*sol_temp_dae.box_jnh_aff,*sol_temp_dae.box_xnh_aff,embedded_dae);
      sol_temp_dae.flush();
       list_solution_j_dae.push_back(u_j);

      break;

    }
  case RADAU5:
    {
      solution_j_radau5 u_j(*sol_temp.box_jnh_aff,tn,newh, embedded_ode,atol,fac);
      u_j.compute_oneStep(*sol_temp.box_jnh_aff,embedded_ode,monotony_active);
      sol_temp.flush();
      list_solution_j.push_back(u_j);
      break;
    }

  default :
    {




      std::cout << "This method does not exist !" << std::endl;
      tn = time_T;
    }

  }


     }
   if (!list_solution_j.empty())
     tn = sol_temp.time_j.ub();
   else
     tn = sol_temp_dae.time_j.ub();

 }while (tn < time_T);

      if (tn > 1e7)
 {
   failed = true;
   tn = time_T;
 }

      else
 {
   failed=false;
 }


      if (!list_solution_j.empty())
 {

   solution_j sol_temp = list_solution_j.back();




   CLogger::getLogger()->Log("Solution at t=%f : ",tn);
   CLogger::getLogger()->Log_sol(sol_temp.box_jnh_aff->itv());
   CLogger::getLogger()->Log_end();

   if (!failed)
     last_aff = new Affine2Vector(*sol_temp.box_jnh_aff);
   else
     last_aff = new Affine2Vector(*sol_temp.box_jnh,true);

   sol_to_generic(list_solution_j);
   list_solution_j.clear();

 }
      else
 {

   solution_j_dae sol_temp_dae = list_solution_j_dae.back();
   std::cout << "\nSolution at t=" << tn << " : " << sol_temp_dae.box_jnh_aff->itv() << std::endl;

   CLogger::getLogger()->Log("Solution at t=%f : ",tn);
   CLogger::getLogger()->Log_sol(sol_temp_dae.box_jnh_aff->itv());
   CLogger::getLogger()->Log_end();

   if (!failed)
     last_aff = new Affine2Vector(*sol_temp_dae.box_jnh_aff);
   else
     last_aff = new Affine2Vector(*sol_temp_dae.box_jnh,true);

   sol_to_generic(list_solution_j_dae);
   list_solution_j_dae.clear();

 }


      return 1;
    };

    IntervalVector find_box(std::list<IntervalVector>* stack, IntervalVector y)
    {

      std::list<IntervalVector>::iterator iterator_list;

      IntervalVector suby = y.subvector(0,y.size()/2 - 1);
      for(iterator_list=stack->begin();iterator_list!=stack->end();iterator_list++)
 {
   IntervalVector yv =*iterator_list;


   if (!(suby & yv).is_empty())
     return yv;
 }

      return IntervalVector(y.size()/2);
    }


    int order_of_method(Method _meth)
    {
      switch(meth)
 {
 case IEULER:
   {
     return 2;
     break;
   }
 case IMIDPOINT:
   {
     return 3;
     break;
   }
 case RADAU3:
   {
     return 4;
     break;
   }
 case HEUN:
   {
     return 3;
     break;
   }
 case TAYLOR4:
   {
     return 5;
     break;
   }
 case LA3:
   {
     return 5;
     break;
   }
 case LC3:
   {
     return 5;
     break;
   }
 case RK4:
   {
     return 5;
     break;
   }
 case RADAU3_DAE:
   {
     return 4;
     break;
   }
 case RADAU5:
   {
     return 6;
     break;
   }
 case GL4:
   {
     return 5;
     break;
   }
 case GL6:
   {
     return 7;
     break;
   }
 case KUTTA3:
   {
     return 4;
     break;
   }
 default :
   {
     return 5;
   }
 }
      return 6;
    }

    double pred_h(ivp_ode* _ode, double atol)
    {
      IntervalMatrix J=_ode->eval_jacobian_init();
      double max_J = 0;
      for (int i=0; i < J.nb_rows(); i++)
 {
   for (int j=0; j < J.nb_cols(); j++)
     {
       if (abs(J[i][j]).ub() > max_J)
  max_J = abs(J[i][j]).ub();
     }

 }
      return max_J;
    }


    simulation(ivp_ode* _ode, double T,Method _meth = RK4, double a = 1e-6){
      process = 0;
      embedded_ode = _ode;
      time_T = T;
      atol = a;
      meth = _meth;
      nb_var=_ode->nbvar;
      monotony_active = false;
      double coef = pred_h(_ode, atol);
      if (coef == 0.0)
 coef=1.0;
      double h = std::min(std::min(dynibex_hmax,0.01/coef),T/2.0);
      if (embedded_ode->get_lte_computation() == SYMBOLIC){
 embedded_ode->frechet_precomputing(order_of_method(meth));
      } else {
 embedded_ode->dag_precomputing(order_of_method(meth));
      }

      solution_j u_j0(*embedded_ode->yinit_aff,embedded_ode->t0,h,atol);
      list_solution_j.push_back(u_j0);
    }


    simulation(ivp_ode* _ode, double T,Method _meth, double a, double _h){
      process = 0;
      embedded_ode = _ode;
      time_T = T;
      atol = a;
      meth = _meth;
      nb_var=_ode->nbvar;
      monotony_active = false;

      double h = _h;
      if (embedded_ode->get_lte_computation() == SYMBOLIC){
 embedded_ode->frechet_precomputing(order_of_method(meth));
      } else {
 embedded_ode->dag_precomputing(order_of_method(meth));
      }

      solution_j u_j0(*embedded_ode->yinit_aff,embedded_ode->t0,h,atol);
      list_solution_j.push_back(u_j0);
    }
# 528 "/usr/local/include/ibex/ibex_simulation.h" 3
    simulation(ivp_ode* _ode, double T,double a){
      process = 0;
      embedded_ode = _ode;
      time_T = T;
      atol = a;
      meth = RK4;
      nb_var=_ode->nbvar;
      monotony_active = false;
      double coef = pred_h(_ode, atol);
      if (coef == 0.0)
 coef=1.0;
      double h = std::min(std::min(dynibex_hmax,0.01/coef),T/2.0);

      if (embedded_ode->get_lte_computation() == SYMBOLIC){
 embedded_ode->frechet_precomputing(order_of_method(meth));
      } else {
 embedded_ode->dag_precomputing(order_of_method(meth));
      }
      solution_j u_j0(*embedded_ode->yinit_aff,embedded_ode->t0,h,atol);
      list_solution_j.push_back(u_j0);
    }



    simulation(ivp_dae_h1* _dae, double T,Method _meth, double a){
      process = 0;
      embedded_dae = _dae;
      time_T = T;
      atol = a;
      meth = RADAU3_DAE;
      nb_var=_dae->nbvar;
      monotony_active = false;
      double h = 0.001;

      embedded_dae->frechet_precomputing(order_of_method(meth));

      solution_j_dae u_j0(*embedded_dae->yinit_aff,*embedded_dae->xinit_aff,embedded_dae->t0,h,atol);
      u_j0.uniqueness(_dae);
      list_solution_j_dae.push_back(u_j0);
    }


    simulation(ivp_dae_h1* _dae, double T){
      process = 0;
      embedded_dae = _dae;
      time_T = T;
      atol = 1e-6;
      meth = RADAU3_DAE;
      nb_var=_dae->nbvar;
      monotony_active = false;
      double h = 0.001;
      embedded_dae->frechet_precomputing(order_of_method(meth));
      solution_j_dae u_j0(*embedded_dae->yinit_aff,*embedded_dae->xinit_aff,embedded_dae->t0,h,atol);
      u_j0.uniqueness(_dae);
      list_solution_j_dae.push_back(u_j0);
    }


    simulation(ivp_dae_h1* _dae, double T,Method _meth){
      process = 0;
      embedded_dae = _dae;
      time_T = T;
      atol = 1e-6;
      meth = RADAU3_DAE;
      nb_var=_dae->nbvar;
      monotony_active = false;
      double h = 0.001;
      embedded_dae->frechet_precomputing(order_of_method(meth));
      solution_j_dae u_j0(*embedded_dae->yinit_aff,*embedded_dae->xinit_aff,embedded_dae->t0,h,atol);
      u_j0.uniqueness(_dae);
      list_solution_j_dae.push_back(u_j0);
    }


    simulation(ivp_dae_h1* _dae, double T,double a){
      process = 0;
      embedded_dae = _dae;
      time_T = T;
      atol = a;
      meth = RADAU3_DAE;
      nb_var=_dae->nbvar;
      monotony_active = false;
      double h = 0.001;
      embedded_dae->frechet_precomputing(order_of_method(meth));
      solution_j_dae u_j0(*embedded_dae->yinit_aff,*embedded_dae->xinit_aff,embedded_dae->t0,h,atol);
      u_j0.uniqueness(_dae);
      list_solution_j_dae.push_back(u_j0);
    }



    ~simulation(){



      destructor();
    }

    void destructor()
    {
      if (!list_solution_j_dae.empty())
 {
   std::list<solution_j_dae>::iterator iterator_list;
   for(iterator_list=list_solution_j_dae.begin();iterator_list!=list_solution_j_dae.end();iterator_list++)
     {
       iterator_list->destructor();
     }
 }
      if (!list_solution_j.empty())
 {
   std::list<solution_j>::iterator iterator_list;
   for(iterator_list=list_solution_j.begin();iterator_list!=list_solution_j.end();iterator_list++)
     {
       iterator_list->destructor();
     }
 }
      if (!list_solution_g.empty())
 {
   std::list<solution_g>::iterator iterator_list;
   for(iterator_list=list_solution_g.begin();iterator_list!=list_solution_g.end();iterator_list++)
     {
       iterator_list->destructor();
     }
 }
    }



    IntervalVector get_last()
    {
      if (!list_solution_g.empty())
 {
   solution_g sol_temp = list_solution_g.back();
   return *sol_temp.box_jnh;
 }
      else
 return *embedded_ode->yinit;
    }


    Affine2Vector get_last_aff()
    {
      if (!failed)
 return *last_aff;
      else
 {
   if (!list_solution_g.empty())
     {
       solution_g sol_temp = list_solution_g.back();
       return Affine2Vector(*sol_temp.box_jnh,true);
     }
   else
     {
       return *embedded_ode->yinit_aff;
     }
 }
    }



    bool finished_in(IntervalVector y_final)
    {
      if (y_final.size()!=nb_var)
 return false;

      if(!list_solution_g.empty())
 {
   solution_g sol_temp = list_solution_g.back();
   return sol_temp.box_jnh->is_subset(y_final);
 }
      else
 return false;
    }


    bool finished_in(std::list<IntervalVector> *stack)
    {
      std::list<IntervalVector>::iterator iterator_l;
      for(iterator_l=stack->begin();iterator_l!=stack->end();iterator_l++)
 {
   if (finished_in((IntervalVector)*iterator_l))
     return true;
 }
      return false;
    }



    bool has_crossed(IntervalVector y)
    {
      if (y.size()!=nb_var)
 return false;

      if(!list_solution_g.empty())
 {
   std::list<solution_g>::iterator iterator_list;
   for(iterator_list=list_solution_g.begin();iterator_list!=list_solution_g.end();iterator_list++)
     {
       IntervalVector y_temp = *(iterator_list->box_j1);
       if (!((y_temp&y).is_empty()))
  return true;
     }
   return false;
 }
      return false;
    }


    Interval has_crossed_when(IntervalVector& y)
    {
      if (y.size()!=embedded_ode->nbvar)
 return Interval(-1.0);

      if(!list_solution_g.empty())
 {
   std::list<solution_g>::iterator iterator_list;

   for(iterator_list=list_solution_g.begin();iterator_list!=list_solution_g.end();iterator_list++)
     {
       IntervalVector y_temp = *(iterator_list->box_j1);
       if (!((y_temp&y).is_empty()))
  {
    return iterator_list->time_j;
  }
     }
   return Interval(-1.0);
 }
      else
 return Interval(-1.0);
    }


    bool has_crossed_before(IntervalVector& y, double time)
    {
      bool test = false;
      if (y.size()!=embedded_ode->nbvar)
 return test;

      if(!list_solution_g.empty())
 {
   std::list<solution_g>::iterator iterator_list;

   for(iterator_list=list_solution_g.begin();iterator_list!=list_solution_g.end();iterator_list++)
     {
       if (iterator_list->time_j.ub() < time)
  {
    IntervalVector y_temp = *(iterator_list->box_j1);
    if (!((y_temp&y).is_empty()))
      {
        return true;
      }
  }
     }
   return false;
 }
      else
 return test;
    }




    bool stayed_in(IntervalVector y_hull)
    {
      if (y_hull.size()!=nb_var)
 return false;

      if(!list_solution_g.empty())
 {
   std::list<solution_g>::iterator iterator_list;
   for(iterator_list=list_solution_g.begin();iterator_list!=list_solution_g.end();iterator_list++)
     {
       IntervalVector y_temp = *(iterator_list->box_j1);
       if (!y_temp.is_subset(y_hull))
  return false;
     }
   return true;
 }
      return true;
    }



    bool go_out(IntervalVector y_hull)
    {
      if (y_hull.size()!=nb_var)
 return false;

      if(!list_solution_g.empty())
 {
   std::list<solution_g>::iterator iterator_list;
   for(iterator_list=list_solution_g.begin();iterator_list!=list_solution_g.end();iterator_list++)
     {
       IntervalVector y_temp = *(iterator_list->box_jnh);
       if ((y_temp&y_hull).is_empty())
  return true;
     }
   return false;
 }
      return false;
    }


    bool stayed_in_till(IntervalVector y_hull, double t)
    {
      if (y_hull.size()!=nb_var)
 return false;

      if (t <0)
 return true;

      if(!list_solution_g.empty())
 {
   std::list<solution_g>::iterator iterator_list;
   for(iterator_list=list_solution_g.begin();iterator_list!=list_solution_g.end();iterator_list++)
     {
       IntervalVector y_temp = *(iterator_list->box_j1);
       if (iterator_list->time_j.lb() > t)
  return true;
       if (!y_temp.is_subset(y_hull))
  return false;
     }
   return true;
 }
      return true;
    }


    bool has_reached(IntervalVector y_final)
    {
      if (y_final.size()!=nb_var)
 return false;

      if(!list_solution_g.empty())
 {
   solution_g sol_temp = list_solution_g.back();
   return (!((*sol_temp.box_jnh)&y_final).is_empty());
 }
      else
 return false;

    }



    bool has_reached(std::list<IntervalVector> *stack)
    {
      std::list<IntervalVector>::iterator iterator_l;
      for(iterator_l=stack->begin();iterator_l!=stack->end();iterator_l++)
 {
   if (has_reached(*iterator_l))
     return true;
 }
      return false;
    }



    double one_in(std::list<IntervalVector> *stack)
    {
      std::list<IntervalVector>::iterator iterator_l;

      if(!list_solution_g.empty())
 {
   std::list<solution_g>::iterator iterator_list;
   for(iterator_list=list_solution_g.begin();iterator_list!=list_solution_g.end();iterator_list++)
     {

       IntervalVector y_temp = *iterator_list->box_jnh;
       double t= iterator_list->time_j.ub();

       for(iterator_l=stack->begin();iterator_l!=stack->end();iterator_l++)
  {
    if (y_temp.is_subset(*iterator_l))
      return t;
  }
     }
   return (-1.0);
 }
      return (-1.0);
    }



    IntervalVector get(double t)
    {

      if(!list_solution_g.empty())
 {
   std::list<solution_g>::iterator iterator_list;
   for(iterator_list=list_solution_g.begin();iterator_list!=list_solution_g.end();iterator_list++)
     {
       if ((iterator_list->time_j).contains(t))
  return *iterator_list->box_j1;
     }
   return IntervalVector(nb_var);
 }
      return IntervalVector(nb_var);

    }


    IntervalVector get(Interval t)
    {

      IntervalVector hull(nb_var);
      bool first_time=true;

      if(!list_solution_g.empty())
 {
   std::list<solution_g>::iterator iterator_list;
   for(iterator_list=list_solution_g.begin();iterator_list!=list_solution_g.end();iterator_list++)
     {
       if (iterator_list->time_j.lb() >= t.ub())
  return hull;

       if (iterator_list->time_j.ub() > t.lb())
  {
    if (first_time)
      {
        hull = *iterator_list->box_j1;
        first_time = false;
      }
    else
      hull |= *iterator_list->box_j1;
  }
     }

 }
      return hull;

    }


    IntervalVector get_tight(double t)
    {

      if(!list_solution_g.empty())
 {
   std::list<solution_g>::iterator iterator_list;
   for(iterator_list=list_solution_g.begin();iterator_list!=list_solution_g.end();iterator_list++)
     {
       if ((iterator_list->time_j).contains(t))
  {
    Affine2Vector* it_box_jn_aff = new Affine2Vector(*iterator_list->box_jn,true);
    double it_tn = iterator_list->time_j.lb();
    double it_h = t - it_tn;


    switch(meth)
      {
      case IEULER:
        {
   solution_j_ieuler u_j(*it_box_jn_aff,it_tn,it_h, embedded_ode,atol,1.0);
   u_j.compute_oneStep(*it_box_jn_aff,embedded_ode,monotony_active);


   solution_g sol_temp(u_j.time_j, u_j.box_j1,u_j.box_jn, u_j.box_jnh, nb_var);
   list_solution_g.insert(iterator_list,sol_temp);
   iterator_list->time_j = Interval((u_j.time_j).ub(),iterator_list->time_j.ub());
   *iterator_list->box_jn = *u_j.box_jnh;
   *iterator_list->box_j1 &= iterator_list->picard(*iterator_list->box_j1,embedded_ode,1);


   if (u_j.time_j.ub() == t)
     return *u_j.box_jnh;
   else
     return *u_j.box_j1;
   break;
        }
      case IMIDPOINT:
        {
   solution_j_imidpoint u_j(*it_box_jn_aff,it_tn,it_h, embedded_ode,atol,1.0);
   u_j.compute_oneStep(*it_box_jn_aff,embedded_ode,monotony_active);


   solution_g sol_temp(u_j.time_j, u_j.box_j1,u_j.box_jn, u_j.box_jnh, nb_var);
   list_solution_g.insert(iterator_list,sol_temp);
   iterator_list->time_j = Interval((u_j.time_j).ub(),iterator_list->time_j.ub());
   *iterator_list->box_jn = *u_j.box_jnh;
   *iterator_list->box_j1 &= iterator_list->picard(*iterator_list->box_j1,embedded_ode,1);

   if (u_j.time_j.ub() == t)
     return *u_j.box_jnh;
   else
     return *u_j.box_j1;
   break;
        }
      case RADAU3:
        {
   solution_j_radau3 u_j(*it_box_jn_aff,it_tn,it_h, embedded_ode,atol,1.0);
   u_j.compute_oneStep(*it_box_jn_aff,embedded_ode,monotony_active);


   solution_g sol_temp(u_j.time_j, u_j.box_j1,u_j.box_jn, u_j.box_jnh, nb_var);
   list_solution_g.insert(iterator_list,sol_temp);
   iterator_list->time_j = Interval((u_j.time_j).ub(),iterator_list->time_j.ub());
   *iterator_list->box_jn = *u_j.box_jnh;
   *iterator_list->box_j1 &= iterator_list->picard(*iterator_list->box_j1,embedded_ode,2);

   if (u_j.time_j.ub() == t)
     return *u_j.box_jnh;
   else
     return *u_j.box_j1;
   break;
        }
      case HEUN:
        {
   solution_j_heun u_j(*it_box_jn_aff,it_tn,it_h, embedded_ode,atol,1.0);
   u_j.compute_oneStep(*it_box_jn_aff,embedded_ode,monotony_active);


   solution_g sol_temp(u_j.time_j, u_j.box_j1,u_j.box_jn, u_j.box_jnh, nb_var);
   list_solution_g.insert(iterator_list,sol_temp);
   iterator_list->time_j = Interval((u_j.time_j).ub(),iterator_list->time_j.ub());
   *iterator_list->box_jn = *u_j.box_jnh;
   *iterator_list->box_j1 &= iterator_list->picard(*iterator_list->box_j1,embedded_ode,1);


   if (u_j.time_j.ub() == t)
     return *u_j.box_jnh;
   else
     return *u_j.box_j1;
   break;
        }
      case TAYLOR4:
        {
   solution_j_tayl4 u_j(*it_box_jn_aff,it_tn,it_h, embedded_ode,atol,1.0);
   u_j.compute_oneStep(*it_box_jn_aff,embedded_ode,monotony_active);


   solution_g sol_temp(u_j.time_j, u_j.box_j1,u_j.box_jn, u_j.box_jnh, nb_var);
   list_solution_g.insert(iterator_list,sol_temp);
   iterator_list->time_j = Interval((u_j.time_j).ub(),iterator_list->time_j.ub());
   *iterator_list->box_jn = *u_j.box_jnh;
   *iterator_list->box_j1 &= iterator_list->picard(*iterator_list->box_j1,embedded_ode,2);

   if (u_j.time_j.ub() == t)
     return *u_j.box_jnh;
   else
     return *u_j.box_j1;
   break;
        }
      case LA3:
        {
   solution_j_la3 u_j(*it_box_jn_aff,it_tn,it_h, embedded_ode,atol,1.0);
   u_j.compute_oneStep(*it_box_jn_aff,embedded_ode,monotony_active);


   solution_g sol_temp(u_j.time_j, u_j.box_j1,u_j.box_jn, u_j.box_jnh, nb_var);
   list_solution_g.insert(iterator_list,sol_temp);
   iterator_list->time_j = Interval((u_j.time_j).ub(),iterator_list->time_j.ub());
   *iterator_list->box_jn = *u_j.box_jnh;
   *iterator_list->box_j1 &= iterator_list->picard(*iterator_list->box_j1,embedded_ode,2);


   if (u_j.time_j.ub() == t)
     return *u_j.box_jnh;
   else
     return *u_j.box_j1;
   break;
        }
      case LC3:
        {
   solution_j_lc3 u_j(*it_box_jn_aff,it_tn,it_h, embedded_ode,atol,1.0);
   u_j.compute_oneStep(*it_box_jn_aff,embedded_ode,monotony_active);


   solution_g sol_temp(u_j.time_j, u_j.box_j1,u_j.box_jn, u_j.box_jnh, nb_var);
   list_solution_g.insert(iterator_list,sol_temp);
   iterator_list->time_j = Interval((u_j.time_j).ub(),iterator_list->time_j.ub());
   *iterator_list->box_jn = *u_j.box_jnh;
   *iterator_list->box_j1 &= iterator_list->picard(*iterator_list->box_j1,embedded_ode,2);

   if (u_j.time_j.ub() == t)
     return *u_j.box_jnh;
   else
     return *u_j.box_j1;
   break;
        }
      case RK4:
        {
   solution_j_rk4 u_j(*it_box_jn_aff,it_tn,it_h, embedded_ode,atol,1.0);
   u_j.compute_oneStep(*it_box_jn_aff,embedded_ode,monotony_active);


   solution_g sol_temp(u_j.time_j, u_j.box_j1,u_j.box_jn, u_j.box_jnh, nb_var);
   list_solution_g.insert(iterator_list,sol_temp);
   iterator_list->time_j = Interval((u_j.time_j).ub(),iterator_list->time_j.ub());
   *iterator_list->box_jn = *u_j.box_jnh;
   *iterator_list->box_j1 &= iterator_list->picard(*iterator_list->box_j1,embedded_ode,2);

   if (u_j.time_j.ub() == t)
     return *u_j.box_jnh;
   else
     return *u_j.box_j1;
   break;
        }
      case RADAU5:
        {
   solution_j_radau5 u_j(*it_box_jn_aff,it_tn,it_h, embedded_ode,atol,1.0);
   u_j.compute_oneStep(*it_box_jn_aff,embedded_ode,monotony_active);


   solution_g sol_temp(u_j.time_j, u_j.box_j1,u_j.box_jn, u_j.box_jnh, nb_var);
   list_solution_g.insert(iterator_list,sol_temp);
   iterator_list->time_j = Interval((u_j.time_j).ub(),iterator_list->time_j.ub());
   *iterator_list->box_jn = *u_j.box_jnh;
   *iterator_list->box_j1 &= iterator_list->picard(*iterator_list->box_j1,embedded_ode,3);

   if (u_j.time_j.ub() == t)
     return *u_j.box_jnh;
   else
     return *u_j.box_j1;
   break;
        }
      case GL4:
        {
   solution_j_gauss4 u_j(*it_box_jn_aff,it_tn,it_h, embedded_ode,atol,1.0);
   u_j.compute_oneStep(*it_box_jn_aff,embedded_ode,monotony_active);


   solution_g sol_temp(u_j.time_j, u_j.box_j1,u_j.box_jn, u_j.box_jnh, nb_var);
   list_solution_g.insert(iterator_list,sol_temp);
   iterator_list->time_j = Interval((u_j.time_j).ub(),iterator_list->time_j.ub());
   *iterator_list->box_jn = *u_j.box_jnh;
   *iterator_list->box_j1 &= iterator_list->picard(*iterator_list->box_j1,embedded_ode,2);

   if (u_j.time_j.ub() == t)
     return *u_j.box_jnh;
   else
     return *u_j.box_j1;
   break;
        }
      case GL6:
        {
   solution_j_gauss6 u_j(*it_box_jn_aff,it_tn,it_h, embedded_ode,atol,1.0);
   u_j.compute_oneStep(*it_box_jn_aff,embedded_ode,monotony_active);


   solution_g sol_temp(u_j.time_j, u_j.box_j1,u_j.box_jn, u_j.box_jnh, nb_var);
   list_solution_g.insert(iterator_list,sol_temp);
   iterator_list->time_j = Interval((u_j.time_j).ub(),iterator_list->time_j.ub());
   *iterator_list->box_jn = *u_j.box_jnh;
   *iterator_list->box_j1 &= iterator_list->picard(*iterator_list->box_j1,embedded_ode,3);

   if (u_j.time_j.ub() == t)
     return *u_j.box_jnh;
   else
     return *u_j.box_j1;
   break;
        }
      case KUTTA3:
        {
   solution_j_kutta3 u_j(*it_box_jn_aff,it_tn,it_h, embedded_ode,atol,1.0);
   u_j.compute_oneStep(*it_box_jn_aff,embedded_ode,monotony_active);


   solution_g sol_temp(u_j.time_j, u_j.box_j1,u_j.box_jn, u_j.box_jnh, nb_var);
   list_solution_g.insert(iterator_list,sol_temp);
   iterator_list->time_j = Interval((u_j.time_j).ub(),iterator_list->time_j.ub());
   *iterator_list->box_jn = *u_j.box_jnh;
   *iterator_list->box_j1 &= iterator_list->picard(*iterator_list->box_j1,embedded_ode,2);

   if (u_j.time_j.ub() == t)
     return *u_j.box_jnh;
   else
     return *u_j.box_j1;
   break;
        }

      default:
        return get(t);
      }
  }
     }
   return IntervalVector(nb_var);
 }
      return IntervalVector(nb_var);

    }


    IntervalVector get_attractor()
    {

      if(!list_solution_g.empty())
 {
   std::list<solution_g>::iterator iterator_list;
   iterator_list=list_solution_g.begin();
   IntervalVector attractor = *iterator_list->box_jnh;

   iterator_list++;

   for(;iterator_list!=list_solution_g.end();iterator_list++)
     {
       if (attractor.is_subset(*iterator_list->box_jnh))
  return attractor;
       else
  attractor = *iterator_list->box_jnh;
     }
   return IntervalVector(nb_var);
 }

      return IntervalVector(nb_var);

    }


    IntervalVector get_domain()
    {
      if(!list_solution_g.empty())
 {
   std::list<solution_g>::iterator iterator_list;
   iterator_list=list_solution_g.begin();

   IntervalVector hull = *iterator_list->box_jnh;

   for(;iterator_list!=list_solution_g.end();iterator_list++)
     {
       hull |= *iterator_list->box_jnh;
     }
   return hull;
 }

      return IntervalVector(nb_var);

    }


    void export2d_yn(const char* filename, int x, int y)
    {
      (static_cast <bool> (nb_var > 1) ? void (0) : __assert_fail ("nb_var > 1", "/usr/local/include/ibex/ibex_simulation.h", 1260, __extension__ __PRETTY_FUNCTION__));
      std::cout << "export in progress..." << std::endl;
      if(!list_solution_g.empty())
 {
   std::ofstream file(filename, std::ios::out | std::ios::trunc);
   std::list<solution_g>::iterator iterator_list;
   for(iterator_list=list_solution_g.begin();iterator_list!=list_solution_g.end();iterator_list++)
     {
       file << iterator_list->box_jnh->operator[](x) << " ; " << iterator_list->box_jnh->operator[](y) << std::endl;
     }

   file.close();
 }

    };


    void export3d_yn(const char* filename, int x, int y, int z)
    {
      (static_cast <bool> (nb_var > 2) ? void (0) : __assert_fail ("nb_var > 2", "/usr/local/include/ibex/ibex_simulation.h", 1279, __extension__ __PRETTY_FUNCTION__));
      std::cout << "export in progress..." << std::endl;
      if(!list_solution_g.empty())
 {
   std::ofstream file(filename, std::ios::out | std::ios::trunc);
   std::list<solution_g>::iterator iterator_list;
   for(iterator_list=list_solution_g.begin();iterator_list!=list_solution_g.end();iterator_list++)
     {
       file << iterator_list->box_jnh->operator[](x) <<
  " ; " << iterator_list->box_jnh->operator[](y) <<
  " ; " << iterator_list->box_jnh->operator[](z) << std::endl;
     }


   file.close();
 }

    };


    void export1d_yn(const char* filename, int x)
    {
      (static_cast <bool> (nb_var > 1) ? void (0) : __assert_fail ("nb_var > 1", "/usr/local/include/ibex/ibex_simulation.h", 1301, __extension__ __PRETTY_FUNCTION__));
      std::cout << "export in progress..." << std::endl;
      if(!list_solution_g.empty())
 {
   std::ofstream file(filename, std::ios::out | std::ios::trunc);
   std::list<solution_g>::iterator iterator_list;
   for(iterator_list=list_solution_g.begin();iterator_list!=list_solution_g.end();iterator_list++)
     {
       file << iterator_list->box_jnh->operator[](x) <<
  " ; " << iterator_list->time_j << std::endl;
     }

   file.close();
 }

    };


    void export_y0(const char* filename)
    {
      (static_cast <bool> (nb_var > 1) ? void (0) : __assert_fail ("nb_var > 1", "/usr/local/include/ibex/ibex_simulation.h", 1321, __extension__ __PRETTY_FUNCTION__));
      std::cout << "export in progress..." << std::endl;
      if(!list_solution_g.empty())
 {
   std::ofstream file(filename, std::ios::out | std::ios::trunc);
   std::list<solution_g>::iterator iterator_list;
   for(iterator_list=list_solution_g.begin();iterator_list!=list_solution_g.end();iterator_list++)
     {
       file << iterator_list->time_j <<
  " ; " << *iterator_list->box_j1 << std::endl;
     }

   file.close();
 }

    };


    void export_yn(const char* filename)
    {
      (static_cast <bool> (nb_var > 1) ? void (0) : __assert_fail ("nb_var > 1", "/usr/local/include/ibex/ibex_simulation.h", 1341, __extension__ __PRETTY_FUNCTION__));
      std::cout << "export in progress..." << std::endl;
      if(!list_solution_g.empty())
 {
   std::ofstream file(filename, std::ios::out | std::ios::trunc);
   std::list<solution_g>::iterator iterator_list;
   for(iterator_list=list_solution_g.begin();iterator_list!=list_solution_g.end();iterator_list++)
     {
       file << iterator_list->time_j.ub() <<
  " ; " << *iterator_list->box_jnh << std::endl;
     }

   file.close();
 }

    };


  };

}
# 50 "/usr/local/include/ibex/ibex_integrate.h" 2 3
# 77 "/usr/local/include/ibex/ibex.h" 2 3
# 103 "/usr/local/include/ibex/ibex.h" 3
# 1 "/usr/local/include/ibex/ibex_LinearRelaxAffine2.h" 1 3
# 20 "/usr/local/include/ibex/ibex_LinearRelaxAffine2.h" 3
namespace ibex {
# 31 "/usr/local/include/ibex/ibex_LinearRelaxAffine2.h" 3
class LinearRelaxAffine2 : public LinearRelax {

public:

 LinearRelaxAffine2 (const System& sys);

 ~LinearRelaxAffine2 ();






 int linearization(const IntervalVector& box, LinearSolver& lp_solver);





 int inlinearization(const IntervalVector& box, LinearSolver& lp_solver);





 bool goal_linearization(const IntervalVector& box, LinearSolver& lp_solver);

private:



 const System& sys;
};

}
# 104 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_LinearRelaxCombo.h" 1 3
# 17 "/usr/local/include/ibex/ibex_LinearRelaxCombo.h" 3
# 1 "/usr/local/include/ibex/ibex_LinearRelaxXTaylor.h" 1 3
# 21 "/usr/local/include/ibex/ibex_LinearRelaxXTaylor.h" 3
namespace ibex {
# 30 "/usr/local/include/ibex/ibex_LinearRelaxXTaylor.h" 3
class LinearRelaxXTaylor : public LinearRelax {

public:




 typedef enum { TAYLOR, HANSEN } linear_mode;




 typedef enum {RANDOM_INV, NEG, INF_X, SUP_X, RANDOM, GREEDY1, GREEDY5, GREEDY6, BEST , MONO,NEGMONO, K4} corner_point;


 static const double default_max_diam_deriv;
# 56 "/usr/local/include/ibex/ibex_LinearRelaxXTaylor.h" 3
 LinearRelaxXTaylor(const System& sys, std::vector<corner_point>& cpoints,
   linear_mode lmode=HANSEN, double max_diam_deriv=default_max_diam_deriv);




 ~LinearRelaxXTaylor();
# 71 "/usr/local/include/ibex/ibex_LinearRelaxXTaylor.h" 3
 int linearization(const IntervalVector& box, LinearSolver& lp_solver);





 int inlinearization(const IntervalVector& box, LinearSolver& lp_solver);





 bool goal_linearization(const IntervalVector& box, LinearSolver& lp_solver);

private:






 std::vector<corner_point>& cpoints;




 const System& sys;




 const int goal_ctr;


 double max_diam_deriv;


 linear_mode lmode;


 IntervalMatrix linear_coef;


 int* last_rnd;

 bool* base_coin;


 bool** linear;


 bool* linear_ctr;




 void init_linear_coeffs();






 int X_Linearization(const IntervalVector & box, int ctr, corner_point cpoint, IntervalVector &G,
   int id_point, int& non_linear_vars, LinearSolver& lp_solver);

 int X_Linearization(const IntervalVector& box, int ctr, corner_point cpoint, CmpOp op,
   IntervalVector &G, int id_point, int& non_linear_vars, LinearSolver& lp_solver);




 bool choose_corner(const IntervalVector& box, IntervalVector& x_corner, bool* corner);




 Function df;
# 161 "/usr/local/include/ibex/ibex_LinearRelaxXTaylor.h" 3
};

}
# 18 "/usr/local/include/ibex/ibex_LinearRelaxCombo.h" 2 3

namespace ibex {
# 30 "/usr/local/include/ibex/ibex_LinearRelaxCombo.h" 3
class LinearRelaxCombo : public LinearRelax {

public:




 typedef enum { ART, AFFINE2, XNEWTON, TAYLOR, HANSEN, COMPO } linear_mode;
# 46 "/usr/local/include/ibex/ibex_LinearRelaxCombo.h" 3
 LinearRelaxCombo(const System& sys, linear_mode lmode=COMPO);




 ~LinearRelaxCombo();






 int linearization(const IntervalVector& box, LinearSolver& lp_solver);





 int inlinearization(const IntervalVector& box, LinearSolver& lp_solver);





 bool goal_linearization(const IntervalVector& box, LinearSolver& lp_solver);

private:


 linear_mode lmode;


 LinearRelaxAffine2 *myart;


 LinearRelaxXTaylor *myxnewton;


 std::vector<LinearRelaxXTaylor::corner_point> cpoints;
};

}
# 105 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_LinearRelaxFixed.h" 1 3
# 15 "/usr/local/include/ibex/ibex_LinearRelaxFixed.h" 3
namespace ibex {





class LinearRelaxFixed : public LinearRelax {
public:



 LinearRelaxFixed(const Matrix& A, const Vector& b);




 int linearization(const IntervalVector& box, LinearSolver& lp_solver);





 int inlinearization(const IntervalVector& box, LinearSolver& lp_solver);





 bool goal_linearization(const IntervalVector& box, LinearSolver& lp_solver);

private:

 Matrix A;

 Vector b;

};


}
# 106 "/usr/local/include/ibex/ibex.h" 2 3



# 1 "/usr/local/include/ibex/ibex_AmplInterface.h" 1 3
# 14 "/usr/local/include/ibex/ibex_AmplInterface.h" 3
# 1 "/usr/local/include/ibex/ibex_Setting.h" 1 3
# 15 "/usr/local/include/ibex/ibex_AmplInterface.h" 2 3
# 110 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_ConstantGenerator.h" 1 3
# 14 "/usr/local/include/ibex/ibex_ConstantGenerator.h" 3
# 1 "/usr/local/include/ibex/ibex_P_ExprVisitor.h" 1 3
# 16 "/usr/local/include/ibex/ibex_P_ExprVisitor.h" 3
namespace ibex {

namespace parser {

class P_ExprPower;
class P_ExprIndex;
class ExprConstantRef;
class ExprIter;
class ExprInfinity;






class P_ExprVisitor : public virtual ExprVisitor {
public:
 virtual ~P_ExprVisitor() { }


 virtual void visit(const P_ExprPower&)=0;


 virtual void visit(const P_ExprIndex&)=0;


 virtual void visit(const ExprConstantRef&)=0;


 virtual void visit(const ExprIter&)=0;


 virtual void visit(const ExprInfinity&)=0;
};





}
}
# 15 "/usr/local/include/ibex/ibex_ConstantGenerator.h" 2 3

# 1 "/usr/local/include/ibex/ibex_Scope.h" 1 3
# 15 "/usr/local/include/ibex/ibex_Scope.h" 3
# 1 "/usr/local/include/ibex/ibex_P_Expr.h" 1 3
# 18 "/usr/local/include/ibex/ibex_P_Expr.h" 3
# 1 "/usr/local/include/ibex/ibex_Entity.h" 1 3
# 17 "/usr/local/include/ibex/ibex_Entity.h" 3
namespace ibex {

namespace parser {




class Entity {
public:
 typedef enum { VAR, EPR, SYB } Type;

 Entity(const char* name, const Dim& dim, const Domain& domain);

 Entity(const char* name, const Dim& dim, const Interval& x);

 const ExprSymbol& symbol;
 Domain domain;

 Type type;
};

}

}
# 19 "/usr/local/include/ibex/ibex_P_Expr.h" 2 3

namespace ibex {

namespace parser {




class P_ExprPower : public ExprBinaryOp {
public:
 P_ExprPower(const ExprNode& expr, const ExprNode& expon);

 virtual void acceptVisitor(ExprVisitor& v) const;
};
# 43 "/usr/local/include/ibex/ibex_P_Expr.h" 3
class P_ExprIndex : public ExprBinaryOp {
public:
 P_ExprIndex(const ExprNode& expr, const ExprNode& index, bool matlab_style);

 virtual void acceptVisitor(ExprVisitor& v) const;

 bool matlab_style;
};
# 65 "/usr/local/include/ibex/ibex_P_Expr.h" 3
class ExprConstantRef : public ExprLeaf {
public:




 ExprConstantRef(const Domain& d);

 virtual void acceptVisitor(ExprVisitor& v) const;




 Domain value;
};




class ExprIter : public ExprLeaf {
public:
 ExprIter(const char* name);

 ~ExprIter();

 virtual void acceptVisitor(ExprVisitor& v) const;

 const char* name;
};
# 103 "/usr/local/include/ibex/ibex_P_Expr.h" 3
class ExprInfinity : public ExprLeaf {
public:
 ExprInfinity();

 virtual void acceptVisitor(ExprVisitor& v) const;
};

void p_print(const ExprNode& e);

}

}
# 16 "/usr/local/include/ibex/ibex_Scope.h" 2 3


namespace ibex {

namespace parser {

class Scope {

public:


 Scope();


 Scope(const Scope& scope);


 Scope(const Scope& scope, bool global);


 ~Scope();



 void add_cst(const char* id, const Domain& domain);


 void add_cst(const char* id, const Dim& d, const Domain& dom);



 void rem_cst(const char* id);


 void add_func(const char* id, Function* f);


 void add_func_input(const char* input_symbol, const ExprSymbol* symbol);


 void add_func_tmp_symbol(const char* tmp_symbol, const ExprNode* expr);


 void add_entity(const char* id, const Entity* e);


 void add_iterator(const char* id);



 const Domain& get_cst(const char* id) const;


 Function& get_func(const char* id);


 const ExprSymbol& get_func_input_symbol(const char* id) const;


 const ExprNode& get_func_tmp_expr(const char* id) const;


 const Entity& get_entity(const char* id) const;


 int get_iter_value(const char* id) const;


 void set_iter_value(const char* id, int value);




 int token(const char* id) const;


 bool is_cst_symbol(const char* id) const;


 bool is_iter_symbol(const char* id) const;


 class S_Object;

private:

 friend std::ostream& operator<<(std::ostream& os, const Scope& scope);

 SymbolMap<S_Object*> tab;
};

std::ostream& operator<<(std::ostream& os, const Scope& scope);

}
}
# 17 "/usr/local/include/ibex/ibex_ConstantGenerator.h" 2 3


namespace ibex {

namespace parser {



class ConstantGenerator : public P_ExprVisitor {
public:
 ConstantGenerator(const Scope& scope);

 virtual ~ConstantGenerator();

 Domain eval(const ExprNode& expr);

 int eval_integer(const ExprNode& expr);

 double eval_double(const ExprNode& expr);

protected:
 void visit(const ExprNode& e);
 void visit(const ExprIndex& i);
 void visit(const ExprConstantRef&);
 void visit(const ExprLeaf& e);
 void visit(const ExprNAryOp& e);
 void visit(const ExprBinaryOp& b);
 void visit(const ExprUnaryOp& u);
 void visit(const ExprSymbol& x);
 void visit(const ExprConstant& c);
 void visit(const ExprVector& e);
 void visit(const ExprApply& e);

 void visit(const ExprAdd& e) ;
 void visit(const ExprMul& e) ;
 void visit(const ExprSub& e) ;
 void visit(const ExprDiv& e) ;
 void visit(const ExprMax& e) ;
 void visit(const ExprMin& e) ;
 void visit(const ExprAtan2& e) ;

 void visit(const ExprMinus& e) ;
 void visit(const ExprTrans& e) ;
 void visit(const ExprSign& e) ;
 void visit(const ExprAbs& e) ;
 void visit(const ExprPower& e) ;
 void visit(const ExprSqr& e) ;
 void visit(const ExprSqrt& e) ;
 void visit(const ExprExp& e) ;
 void visit(const ExprLog& e) ;
 void visit(const ExprCos& e) ;
 void visit(const ExprSin& e) ;
 void visit(const ExprTan& e) ;
 void visit(const ExprCosh& e) ;
 void visit(const ExprSinh& e) ;
 void visit(const ExprTanh& e) ;
 void visit(const ExprAcos& e) ;
 void visit(const ExprAsin& e) ;
 void visit(const ExprAtan& e) ;
 void visit(const ExprAcosh& e) ;
 void visit(const ExprAsinh& e) ;
 void visit(const ExprAtanh& e) ;

 void visit(const P_ExprPower& e);
 void visit(const P_ExprIndex& e);
 void visit(const ExprIter& i);
 void visit(const ExprInfinity&);

 void unary_eval(const ExprUnaryOp& e, Domain (*f)(const Domain&));
 void binary_eval(const ExprBinaryOp& e, Domain (*f)(const Domain&, const Domain&));

 const Scope& scope;
 NodeMap<Domain*> map;

 int number_type;
};

}
}
# 111 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CtrGenerator.h" 1 3
# 23 "/usr/local/include/ibex/ibex_CtrGenerator.h" 3
namespace ibex {

namespace parser {

class P_NumConstraint;
class P_OneConstraint;
class P_ConstraintList;
class P_ConstraintLoop;

class CtrGenerator {
public:
 void generate(const Array<const ExprSymbol>& src_vars, const P_ConstraintList& src, std::vector<NumConstraint*>& dest);

 void visit(const P_NumConstraint& c);
 void visit(const P_OneConstraint& c);
 void visit(const P_ConstraintList& l);
 void visit(const P_ConstraintLoop& l);


protected:
 const Array<const ExprSymbol>* src_vars;
 const Array<const ExprSymbol>* res_vars;
 std::vector<NumConstraint*>* ctrs;

 std::stack<Scope> scopes;

};

}
}
# 112 "/usr/local/include/ibex/ibex.h" 2 3

# 1 "/usr/local/include/ibex/ibex_MainGenerator.h" 1 3
# 15 "/usr/local/include/ibex/ibex_MainGenerator.h" 3
# 1 "/usr/local/include/ibex/ibex_ParserSource.h" 1 3
# 16 "/usr/local/include/ibex/ibex_ParserSource.h" 3
# 1 "/usr/local/include/ibex/ibex_P_NumConstraint.h" 1 3
# 17 "/usr/local/include/ibex/ibex_P_NumConstraint.h" 3
namespace ibex {

namespace parser {

class P_NumConstraint {
public:
 virtual void acceptVisitor(CtrGenerator& g) const=0;




 virtual ~P_NumConstraint() { }
};

class P_OneConstraint : public P_NumConstraint {
public:
 P_OneConstraint(const ExprNode& left, CmpOp op, const ExprNode& right);

 void acceptVisitor(CtrGenerator& g) const {
  g.visit(*this);
 }




 ~P_OneConstraint();

 const ExprNode& expr;
 CmpOp op;
};

class P_ConstraintList : public P_NumConstraint {
public:
 P_ConstraintList(std::vector<P_NumConstraint*>& ctrs);

 void acceptVisitor(CtrGenerator& g) const {
  g.visit(*this);
 }




 ~P_ConstraintList();

 std::vector<P_NumConstraint*>& ctrs;

};

class P_ConstraintLoop : public P_NumConstraint {
public:
 P_ConstraintLoop(const char* iter, const ExprNode& first_value, const ExprNode& last_value, std::vector<P_NumConstraint*>& ctrs);

 void acceptVisitor(CtrGenerator& g) const {
  g.visit(*this);
 }




 ~P_ConstraintLoop();

 const char* iter;
 const ExprNode& first_value;
 const ExprNode& last_value;

 P_ConstraintList ctrs;
};

}
}
# 17 "/usr/local/include/ibex/ibex_ParserSource.h" 2 3


namespace ibex {

namespace parser {




class P_Source {
public:





 void cleanup();

 P_Source();


 std::vector<Entity*> vars;


 std::vector<Function*> func;


 const ExprNode* goal;


 P_ConstraintList* ctrs;
};

}
}
# 16 "/usr/local/include/ibex/ibex_MainGenerator.h" 2 3

namespace ibex {

namespace parser {

class MainGenerator {
public:
 void generate(const P_Source& source, System& result);
};

}
}
# 114 "/usr/local/include/ibex/ibex.h" 2 3

# 1 "/usr/local/include/ibex/ibex_P_ExprGenerator.h" 1 3
# 18 "/usr/local/include/ibex/ibex_P_ExprGenerator.h" 3
namespace ibex {
namespace parser {






class ExprGenerator : private ExprCopy, public virtual P_ExprVisitor {
public:
 ExprGenerator(const Scope& scope);

 const ExprNode& generate(const Array<const ExprSymbol>& old_x, const Array<const ExprSymbol>& new_x, const ExprNode& y);

protected:

 void visit(const ExprNode& e);
 void visit(const P_ExprPower& c);
 void visit(const P_ExprIndex& e);
 void visit(const ExprConstantRef&);
 void visit(const ExprIter& i);
 void visit(const ExprInfinity&);

 const Scope& scope;
};





}
}
# 116 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_P_ExprPrinter.h" 1 3
# 15 "/usr/local/include/ibex/ibex_P_ExprPrinter.h" 3
# 1 "/usr/local/include/ibex/ibex_ExprPrinter.h" 1 3
# 18 "/usr/local/include/ibex/ibex_ExprPrinter.h" 3
namespace ibex {




class ExprPrinter : public virtual ExprVisitor {
public:

 void print(std::ostream& os, const ExprNode&);

protected:
 std::ostream* os;
 void visit(const ExprNode& e);

 void visit(const ExprIndex& e);
 void visit(const ExprLeaf& e);
 void visit(const ExprNAryOp& e);
 void visit(const ExprUnaryOp& e);
 void visit(const ExprBinaryOp& e);
 void visit(const ExprSymbol& e);
 void visit(const ExprConstant& e);
 void visit(const ExprVector& e);
 void visit(const ExprApply& a);
 void visit(const ExprChi& a);
 void visit(const ExprAdd& e);
 void visit(const ExprMul& e);
 void visit(const ExprSub& e);
 void visit(const ExprDiv& e);
 void visit(const ExprMax& e);
 void visit(const ExprMin& e);
 void visit(const ExprAtan2& e);
 void visit(const ExprMinus& e);
 void visit(const ExprTrans& e);
 void visit(const ExprSign& e);
 void visit(const ExprAbs& e);
 void visit(const ExprPower& e);
 void visit(const ExprSqr& e);
 void visit(const ExprSqrt& e);
 void visit(const ExprExp& e);
 void visit(const ExprLog& e);
 void visit(const ExprCos& e);
 void visit(const ExprSin& e);
 void visit(const ExprTan& e);
 void visit(const ExprCosh& e);
 void visit(const ExprSinh& e);
 void visit(const ExprTanh& e);
 void visit(const ExprAcos& e);
 void visit(const ExprAsin& e);
 void visit(const ExprAtan& e);
 void visit(const ExprAcosh& e);
 void visit(const ExprAsinh& e);
 void visit(const ExprAtanh& e);
};

}
# 16 "/usr/local/include/ibex/ibex_P_ExprPrinter.h" 2 3


namespace ibex {

namespace parser {






class P_ExprPrinter : private ExprPrinter, public virtual P_ExprVisitor {
public:
 void print(std::ostream& os, const ExprNode& e);

protected:
 void visit(const ExprNode& e);
 void visit(const P_ExprPower&);
 void visit(const P_ExprIndex&);
 void visit(const ExprConstantRef&);
 void visit(const ExprIter&);
 void visit(const ExprInfinity&);
};





}
}
# 117 "/usr/local/include/ibex/ibex.h" 2 3




# 1 "/usr/local/include/ibex/ibex_SyntaxError.h" 1 3
# 15 "/usr/local/include/ibex/ibex_SyntaxError.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 16 "/usr/local/include/ibex/ibex_SyntaxError.h" 2 3


namespace ibex {






class SyntaxError : public Exception {
 public:
  SyntaxError(const std::string& msg1, const char* token1=__null, int line1=-1) : msg(msg1), token(token1? strdup(token1) : __null), line(line1) { }

  SyntaxError(const SyntaxError& e) : msg(e.msg), token(e.token? strdup(e.token) : __null), line(e.line) { }

  ~SyntaxError() { if (token) free((char*) token); }


  std::string msg;

  const char *token;

  int line;
};


std::ostream& operator<< (std::ostream& os, const SyntaxError& e);

}
# 122 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_UnknownFileException.h" 1 3
# 16 "/usr/local/include/ibex/ibex_UnknownFileException.h" 3
namespace ibex {






class UnknownFileException : public Exception {
 public:
  UnknownFileException(const char* name) : filename(strdup(name)) { }

  UnknownFileException(const UnknownFileException& e) : filename(strdup(e.filename)) { }

  ~UnknownFileException() { free((char*) filename); }

  const char* filename;
};

}
# 123 "/usr/local/include/ibex/ibex.h" 2 3


# 1 "/usr/local/include/ibex/ibex_PdcAnd.h" 1 3
# 17 "/usr/local/include/ibex/ibex_PdcAnd.h" 3
namespace ibex {







class PdcAnd : public Pdc {
public:




 PdcAnd(const Array<Pdc>& list);




 PdcAnd(Pdc& c1, Pdc& c2);




 PdcAnd(Pdc& c1, Pdc& c2, Pdc& c3);




 PdcAnd(Pdc& c1, Pdc& c2, Pdc& c3, Pdc& c4);




 PdcAnd(Pdc& c1, Pdc& c2, Pdc& c3, Pdc& c4, Pdc& c5);




 PdcAnd(Pdc& c1, Pdc& c2, Pdc& c3, Pdc& c4, Pdc& c5, Pdc& c6);




 BoolInterval test(const IntervalVector& box);




 Array<Pdc> list;
};

}
# 126 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_PdcCleared.h" 1 3
# 17 "/usr/local/include/ibex/ibex_PdcCleared.h" 3
namespace ibex {

class PdcCleared : public Pdc {
public:
 PdcCleared(Ctc& c);




 virtual BoolInterval test(const IntervalVector& box);

 Ctc& ctc;
};

}
# 127 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_PdcDiameterLT.h" 1 3
# 17 "/usr/local/include/ibex/ibex_PdcDiameterLT.h" 3
namespace ibex {
# 39 "/usr/local/include/ibex/ibex_PdcDiameterLT.h" 3
class PdcDiameterLT : public Pdc {
public:






 PdcDiameterLT(double ceil);
# 58 "/usr/local/include/ibex/ibex_PdcDiameterLT.h" 3
 PdcDiameterLT(const Vector& ceil);




 virtual BoolInterval test(const IntervalVector& box);




 virtual ~PdcDiameterLT();




 const Vector ceil;
};

}
# 128 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_PdcFirstOrder.h" 1 3
# 16 "/usr/local/include/ibex/ibex_PdcFirstOrder.h" 3
# 1 "/usr/local/include/ibex/ibex_EntailedCtr.h" 1 3
# 18 "/usr/local/include/ibex/ibex_EntailedCtr.h" 3
namespace ibex {





class EntailedCtr : public Backtrackable {
public:



 EntailedCtr();






 void init_root(const System& orig_sys, const NormalizedSystem& norm_sys);




 ~EntailedCtr();







 void set_normalized_entailed(int i);






 bool& original(int i);






 const bool& original(int i) const;







 bool& normalized(int i);






 const bool& normalized(int i) const;




 std::pair<Backtrackable*,Backtrackable*> down();





protected:
 const System* orig_sys;
 const NormalizedSystem* norm_sys;





 bool *orig_entailed;
 bool *norm_entailed;

 EntailedCtr(const EntailedCtr&);

 friend std::ostream& operator<<(std::ostream& os, const EntailedCtr&);
};


std::ostream& operator<<(std::ostream& os, const EntailedCtr&);



inline bool& EntailedCtr::normalized(int i) {
 return norm_entailed[i];
}

inline const bool& EntailedCtr::normalized(int i) const {
 return norm_entailed[i];
}

inline bool& EntailedCtr::original(int i) {
 return orig_entailed[i];
}

inline const bool& EntailedCtr::original(int i) const {
 return orig_entailed[i];
}

}
# 17 "/usr/local/include/ibex/ibex_PdcFirstOrder.h" 2 3

namespace ibex {
# 28 "/usr/local/include/ibex/ibex_PdcFirstOrder.h" 3
class PdcFirstOrder : public Pdc {
public:







 PdcFirstOrder(const System& sys, const IntervalVector& init_box);






 void set_entailed(EntailedCtr* e);




 BoolInterval test(const IntervalVector& box);




 const System& sys;




 const IntervalVector& init_box;

protected:

 EntailedCtr* e;
};

inline void PdcFirstOrder::set_entailed(EntailedCtr* e) {
 this->e = e;
}

}
# 129 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_PdcFwdBwd.h" 1 3
# 18 "/usr/local/include/ibex/ibex_PdcFwdBwd.h" 3
namespace ibex {






class PdcFwdBwd: public PdcCleared {
public:






 PdcFwdBwd(Function& f, CmpOp op);




 PdcFwdBwd(const NumConstraint& ctr);




 virtual ~PdcFwdBwd();

};

}
# 130 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_PdcHansenFeasibility.h" 1 3
# 17 "/usr/local/include/ibex/ibex_PdcHansenFeasibility.h" 3
namespace ibex {
# 26 "/usr/local/include/ibex/ibex_PdcHansenFeasibility.h" 3
class PdcHansenFeasibility : public Pdc {
public:





 PdcHansenFeasibility(Function& f, bool inflating=false);




 const IntervalVector& solution() const;




 virtual BoolInterval test(const IntervalVector& box);


 Function& f;

protected:
 IntervalVector _solution;
 bool inflating;
};




inline const IntervalVector& PdcHansenFeasibility::solution() const {
 return _solution;
}

}
# 131 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_PdcImageSubset.h" 1 3
# 17 "/usr/local/include/ibex/ibex_PdcImageSubset.h" 3
namespace ibex {
# 29 "/usr/local/include/ibex/ibex_PdcImageSubset.h" 3
class PdcImageSubset : public Pdc {
public:
# 43 "/usr/local/include/ibex/ibex_PdcImageSubset.h" 3
 PdcImageSubset(Function& f, const IntervalVector& x0, Pdc& p_in);






 virtual BoolInterval test(const IntervalVector& box);


 Function& f;



 const IntervalVector& x0;


 Pdc& p_in;
};

}
# 132 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_PdcNo.h" 1 3
# 16 "/usr/local/include/ibex/ibex_PdcNo.h" 3
namespace ibex {





class PdcNo : public Pdc {
public:


 PdcNo(int n);




 BoolInterval test(const IntervalVector& box);

};

}
# 133 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_PdcNot.h" 1 3
# 15 "/usr/local/include/ibex/ibex_PdcNot.h" 3
namespace ibex {
# 27 "/usr/local/include/ibex/ibex_PdcNot.h" 3
class PdcNot : public Pdc {

public:




 PdcNot(Pdc& p);




 BoolInterval test(const IntervalVector& box);

protected:




 Pdc& p;
};

}
# 134 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_PdcOr.h" 1 3
# 17 "/usr/local/include/ibex/ibex_PdcOr.h" 3
namespace ibex {







class PdcOr : public Pdc {
public:




 PdcOr(const Array<Pdc>& list);




 PdcOr(Pdc& c1, Pdc& c2);




 PdcOr(Pdc& c1, Pdc& c2, Pdc& c3);




 PdcOr(Pdc& c1, Pdc& c2, Pdc& c3, Pdc& c4);




 PdcOr(Pdc& c1, Pdc& c2, Pdc& c3, Pdc& c4, Pdc& c5);




 PdcOr(Pdc& c1, Pdc& c2, Pdc& c3, Pdc& c4, Pdc& c5, Pdc& c6);




 BoolInterval test(const IntervalVector& box);




 Array<Pdc> list;
};

}
# 135 "/usr/local/include/ibex/ibex.h" 2 3



# 1 "/usr/local/include/ibex/ibex_SepCtcPair.h" 1 3
# 16 "/usr/local/include/ibex/ibex_SepCtcPair.h" 3
namespace ibex {






class SepCtcPair : public Sep {
public:



 SepCtcPair(Ctc& ctc_in, Ctc& ctc_out);






 virtual void separate(IntervalVector& x_in, IntervalVector& x_out);


 Ctc& ctc_in;

 Ctc& ctc_out;

};

}
# 139 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_SepFwdBwd.h" 1 3
# 20 "/usr/local/include/ibex/ibex_SepFwdBwd.h" 3
namespace ibex {
# 34 "/usr/local/include/ibex/ibex_SepFwdBwd.h" 3
class SepFwdBwd : public SepCtcPair {
public:
# 46 "/usr/local/include/ibex/ibex_SepFwdBwd.h" 3
    SepFwdBwd(Function &f, CmpOp op);







    SepFwdBwd(Function &f, const Interval &y);







    SepFwdBwd(Function &f, const IntervalVector &y);







    SepFwdBwd(Function &f, const IntervalMatrix& y);




    SepFwdBwd(const System& sys);




    SepFwdBwd(NumConstraint& c);




    ~SepFwdBwd();

};





inline SepFwdBwd::SepFwdBwd(Function &f, const Interval &y): SepCtcPair(*new CtcNotIn(f,y), *new CtcFwdBwd(f,y)) { }

inline SepFwdBwd::SepFwdBwd(Function &f, const IntervalVector &y): SepCtcPair(*new CtcNotIn(f,y), *new CtcFwdBwd(f,y)) { }

inline SepFwdBwd::SepFwdBwd(Function &f, const IntervalMatrix &y): SepCtcPair(*new CtcNotIn(f,y), *new CtcFwdBwd(f,y)) { }

inline SepFwdBwd::SepFwdBwd(NumConstraint& c) : SepCtcPair(*new CtcFwdBwd(c.f,!c.op), *new CtcFwdBwd(c)) { }

inline SepFwdBwd::~SepFwdBwd() {
 delete &ctc_out;
 delete &ctc_in;
}

}
# 140 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_SepInter.h" 1 3
# 17 "/usr/local/include/ibex/ibex_SepInter.h" 3
namespace ibex {
# 38 "/usr/local/include/ibex/ibex_SepInter.h" 3
class SepInter : public Sep {
public:




    SepInter(const Array<Sep>& list);




    SepInter(Sep& s1, Sep& s2);




    SepInter(Sep& s1, Sep& s2, Sep& s3);




    SepInter(Sep& s1, Sep& s2, Sep& s3, Sep& s4);




    SepInter(Sep& c1, Sep& c2, Sep& c3, Sep& c4, Sep& c5);




    SepInter(Sep& c1, Sep& c2, Sep& c3, Sep& c4, Sep& c5, Sep& c6);




    virtual void separate(IntervalVector& x_in, IntervalVector& x_out);




    Array<Sep> list;

};

}
# 141 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_SepNot.h" 1 3
# 15 "/usr/local/include/ibex/ibex_SepNot.h" 3
namespace ibex {
# 25 "/usr/local/include/ibex/ibex_SepNot.h" 3
class SepNot: public Sep {

public:



 SepNot(Sep& sep);




    virtual void separate(IntervalVector& x_in, IntervalVector& x_out);

protected:



 Sep& sep;
};

}
# 142 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_SepUnion.h" 1 3
# 17 "/usr/local/include/ibex/ibex_SepUnion.h" 3
namespace ibex {
# 38 "/usr/local/include/ibex/ibex_SepUnion.h" 3
class SepUnion : public Sep {
public:




    SepUnion(const Array<Sep>& list);




    SepUnion(Sep& s1, Sep& s2);




    SepUnion(Sep& s1, Sep& s2, Sep& s3);




    SepUnion(Sep& c1, Sep& c2, Sep& c3, Sep& c4);




    SepUnion(Sep& c1, Sep& c2, Sep& c3, Sep& c4, Sep& c5);




    SepUnion(Sep& c1, Sep& c2, Sep& c3, Sep& c4, Sep& c5, Sep& c6);




   virtual void separate(IntervalVector &x_in, IntervalVector &x_out);




    Array<Sep> list;
};

}
# 143 "/usr/local/include/ibex/ibex.h" 2 3

# 1 "/usr/local/include/ibex/ibex_SetBisect.h" 1 3
# 15 "/usr/local/include/ibex/ibex_SetBisect.h" 3
namespace ibex {





class SetBisect : public SetNode {

public:







 SetBisect(int var, double pt, SetNode* left, SetNode* right);




 virtual ~SetBisect();


 virtual bool is_leaf() const;


 virtual SetNode* inter(bool iset, const IntervalVector& nodebox, const IntervalVector& x, BoolInterval x_status);


 virtual SetNode* inter(bool iset, const IntervalVector& nodebox, Sep& sep, double eps);


 virtual SetNode* union_(const IntervalVector& nodebox, const IntervalVector& x, BoolInterval x_status);


 virtual void visit(const IntervalVector& nodebox, SetVisitor& visitor) const;


 virtual void print(std::ostream& os, const IntervalVector& nodebox, int shift) const;


 virtual BoolInterval is_superset(const IntervalVector& nodebox, const IntervalVector& box) const;


 virtual SetNode* contract_no_diff(BoolInterval status, const IntervalVector& nodebox, const IntervalVector& box);

 IntervalVector left_box(const IntervalVector& nodebox) const;

 IntervalVector right_box(const IntervalVector& nodebox) const;


 friend class SetNode;
 friend class Set;



 SetBisect(int var, double pt);

 SetNode* try_merge();

 int var;
 double pt;
 SetNode* left;
 SetNode* right;

private:
 SetBisect(const SetBisect&);
};

}
# 145 "/usr/local/include/ibex/ibex.h" 2 3



# 1 "/usr/local/include/ibex/ibex_SetValueNode.h" 1 3
# 17 "/usr/local/include/ibex/ibex_SetValueNode.h" 3
namespace ibex {

class SetValueNode : public SetNode {
public:

 SetValueNode(int var, Interval value);

 virtual ~SetValueNode();

 int var;
 Interval value;
};

}
# 149 "/usr/local/include/ibex/ibex.h" 2 3



# 1 "/usr/local/include/ibex/ibex_CellBuffer.h" 1 3
# 16 "/usr/local/include/ibex/ibex_CellBuffer.h" 3
namespace ibex {





class CellBufferOverflow : Exception {

};
# 37 "/usr/local/include/ibex/ibex_CellBuffer.h" 3
class CellBuffer {

 public:







 unsigned int capacity;




 CellBuffer();


 virtual ~CellBuffer();



 virtual void flush()=0;


 virtual unsigned int size() const=0;


 virtual bool empty() const=0;


 virtual void push(Cell* cell)=0;


 virtual Cell* pop()=0;


 virtual Cell* top() const=0;




protected:
 friend std::ostream& operator<<(std::ostream& os, const CellBuffer&);

 virtual std::ostream& print(std::ostream& os) const;

 private:

 mutable int screen;

};

std::ostream& operator<<(std::ostream& os, const CellBuffer& h);

}
# 153 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CellCostFunc.h" 1 3
# 14 "/usr/local/include/ibex/ibex_CellCostFunc.h" 3
# 1 "/usr/local/include/ibex/ibex_SharedHeap.h" 1 3
# 14 "/usr/local/include/ibex/ibex_SharedHeap.h" 3
# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 44 "/usr/include/c++/7/cassert" 2 3
# 15 "/usr/local/include/ibex/ibex_SharedHeap.h" 2 3

# 1 "/usr/local/include/ibex/ibex_Heap.h" 1 3
# 18 "/usr/local/include/ibex/ibex_Heap.h" 3
namespace ibex {
# 27 "/usr/local/include/ibex/ibex_Heap.h" 3
template<class T>
class CostFunc {
public:

 virtual ~CostFunc() { }




 virtual double cost(const T& data) const=0;
};
# 52 "/usr/local/include/ibex/ibex_Heap.h" 3
template<class T>
class Heap {
public:

 Heap(CostFunc<T>& costf);







 void flush();


 int size() const;


 bool empty() const;


 void push(T* el);


 T* pop();


 T* top() const;







 void contract(double lb);



 double minimum() const;


 CostFunc<T>& costf;

protected:

 double cost(const T& data) const;


 bool operator()(const std::pair<T*,double>& c1, const std::pair<T*,double>& c2) const;


 std::vector<std::pair<T*,double> > l;

 template<class U>
 friend std::ostream& operator<<(std::ostream&, const Heap<U>&);
};


template<class T>
std::ostream& operator<<(std::ostream&, const Heap<T>&);
# 122 "/usr/local/include/ibex/ibex_Heap.h" 3
template<class T>
struct HeapComparator {
 bool operator()(const std::pair<T*,double>& c1, const std::pair<T*,double>& c2) {
  return c1.second >= c2.second;
 }
};

template<class T>
Heap<T>::Heap(CostFunc<T>& costf) : costf(costf) {

}

template<class T>
bool Heap<T>::operator()(const std::pair<T*,double>& c1, const std::pair<T*,double>& c2) const {
 return c1.second >= c2.second;
}

template<class T>
void Heap<T>::flush() {
 for (typename std::vector<std::pair<T*,double> >::iterator it=l.begin(); it!=l.end(); it++)
  delete it->first;

 l.clear();
}

template<class T>
int Heap<T>::size() const {
 return l.size();
}




template<class T>
void Heap<T>::contract(double loup) {


 sort_heap(l.begin(),l.end(),HeapComparator<T>());
 typename std::vector<std::pair<T*,double> >::iterator it0=l.begin();

 int k=0;
 while (it0!=l.end() && it0->second > loup) { it0++; k++; }

 for (int i=0;i<k;i++) {
  delete l[i].first;
 }

 if (k>0) l.erase(l.begin(),it0);

 make_heap(l.begin(), l.end() ,HeapComparator<T>());



}

template<class T>
bool Heap<T>::empty() const {
 return l.empty();
}

template<class T>
void Heap<T>::push(T* el) {
 l.push_back(std::pair<T*,double>(el,cost(*el)));
 push_heap(l.begin(), l.end(), HeapComparator<T>());
}

template<class T>
T* Heap<T>::pop() {
 T* c = l.front().first;
 pop_heap(l.begin(),l.end(), HeapComparator<T>());
 l.pop_back();
 return c;
}

template<class T>
T* Heap<T>::top() const {
 return l.front().first;
}

template<class T>
double Heap<T>::minimum() const {
 return l.begin()->second;
}

template<class T>
double Heap<T>::cost(const T& data) const {
 return costf.cost(data);
}

template<class T>
std::ostream& operator<<(std::ostream& os, const Heap<T>& heap) {
 os << "[ ";
 for (typename std::vector<std::pair<T*,double> >::const_iterator it=heap.l.begin(); it!=heap.l.end(); it++)
  os << (*it->first) << " ";
 return os << "]";
}

}
# 17 "/usr/local/include/ibex/ibex_SharedHeap.h" 2 3

namespace ibex {

template<class T> class HeapNode;
template<class T> class HeapElt;
template<class T> class DoubleHeap;
# 45 "/usr/local/include/ibex/ibex_SharedHeap.h" 3
template<class T>
class SharedHeap {

public:
# 57 "/usr/local/include/ibex/ibex_SharedHeap.h" 3
 SharedHeap(CostFunc<T>& cost, bool update_cost_when_sorting, int id);


 virtual ~SharedHeap();


 unsigned int size() const;


 bool empty() const;






 T* top() const;





 double minimum() const;







 void sort();




 unsigned int nb_nodes;




 CostFunc<T>& costf;


 const int heap_id;

protected:

 friend class DoubleHeap<T>;


 double cost(const T& data) const;


 HeapNode<T>* root;


 bool update_cost_when_sorting;






 HeapElt<T>* pop_elt();






 void push_elt(HeapElt<T>* elt);




 void percolate_down(HeapNode<T>* node);




 void percolate_up(HeapNode<T>* node);






 void erase_node(HeapNode<T>* node);
# 157 "/usr/local/include/ibex/ibex_SharedHeap.h" 3
 HeapNode<T>* erase_node_no_percolate(HeapNode<T>* node);






 HeapNode<T>* get_node(unsigned int i) const;






 template<class U>
 friend std::ostream& operator<<(std::ostream& os, const SharedHeap<U>& heap);




 bool heap_state();

private:


 void sort_rec(HeapNode<T>* node, SharedHeap<T>& heap);
};
# 194 "/usr/local/include/ibex/ibex_SharedHeap.h" 3
template<class T>
class HeapNode {

private:
 friend class SharedHeap<T>;
 friend class DoubleHeap<T>;


 explicit HeapNode(HeapElt<T>* elt, HeapNode<T>* father=__null);





 HeapElt<T>* elt;


 HeapNode<T>* right;


 HeapNode<T>* left;


 HeapNode<T>* father;


 bool is_sup(HeapNode<T>* node, int heap_id) const;


 bool is_sup(double d, int heap_id) const;


 void switch_elt(HeapNode<T>* node, int heap_id);

 template<class U>
 friend std::ostream& operator<<(std::ostream& os, const HeapNode<U>& node);

 template<class U>
 friend std::ostream& operator<<(std::ostream& os, const SharedHeap<U>& heap);

};
# 243 "/usr/local/include/ibex/ibex_SharedHeap.h" 3
template<class T>
class HeapElt {

private:
 friend class HeapNode<T>;
 friend class SharedHeap<T>;
 friend class DoubleHeap<T>;





 explicit HeapElt(T* data, double crit_1);


 explicit HeapElt(T* data, double crit_1, double crit_2);


 ~HeapElt() ;





 bool is_sup(double d, int heap_id) const;


 T* data;






 double *crit;


 HeapNode<T>** holder;

 template<class U>
 friend std::ostream& operator<<(std::ostream& os, const HeapElt<U>& node) ;

 template<class U>
 friend std::ostream& operator<<(std::ostream& os, const SharedHeap<U>& heap);
};






template<class T>
SharedHeap<T>::SharedHeap(CostFunc<T>& cost, bool update_cost, int id) : nb_nodes(0), costf(cost), heap_id(id), root(__null), update_cost_when_sorting(update_cost) {

}

template<class T>
SharedHeap<T>::~SharedHeap() {
 if (root) delete root;
 root = __null;
}

template<class T>
inline double SharedHeap<T>::minimum() const {
 return root->elt->crit[heap_id];
}

template<class T>
unsigned int SharedHeap<T>::size() const {
 return nb_nodes;
}

template<class T>
bool SharedHeap<T>::empty() const {
 return (nb_nodes==0);
}

template<class T>
T* SharedHeap<T>::top() const {
 return root->elt->data;
}


template<class T>
void SharedHeap<T>::sort() {
 if (nb_nodes==0) return;

 SharedHeap<T>* heap_tmp = new SharedHeap<T>(costf, update_cost_when_sorting, heap_id);


 sort_rec(root, *heap_tmp);

 root = heap_tmp->root;
 nb_nodes = heap_tmp->size();

 heap_tmp->root = __null;
 delete heap_tmp;

}

template<class T>
inline double SharedHeap<T>::cost(const T& data) const {
 return costf.cost(data);
}

template<class T>
void SharedHeap<T>::sort_rec(HeapNode<T>* node, SharedHeap<T>& heap) {

 if (update_cost_when_sorting)
  node->elt->crit[heap_id] = cost(*(node->elt->data));

 heap.push_elt(node->elt);
 if (node->left) sort_rec(node->left, heap);
 if (node->right) sort_rec(node->right, heap);

 delete node;
}

template<class T>
void SharedHeap<T>::push_elt(HeapElt<T>* elt) {

 if (nb_nodes==0) {
  root = new HeapNode<T>(elt,__null);
  root->elt->holder[heap_id] = root;
  nb_nodes++;
 } else {
  nb_nodes++;

  int height = 0;
  int aux = nb_nodes;
  while(aux>1) { aux /= 2; height++; }


  HeapNode<T> * pt = root;
  for (int pos=height-1; pos>0; pos--) {
   if ( nb_nodes & (1 << pos)) {
    pt = pt->right;
   } else {
    pt = pt->left;
   }
  }
  HeapNode<T>* tmp= new HeapNode<T>(elt,pt);
  tmp->elt->holder[heap_id] = tmp;
  if (nb_nodes%2==0) { pt->left =tmp; }
  else { pt->right=tmp; }

  percolate_up(tmp);
 }
}

template<class T>
HeapNode<T> * SharedHeap<T>::get_node(unsigned int i) const {
 (static_cast <bool> (i<nb_nodes) ? void (0) : __assert_fail ("i<nb_nodes", "/usr/local/include/ibex/ibex_SharedHeap.h", 395, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (nb_nodes>0) ? void (0) : __assert_fail ("nb_nodes>0", "/usr/local/include/ibex/ibex_SharedHeap.h", 396, __extension__ __PRETTY_FUNCTION__));



 int height = 0;
 unsigned int aux = i+1;
 while(aux>1) { aux /= 2; height++; }


 HeapNode<T>* pt = root;
 for (int pos=height-1; pos>=0; pos--) {
  if ( (i+1) & (1 << pos)) {

   pt = pt->right;
  } else {

   pt = pt->left;
  }
 }
 return pt;
}

template<class T>
HeapElt<T>* SharedHeap<T>::pop_elt() {
 (static_cast <bool> (nb_nodes>0) ? void (0) : __assert_fail ("nb_nodes>0", "/usr/local/include/ibex/ibex_SharedHeap.h", 420, __extension__ __PRETTY_FUNCTION__));
 HeapElt<T>* c_return = root->elt;
 erase_node(root);
 return c_return;
}


template<class T>
void SharedHeap<T>::erase_node(HeapNode<T>* node) {
 (static_cast <bool> (node) ? void (0) : __assert_fail ("node", "/usr/local/include/ibex/ibex_SharedHeap.h", 429, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (nb_nodes>0) ? void (0) : __assert_fail ("nb_nodes>0", "/usr/local/include/ibex/ibex_SharedHeap.h", 430, __extension__ __PRETTY_FUNCTION__));

 if (erase_node_no_percolate(node)) {
  percolate_down(node);
  percolate_up(node);
 }
}


template<class T>
HeapNode<T>* SharedHeap<T>::erase_node_no_percolate(HeapNode<T>* node) {
 (static_cast <bool> (nb_nodes>0) ? void (0) : __assert_fail ("nb_nodes>0", "/usr/local/include/ibex/ibex_SharedHeap.h", 441, __extension__ __PRETTY_FUNCTION__));

 if (nb_nodes==1) {
  (static_cast <bool> (node==root) ? void (0) : __assert_fail ("node==root", "/usr/local/include/ibex/ibex_SharedHeap.h", 444, __extension__ __PRETTY_FUNCTION__));
  root->elt=__null;
  delete root;
  root = __null;
  node = __null;
 } else {

  HeapNode<T>* last = get_node(nb_nodes-1);


  HeapElt<T>* elt = last->elt;

  if (nb_nodes%2==0) { last->father->left =__null; }
  else { last->father->right=__null; }


  last->elt = __null;

  if (node!=last) {
   node->elt = elt;
   node->elt->holder[heap_id] = node;
  } else {
   node = __null;
  }
  delete last;
 }
 nb_nodes--;
 return node;
}

template<class T>
void SharedHeap<T>::percolate_up(HeapNode<T>* node) {
 (static_cast <bool> (node) ? void (0) : __assert_fail ("node", "/usr/local/include/ibex/ibex_SharedHeap.h", 476, __extension__ __PRETTY_FUNCTION__));

 while (node->father && node->father->is_sup(node,heap_id)) {
  node->switch_elt(node->father,heap_id);
  node = node->father;
 }
}

template<class T>
void SharedHeap<T>::percolate_down(HeapNode<T>* node) {
 (static_cast <bool> (node) ? void (0) : __assert_fail ("node", "/usr/local/include/ibex/ibex_SharedHeap.h", 486, __extension__ __PRETTY_FUNCTION__));


 bool b=true;
 while (b && (node->left)) {
  if (node->right) {
   if (node->is_sup(node->left,heap_id)) {
    if (node->right->is_sup(node->left,heap_id)) {

     node->switch_elt(node->left,heap_id);
     node = node->left;
    } else {

     node->switch_elt(node->right,heap_id);
     node = node->right;
    }
   } else {
    if (node->is_sup(node->right,heap_id)) {

     node->switch_elt(node->right,heap_id);
     node = node->right;
    } else {
     b=false;
    }
   }
  } else {
   if (node->is_sup(node->left,heap_id)) {

    node->switch_elt(node->left,heap_id);
    node = node->left;
   } else {
    b=false;
   }
  }
 }
}

template<class T>
bool SharedHeap<T>::heap_state() {

 if (empty()) return true;

 std::stack<HeapNode<T>* > s;
 s.push(root);
 while (!s.empty()) {
  HeapNode<T>* node=s.top();
  s.pop();
  if (node->right && (!node->left)) {

   return false;
  }
  if (node->left) {
   if (node->is_sup(node->left,heap_id)) {

    return false;
   }
   else s.push(node->left);
  }
  if (node->right) {
   if (node->is_sup(node->right,heap_id)) {

    return false;
   }
   else s.push(node->right);
  }
 }
 return true;
}

template<class T>
HeapNode<T>::HeapNode(HeapElt<T>* elt, HeapNode<T>* father): elt(elt), right(__null), left(__null), father(father) { }
# 577 "/usr/local/include/ibex/ibex_SharedHeap.h" 3
template<class T>
bool HeapNode<T>::is_sup(HeapNode<T>* node, int heap_id) const {
 return elt->is_sup(node->elt->crit[heap_id],heap_id);
}

template<class T>
bool HeapNode<T>::is_sup(double d, int heap_id) const {
 return elt->is_sup(d,heap_id);
}

template<class T>
void HeapNode<T>::switch_elt(HeapNode<T>* node, int heap_id) {

 elt->holder[heap_id] = node;
 node->elt->holder[heap_id] = this;

 HeapElt<T> * elt_tmp = elt;
 elt = node->elt;
 node->elt = elt_tmp;

}
# 608 "/usr/local/include/ibex/ibex_SharedHeap.h" 3
template<class T>
HeapElt<T>::HeapElt(T* data, double crit_1) : data(data), crit(new double[1]), holder(new HeapNode<T>*[1]){
 crit[0] = crit_1;
 holder[0] = __null;
}

template<class T>
HeapElt<T>::HeapElt(T* data, double crit_1, double crit_2) : data(data), crit(new double[2]), holder(new HeapNode<T>*[2]){
 crit[0] = crit_1;
 crit[1] = crit_2;
 holder[0] = __null;
 holder[1] = __null;
}

template<class T>
HeapElt<T>::~HeapElt() {
 if (data) delete data;
 delete [] crit;
 delete [] holder;
}

template<class T>
bool HeapElt<T>::is_sup(double d, int ind_crit) const {
 return (crit[ind_crit] > d);
}

template<class T>
std::ostream& operator<<(std::ostream& os, const HeapElt<T>& elt) {
 os << "{ crit[0]= " << (elt.crit[0]) << ": "<< *(elt.data)<<" } ";
 return os;
}

template<class T>
std::ostream& operator<<(std::ostream& os, const HeapNode<T>& node) {
 os <<*(node.elt) << " ";
 if (node.left) os << *(node.left);
 if (node.right) os << *(node.right);
 return os;
}

template<class T>
std::ostream& operator<<(std::ostream& os, const SharedHeap<T>& heap) {
 if (!heap.root) return os << "(empty heap)";
 os << std::endl;
 std::stack<std::pair<HeapNode<T>*,int> > s;
 s.push(std::pair<HeapNode<T>*,int>(heap.root,0));
 while (!s.empty()) {
  std::pair<HeapNode<T>*,int> p=s.top();
  s.pop();
  for (int i=0; i<p.second; i++) os << "   ";
  os << (p.first->elt->crit[heap.heap_id]) << std::endl;
  if (p.first->right) s.push(std::pair<HeapNode<T>*,int>(p.first->right,p.second+1));
  if (p.first->left) s.push(std::pair<HeapNode<T>*,int>(p.first->left,p.second+1));
 }
 return os;
}

}
# 15 "/usr/local/include/ibex/ibex_CellCostFunc.h" 2 3


namespace ibex {
# 26 "/usr/local/include/ibex/ibex_CellCostFunc.h" 3
class CellCostFunc : public CostFunc<Cell> {

public:

 CellCostFunc(bool depends_on_loup);







 typedef enum {LB,UB,C3,C5,C7,PU,PF_LB, PF_UB} criterion;




 static CellCostFunc* get_cost(criterion crit, int goal_var);






       virtual void set_loup(double ) { }
# 60 "/usr/local/include/ibex/ibex_CellCostFunc.h" 3
       virtual void add_backtrackable(Cell& ) { }
# 71 "/usr/local/include/ibex/ibex_CellCostFunc.h" 3
       virtual void set_optim_data(Cell& , System& ) { }




 bool depends_on_loup;

};






class CellCostVarLB: public CellCostFunc {
public:

 CellCostVarLB(int goal_var) ;


 virtual double cost(const Cell& c) const;


private:

 const int goal_var;
};







class CellCostVarUB: public CellCostFunc {
public:

 CellCostVarUB(int ind_var) ;


 virtual double cost(const Cell& c) const;


private:

 const int goal_var;
};







class CellCostC3: public CellCostFunc {
public:




 CellCostC3(double lb= filib::primitive::compose(1,0x7FF,0,0)) ;







 virtual void set_loup(double lb) { loup = lb; }


 virtual double cost(const Cell& c) const;




 virtual void add_backtrackable(Cell& root);




 virtual void set_optim_data(Cell& c, System& sys);
private:


 double loup;

};



class CellCostC5: public CellCostFunc {
public:




 CellCostC5(double lb= filib::primitive::compose(1,0x7FF,0,0)) ;







 virtual void set_loup(double lb) { loup = lb; }


 virtual double cost(const Cell& c) const;




 virtual void add_backtrackable(Cell& root);




 virtual void set_optim_data(Cell& c, System& sys);
private:


 double loup;
};


class CellCostC7: public CellCostFunc {
public:




 CellCostC7(int ind_var, double lb=filib::primitive::compose(1,0x7FF,0,0)) ;







 virtual void set_loup(double lb) { loup = lb; }


 virtual double cost(const Cell& c) const;




 virtual void add_backtrackable(Cell& root);




 virtual void set_optim_data(Cell& c, System& sys);
private:


 double loup;


 const int goal_var;
};



class CellCostPU: public CellCostFunc {
public:
 CellCostPU();


 virtual double cost(const Cell& c) const;




 virtual void add_backtrackable(Cell& root);




 virtual void set_optim_data(Cell& c, System& sys);
};


class CellCostPFlb: public CellCostFunc {
public:
 CellCostPFlb();




 virtual void add_backtrackable(Cell& root);




 virtual void set_optim_data(Cell& c, System& sys);


 virtual double cost(const Cell& c) const;

};




class CellCostPFub: public CellCostFunc {
public:
 CellCostPFub();




 virtual void add_backtrackable(Cell& root);




 virtual void set_optim_data(Cell& c, System& sys);


 virtual double cost(const Cell& c) const;

};

}
# 154 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CellDoubleHeap.h" 1 3
# 13 "/usr/local/include/ibex/ibex_CellDoubleHeap.h" 3
# 1 "/usr/local/include/ibex/ibex_DoubleHeap.h" 1 3
# 16 "/usr/local/include/ibex/ibex_DoubleHeap.h" 3
namespace ibex {




template<class T>
class DoubleHeap {
public:
# 36 "/usr/local/include/ibex/ibex_DoubleHeap.h" 3
 DoubleHeap(CostFunc<T>& cost1, bool update_cost1_when_sorting, CostFunc<T>& cost2, bool update_cost2_when_sorting, int critpr=50);






 void flush();


 unsigned int size() const;


 bool empty() const;


 void push(T* data);


 T* pop();


 T* pop1();


 T* pop2();


 T* top() const;


 T* top1() const;


 T* top2() const;






 double minimum() const;






 double minimum1() const;






 double minimum2() const;
# 106 "/usr/local/include/ibex/ibex_DoubleHeap.h" 3
 void contract(double loup1);




 virtual ~DoubleHeap();

 template<class U>
 friend std::ostream& operator<<(std::ostream& os, const DoubleHeap<U>& heap);

protected:


 unsigned int nb_nodes;


 SharedHeap<T> *heap1;


 SharedHeap<T> *heap2;



 const int critpr;


 mutable int current_heap_id;







 void contract_rec(double new_loup, HeapNode<T>* node, SharedHeap<T>& heap, bool percolate);
# 153 "/usr/local/include/ibex/ibex_DoubleHeap.h" 3
 void erase_subnodes(HeapNode<T>* node, bool percolate);

 std::ostream& print(std::ostream& os) const;
};




template<class T>
DoubleHeap<T>::DoubleHeap(CostFunc<T>& cost1, bool update_cost1_when_sorting, CostFunc<T>& cost2, bool update_cost2_when_sorting, int critpr) :
   nb_nodes(0), heap1(new SharedHeap<T>(cost1,update_cost1_when_sorting,0)),
                heap2(new SharedHeap<T>(cost2,update_cost2_when_sorting,1)),
                critpr(critpr), current_heap_id(0) {

}

template<class T>
DoubleHeap<T>::~DoubleHeap() {
 if (heap1) delete heap1;
 if (heap2) delete heap2;
}

template<class T>
void DoubleHeap<T>::flush() {
 if (nb_nodes>0) {
  erase_subnodes(heap1->root,false);
  heap1->nb_nodes=0;
  heap1->root=__null;
  nb_nodes=0;
 }
}

template<class T>
unsigned int DoubleHeap<T>::size() const {
 (static_cast <bool> (heap1->size()==heap2->size()) ? void (0) : __assert_fail ("heap1->size()==heap2->size()", "/usr/local/include/ibex/ibex_DoubleHeap.h", 187, __extension__ __PRETTY_FUNCTION__));
 return nb_nodes;
}

template<class T>
void DoubleHeap<T>::contract(double new_loup1) {

 if (nb_nodes==0) return;

 SharedHeap<T>* copy1 = new SharedHeap<T>(heap1->costf, heap1->update_cost_when_sorting, 0);

 contract_rec(new_loup1, heap1->root, *copy1, !heap2->update_cost_when_sorting);

 heap1->root = copy1->root;
 heap1->nb_nodes = copy1->size();
 nb_nodes = copy1->size();
 copy1->root = __null;
 delete copy1;

 if (heap2->update_cost_when_sorting) heap2->sort();

 (static_cast <bool> (nb_nodes==heap2->size()) ? void (0) : __assert_fail ("nb_nodes==heap2->size()", "/usr/local/include/ibex/ibex_DoubleHeap.h", 208, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (nb_nodes==heap1->size()) ? void (0) : __assert_fail ("nb_nodes==heap1->size()", "/usr/local/include/ibex/ibex_DoubleHeap.h", 209, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (heap1->heap_state()) ? void (0) : __assert_fail ("heap1->heap_state()", "/usr/local/include/ibex/ibex_DoubleHeap.h", 210, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (!heap2 || heap2->heap_state()) ? void (0) : __assert_fail ("!heap2 || heap2->heap_state()", "/usr/local/include/ibex/ibex_DoubleHeap.h", 211, __extension__ __PRETTY_FUNCTION__));
}


template<class T>
void DoubleHeap<T>::contract_rec(double new_loup1, HeapNode<T>* node, SharedHeap<T>& heap, bool percolate) {


 if (node->is_sup(new_loup1, 0)) {

  if (heap2) erase_subnodes(node, percolate);
 } else {
  heap.push_elt(node->elt);
  if (node->left) contract_rec(new_loup1, node->left, heap, percolate);
  if (node->right) contract_rec(new_loup1, node->right, heap, percolate);

  delete node;
 }
}

template<class T>
void DoubleHeap<T>::erase_subnodes(HeapNode<T>* node, bool percolate) {
 if (node->left) erase_subnodes(node->left, percolate);
 if (node->right) erase_subnodes(node->right, percolate);

 if (!percolate)



  heap2->erase_node_no_percolate(node->elt->holder[1]);
 else
  heap2->erase_node(node->elt->holder[1]);

 delete node->elt;
 delete node;
}

template<class T>
bool DoubleHeap<T>::empty() const {

 return (nb_nodes==0);
}

template<class T>
void DoubleHeap<T>::push(T* data) {
 HeapElt<T>* elt;
 if (heap2) {
  elt = new HeapElt<T>(data, heap1->cost(*data), heap2->cost(*data));
 } else {
  elt = new HeapElt<T>(data, heap1->cost(*data));
 }


 heap1->push_elt(elt);
 if (heap2) heap2->push_elt(elt);

 nb_nodes++;
}

template<class T>
T* DoubleHeap<T>::pop() {
 (static_cast <bool> (size()>0) ? void (0) : __assert_fail ("size()>0", "/usr/local/include/ibex/ibex_DoubleHeap.h", 272, __extension__ __PRETTY_FUNCTION__));




 HeapElt<T>* elt;
 if (current_heap_id==0) {
  elt = heap1->pop_elt();
  if (heap2) heap2->erase_node(elt->holder[1]);
 } else {
  elt = heap2->pop_elt();
  heap1->erase_node(elt->holder[0]);
 }
 T* data = elt->data;
 elt->data=__null;
 delete elt;

 nb_nodes--;

 (static_cast <bool> (heap1->heap_state()) ? void (0) : __assert_fail ("heap1->heap_state()", "/usr/local/include/ibex/ibex_DoubleHeap.h", 291, __extension__ __PRETTY_FUNCTION__));
 (static_cast <bool> (!heap2 || heap2->heap_state()) ? void (0) : __assert_fail ("!heap2 || heap2->heap_state()", "/usr/local/include/ibex/ibex_DoubleHeap.h", 292, __extension__ __PRETTY_FUNCTION__));

 return data;
}

template<class T>
T* DoubleHeap<T>::pop1() {

 current_heap_id=0;
 return pop();
}

template<class T>
T* DoubleHeap<T>::pop2() {

 current_heap_id=1;
 return pop();

}

template<class T>
T* DoubleHeap<T>::top() const {
 (static_cast <bool> (size()>0) ? void (0) : __assert_fail ("size()>0", "/usr/local/include/ibex/ibex_DoubleHeap.h", 314, __extension__ __PRETTY_FUNCTION__));


 if (RNG::rand() % 100 >= static_cast<unsigned>(critpr)) {

  current_heap_id=0;
  return heap1->top();
 }
 else {

  current_heap_id=1;
  return heap2->top();
 }
}

template<class T>
T* DoubleHeap<T>::top1() const {

 current_heap_id=0;
 return heap1->top();
}

template<class T>
T* DoubleHeap<T>::top2() const {

 current_heap_id=1;
 return heap2->top();

}

template<class T>
inline double DoubleHeap<T>::minimum() const { return heap1->minimum(); }

template<class T>
inline double DoubleHeap<T>::minimum1() const { return heap1->minimum(); }

template<class T>
inline double DoubleHeap<T>::minimum2() const { return heap2->minimum(); }

template<class T>
std::ostream& DoubleHeap<T>::print(std::ostream& os) const{
 if (this->empty()) {
  os << " EMPTY ";
  os<<std::endl;
 } else {
  os << "First Heap:  "<<std::endl;
  heap1->print(os);
  os<<std::endl;
  os << "Second Heap: "<<std::endl;
  heap2->print(os);
  os<<std::endl;
 }
 return os;


}

template<class T>
std::ostream& operator<<(std::ostream& os, const DoubleHeap<T>& heap) {
 return heap.print(os);
}


}
# 14 "/usr/local/include/ibex/ibex_CellDoubleHeap.h" 2 3



namespace ibex {







class CellDoubleHeap : public DoubleHeap<Cell>, public CellBuffer {

public:
# 40 "/usr/local/include/ibex/ibex_CellDoubleHeap.h" 3
 CellDoubleHeap(CellCostFunc& cost1, CellCostFunc& cost2, int critpr=50);






 void flush();


 unsigned int size() const;


 bool empty() const;


 void push(Cell* cell);


 Cell* pop();


 Cell* top() const;


 std::ostream& print(std::ostream& os) const;
# 75 "/usr/local/include/ibex/ibex_CellDoubleHeap.h" 3
 void contract(double loup);




 CellCostFunc& cost1();




 CellCostFunc& cost2();
};



inline CellDoubleHeap::CellDoubleHeap(CellCostFunc& cost1, CellCostFunc& cost2, int critpr) :
  DoubleHeap<Cell>(cost1,cost1.depends_on_loup,cost2,cost2.depends_on_loup, critpr) { }

inline void CellDoubleHeap::flush() { DoubleHeap<Cell>::flush(); }

inline unsigned int CellDoubleHeap::size() const { return DoubleHeap<Cell>::size(); }

inline bool CellDoubleHeap::empty() const { return DoubleHeap<Cell>::empty(); }

inline void CellDoubleHeap::push(Cell* cell) { DoubleHeap<Cell>::push(cell); }

inline Cell* CellDoubleHeap::pop() { return DoubleHeap<Cell>::pop(); }

inline Cell* CellDoubleHeap::top() const { return DoubleHeap<Cell>::top(); }

 inline std::ostream& CellDoubleHeap::print(std::ostream& os) const
 { os << "==============================================================================\n";
   os << " first heap " << " size " << heap1->size() << " top " << heap1->top()->box << std::endl;
     os << " second heap " << " size " << heap2->size() << " top " << heap2->top()->box ;
     return os << std::endl;
 }



inline void CellDoubleHeap::contract(double new_loup) {



 if (cost1().depends_on_loup) {
  cost1().set_loup(new_loup);
  heap1->sort();
 }

 cost2().set_loup(new_loup);
 DoubleHeap<Cell>::contract(new_loup);
}

inline CellCostFunc& CellDoubleHeap::cost1() { return (CellCostFunc&) heap1->costf; }

inline CellCostFunc& CellDoubleHeap::cost2() { return (CellCostFunc&) heap2->costf; }


}
# 155 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_CellStack.h" 1 3
# 17 "/usr/local/include/ibex/ibex_CellStack.h" 3
namespace ibex {







class CellStack : public CellBuffer {
 public:


  void flush();


  unsigned int size() const;


  bool empty() const;


  void push(Cell* cell);


  Cell* pop();


  Cell* top() const;

 private:

  std::stack<Cell*> cstack;
};

}
# 156 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_DefaultOptimizer.h" 1 3
# 14 "/usr/local/include/ibex/ibex_DefaultOptimizer.h" 3
# 1 "/usr/local/include/ibex/ibex_Optimizer.h" 1 3
# 22 "/usr/local/include/ibex/ibex_Optimizer.h" 3
# 1 "/usr/local/include/ibex/ibex_ExtendedSystem.h" 1 3
# 16 "/usr/local/include/ibex/ibex_ExtendedSystem.h" 3
namespace ibex {






class ExtendedSystem : public System {
public:
# 41 "/usr/local/include/ibex/ibex_ExtendedSystem.h" 3
 ExtendedSystem(const System& sys, double eps=0);




 static const char* goal_name();




 int goal_var() const;




 int goal_ctr() const;






};



inline int ExtendedSystem::goal_var() const {
 return nb_var-1;
}

inline int ExtendedSystem::goal_ctr() const {
 return 0;
}

}
# 23 "/usr/local/include/ibex/ibex_Optimizer.h" 2 3






namespace ibex {
# 43 "/usr/local/include/ibex/ibex_Optimizer.h" 3
class Optimizer {
public:
# 72 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 Optimizer(System& sys, Ctc& ctc, Bsc& bsc, double prec=default_prec,
   double goal_rel_prec=default_goal_rel_prec, double goal_abs_prec=default_goal_abs_prec,
     int sample_size=default_sample_size, double equ_eps=default_equ_eps, bool rigor=false, int critpr=50,CellCostFunc::criterion crit= CellCostFunc::UB);




 virtual ~Optimizer();




 typedef enum {SUCCESS, INFEASIBLE, NO_FEASIBLE_FOUND, UNBOUNDED_OBJ, TIME_OUT} Status;
# 110 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 Status optimize(const IntervalVector& init_box, double obj_init_bound=filib::primitive::compose(0,0x7FF,0,0));
# 122 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 void report();
# 134 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 void time_cells_report();
# 144 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 void report_perf();






 System& user_sys;







 NormalizedSystem sys;


 const int n;


 const int m;
# 179 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 ExtendedSystem ext_sys;






 System* equs;



 Ctc& ctc;


 Bsc& bsc;






 CellDoubleHeap buffer;







 const double prec;


 const double goal_rel_prec;


 const double goal_abs_prec;


 const int sample_size;



 bool mono_analysis_flag;




 bool in_HC4_flag;





 int trace;
# 241 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 double timeout;


 double time;

 void time_limit_check();


 static const double default_prec;


 static const double default_goal_rel_prec;
# 261 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 static const double default_goal_abs_prec;


 static const int default_sample_size;


 static const double default_equ_eps;


 static const double default_loup_tolerance;





 double loup;






 double pseudo_loup;


 double uplo;


 Vector loup_point;


 IntervalVector loup_box;


 int nb_cells;

protected:





 inline double goal(const Vector& x) const {
  Interval fx=sys.goal->eval(x);
  if (fx.is_empty())
   return filib::primitive::compose(0,0x7FF,0,0);
  else
   return fx.ub();

 }
# 321 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 void handle_cell(Cell& c, const IntervalVector& init_box);
# 334 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 void contract_and_bound(Cell& c, const IntervalVector& init_box);
# 346 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 virtual void firstorder_contract ( IntervalVector& box, const IntervalVector& init_box);






 bool update_entailed_ctr(const IntervalVector& box);




 void update_uplo_of_epsboxes(double ymin);




 void update_uplo();





 bool update_loup(const IntervalVector& box);
# 382 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 void monotonicity_analysis(IntervalVector& box, bool inner_found);







 bool is_feasible(const IntervalVector& box);







 bool is_inner(const IntervalVector& box);
# 408 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 bool in_HC4(IntervalVector& box);
# 425 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 bool check_candidate(const Vector& pt, bool is_inner);
 bool check_candidate_extended(const Vector& pt, bool is_inner);






 bool update_real_loup();
# 448 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 bool random_probing (const IntervalVector& box, const IntervalVector& fullbox, bool is_innner);
# 458 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 bool dichotomic_line_search(const Vector& end_point, bool exit_if_above_loup);
# 468 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 bool line_probing(const IntervalVector& box);
# 478 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 bool update_loup_probing(const IntervalVector& box);





 bool update_loup_simplex(const IntervalVector& box);





 void trace_loup(bool inner_found);
# 500 "/usr/local/include/ibex/ibex_Optimizer.h" 3
 void write_ext_box(const IntervalVector& box, IntervalVector& ext_box);






 void read_ext_box(const IntervalVector& ext_box, IntervalVector& box);




 Function df;






 double compute_ymax ();

 bool loup_changed;







 double initial_loup;

 Ctc3BCid* objshaver;

private:


 const bool rigor;


 LinearSolver *mylp;
 LinearRelaxCombo *lr;


 CtcUnion* is_inside;


 double uplo_of_epsboxes;


 EntailedCtr* entailed;


 int nb_simplex;
 int nb_rand;
 double diam_simplex;
 double diam_rand;
 int nb_inhc4;
 double diam_inhc4;


};


}
# 15 "/usr/local/include/ibex/ibex_DefaultOptimizer.h" 2 3


namespace ibex {





class DefaultOptimizer : public Optimizer {
public:







    DefaultOptimizer(System& sys, double prec, double goal_prec);




    ~DefaultOptimizer();

private:



 Ctc& ctc(System& sys, System& ext_sys,double prec);



 void* data;
};

}
# 157 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_DefaultSolver.h" 1 3
# 14 "/usr/local/include/ibex/ibex_DefaultSolver.h" 3
# 1 "/usr/local/include/ibex/ibex_Solver.h" 1 3
# 18 "/usr/local/include/ibex/ibex_Solver.h" 3
# 1 "/usr/local/include/ibex/ibex_SubPaving.h" 1 3
# 19 "/usr/local/include/ibex/ibex_SubPaving.h" 3
namespace ibex {





class SubPaving {
public:



 void add(const IntervalVector& before, const IntervalVector& after);




 void add(const IntervalVector& box);




 int size() const;




 std::vector<std::pair<IntervalVector,IntervalVector> > traces;
};



inline void SubPaving::add(const IntervalVector& before, const IntervalVector& after) {
 traces.push_back(std::pair<IntervalVector,IntervalVector>(before,after));
}

inline void SubPaving::add(const IntervalVector& box) {
 traces.push_back(std::pair<IntervalVector,IntervalVector>(box,IntervalVector::empty(box.size())));
}

inline int SubPaving::size() const {
 return traces.size();
}

}
# 19 "/usr/local/include/ibex/ibex_Solver.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Timer.h" 1 3
# 17 "/usr/local/include/ibex/ibex_Timer.h" 3
# 1 "/usr/include/x86_64-linux-gnu/sys/time.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern "C" {
# 52 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 68 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) throw () __attribute__ ((__nonnull__ (1)));




extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     throw ();





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) throw ();




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) throw ();




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) throw ();




extern int utimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));



extern int lutimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) throw ();






extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) throw ();
# 186 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
}
# 18 "/usr/local/include/ibex/ibex_Timer.h" 2 3






# 1 "/usr/include/x86_64-linux-gnu/sys/resource.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/resource.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/resource.h" 3 4
enum __rlimit_resource
{

  RLIMIT_CPU = 0,



  RLIMIT_FSIZE = 1,



  RLIMIT_DATA = 2,



  RLIMIT_STACK = 3,



  RLIMIT_CORE = 4,






  __RLIMIT_RSS = 5,



  RLIMIT_NOFILE = 7,
  __RLIMIT_OFILE = RLIMIT_NOFILE,




  RLIMIT_AS = 9,



  __RLIMIT_NPROC = 6,



  __RLIMIT_MEMLOCK = 8,



  __RLIMIT_LOCKS = 10,



  __RLIMIT_SIGPENDING = 11,



  __RLIMIT_MSGQUEUE = 12,





  __RLIMIT_NICE = 13,




  __RLIMIT_RTPRIO = 14,





  __RLIMIT_RTTIME = 15,


  __RLIMIT_NLIMITS = 16,
  __RLIM_NLIMITS = __RLIMIT_NLIMITS


};
# 131 "/usr/include/x86_64-linux-gnu/bits/resource.h" 3 4
typedef __rlim_t rlim_t;




typedef __rlim64_t rlim64_t;


struct rlimit
  {

    rlim_t rlim_cur;

    rlim_t rlim_max;
  };


struct rlimit64
  {

    rlim64_t rlim_cur;

    rlim64_t rlim_max;
 };



enum __rusage_who
{

  RUSAGE_SELF = 0,



  RUSAGE_CHILDREN = -1



  ,

  RUSAGE_THREAD = 1




};


# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h" 3 4
struct rusage
  {

    struct timeval ru_utime;

    struct timeval ru_stime;

    __extension__ union
      {
 long int ru_maxrss;
 __syscall_slong_t __ru_maxrss_word;
      };



    __extension__ union
      {
 long int ru_ixrss;
 __syscall_slong_t __ru_ixrss_word;
      };

    __extension__ union
      {
 long int ru_idrss;
 __syscall_slong_t __ru_idrss_word;
      };

    __extension__ union
      {
 long int ru_isrss;
  __syscall_slong_t __ru_isrss_word;
      };


    __extension__ union
      {
 long int ru_minflt;
 __syscall_slong_t __ru_minflt_word;
      };

    __extension__ union
      {
 long int ru_majflt;
 __syscall_slong_t __ru_majflt_word;
      };

    __extension__ union
      {
 long int ru_nswap;
 __syscall_slong_t __ru_nswap_word;
      };


    __extension__ union
      {
 long int ru_inblock;
 __syscall_slong_t __ru_inblock_word;
      };

    __extension__ union
      {
 long int ru_oublock;
 __syscall_slong_t __ru_oublock_word;
      };

    __extension__ union
      {
 long int ru_msgsnd;
 __syscall_slong_t __ru_msgsnd_word;
      };

    __extension__ union
      {
 long int ru_msgrcv;
 __syscall_slong_t __ru_msgrcv_word;
      };

    __extension__ union
      {
 long int ru_nsignals;
 __syscall_slong_t __ru_nsignals_word;
      };



    __extension__ union
      {
 long int ru_nvcsw;
 __syscall_slong_t __ru_nvcsw_word;
      };


    __extension__ union
      {
 long int ru_nivcsw;
 __syscall_slong_t __ru_nivcsw_word;
      };
  };
# 180 "/usr/include/x86_64-linux-gnu/bits/resource.h" 2 3 4







enum __priority_which
{
  PRIO_PROCESS = 0,

  PRIO_PGRP = 1,

  PRIO_USER = 2

};


extern "C" {




extern int prlimit (__pid_t __pid, enum __rlimit_resource __resource,
      const struct rlimit *__new_limit,
      struct rlimit *__old_limit) throw ();
# 217 "/usr/include/x86_64-linux-gnu/bits/resource.h" 3 4
extern int prlimit64 (__pid_t __pid, enum __rlimit_resource __resource,
        const struct rlimit64 *__new_limit,
        struct rlimit64 *__old_limit) throw ();



}
# 25 "/usr/include/x86_64-linux-gnu/sys/resource.h" 2 3 4






extern "C" {
# 42 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
typedef int __rlimit_resource_t;
typedef int __rusage_who_t;
typedef int __priority_which_t;





extern int getrlimit (__rlimit_resource_t __resource,
        struct rlimit *__rlimits) throw ();
# 61 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
extern int getrlimit64 (__rlimit_resource_t __resource,
   struct rlimit64 *__rlimits) throw ();






extern int setrlimit (__rlimit_resource_t __resource,
        const struct rlimit *__rlimits) throw ();
# 81 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
extern int setrlimit64 (__rlimit_resource_t __resource,
   const struct rlimit64 *__rlimits) throw ();




extern int getrusage (__rusage_who_t __who, struct rusage *__usage) throw ();





extern int getpriority (__priority_which_t __which, id_t __who) throw ();



extern int setpriority (__priority_which_t __which, id_t __who, int __prio)
     throw ();

}
# 25 "/usr/local/include/ibex/ibex_Timer.h" 2 3
# 33 "/usr/local/include/ibex/ibex_Timer.h" 3
namespace ibex {






class TimeOutException : public Exception { };





class Timer {
 public:

  typedef double Time;

  typedef enum type_timer {__REAL, VIRTUAL} TimerType;

  static void start();

  static void stop(TimerType type=VIRTUAL);







  static void check(double timeout);

  inline static Time REAL_TIMELAPSE() { return real_lapse; }
  inline static double RESIDENT_MEMORY() { return resident_memory; }

  inline static Time VIRTUAL_TIMELAPSE() { return (virtual_ulapse + virtual_slapse); }

  static Time real_lapse;
  static Time virtual_ulapse;
  static Time virtual_slapse;

 private:
  static Time real_time;
  static Time virtual_utime;
  static Time virtual_stime;
  static long resident_memory;



  static struct rusage res;

  static struct timeval tp;
};

}
# 20 "/usr/local/include/ibex/ibex_Solver.h" 2 3




namespace ibex {
# 35 "/usr/local/include/ibex/ibex_Solver.h" 3
class CellLimitException : public Exception {} ;

class Solver {
public:







 Solver(Ctc& ctc, Bsc& bsc, CellBuffer& buffer);
# 55 "/usr/local/include/ibex/ibex_Solver.h" 3
 std::vector<IntervalVector> solve(const IntervalVector& init_box);






 void start(const IntervalVector& init_box);







 bool next(std::vector<IntervalVector>& sols);
# 80 "/usr/local/include/ibex/ibex_Solver.h" 3
 Ctc& ctc;


 Bsc& bsc;


 CellBuffer& buffer;





 double time_limit;





 long cell_limit;
# 108 "/usr/local/include/ibex/ibex_Solver.h" 3
 int trace;


 int nb_cells;



 double time;

protected :

 void time_limit_check();

 void new_sol(std::vector<IntervalVector> & sols, IntervalVector & box);

 BitSet impact;

};

}
# 15 "/usr/local/include/ibex/ibex_DefaultSolver.h" 2 3




namespace ibex {





class DefaultSolver : public Solver {
public:






    DefaultSolver(System& sys, double prec);
# 42 "/usr/local/include/ibex/ibex_DefaultSolver.h" 3
    DefaultSolver(System& sys, const Vector& prec);




 ~DefaultSolver();

 System & sys;
private:



 Ctc* ctc(System& sys, double prec);



 void* data;
};

}
# 158 "/usr/local/include/ibex/ibex.h" 2 3

# 1 "/usr/local/include/ibex/ibex_LineSearch.h" 1 3
# 16 "/usr/local/include/ibex/ibex_LineSearch.h" 3
namespace ibex {

class LineSearchData;






class LineSearch {
public:
# 36 "/usr/local/include/ibex/ibex_LineSearch.h" 3
 typedef enum { TOWARDS_LB, PARALLEL, TOWARDS_UB, MEETS_BOUND } Status;




 class NullDirectionException { };
# 56 "/usr/local/include/ibex/ibex_LineSearch.h" 3
 LineSearch(const IntervalVector& box, const Vector& x, const Vector& d, LineSearchData& data, double sigma);
# 66 "/usr/local/include/ibex/ibex_LineSearch.h" 3
 double alpha_max();
# 78 "/usr/local/include/ibex/ibex_LineSearch.h" 3
 Vector endpoint();






 bool next_activated(int i);




 void proj(Vector& y);






private:
 int n;
 const IntervalVector& box;
 const Vector& x;
 const Vector& d;
 LineSearchData& data;
 double alpha1;
};
# 116 "/usr/local/include/ibex/ibex_LineSearch.h" 3
class LineSearchData {
public:






 LineSearchData(int n);




 ~LineSearchData();

private:
 friend class LineSearch;


 int n;




 LineSearch::Status* ctr;






 Vector alpha;
};




inline double LineSearch::alpha_max() {
 return alpha1;
}

inline bool LineSearch::next_activated(int i) {
 return data.ctr[i]==MEETS_BOUND;
}






}
# 160 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Multipliers.h" 1 3
# 16 "/usr/local/include/ibex/ibex_Multipliers.h" 3
namespace ibex {





class Multipliers : public Backtrackable {
public:



 Multipliers();
# 38 "/usr/local/include/ibex/ibex_Multipliers.h" 3
 void init_root(int m, int r, int k);




 ~Multipliers();





 Interval& operator[](int i);




 std::pair<Backtrackable*,Backtrackable*> down();

 IntervalVector lambda;
protected:

 Multipliers(const Multipliers&);
};




inline Interval& Multipliers::operator[](int i) {
 return lambda[i];
}

}
# 161 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_OptimData.h" 1 3
# 17 "/usr/local/include/ibex/ibex_OptimData.h" 3
namespace ibex {






class OptimData : public Backtrackable {
public:



 OptimData();




 ~OptimData();




 std::pair<Backtrackable*,Backtrackable*> down();






 void compute_pf(Function& goal, const IntervalVector& box);






 void compute_pu(System& sys, const IntervalVector& box, const EntailedCtr& entailed);






 Interval pf;






 double pu;

protected:

 OptimData(const OptimData&);
};

}
# 162 "/usr/local/include/ibex/ibex.h" 2 3

# 1 "/usr/local/include/ibex/ibex_Paver.h" 1 3
# 20 "/usr/local/include/ibex/ibex_Paver.h" 3
namespace ibex {

class CapacityException : public Exception { };
# 33 "/usr/local/include/ibex/ibex_Paver.h" 3
class Paver {
public:
# 45 "/usr/local/include/ibex/ibex_Paver.h" 3
 Paver(const Array<Ctc>& c, Bsc& b, CellBuffer& cells);






 SubPaving* pave(const IntervalVector& init_box);
# 66 "/usr/local/include/ibex/ibex_Paver.h" 3
 long capacity;
# 75 "/usr/local/include/ibex/ibex_Paver.h" 3
 double timeout;
# 84 "/usr/local/include/ibex/ibex_Paver.h" 3
 bool ctc_loop;







 bool trace;


 Array<Ctc> ctc;


 Bsc& bsc;


 CellBuffer& buffer;

protected:
# 113 "/usr/local/include/ibex/ibex_Paver.h" 3
 void contract(Cell& c, SubPaving*);




 void check_capacity(SubPaving*);




 void bisect(Cell& c);

};





}
# 164 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_SetImage.h" 1 3
# 19 "/usr/local/include/ibex/ibex_SetImage.h" 3
namespace ibex {
# 35 "/usr/local/include/ibex/ibex_SetImage.h" 3
class SetImage {
public:
# 45 "/usr/local/include/ibex/ibex_SetImage.h" 3
 SetImage(Function& f, Ctc& c_out, Pdc& p_in);





 SetImage(Function& f, const IntervalVector& x);
# 61 "/usr/local/include/ibex/ibex_SetImage.h" 3
 void pave(const IntervalVector& x, double epsilon);
# 71 "/usr/local/include/ibex/ibex_SetImage.h" 3
 const std::vector<IntervalVector>& interior();
# 80 "/usr/local/include/ibex/ibex_SetImage.h" 3
 const std::vector<IntervalVector>& boundary();

private:
 Function &f;
 int n;

 Ctc &c_out;
 Pdc &p_in;

 std::vector<IntervalVector> Linside;
 std::vector<IntervalVector> Lboundary;
};

inline const std::vector<IntervalVector>& SetImage::interior() {
 return Linside;
}

inline const std::vector<IntervalVector>& SetImage::boundary() {
 return Lboundary;
}

}
# 165 "/usr/local/include/ibex/ibex.h" 2 3

# 1 "/usr/local/include/ibex/ibex_StrategyParam.h" 1 3
# 18 "/usr/local/include/ibex/ibex_StrategyParam.h" 3
namespace ibex {

class StrategyParam {
public:

 StrategyParam(const char* filename, const char* ctc, const char* lin_relax,
   const char* bsc, double prec, double time_limit, bool hc4_incremental,
   double ratio_propag, double fixpoint_ratio, bool optim=false);

 Ctc& get_ctc();

 Bsc& get_bsc();

 System& get_sys();

 virtual ~StrategyParam();

 double prec;

 double time_limit;

protected:

 std::string filename;
 std::string filtering;
 std::string lin_relax;
 std::string bisection;
 bool hc4_incremental;
 double ratio_propag;
 double fixpoint_ratio;
 bool optim;
# 58 "/usr/local/include/ibex/ibex_StrategyParam.h" 3
 virtual System& get_ext_sys();

private:
 void* data;
};

class OptimizerParam : public StrategyParam {

public:
 OptimizerParam(const char* filename, const char* ctc, const char* lin_relax,
   const char* bsc, double prec, double time_limit, bool hc4_incremental,
   double ratio_propag, double fixpoint_ratio,
   double goal_rel_prec, double goal_abs_prec, int sample_size, double eq_eps);

 double goal_rel_prec;
 double goal_abs_prec;
 int sample_size;
 double eq_eps;

protected:

 virtual System& get_ext_sys();
};

}
# 167 "/usr/local/include/ibex/ibex.h" 2 3

# 1 "/usr/local/include/ibex/ibex_UnconstrainedLocalSearch.h" 1 3
# 19 "/usr/local/include/ibex/ibex_UnconstrainedLocalSearch.h" 3
namespace ibex {
# 32 "/usr/local/include/ibex/ibex_UnconstrainedLocalSearch.h" 3
class UnconstrainedLocalSearch {
public:
# 47 "/usr/local/include/ibex/ibex_UnconstrainedLocalSearch.h" 3
 typedef enum { SUCCESS, TOO_MANY_ITER, INVALID_POINT } ReturnCode;







 UnconstrainedLocalSearch(const Function& f, const IntervalVector& box);
# 71 "/usr/local/include/ibex/ibex_UnconstrainedLocalSearch.h" 3
 ReturnCode minimize( const Vector& x0, Vector& x_min, double eps=1.e-8, int max_iter=100);




 int nb_iter() const;




 void set_box( const IntervalVector& box );



 virtual ~UnconstrainedLocalSearch();

private:






 class InvalidPointException { };

 const Function f;
 IntervalVector box;
 int n;


 double eps;


 double sigma;


 int niter ;

 LineSearchData data;




 bool stop(const Vector& z, const Vector& g);






 Vector find_gcp(const Vector& gk, const Matrix& Bk, const Vector& zk, const IntervalVector& region);
# 131 "/usr/local/include/ibex/ibex_UnconstrainedLocalSearch.h" 3
 Vector conj_grad(const Vector& gk, const Matrix& Bk, const Vector& zk, const Vector& z_gcp, const IntervalVector& region, const BitSet& I);




 double get_eta(const Vector& gk, const Vector& zk, const IntervalVector& region, const BitSet& I);
# 147 "/usr/local/include/ibex/ibex_UnconstrainedLocalSearch.h" 3
 void update_B_SR1(Matrix& Bk, const Vector& sk, const Vector& gk, const Vector& gk1);





 double _mid(const Interval& x);




 Vector _mid(const IntervalVector& x);

};



std::ostream& operator<<(std::ostream& cc, const UnconstrainedLocalSearch::ReturnCode& res);


inline int UnconstrainedLocalSearch::nb_iter() const {
 return this->niter;
}

inline double UnconstrainedLocalSearch::_mid(const Interval& x) {
 if (x.is_empty() || x.is_unbounded()) throw InvalidPointException();
 else return x.mid();
}

inline Vector UnconstrainedLocalSearch::_mid(const IntervalVector& x) {
 if (x.is_empty() || x.is_unbounded()) throw InvalidPointException();
 else return x.mid();
}

}
# 169 "/usr/local/include/ibex/ibex.h" 2 3


# 1 "/usr/local/include/ibex/ibex_Expr2DAG.h" 1 3
# 16 "/usr/local/include/ibex/ibex_Expr2DAG.h" 3
namespace ibex {
# 27 "/usr/local/include/ibex/ibex_Expr2DAG.h" 3
class Expr2DAG : public virtual ExprVisitor {
public:



 const ExprNode& transform(const Array<const ExprSymbol>& old_x, const Array<const ExprNode>& new_x, const ExprNode& y);

protected:
 void visit(const ExprNode& e);
 void visit(const ExprIndex& i);
 void visit(const ExprNAryOp& e);
 void visit(const ExprLeaf& e);
 void visit(const ExprBinaryOp& b);
 void visit(const ExprUnaryOp& u);
 void visit(const ExprSymbol& x);
 void visit(const ExprConstant& c);
 void visit(const ExprVector& e);
 void visit(const ExprApply& e);
 void visit(const ExprChi& e);
 void visit(const ExprAdd& e);
 void visit(const ExprMul& e);
 void visit(const ExprSub& e);
 void visit(const ExprDiv& e);
 void visit(const ExprMax& e);
 void visit(const ExprMin& e);
 void visit(const ExprAtan2& e);
 void visit(const ExprMinus& e);
 void visit(const ExprTrans& e);
 void visit(const ExprSign& e);
 void visit(const ExprAbs& e);
 void visit(const ExprPower& e);
 void visit(const ExprSqr& e);
 void visit(const ExprSqrt& e);
 void visit(const ExprExp& e);
 void visit(const ExprLog& e);
 void visit(const ExprCos& e);
 void visit(const ExprSin& e);
 void visit(const ExprTan& e);
 void visit(const ExprCosh& e);
 void visit(const ExprSinh& e);
 void visit(const ExprTanh& e);
 void visit(const ExprAcos& e);
 void visit(const ExprAsin& e);
 void visit(const ExprAtan& e);
 void visit(const ExprAcosh& e);
 void visit(const ExprAsinh& e);
 void visit(const ExprAtanh& e);

 NodeMap<const ExprNode*> peer;

 Array<const ExprNode> comps(const ExprNAryOp& e);

 template<class T>
 void visit_unary(const T& e);

 template<class T>
 void visit_binary(const T& e);
};

}
# 172 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_Expr2Minibex.h" 1 3
# 16 "/usr/local/include/ibex/ibex_Expr2Minibex.h" 3
namespace ibex {







class Expr2Minibex : private ExprPrinter {
public:

 void print(std::ostream& os, const ExprNode&);

protected:
 void visit(const ExprNode& e);


 NodeMap<int> map;
};

}
# 173 "/usr/local/include/ibex/ibex.h" 2 3
# 1 "/usr/local/include/ibex/ibex_ExprCmp.h" 1 3
# 15 "/usr/local/include/ibex/ibex_ExprCmp.h" 3
namespace ibex {
# 28 "/usr/local/include/ibex/ibex_ExprCmp.h" 3
class ExprCmp : public virtual ExprVisitor {
public:



 bool compare(const ExprNode& e1, const ExprNode& e2);

protected:

 const ExprNode* e2;
 bool are_equal;

 void visit(const ExprNode& e);
 void visit(const ExprIndex& i);
 void visit(const ExprNAryOp& e);
 void visit(const ExprLeaf& e);
 void visit(const ExprBinaryOp& b);
 void visit(const ExprUnaryOp& u);
 void visit(const ExprSymbol& x);
 void visit(const ExprConstant& c);
 void visit(const ExprVector& e);
 void visit(const ExprApply& e);
 void visit(const ExprChi& e);
 void visit(const ExprAdd& e);
 void visit(const ExprMul& e);
 void visit(const ExprSub& e);
 void visit(const ExprDiv& e);
 void visit(const ExprMax& e);
 void visit(const ExprMin& e);
 void visit(const ExprAtan2& e);
 void visit(const ExprMinus& e);
 void visit(const ExprTrans& e);
 void visit(const ExprSign& e);
 void visit(const ExprAbs& e);
 void visit(const ExprPower& e);
 void visit(const ExprSqr& e);
 void visit(const ExprSqrt& e);
 void visit(const ExprExp& e);
 void visit(const ExprLog& e);
 void visit(const ExprCos& e);
 void visit(const ExprSin& e);
 void visit(const ExprTan& e);
 void visit(const ExprCosh& e);
 void visit(const ExprSinh& e);
 void visit(const ExprTanh& e);
 void visit(const ExprAcos& e);
 void visit(const ExprAsin& e);
 void visit(const ExprAtan& e);
 void visit(const ExprAcosh& e);
 void visit(const ExprAsinh& e);
 void visit(const ExprAtanh& e);

 template<class T>
 void visit_nary(const T& e);

 template<class T>
 void visit_unary(const T& e);

 template<class T>
 void visit_binary(const T& e);

};

}
# 174 "/usr/local/include/ibex/ibex.h" 2 3


# 1 "/usr/local/include/ibex/ibex_ExprDiff.h" 1 3
# 18 "/usr/local/include/ibex/ibex_ExprDiff.h" 3
namespace ibex {







class ExprDiff : public virtual ExprVisitor {
public:
# 37 "/usr/local/include/ibex/ibex_ExprDiff.h" 3
 const ExprNode& diff(const Array<const ExprSymbol>& old_x, const Array<const ExprSymbol>& new_x, const ExprNode& y);

protected:
 void visit(const ExprNode& e);
 void visit(const ExprIndex& i);
 void visit(const ExprNAryOp& e);
 void visit(const ExprLeaf& e);
 void visit(const ExprBinaryOp& b);
 void visit(const ExprUnaryOp& u);
 void visit(const ExprSymbol& x);
 void visit(const ExprConstant& c);
 void visit(const ExprVector& e);
 void visit(const ExprApply& e);
 void visit(const ExprChi& e);
 void visit(const ExprAdd& e);
 void visit(const ExprMul& e);
 void visit(const ExprSub& e);
 void visit(const ExprDiv& e);
 void visit(const ExprMax& e);
 void visit(const ExprMin& e);
 void visit(const ExprAtan2& e);
 void visit(const ExprMinus& e);
 void visit(const ExprTrans& e);
 void visit(const ExprSign& e);
 void visit(const ExprAbs& e);
 void visit(const ExprPower& e);
 void visit(const ExprSqr& e);
 void visit(const ExprSqrt& e);
 void visit(const ExprExp& e);
 void visit(const ExprLog& e);
 void visit(const ExprCos& e);
 void visit(const ExprSin& e);
 void visit(const ExprTan& e);
 void visit(const ExprCosh& e);
 void visit(const ExprSinh& e);
 void visit(const ExprTanh& e);
 void visit(const ExprAcos& e);
 void visit(const ExprAsin& e);
 void visit(const ExprAtan& e);
 void visit(const ExprAcosh& e);
 void visit(const ExprAsinh& e);
 void visit(const ExprAtanh& e);

 const ExprNode& gradient(const Array<const ExprSymbol>& old_x, const Array<const ExprSymbol>& new_x, const ExprNode& y);

 void add_grad_expr(const ExprNode& node, const ExprNode& expr);

 NodeMap<const ExprNode*> grad;





 std::vector<const ExprNode*> leaves;
};

}
# 177 "/usr/local/include/ibex/ibex.h" 2 3


# 1 "/usr/local/include/ibex/ibex_ExprSize.h" 1 3
# 17 "/usr/local/include/ibex/ibex_ExprSize.h" 3
namespace ibex {




int bin_size(const ExprNode& left, const ExprNode& right);




int nary_size(const Array<const ExprNode>& args);




class ExprSize : public virtual ExprVisitor {
public:

 ExprSize(const ExprNode& l, const ExprNode& r);


 ExprSize(const Array<const ExprNode>& args);


 int size;

protected:
  void visit(const ExprNode& e);
  void visit(const ExprIndex& e);
  void visit(const ExprLeaf& e);
  void visit(const ExprNAryOp& e);
  void visit(const ExprBinaryOp& e);
  void visit(const ExprUnaryOp& e);

  NodeMap<bool> map;
};

}
# 180 "/usr/local/include/ibex/ibex.h" 2 3




# 1 "/usr/local/include/ibex/ibex_EmptySystemException.h" 1 3
# 15 "/usr/local/include/ibex/ibex_EmptySystemException.h" 3
namespace ibex {





class EmptySystemException {

};

}
# 185 "/usr/local/include/ibex/ibex.h" 2 3

# 1 "/usr/local/include/ibex/ibex_FritzJohnCond.h" 1 3
# 16 "/usr/local/include/ibex/ibex_FritzJohnCond.h" 3
namespace ibex {






class FritzJohnCond : public System {

public:

 FritzJohnCond(const System& sys);


 const int n;


 const int M;


 const int R;


 const int K;

};

}
# 187 "/usr/local/include/ibex/ibex.h" 2 3


# 1 "/usr/local/include/ibex/ibex_SystemFactory.h" 1 3
# 16 "/usr/local/include/ibex/ibex_SystemFactory.h" 3
namespace ibex {







class SystemFactory {
public:




 SystemFactory();

 virtual ~SystemFactory();







 void add_var(const ExprSymbol& v);







 void add_var(const Array<const ExprSymbol>& a);
# 57 "/usr/local/include/ibex/ibex_SystemFactory.h" 3
 void add_goal(const ExprNode& goal);




 void add_goal(const Function& goal);






 void add_ctr(const ExprCtr& ctr);






 void add_ctr(const NumConstraint& ctr);
 void add_ctr2(const ExprCtr& ctr);






 void add_ctr_eq (const ExprNode& exp);

protected:
 friend class System;


 int nb_arg;

 int nb_var;

 Function* goal;


 std::vector<const ExprSymbol*> tmp_args;

 Array<const ExprSymbol>* args;

 std::vector<NumConstraint*> ctrs;
};


inline void SystemFactory::add_ctr_eq (const ExprNode& exp) {
 return add_ctr(ExprCtr(exp,EQ));
}


}
# 190 "/usr/local/include/ibex/ibex.h" 2 3
# 203 "/usr/local/include/ibex/ibex.h" 3
# 1 "/usr/local/include/ibex/ibex_String.h" 1 3
# 14 "/usr/local/include/ibex/ibex_String.h" 3
# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 44 "/usr/include/c++/7/cassert" 2 3
# 15 "/usr/local/include/ibex/ibex_String.h" 2 3



namespace ibex {
# 31 "/usr/local/include/ibex/ibex_String.h" 3
char* append_index(const char* base, char lbracket, char rbracket, int index);




char* next_generated_var_name();




char* next_generated_func_name();

}
# 204 "/usr/local/include/ibex/ibex.h" 2 3


# 1 "/usr/local/include/ibex/ibex_Setting.h" 1 3
# 207 "/usr/local/include/ibex/ibex.h" 2 3
# 2 "/home/richard/Documents/ucsp-solar/code/main.cpp" 2


# 1 "/usr/include/c++/7/queue" 1 3
# 58 "/usr/include/c++/7/queue" 3
       
# 59 "/usr/include/c++/7/queue" 3





# 1 "/usr/include/c++/7/bits/stl_queue.h" 1 3
# 65 "/usr/include/c++/7/bits/stl_queue.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 95 "/usr/include/c++/7/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class queue
    {
# 109 "/usr/include/c++/7/bits/stl_queue.h" 3
      template<typename _Tp1, typename _Seq1>
 friend bool
 operator==(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);

      template<typename _Tp1, typename _Seq1>
 friend bool
 operator<(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);


      template<typename _Alloc>
 using _Uses = typename
   enable_if<uses_allocator<_Sequence, _Alloc>::value>::type;


    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:
# 139 "/usr/include/c++/7/bits/stl_queue.h" 3
      _Sequence c;

    public:
# 150 "/usr/include/c++/7/bits/stl_queue.h" 3
      template<typename _Seq = _Sequence, typename _Requires = typename
        enable_if<is_default_constructible<_Seq>::value>::type>
 queue()
 : c() { }

      explicit
      queue(const _Sequence& __c)
      : c(__c) { }

      explicit
      queue(_Sequence&& __c)
      : c(std::move(__c)) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 explicit
 queue(const _Alloc& __a)
 : c(__a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 queue(const _Sequence& __c, const _Alloc& __a)
 : c(__c, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 queue(_Sequence&& __c, const _Alloc& __a)
 : c(std::move(__c), __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 queue(const queue& __q, const _Alloc& __a)
 : c(__q.c, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 queue(queue&& __q, const _Alloc& __a)
 : c(std::move(__q.c), __a) { }





      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      reference
      front()
      {
 ;
 return c.front();
      }





      const_reference
      front() const
      {
 ;
 return c.front();
      }





      reference
      back()
      {
 ;
 return c.back();
      }





      const_reference
      back() const
      {
 ;
 return c.back();
      }
# 250 "/usr/include/c++/7/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      { c.push_back(__x); }


      void
      push(value_type&& __x)
      { c.push_back(std::move(__x)); }







      template<typename... _Args>
 void
 emplace(_Args&&... __args)
 { c.emplace_back(std::forward<_Args>(__args)...); }
# 283 "/usr/include/c++/7/bits/stl_queue.h" 3
      void
      pop()
      {
 ;
 c.pop_front();
      }


      void
      swap(queue& __q)

      noexcept(__is_nothrow_swappable<_Sequence>::value)



      {
 using std::swap;
 swap(c, __q.c);
      }

    };
# 316 "/usr/include/c++/7/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator==(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c == __y.c; }
# 334 "/usr/include/c++/7/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator<(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c < __y.c; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator!=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator<=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Seq>
    inline


    typename enable_if<__is_swappable<_Seq>::value>::type



    swap(queue<_Tp, _Seq>& __x, queue<_Tp, _Seq>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<typename _Tp, typename _Seq, typename _Alloc>
    struct uses_allocator<queue<_Tp, _Seq>, _Alloc>
    : public uses_allocator<_Seq, _Alloc>::type { };
# 421 "/usr/include/c++/7/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = vector<_Tp>,
    typename _Compare = less<typename _Sequence::value_type> >
    class priority_queue
    {
# 439 "/usr/include/c++/7/bits/stl_queue.h" 3
      template<typename _Alloc>
 using _Uses = typename
   enable_if<uses_allocator<_Sequence, _Alloc>::value>::type;


    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;


      typedef _Compare value_compare;

    protected:

      _Sequence c;
      _Compare comp;

    public:
# 470 "/usr/include/c++/7/bits/stl_queue.h" 3
      template<typename _Seq = _Sequence, typename _Requires = typename
        enable_if<__and_<is_default_constructible<_Compare>,
    is_default_constructible<_Seq>>::value>::type>
 priority_queue()
 : c(), comp() { }

      explicit
      priority_queue(const _Compare& __x, const _Sequence& __s)
      : c(__s), comp(__x)
      { std::make_heap(c.begin(), c.end(), comp); }

      explicit
      priority_queue(const _Compare& __x, _Sequence&& __s = _Sequence())
      : c(std::move(__s)), comp(__x)
      { std::make_heap(c.begin(), c.end(), comp); }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 explicit
 priority_queue(const _Alloc& __a)
 : c(__a), comp() { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(const _Compare& __x, const _Alloc& __a)
 : c(__a), comp(__x) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(const _Compare& __x, const _Sequence& __c,
         const _Alloc& __a)
 : c(__c, __a), comp(__x) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(const _Compare& __x, _Sequence&& __c, const _Alloc& __a)
 : c(std::move(__c), __a), comp(__x) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(const priority_queue& __q, const _Alloc& __a)
 : c(__q.c, __a), comp(__q.comp) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(priority_queue&& __q, const _Alloc& __a)
 : c(std::move(__q.c), __a), comp(std::move(__q.comp)) { }
# 540 "/usr/include/c++/7/bits/stl_queue.h" 3
      template<typename _InputIterator>
 priority_queue(_InputIterator __first, _InputIterator __last,
         const _Compare& __x,
         const _Sequence& __s)
 : c(__s), comp(__x)
 {
   ;
   c.insert(c.end(), __first, __last);
   std::make_heap(c.begin(), c.end(), comp);
 }

      template<typename _InputIterator>
 priority_queue(_InputIterator __first, _InputIterator __last,
         const _Compare& __x = _Compare(),
         _Sequence&& __s = _Sequence())
 : c(std::move(__s)), comp(__x)
 {
   ;
   c.insert(c.end(), __first, __last);
   std::make_heap(c.begin(), c.end(), comp);
 }





      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      const_reference
      top() const
      {
 ;
 return c.front();
      }
# 594 "/usr/include/c++/7/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      {
 c.push_back(__x);
 std::push_heap(c.begin(), c.end(), comp);
      }


      void
      push(value_type&& __x)
      {
 c.push_back(std::move(__x));
 std::push_heap(c.begin(), c.end(), comp);
      }

      template<typename... _Args>
 void
 emplace(_Args&&... __args)
 {
   c.emplace_back(std::forward<_Args>(__args)...);
   std::push_heap(c.begin(), c.end(), comp);
 }
# 629 "/usr/include/c++/7/bits/stl_queue.h" 3
      void
      pop()
      {
 ;
 std::pop_heap(c.begin(), c.end(), comp);
 c.pop_back();
      }


      void
      swap(priority_queue& __pq)
      noexcept(__and_<

   __is_nothrow_swappable<_Sequence>,



   __is_nothrow_swappable<_Compare>
        >::value)
      {
 using std::swap;
 swap(c, __pq.c);
 swap(comp, __pq.comp);
      }

    };




  template<typename _Tp, typename _Sequence, typename _Compare>
    inline


    typename enable_if<__and_<__is_swappable<_Sequence>,
         __is_swappable<_Compare>>::value>::type



    swap(priority_queue<_Tp, _Sequence, _Compare>& __x,
  priority_queue<_Tp, _Sequence, _Compare>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<typename _Tp, typename _Sequence, typename _Compare,
    typename _Alloc>
    struct uses_allocator<priority_queue<_Tp, _Sequence, _Compare>, _Alloc>
    : public uses_allocator<_Sequence, _Alloc>::type { };



}
# 65 "/usr/include/c++/7/queue" 2 3
# 5 "/home/richard/Documents/ucsp-solar/code/main.cpp" 2
# 17 "/home/richard/Documents/ucsp-solar/code/main.cpp"

# 17 "/home/richard/Documents/ucsp-solar/code/main.cpp"
using namespace ibex;


typedef struct {
 double period;
 std::vector<Function*> dynamics;
 int nb_dynamics;
}sampledSwitchedSystem;

typedef struct {
 IntervalVector *Yinit;
 Affine2Vector *Ycurrent;
 std::vector<int> pattern;
} node;



IntervalVector post(const sampledSwitchedSystem& sys, const IntervalVector W,
  const std::vector<int> pattern) {

 Affine2Vector y0 = Affine2Vector(W);

 std::vector<int>::const_iterator it = pattern.begin();
 for (; it != pattern.end(); it++)
 {
  ivp_ode mode = ivp_ode(*(sys.dynamics[*it]), 0.0, y0);
  simulation simu = simulation(&mode, sys.period, HEUN, 1e-5);
  simu.run_simulation();
  y0=*(simu.list_solution_j.back().box_jnh_aff);
 }
 return y0.itv();
}


bool nextPattern(std::vector<int>& pattern)
{
 for (int i = pattern.size() - 1; i >= 0; i-- )
 {
  pattern[i] += 1 ;
  if ( pattern[i] > 15 )
  {
   pattern[i] = 0 ;
   continue ;
  }
  return true ;
 }
 return false;
}


bool constraint(const sampledSwitchedSystem& sys, const IntervalVector W, const IntervalVector B,
 const IntervalVector S, const std::vector<int> pattern) {

 Affine2Vector y1 = Affine2Vector(W);

 std::vector<int>::const_iterator it = pattern.begin();
 for (; it != pattern.end(); it++) {
  ivp_ode mode = ivp_ode(*(sys.dynamics[*it]), 0.0, y1);
  simulation simu = simulation(&mode, sys.period, HEUN, 1e-5);
  simu.run_simulation();
  if (simu.has_crossed(B) )
  {
   return false;
  }
  if (!simu.stayed_in(S))
  {
   return false;
  }
 }
 return true;
}




bool findPattern (const sampledSwitchedSystem& sys, const IntervalVector W,
  const IntervalVector R, const IntervalVector B,
  const IntervalVector S, unsigned int k,
  std::vector<int>& res_pattern) {

 std::cerr << "\tINIT = " << W << std::endl;
 for (unsigned int i = 1; i <= k; i++)
 {
  std::vector<int> pattern(i, 0);
  do {
   std::vector<int>::const_iterator it = pattern.begin();
   std::cerr << "\tPATTERN = (";
   for (; it != pattern.end(); it++) {
    std::cerr << *it << " " ;
   }
   std::cerr << ")" << std::endl;
   IntervalVector res = post(sys, W, pattern);
   std::cerr << "Post(" << W << ") = " << res << " AND R = " << R << std::endl;

   if (res.is_subset(R) && constraint(sys,W,B,S,pattern))
   {
    std::cerr << "\tPATTERN FOUND !!!" << std::endl;
    res_pattern = pattern;
    return true;
   }
  } while (nextPattern(pattern));


 }
 return false;
}



bool findPattern2 (const sampledSwitchedSystem& sys, const IntervalVector W,
  const IntervalVector R, const IntervalVector B,
  const IntervalVector S, unsigned int k,
  std::vector<int>& res_pattern) {

node node_init;
node_init.Yinit = new IntervalVector(W);
node_init.Ycurrent = new Affine2Vector(W,true);
node_init.pattern = std::vector<int>();

std::list<node> list_node;
std::list <std::pair <IntervalVector,std::vector<int> > > list_sol;

list_node.push_back(node_init);

int nb_pattern = sys.nb_dynamics;

while(!list_node.empty())
{

node node_current = list_node.front();
list_node.pop_front();

for (int i=0; i < nb_pattern; i++)
{
 if (node_current.pattern.empty())
std::cout << "current pattern : " << i << std::endl;
 else
std::cout << "current pattern : " << node_current.pattern << " + " << i << std::endl;

 ivp_ode mode = ivp_ode(*(sys.dynamics[i]), 0.0, *node_current.Ycurrent);
 simulation simu = simulation(&mode, sys.period, HEUN, 1e-5);
 simu.run_simulation();

 bool fin_R = simu.finished_in(R);
 bool stay_S = simu.stayed_in(S);
 bool cross_B = simu.has_crossed(B);
 bool out_S = simu.go_out(S);
 bool fin_B = simu.finished_in(B);

 if (fin_R && stay_S && !cross_B)
 {
std::cout << "sol found !" << std::endl;
node_current.pattern.push_back(i);

res_pattern = node_current.pattern;

return true;
 }
 else
 {
if (out_S || fin_B)
{
 std::cout << "Wrong direction !" << std::endl;

}
else
{
 if (stay_S && !cross_B)
 {
 if (node_current.pattern.size()+1 < k)
 {
  std::cout << "Increment of pattern !" << std::endl;

  node new_node;
  new_node.Yinit = new IntervalVector(*node_current.Yinit);
  new_node.Ycurrent = new Affine2Vector(simu.get_last());

  std::vector<int> new_pattern (node_current.pattern);
  new_pattern.push_back(i);
  new_node.pattern = new_pattern;
  list_node.push_back(new_node);

 }
 }
}
 }
}

}
return false;
}



bool decompose (const sampledSwitchedSystem& sys, const IntervalVector W,
 const IntervalVector R, const IntervalVector B,
 const IntervalVector S, unsigned int k, unsigned int d,
 std::vector<std::pair<IntervalVector, std::vector<int> > >& result) {

 std::vector<int> res_pattern;


 std::queue<IntervalVector> q;
 q.push (W);

 unsigned int nbStep = d;

 while (!q.empty() && nbStep > 0) {
  IntervalVector current = q.front ();
  q.pop();
  bool flag = findPattern (sys, current, R, B, S, k, res_pattern);

  if (flag) {

   result.push_back (std::pair< IntervalVector, std::vector<int> > (current, res_pattern));
  }
  else {


   LargestFirst bbb(0.1,0.5);
   std::pair<IntervalVector,IntervalVector> p = bbb.bisect(current);
   q.push (p.first);
   q.push (p.second);
   nbStep--;

  }

 }

 if (nbStep <= 0)
 {
  return false;
 }
 else
 {
  return true;
 }
}

int main(){

 const int n = 2;
 Variable x(n);





    Interval Te(0.0, 40.0);
    Interval I (0.0, 900.0);



    IntervalVector x0(2);
    x0[0] = Interval(23.0, 23.2);
    x0[1] = Interval(0.1, 0.13);

 Function m1 = Function(x, Return( -2.8811059759131854e-06*(x[0]-Te)/x[1] + 8.403225763080125e-07*I/x[1] + 0.00048018432931886426/x[1], 0.001*(0.1-x[1]) ) );
 Function m2 = Function(x, Return( -2.8811059759131854e-06*(x[0]-Te)/x[1] + 8.403225763080125e-07*I/x[1] + 0.00048018432931886426/x[1], 0.001*(0.2-x[1]) ) );
 Function m3 = Function(x, Return( -2.8811059759131854e-06*(x[0]-Te)/x[1] + 8.403225763080125e-07*I/x[1] + 0.00048018432931886426/x[1], 0.001*(0.3-x[1]) ) );
 Function m4 = Function(x, Return( -2.8811059759131854e-06*(x[0]-Te)/x[1] + 8.403225763080125e-07*I/x[1], 0.001*(0.1-x[1]) ) );
 Function m5 = Function(x, Return( -2.8811059759131854e-06*(x[0]-Te)/x[1] + 8.403225763080125e-07*I/x[1], 0.001*(0.2-x[1]) ) );
 Function m6 = Function(x, Return( -2.8811059759131854e-06*(x[0]-Te)/x[1] + 8.403225763080125e-07*I/x[1], 0.001*(0.3-x[1]) ) );


 sampledSwitchedSystem sys;

 sys.period = 15*60;
 sys.dynamics.push_back(&m1);
 sys.dynamics.push_back(&m2);
 sys.dynamics.push_back(&m3);
 sys.dynamics.push_back(&m4);
 sys.dynamics.push_back(&m5);
 sys.dynamics.push_back(&m6);


 sys.nb_dynamics = 6;

 IntervalVector R(2);
 R[0] = Interval(40,80);
 R[1] = Interval(0.1,0.3);
# 323 "/home/richard/Documents/ucsp-solar/code/main.cpp"
 IntervalVector W(2);
 W[0]= Interval(40,80);
 W[1]= Interval(0.1,0.3);



 IntervalVector B(2);
 B[0] = Interval(0.0,1.0);
 B[1] = Interval(0.0,0.01);



 IntervalVector S(2);
 S[0] = Interval(0,100);
 S[1] = Interval(0.0,0.3);





 std::list<IntervalVector> list_W;
 list_W.push_back(W);



 cout << "current_W.diam().max(): "<< list_W.front().diam().max() << endl;


 std::ofstream file("./result_solar_water_heating.txt", std::ios::out | std::ios::trunc);

 while(!list_W.empty())
 {
 IntervalVector current_W = list_W.front();
 list_W.pop_front();

 if (current_W.diam().max() > 0.6)
 {
  LargestFirst bbb(0.1,0.5);

  std::pair<IntervalVector,IntervalVector> p = bbb.bisect(current_W);
  list_W.push_back(p.first);
  list_W.push_back(p.second);
  continue;
 }



 std::cout << "taille list_W : " << list_W.size() << std::endl;

 std::vector< std::pair<IntervalVector, std::vector<int> > > result;
 unsigned int k = 3;
 unsigned int d = 20;


 bool flag = decompose(sys, current_W, R, B, S, k, d, result);


 if (result.empty())
 {

  std::cerr << "No solution with k = " << k << " and d = " << d << std::endl;
  file << current_W << " : no sol" << std::endl;


 }
 else
 {
  if (flag)
  {
   std::cerr << "Complete result -> PROOF" << std::endl;
  }
  else
  {
   std::cerr << "Incomplete result" << std::endl;
  }


  std::vector< std::pair<IntervalVector, std::vector<int> > >::const_iterator it = result.begin();
  for (; it != result.end(); it++) {
  file << "zon = str2zon2(\"" ;
  file << it->first << "\"); \n if is_in_zonotope(X,zon) \t \n pattern = [";

  std::vector<int>::const_iterator it_pat = (it->second).begin();
  for (; it_pat != (it->second).end(); it_pat++) {
   file << *it_pat << " ";
  }
  file << "]; \n endif" << std::endl;
  }
 }


 }
 file.close();


 return 0;

}
